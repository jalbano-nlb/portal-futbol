import { ElementRef } from '@angular/core';
import { Observable } from 'rxjs';
import { NbConnectedPosition, NbFlexibleConnectedPositionStrategy, NbOverlayPositionBuilder, NbOverlayRef, NbPlatform, NbPositionStrategy } from './mapping';
import { NbOverlayContainerAdapter } from '../adapter/overlay-container-adapter';
import { NbViewportRulerAdapter } from '../adapter/viewport-ruler-adapter';
import { NbGlobalLogicalPosition } from './position-helper';
import { GlobalPositionStrategy } from '@angular/cdk/overlay';
import * as ɵngcc0 from '@angular/core';
export declare enum NbAdjustment {
    NOOP = "noop",
    CLOCKWISE = "clockwise",
    COUNTERCLOCKWISE = "counterclockwise",
    VERTICAL = "vertical",
    HORIZONTAL = "horizontal"
}
export declare enum NbPosition {
    TOP = "top",
    BOTTOM = "bottom",
    LEFT = "left",
    RIGHT = "right",
    START = "start",
    END = "end",
    TOP_END = "top-end",
    TOP_START = "top-start",
    BOTTOM_END = "bottom-end",
    BOTTOM_START = "bottom-start",
    END_TOP = "end-top",
    END_BOTTOM = "end-bottom",
    START_TOP = "start-top",
    START_BOTTOM = "start-bottom"
}
/**
 * The main idea of the adjustable connected strategy is to provide predefined set of positions for your overlay.
 * You have to provide adjustment and appropriate strategy will be chosen in runtime.
 * */
export declare class NbAdjustableConnectedPositionStrategy extends NbFlexibleConnectedPositionStrategy implements NbPositionStrategy {
    protected _position: NbPosition;
    protected _offset: number;
    protected _adjustment: NbAdjustment;
    protected appliedPositions: {
        key: NbPosition;
        connectedPosition: NbConnectedPosition;
    }[];
    readonly positionChange: Observable<NbPosition>;
    attach(overlayRef: NbOverlayRef): void;
    apply(): void;
    position(position: NbPosition): this;
    adjustment(adjustment: NbAdjustment): this;
    offset(offset: number): this;
    protected applyPositions(): void;
    protected createPositions(): NbPosition[];
    protected persistChosenPositions(positions: NbPosition[]): void;
    protected reorderPreferredPositions(positions: NbPosition[]): NbPosition[];
    protected mapToLogicalPosition(position: NbPosition): NbPosition;
}
export declare class NbGlobalPositionStrategy extends GlobalPositionStrategy {
    position(position: NbGlobalLogicalPosition): this;
}
export declare class NbPositionBuilderService {
    protected document: any;
    protected viewportRuler: NbViewportRulerAdapter;
    protected platform: NbPlatform;
    protected positionBuilder: NbOverlayPositionBuilder;
    protected overlayContainer: NbOverlayContainerAdapter;
    constructor(document: any, viewportRuler: NbViewportRulerAdapter, platform: NbPlatform, positionBuilder: NbOverlayPositionBuilder, overlayContainer: NbOverlayContainerAdapter);
    global(): NbGlobalPositionStrategy;
    connectedTo(elementRef: ElementRef): NbAdjustableConnectedPositionStrategy;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbPositionBuilderService>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<NbPositionBuilderService>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmxheS1wb3NpdGlvbi5kLnRzIiwic291cmNlcyI6WyJvdmVybGF5LXBvc2l0aW9uLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBT0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyREEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBOYkNvbm5lY3RlZFBvc2l0aW9uLCBOYkZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSwgTmJPdmVybGF5UG9zaXRpb25CdWlsZGVyLCBOYk92ZXJsYXlSZWYsIE5iUGxhdGZvcm0sIE5iUG9zaXRpb25TdHJhdGVneSB9IGZyb20gJy4vbWFwcGluZyc7XG5pbXBvcnQgeyBOYk92ZXJsYXlDb250YWluZXJBZGFwdGVyIH0gZnJvbSAnLi4vYWRhcHRlci9vdmVybGF5LWNvbnRhaW5lci1hZGFwdGVyJztcbmltcG9ydCB7IE5iVmlld3BvcnRSdWxlckFkYXB0ZXIgfSBmcm9tICcuLi9hZGFwdGVyL3ZpZXdwb3J0LXJ1bGVyLWFkYXB0ZXInO1xuaW1wb3J0IHsgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLWhlbHBlcic7XG5pbXBvcnQgeyBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuZXhwb3J0IGRlY2xhcmUgZW51bSBOYkFkanVzdG1lbnQge1xuICAgIE5PT1AgPSBcIm5vb3BcIixcbiAgICBDTE9DS1dJU0UgPSBcImNsb2Nrd2lzZVwiLFxuICAgIENPVU5URVJDTE9DS1dJU0UgPSBcImNvdW50ZXJjbG9ja3dpc2VcIixcbiAgICBWRVJUSUNBTCA9IFwidmVydGljYWxcIixcbiAgICBIT1JJWk9OVEFMID0gXCJob3Jpem9udGFsXCJcbn1cbmV4cG9ydCBkZWNsYXJlIGVudW0gTmJQb3NpdGlvbiB7XG4gICAgVE9QID0gXCJ0b3BcIixcbiAgICBCT1RUT00gPSBcImJvdHRvbVwiLFxuICAgIExFRlQgPSBcImxlZnRcIixcbiAgICBSSUdIVCA9IFwicmlnaHRcIixcbiAgICBTVEFSVCA9IFwic3RhcnRcIixcbiAgICBFTkQgPSBcImVuZFwiLFxuICAgIFRPUF9FTkQgPSBcInRvcC1lbmRcIixcbiAgICBUT1BfU1RBUlQgPSBcInRvcC1zdGFydFwiLFxuICAgIEJPVFRPTV9FTkQgPSBcImJvdHRvbS1lbmRcIixcbiAgICBCT1RUT01fU1RBUlQgPSBcImJvdHRvbS1zdGFydFwiLFxuICAgIEVORF9UT1AgPSBcImVuZC10b3BcIixcbiAgICBFTkRfQk9UVE9NID0gXCJlbmQtYm90dG9tXCIsXG4gICAgU1RBUlRfVE9QID0gXCJzdGFydC10b3BcIixcbiAgICBTVEFSVF9CT1RUT00gPSBcInN0YXJ0LWJvdHRvbVwiXG59XG4vKipcbiAqIFRoZSBtYWluIGlkZWEgb2YgdGhlIGFkanVzdGFibGUgY29ubmVjdGVkIHN0cmF0ZWd5IGlzIHRvIHByb3ZpZGUgcHJlZGVmaW5lZCBzZXQgb2YgcG9zaXRpb25zIGZvciB5b3VyIG92ZXJsYXkuXG4gKiBZb3UgaGF2ZSB0byBwcm92aWRlIGFkanVzdG1lbnQgYW5kIGFwcHJvcHJpYXRlIHN0cmF0ZWd5IHdpbGwgYmUgY2hvc2VuIGluIHJ1bnRpbWUuXG4gKiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJBZGp1c3RhYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSBleHRlbmRzIE5iRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IGltcGxlbWVudHMgTmJQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICBwcm90ZWN0ZWQgX3Bvc2l0aW9uOiBOYlBvc2l0aW9uO1xuICAgIHByb3RlY3RlZCBfb2Zmc2V0OiBudW1iZXI7XG4gICAgcHJvdGVjdGVkIF9hZGp1c3RtZW50OiBOYkFkanVzdG1lbnQ7XG4gICAgcHJvdGVjdGVkIGFwcGxpZWRQb3NpdGlvbnM6IHtcbiAgICAgICAga2V5OiBOYlBvc2l0aW9uO1xuICAgICAgICBjb25uZWN0ZWRQb3NpdGlvbjogTmJDb25uZWN0ZWRQb3NpdGlvbjtcbiAgICB9W107XG4gICAgcmVhZG9ubHkgcG9zaXRpb25DaGFuZ2U6IE9ic2VydmFibGU8TmJQb3NpdGlvbj47XG4gICAgYXR0YWNoKG92ZXJsYXlSZWY6IE5iT3ZlcmxheVJlZik6IHZvaWQ7XG4gICAgYXBwbHkoKTogdm9pZDtcbiAgICBwb3NpdGlvbihwb3NpdGlvbjogTmJQb3NpdGlvbik6IHRoaXM7XG4gICAgYWRqdXN0bWVudChhZGp1c3RtZW50OiBOYkFkanVzdG1lbnQpOiB0aGlzO1xuICAgIG9mZnNldChvZmZzZXQ6IG51bWJlcik6IHRoaXM7XG4gICAgcHJvdGVjdGVkIGFwcGx5UG9zaXRpb25zKCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGNyZWF0ZVBvc2l0aW9ucygpOiBOYlBvc2l0aW9uW107XG4gICAgcHJvdGVjdGVkIHBlcnNpc3RDaG9zZW5Qb3NpdGlvbnMocG9zaXRpb25zOiBOYlBvc2l0aW9uW10pOiB2b2lkO1xuICAgIHByb3RlY3RlZCByZW9yZGVyUHJlZmVycmVkUG9zaXRpb25zKHBvc2l0aW9uczogTmJQb3NpdGlvbltdKTogTmJQb3NpdGlvbltdO1xuICAgIHByb3RlY3RlZCBtYXBUb0xvZ2ljYWxQb3NpdGlvbihwb3NpdGlvbjogTmJQb3NpdGlvbik6IE5iUG9zaXRpb247XG59XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBOYkdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICBwb3NpdGlvbihwb3NpdGlvbjogTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24pOiB0aGlzO1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJQb3NpdGlvbkJ1aWxkZXJTZXJ2aWNlIHtcbiAgICBwcm90ZWN0ZWQgZG9jdW1lbnQ6IGFueTtcbiAgICBwcm90ZWN0ZWQgdmlld3BvcnRSdWxlcjogTmJWaWV3cG9ydFJ1bGVyQWRhcHRlcjtcbiAgICBwcm90ZWN0ZWQgcGxhdGZvcm06IE5iUGxhdGZvcm07XG4gICAgcHJvdGVjdGVkIHBvc2l0aW9uQnVpbGRlcjogTmJPdmVybGF5UG9zaXRpb25CdWlsZGVyO1xuICAgIHByb3RlY3RlZCBvdmVybGF5Q29udGFpbmVyOiBOYk92ZXJsYXlDb250YWluZXJBZGFwdGVyO1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50OiBhbnksIHZpZXdwb3J0UnVsZXI6IE5iVmlld3BvcnRSdWxlckFkYXB0ZXIsIHBsYXRmb3JtOiBOYlBsYXRmb3JtLCBwb3NpdGlvbkJ1aWxkZXI6IE5iT3ZlcmxheVBvc2l0aW9uQnVpbGRlciwgb3ZlcmxheUNvbnRhaW5lcjogTmJPdmVybGF5Q29udGFpbmVyQWRhcHRlcik7XG4gICAgZ2xvYmFsKCk6IE5iR2xvYmFsUG9zaXRpb25TdHJhdGVneTtcbiAgICBjb25uZWN0ZWRUbyhlbGVtZW50UmVmOiBFbGVtZW50UmVmKTogTmJBZGp1c3RhYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneTtcbn1cbiJdfQ==