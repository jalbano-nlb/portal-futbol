import { AfterViewInit, ChangeDetectorRef, ElementRef, IterableDiffers, OnDestroy } from '@angular/core';
import { NbPlatform } from '../cdk/platform/platform-service';
import { NbDirectionality } from '../cdk/bidi/bidi-service';
import { NbTable } from '../cdk/table/table.module';
import { NbTreeGridDataSource, NbTreeGridDataSourceBuilder } from './data-source/tree-grid-data-source';
import { NbTreeGridPresentationNode } from './data-source/tree-grid.model';
import { NbToggleOptions } from './data-source/tree-grid.service';
import { NbTreeGridRowComponent } from './tree-grid-row.component';
import { NbTreeGridCellDirective } from './tree-grid-cell.component';
/**
 * Tree grid component that can be used to display nested rows of data.
 * Supports filtering and sorting.
 * @stacked-example(Showcase, tree-grid/tree-grid-showcase.component)
 *
 * ### Installation
 *
 * Import `NbTreeGridModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTreeGridModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * ### Usage
 *
 * As the most basic usage you need to define [nbTreeGridRowDef](docs/components/treegrid/api#nbtreegridrowdefdirective)
 * where you should pass columns to display in rows and
 * [nbTreeGridColumnDef](docs/components/treegrid/api#nbtreegridcolumndefdirective) - component containing cell
 * definitions for each column passed to row definition.
 * @stacked-example(Basic, tree-grid/tree-grid-basic.component)
 *
 * `NbTreeGridComponent`'s source input and `NbTreeGridDataSourceBuilder.create` expecting data to be an array of
 * objects with `data`, `children` and `expanded` properties. If your data doesn't match this interface, you can pass
 * getter functions for each property as arguments to `NbTreeGridDataSourceBuilder.create` method.
 * @stacked-example(Custom node structure, tree-grid/tree-grid-custom-node-structure.component)
 *
 * To use sorting you can add `nbSort` directive to table and subscribe to `sort` method. When user click on header,
 * sort event will be emitted. Event object contain clicked column name and desired sort direction.
 * @stacked-example(Sortable, tree-grid/tree-grid-sortable.component)
 *
 * You can use `Data Source Builder` to create `NbTreeGridDataSource` which would have toggle, sort and
 * filter methods. Then you can call this methods to change sort or toggle rows programmatically. Also `nbSort` and
 * `nbFilterInput` directives both support `NbTreeGridDataSource`, so you can pass it directly as an input and
 * directives will trigger sort, toggle themselves.
 * @stacked-example(Data Source Builder, tree-grid/tree-grid-showcase.component)
 *
 * You can create responsive grid by setting `hideOn` and `showOn` inputs of
 * [nbTreeGridColumnDef](docs/components/tree-grid/api#nbtreegridcolumndefdirective) directive.
 * When viewport reaches specified width grid hides or shows columns.
 * @stacked-example(Responsive columns, tree-grid/tree-grid-responsive.component)
 *
 * To customize sort or row toggle icons you can use `nbSortHeaderIcon` and `nbTreeGridRowToggle` directives
 * respectively. `nbSortHeaderIcon` is a structural directive and it's implicit context set to current direction.
 * Also context has three properties: `isAscending`, `isDescending` and `isNone`.
 * @stacked-example(Custom icons, tree-grid/tree-grid-custom-icons.component)
 *
 * By default, row to toggle happens when user clicks anywhere in the row. Also double click expands row deeply.
 * To disable this you can set `[clickToToggle]="false"` input of `nbTreeGridRow`.
 * @stacked-example(Disable click toggle, tree-grid/tree-grid-disable-click-toggle.component)
 *
 * @styles
 *
 * tree-grid-cell-border-width:
 * tree-grid-cell-border-style:
 * tree-grid-cell-border-color:
 * tree-grid-row-min-height:
 * tree-grid-cell-padding:
 * tree-grid-header-background-color:
 * tree-grid-header-text-color:
 * tree-grid-header-text-font-family:
 * tree-grid-header-text-font-size:
 * tree-grid-header-text-font-weight:
 * tree-grid-header-text-line-height:
 * tree-grid-footer-background-color:
 * tree-grid-footer-text-color:
 * tree-grid-footer-text-font-family:
 * tree-grid-footer-text-font-size:
 * tree-grid-footer-text-font-weight:
 * tree-grid-footer-text-line-height:
 * tree-grid-row-background-color:
 * tree-grid-row-even-background-color:
 * tree-grid-row-hover-background-color:
 * tree-grid-row-text-color:
 * tree-grid-row-text-font-family:
 * tree-grid-row-text-font-size:
 * tree-grid-row-text-font-weight:
 * tree-grid-row-text-line-height:
 * tree-grid-sort-header-button-background-color:
 * tree-grid-sort-header-button-border:
 * tree-grid-sort-header-button-padding:
 */
import * as ɵngcc0 from '@angular/core';
export declare class NbTreeGridComponent<T> extends NbTable<NbTreeGridPresentationNode<T>> implements AfterViewInit, OnDestroy {
    private dataSourceBuilder;
    private window;
    constructor(dataSourceBuilder: NbTreeGridDataSourceBuilder<T>, differs: IterableDiffers, changeDetectorRef: ChangeDetectorRef, elementRef: ElementRef, role: string, dir: NbDirectionality, document: any, platform: NbPlatform | undefined, window: any);
    private alive;
    private _source;
    private platform;
    /**
     * The table's data
     * @param data
     * @type {<T>[] | NbTreeGridDataSource}
     */
    source: T[] | NbTreeGridDataSource<T>;
    levelPadding: string;
    /**
     * Make all columns equal width. False by default.
     */
    equalColumnsWidth: boolean;
    private equalColumnsWidthValue;
    private rows;
    readonly treeClass = true;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    toggleRow(row: NbTreeGridRowComponent, options?: NbToggleOptions): void;
    toggleCellRow(cell: NbTreeGridCellDirective): void;
    getColumnWidth(): string;
    getCellLevel(cell: NbTreeGridCellDirective, columnName: string): number;
    private getDataIndex;
    private getRowLevel;
    private getColumns;
    private getColumnsCount;
    private isFirstColumn;
    private findCellRow;
    private checkDefsCount;
    private updateVisibleColumns;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbTreeGridComponent<any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbTreeGridComponent<any>, "table[nbTreeGrid]", never, {
    "levelPadding": "levelPadding";
    "source": "nbTreeGrid";
    "equalColumnsWidth": "equalColumnsWidth";
}, {}, ["rows"]>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLmNvbXBvbmVudC5kLnRzIiwic291cmNlcyI6WyJ0cmVlLWdyaWQuY29tcG9uZW50LmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQStGQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgRWxlbWVudFJlZiwgSXRlcmFibGVEaWZmZXJzLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5iUGxhdGZvcm0gfSBmcm9tICcuLi9jZGsvcGxhdGZvcm0vcGxhdGZvcm0tc2VydmljZSc7XG5pbXBvcnQgeyBOYkRpcmVjdGlvbmFsaXR5IH0gZnJvbSAnLi4vY2RrL2JpZGkvYmlkaS1zZXJ2aWNlJztcbmltcG9ydCB7IE5iVGFibGUgfSBmcm9tICcuLi9jZGsvdGFibGUvdGFibGUubW9kdWxlJztcbmltcG9ydCB7IE5iVHJlZUdyaWREYXRhU291cmNlLCBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIgfSBmcm9tICcuL2RhdGEtc291cmNlL3RyZWUtZ3JpZC1kYXRhLXNvdXJjZSc7XG5pbXBvcnQgeyBOYlRyZWVHcmlkUHJlc2VudGF0aW9uTm9kZSB9IGZyb20gJy4vZGF0YS1zb3VyY2UvdHJlZS1ncmlkLm1vZGVsJztcbmltcG9ydCB7IE5iVG9nZ2xlT3B0aW9ucyB9IGZyb20gJy4vZGF0YS1zb3VyY2UvdHJlZS1ncmlkLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmJUcmVlR3JpZFJvd0NvbXBvbmVudCB9IGZyb20gJy4vdHJlZS1ncmlkLXJvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgTmJUcmVlR3JpZENlbGxEaXJlY3RpdmUgfSBmcm9tICcuL3RyZWUtZ3JpZC1jZWxsLmNvbXBvbmVudCc7XG4vKipcbiAqIFRyZWUgZ3JpZCBjb21wb25lbnQgdGhhdCBjYW4gYmUgdXNlZCB0byBkaXNwbGF5IG5lc3RlZCByb3dzIG9mIGRhdGEuXG4gKiBTdXBwb3J0cyBmaWx0ZXJpbmcgYW5kIHNvcnRpbmcuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCB0cmVlLWdyaWQvdHJlZS1ncmlkLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlRyZWVHcmlkTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlRyZWVHcmlkTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogQXMgdGhlIG1vc3QgYmFzaWMgdXNhZ2UgeW91IG5lZWQgdG8gZGVmaW5lIFtuYlRyZWVHcmlkUm93RGVmXShkb2NzL2NvbXBvbmVudHMvdHJlZWdyaWQvYXBpI25idHJlZWdyaWRyb3dkZWZkaXJlY3RpdmUpXG4gKiB3aGVyZSB5b3Ugc2hvdWxkIHBhc3MgY29sdW1ucyB0byBkaXNwbGF5IGluIHJvd3MgYW5kXG4gKiBbbmJUcmVlR3JpZENvbHVtbkRlZl0oZG9jcy9jb21wb25lbnRzL3RyZWVncmlkL2FwaSNuYnRyZWVncmlkY29sdW1uZGVmZGlyZWN0aXZlKSAtIGNvbXBvbmVudCBjb250YWluaW5nIGNlbGxcbiAqIGRlZmluaXRpb25zIGZvciBlYWNoIGNvbHVtbiBwYXNzZWQgdG8gcm93IGRlZmluaXRpb24uXG4gKiBAc3RhY2tlZC1leGFtcGxlKEJhc2ljLCB0cmVlLWdyaWQvdHJlZS1ncmlkLWJhc2ljLmNvbXBvbmVudClcbiAqXG4gKiBgTmJUcmVlR3JpZENvbXBvbmVudGAncyBzb3VyY2UgaW5wdXQgYW5kIGBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIuY3JlYXRlYCBleHBlY3RpbmcgZGF0YSB0byBiZSBhbiBhcnJheSBvZlxuICogb2JqZWN0cyB3aXRoIGBkYXRhYCwgYGNoaWxkcmVuYCBhbmQgYGV4cGFuZGVkYCBwcm9wZXJ0aWVzLiBJZiB5b3VyIGRhdGEgZG9lc24ndCBtYXRjaCB0aGlzIGludGVyZmFjZSwgeW91IGNhbiBwYXNzXG4gKiBnZXR0ZXIgZnVuY3Rpb25zIGZvciBlYWNoIHByb3BlcnR5IGFzIGFyZ3VtZW50cyB0byBgTmJUcmVlR3JpZERhdGFTb3VyY2VCdWlsZGVyLmNyZWF0ZWAgbWV0aG9kLlxuICogQHN0YWNrZWQtZXhhbXBsZShDdXN0b20gbm9kZSBzdHJ1Y3R1cmUsIHRyZWUtZ3JpZC90cmVlLWdyaWQtY3VzdG9tLW5vZGUtc3RydWN0dXJlLmNvbXBvbmVudClcbiAqXG4gKiBUbyB1c2Ugc29ydGluZyB5b3UgY2FuIGFkZCBgbmJTb3J0YCBkaXJlY3RpdmUgdG8gdGFibGUgYW5kIHN1YnNjcmliZSB0byBgc29ydGAgbWV0aG9kLiBXaGVuIHVzZXIgY2xpY2sgb24gaGVhZGVyLFxuICogc29ydCBldmVudCB3aWxsIGJlIGVtaXR0ZWQuIEV2ZW50IG9iamVjdCBjb250YWluIGNsaWNrZWQgY29sdW1uIG5hbWUgYW5kIGRlc2lyZWQgc29ydCBkaXJlY3Rpb24uXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNvcnRhYmxlLCB0cmVlLWdyaWQvdHJlZS1ncmlkLXNvcnRhYmxlLmNvbXBvbmVudClcbiAqXG4gKiBZb3UgY2FuIHVzZSBgRGF0YSBTb3VyY2UgQnVpbGRlcmAgdG8gY3JlYXRlIGBOYlRyZWVHcmlkRGF0YVNvdXJjZWAgd2hpY2ggd291bGQgaGF2ZSB0b2dnbGUsIHNvcnQgYW5kXG4gKiBmaWx0ZXIgbWV0aG9kcy4gVGhlbiB5b3UgY2FuIGNhbGwgdGhpcyBtZXRob2RzIHRvIGNoYW5nZSBzb3J0IG9yIHRvZ2dsZSByb3dzIHByb2dyYW1tYXRpY2FsbHkuIEFsc28gYG5iU29ydGAgYW5kXG4gKiBgbmJGaWx0ZXJJbnB1dGAgZGlyZWN0aXZlcyBib3RoIHN1cHBvcnQgYE5iVHJlZUdyaWREYXRhU291cmNlYCwgc28geW91IGNhbiBwYXNzIGl0IGRpcmVjdGx5IGFzIGFuIGlucHV0IGFuZFxuICogZGlyZWN0aXZlcyB3aWxsIHRyaWdnZXIgc29ydCwgdG9nZ2xlIHRoZW1zZWx2ZXMuXG4gKiBAc3RhY2tlZC1leGFtcGxlKERhdGEgU291cmNlIEJ1aWxkZXIsIHRyZWUtZ3JpZC90cmVlLWdyaWQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIFlvdSBjYW4gY3JlYXRlIHJlc3BvbnNpdmUgZ3JpZCBieSBzZXR0aW5nIGBoaWRlT25gIGFuZCBgc2hvd09uYCBpbnB1dHMgb2ZcbiAqIFtuYlRyZWVHcmlkQ29sdW1uRGVmXShkb2NzL2NvbXBvbmVudHMvdHJlZS1ncmlkL2FwaSNuYnRyZWVncmlkY29sdW1uZGVmZGlyZWN0aXZlKSBkaXJlY3RpdmUuXG4gKiBXaGVuIHZpZXdwb3J0IHJlYWNoZXMgc3BlY2lmaWVkIHdpZHRoIGdyaWQgaGlkZXMgb3Igc2hvd3MgY29sdW1ucy5cbiAqIEBzdGFja2VkLWV4YW1wbGUoUmVzcG9uc2l2ZSBjb2x1bW5zLCB0cmVlLWdyaWQvdHJlZS1ncmlkLXJlc3BvbnNpdmUuY29tcG9uZW50KVxuICpcbiAqIFRvIGN1c3RvbWl6ZSBzb3J0IG9yIHJvdyB0b2dnbGUgaWNvbnMgeW91IGNhbiB1c2UgYG5iU29ydEhlYWRlckljb25gIGFuZCBgbmJUcmVlR3JpZFJvd1RvZ2dsZWAgZGlyZWN0aXZlc1xuICogcmVzcGVjdGl2ZWx5LiBgbmJTb3J0SGVhZGVySWNvbmAgaXMgYSBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSBhbmQgaXQncyBpbXBsaWNpdCBjb250ZXh0IHNldCB0byBjdXJyZW50IGRpcmVjdGlvbi5cbiAqIEFsc28gY29udGV4dCBoYXMgdGhyZWUgcHJvcGVydGllczogYGlzQXNjZW5kaW5nYCwgYGlzRGVzY2VuZGluZ2AgYW5kIGBpc05vbmVgLlxuICogQHN0YWNrZWQtZXhhbXBsZShDdXN0b20gaWNvbnMsIHRyZWUtZ3JpZC90cmVlLWdyaWQtY3VzdG9tLWljb25zLmNvbXBvbmVudClcbiAqXG4gKiBCeSBkZWZhdWx0LCByb3cgdG8gdG9nZ2xlIGhhcHBlbnMgd2hlbiB1c2VyIGNsaWNrcyBhbnl3aGVyZSBpbiB0aGUgcm93LiBBbHNvIGRvdWJsZSBjbGljayBleHBhbmRzIHJvdyBkZWVwbHkuXG4gKiBUbyBkaXNhYmxlIHRoaXMgeW91IGNhbiBzZXQgYFtjbGlja1RvVG9nZ2xlXT1cImZhbHNlXCJgIGlucHV0IG9mIGBuYlRyZWVHcmlkUm93YC5cbiAqIEBzdGFja2VkLWV4YW1wbGUoRGlzYWJsZSBjbGljayB0b2dnbGUsIHRyZWUtZ3JpZC90cmVlLWdyaWQtZGlzYWJsZS1jbGljay10b2dnbGUuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiB0cmVlLWdyaWQtY2VsbC1ib3JkZXItd2lkdGg6XG4gKiB0cmVlLWdyaWQtY2VsbC1ib3JkZXItc3R5bGU6XG4gKiB0cmVlLWdyaWQtY2VsbC1ib3JkZXItY29sb3I6XG4gKiB0cmVlLWdyaWQtcm93LW1pbi1oZWlnaHQ6XG4gKiB0cmVlLWdyaWQtY2VsbC1wYWRkaW5nOlxuICogdHJlZS1ncmlkLWhlYWRlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdHJlZS1ncmlkLWhlYWRlci10ZXh0LWNvbG9yOlxuICogdHJlZS1ncmlkLWhlYWRlci10ZXh0LWZvbnQtZmFtaWx5OlxuICogdHJlZS1ncmlkLWhlYWRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRyZWUtZ3JpZC1oZWFkZXItdGV4dC1mb250LXdlaWdodDpcbiAqIHRyZWUtZ3JpZC1oZWFkZXItdGV4dC1saW5lLWhlaWdodDpcbiAqIHRyZWUtZ3JpZC1mb290ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1mb290ZXItdGV4dC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1mb290ZXItdGV4dC1mb250LWZhbWlseTpcbiAqIHRyZWUtZ3JpZC1mb290ZXItdGV4dC1mb250LXNpemU6XG4gKiB0cmVlLWdyaWQtZm9vdGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0cmVlLWdyaWQtZm9vdGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0cmVlLWdyaWQtcm93LWJhY2tncm91bmQtY29sb3I6XG4gKiB0cmVlLWdyaWQtcm93LWV2ZW4tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1yb3ctaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1yb3ctdGV4dC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1yb3ctdGV4dC1mb250LWZhbWlseTpcbiAqIHRyZWUtZ3JpZC1yb3ctdGV4dC1mb250LXNpemU6XG4gKiB0cmVlLWdyaWQtcm93LXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0cmVlLWdyaWQtcm93LXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0cmVlLWdyaWQtc29ydC1oZWFkZXItYnV0dG9uLWJhY2tncm91bmQtY29sb3I6XG4gKiB0cmVlLWdyaWQtc29ydC1oZWFkZXItYnV0dG9uLWJvcmRlcjpcbiAqIHRyZWUtZ3JpZC1zb3J0LWhlYWRlci1idXR0b24tcGFkZGluZzpcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJUcmVlR3JpZENvbXBvbmVudDxUPiBleHRlbmRzIE5iVGFibGU8TmJUcmVlR3JpZFByZXNlbnRhdGlvbk5vZGU8VD4+IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIGRhdGFTb3VyY2VCdWlsZGVyO1xuICAgIHByaXZhdGUgd2luZG93O1xuICAgIGNvbnN0cnVjdG9yKGRhdGFTb3VyY2VCdWlsZGVyOiBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXI8VD4sIGRpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycywgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLCByb2xlOiBzdHJpbmcsIGRpcjogTmJEaXJlY3Rpb25hbGl0eSwgZG9jdW1lbnQ6IGFueSwgcGxhdGZvcm06IE5iUGxhdGZvcm0gfCB1bmRlZmluZWQsIHdpbmRvdzogYW55KTtcbiAgICBwcml2YXRlIGFsaXZlO1xuICAgIHByaXZhdGUgX3NvdXJjZTtcbiAgICBwcml2YXRlIHBsYXRmb3JtO1xuICAgIC8qKlxuICAgICAqIFRoZSB0YWJsZSdzIGRhdGFcbiAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAqIEB0eXBlIHs8VD5bXSB8IE5iVHJlZUdyaWREYXRhU291cmNlfVxuICAgICAqL1xuICAgIHNvdXJjZTogVFtdIHwgTmJUcmVlR3JpZERhdGFTb3VyY2U8VD47XG4gICAgbGV2ZWxQYWRkaW5nOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogTWFrZSBhbGwgY29sdW1ucyBlcXVhbCB3aWR0aC4gRmFsc2UgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBlcXVhbENvbHVtbnNXaWR0aDogYm9vbGVhbjtcbiAgICBwcml2YXRlIGVxdWFsQ29sdW1uc1dpZHRoVmFsdWU7XG4gICAgcHJpdmF0ZSByb3dzO1xuICAgIHJlYWRvbmx5IHRyZWVDbGFzcyA9IHRydWU7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICB0b2dnbGVSb3cocm93OiBOYlRyZWVHcmlkUm93Q29tcG9uZW50LCBvcHRpb25zPzogTmJUb2dnbGVPcHRpb25zKTogdm9pZDtcbiAgICB0b2dnbGVDZWxsUm93KGNlbGw6IE5iVHJlZUdyaWRDZWxsRGlyZWN0aXZlKTogdm9pZDtcbiAgICBnZXRDb2x1bW5XaWR0aCgpOiBzdHJpbmc7XG4gICAgZ2V0Q2VsbExldmVsKGNlbGw6IE5iVHJlZUdyaWRDZWxsRGlyZWN0aXZlLCBjb2x1bW5OYW1lOiBzdHJpbmcpOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBnZXREYXRhSW5kZXg7XG4gICAgcHJpdmF0ZSBnZXRSb3dMZXZlbDtcbiAgICBwcml2YXRlIGdldENvbHVtbnM7XG4gICAgcHJpdmF0ZSBnZXRDb2x1bW5zQ291bnQ7XG4gICAgcHJpdmF0ZSBpc0ZpcnN0Q29sdW1uO1xuICAgIHByaXZhdGUgZmluZENlbGxSb3c7XG4gICAgcHJpdmF0ZSBjaGVja0RlZnNDb3VudDtcbiAgICBwcml2YXRlIHVwZGF0ZVZpc2libGVDb2x1bW5zO1xufVxuIl19