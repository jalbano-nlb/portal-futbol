/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import { EventEmitter, OnChanges, Type } from '@angular/core';
import { NbCalendarCell, NbCalendarSize } from '../../model';
import { NbDateService } from '../../services/date.service';
import * as ɵngcc0 from '@angular/core';
export declare const YEARS_IN_VIEW = 20;
export declare const YEARS_IN_COLUMN = 4;
export declare class NbCalendarYearPickerComponent<D> implements OnChanges {
    protected dateService: NbDateService<D>;
    date: D;
    min: D;
    max: D;
    filter: (D: any) => boolean;
    _cellComponent: Type<NbCalendarCell<D, D>>;
    cellComponent: Type<NbCalendarCell<D, D>>;
    size: NbCalendarSize;
    year: D;
    yearChange: EventEmitter<D>;
    readonly medium: boolean;
    readonly large: boolean;
    years: D[][];
    constructor(dateService: NbDateService<D>);
    ngOnChanges(): void;
    initYears(): void;
    onSelect(year: any): void;
    private createYearDateByIndex;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbCalendarYearPickerComponent<any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbCalendarYearPickerComponent<any>, "nb-calendar-year-picker", never, {
    "size": "size";
    "_cellComponent": "cellComponent";
    "date": "date";
    "min": "min";
    "max": "max";
    "filter": "filter";
    "year": "year";
}, {
    "yearChange": "yearChange";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIteWVhci1waWNrZXIuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbImNhbGVuZGFyLXllYXItcGlja2VyLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBPbkNoYW5nZXMsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5iQ2FsZW5kYXJDZWxsLCBOYkNhbGVuZGFyU2l6ZSB9IGZyb20gJy4uLy4uL21vZGVsJztcbmltcG9ydCB7IE5iRGF0ZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9kYXRlLnNlcnZpY2UnO1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgWUVBUlNfSU5fVklFVyA9IDIwO1xuZXhwb3J0IGRlY2xhcmUgY29uc3QgWUVBUlNfSU5fQ09MVU1OID0gNDtcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iQ2FsZW5kYXJZZWFyUGlja2VyQ29tcG9uZW50PEQ+IGltcGxlbWVudHMgT25DaGFuZ2VzIHtcbiAgICBwcm90ZWN0ZWQgZGF0ZVNlcnZpY2U6IE5iRGF0ZVNlcnZpY2U8RD47XG4gICAgZGF0ZTogRDtcbiAgICBtaW46IEQ7XG4gICAgbWF4OiBEO1xuICAgIGZpbHRlcjogKEQ6IGFueSkgPT4gYm9vbGVhbjtcbiAgICBfY2VsbENvbXBvbmVudDogVHlwZTxOYkNhbGVuZGFyQ2VsbDxELCBEPj47XG4gICAgY2VsbENvbXBvbmVudDogVHlwZTxOYkNhbGVuZGFyQ2VsbDxELCBEPj47XG4gICAgc2l6ZTogTmJDYWxlbmRhclNpemU7XG4gICAgeWVhcjogRDtcbiAgICB5ZWFyQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RD47XG4gICAgcmVhZG9ubHkgbWVkaXVtOiBib29sZWFuO1xuICAgIHJlYWRvbmx5IGxhcmdlOiBib29sZWFuO1xuICAgIHllYXJzOiBEW11bXTtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZTogTmJEYXRlU2VydmljZTxEPik7XG4gICAgbmdPbkNoYW5nZXMoKTogdm9pZDtcbiAgICBpbml0WWVhcnMoKTogdm9pZDtcbiAgICBvblNlbGVjdCh5ZWFyOiBhbnkpOiB2b2lkO1xuICAgIHByaXZhdGUgY3JlYXRlWWVhckRhdGVCeUluZGV4O1xufVxuIl19