import { ComponentFactoryResolver, ComponentRef, OnChanges, ElementRef, EventEmitter, OnDestroy, Type, AfterViewInit, OnInit, SimpleChanges } from '@angular/core';
import { Observable, ReplaySubject, Subject } from 'rxjs';
import { NbOverlayRef } from '../cdk/overlay/mapping';
import { NbAdjustableConnectedPositionStrategy, NbPositionBuilderService } from '../cdk/overlay/overlay-position';
import { NbOverlayService } from '../cdk/overlay/overlay-service';
import { NbTriggerStrategy, NbTriggerStrategyBuilderService } from '../cdk/overlay/overlay-trigger';
import { NbDatepickerContainerComponent } from './datepicker-container.component';
import { NbCalendarRange, NbCalendarRangeComponent } from '../calendar/calendar-range.component';
import { NbCalendarComponent } from '../calendar/calendar.component';
import { NbCalendarCell, NbCalendarSize, NbCalendarViewMode } from '../calendar-kit/model';
import { NbDateService } from '../calendar-kit/services/date.service';
import { NbDatepicker, NbPickerValidatorConfig } from './datepicker.directive';
/**
 * The `NbBasePicker` component concentrates overlay manipulation logic.
 * */
import * as ɵngcc0 from '@angular/core';
export declare abstract class NbBasePicker<D, T, P> extends NbDatepicker<T> implements OnInit, OnChanges, AfterViewInit, OnDestroy {
    protected overlay: NbOverlayService;
    protected positionBuilder: NbPositionBuilderService;
    protected triggerStrategyBuilder: NbTriggerStrategyBuilderService;
    protected cfr: ComponentFactoryResolver;
    protected dateService: NbDateService<D>;
    protected dateServiceOptions: any;
    /**
     * Datepicker date format. Can be used only with date adapters (moment, date-fns) since native date
     * object doesn't support formatting.
     * */
    abstract format: string;
    /**
     * Defines if we should render previous and next months
     * in the current month view.
     * */
    abstract boundingMonth: boolean;
    /**
     * Defines starting view for calendar.
     * */
    abstract startView: NbCalendarViewMode;
    /**
     * Minimum available date for selection.
     * */
    abstract min: T;
    /**
     * Maximum available date for selection.
     * */
    abstract max: T;
    /**
     * Predicate that decides which cells will be disabled.
     * */
    abstract filter: (T: any) => boolean;
    /**
     * Custom day cell component. Have to implement `NbCalendarCell` interface.
     * */
    abstract dayCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Custom month cell component. Have to implement `NbCalendarCell` interface.
     * */
    abstract monthCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Custom year cell component. Have to implement `NbCalendarCell` interface.
     * */
    abstract yearCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Size of the calendar and entire components.
     * Can be 'medium' which is default or 'large'.
     * */
    abstract size: NbCalendarSize;
    /**
     * Depending on this date a particular month is selected in the calendar
     */
    abstract visibleDate: D;
    /**
     * Hide picker when a date or a range is selected, `true` by default
     * @type {boolean}
     */
    abstract hideOnSelect: boolean;
    /**
     * Determines should we show calendars header or not.
     * @type {boolean}
     */
    abstract showHeader: boolean;
    /**
     * Sets symbol used as a header for week numbers column
     * */
    abstract weekNumberSymbol: string;
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    abstract showWeekNumber: boolean;
    /**
     * Calendar component class that has to be instantiated inside overlay.
     * */
    protected abstract pickerClass: Type<P>;
    /**
     * Overlay reference object.
     * */
    protected ref: NbOverlayRef;
    /**
     * Datepicker container that contains instantiated picker.
     * */
    protected container: ComponentRef<NbDatepickerContainerComponent>;
    /**
     * Positioning strategy used by overlay.
     * */
    protected positionStrategy: NbAdjustableConnectedPositionStrategy;
    /**
     * Trigger strategy used by overlay
     * */
    protected triggerStrategy: NbTriggerStrategy;
    /**
     * HTML input reference to which datepicker connected.
     * */
    protected hostRef: ElementRef;
    protected init$: ReplaySubject<void>;
    /**
     * Stream of picker changes. Required to be the subject because picker hides and shows and picker
     * change stream becomes recreated.
     * */
    protected onChange$: Subject<T>;
    /**
     * Reference to the picker instance itself.
     * */
    protected pickerRef: ComponentRef<any>;
    protected alive: boolean;
    /**
     * Queue contains the last value that was applied to the picker when it was hidden.
     * This value will be passed to the picker as soon as it shown.
     * */
    protected queue: T | undefined;
    protected blur$: Subject<void>;
    protected constructor(overlay: NbOverlayService, positionBuilder: NbPositionBuilderService, triggerStrategyBuilder: NbTriggerStrategyBuilderService, cfr: ComponentFactoryResolver, dateService: NbDateService<D>, dateServiceOptions: any);
    /**
     * Returns picker instance.
     * */
    readonly picker: any;
    /**
     * Stream of picker value changes.
     * */
    readonly valueChange: Observable<T>;
    readonly isShown: boolean;
    readonly init: Observable<void>;
    /**
     * Emits when datepicker looses focus.
     */
    readonly blur: Observable<void>;
    protected abstract readonly pickerValueChange: Observable<T>;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /**
     * Datepicker knows nothing about host html input element.
     * So, attach method attaches datepicker to the host input element.
     * */
    attach(hostRef: ElementRef): void;
    getValidatorConfig(): NbPickerValidatorConfig<T>;
    show(): void;
    shouldHide(): boolean;
    hide(): void;
    protected abstract writeQueue(): any;
    protected createOverlay(): void;
    protected openDatepicker(): void;
    protected createPositionStrategy(): NbAdjustableConnectedPositionStrategy;
    protected subscribeOnPositionChange(): void;
    protected createTriggerStrategy(): NbTriggerStrategy;
    protected subscribeOnTriggers(): void;
    protected instantiatePicker(): void;
    /**
     * Subscribes on picker value changes and emit data through this.onChange$ subject.
     * */
    protected subscribeOnValueChange(): void;
    protected patchWithInputs(): void;
    protected checkFormat(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbBasePicker<any, any, any>>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbBasePicker<any, any, any>, never, never, {}, {}, never>;
}
export declare class NbBasePickerComponent<D, T, P> extends NbBasePicker<D, T, P> {
    /**
     * Datepicker date format. Can be used only with date adapters (moment, date-fns) since native date
     * object doesn't support formatting.
     * */
    format: string;
    /**
     * Defines if we should render previous and next months
     * in the current month view.
     * */
    boundingMonth: boolean;
    /**
     * Defines starting view for calendar.
     * */
    startView: NbCalendarViewMode;
    /**
     * Minimum available date for selection.
     * */
    min: T;
    /**
     * Maximum available date for selection.
     * */
    max: T;
    /**
     * Predicate that decides which cells will be disabled.
     * */
    filter: (T: any) => boolean;
    /**
     * Custom day cell component. Have to implement `NbCalendarCell` interface.
     * */
    dayCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Custom month cell component. Have to implement `NbCalendarCell` interface.
     * */
    monthCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Custom year cell component. Have to implement `NbCalendarCell` interface.
     * */
    yearCellComponent: Type<NbCalendarCell<D, T>>;
    /**
     * Size of the calendar and entire components.
     * Can be 'medium' which is default or 'large'.
     * */
    size: NbCalendarSize;
    /**
     * Depending on this date a particular month is selected in the calendar
     */
    visibleDate: D;
    /**
     * Hide picker when a date or a range is selected, `true` by default
     * @type {boolean}
     */
    hideOnSelect: boolean;
    /**
     * Determines should we show calendars header or not.
     * @type {boolean}
     */
    showHeader: boolean;
    /**
     * Sets symbol used as a header for week numbers column
     * */
    weekNumberSymbol: string;
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    showWeekNumber: boolean;
    protected _showWeekNumber: boolean;
    constructor(document: any, positionBuilder: NbPositionBuilderService, triggerStrategyBuilder: NbTriggerStrategyBuilderService, overlay: NbOverlayService, cfr: ComponentFactoryResolver, dateService: NbDateService<D>, dateServiceOptions: any);
    protected pickerClass: Type<P>;
    protected readonly pickerValueChange: Observable<T>;
    value: T | undefined;
    protected writeQueue(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbBasePickerComponent<any, any, any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbBasePickerComponent<any, any, any>, "ng-component", never, {
    "boundingMonth": "boundingMonth";
    "startView": "startView";
    "size": "size";
    "hideOnSelect": "hideOnSelect";
    "showHeader": "showHeader";
    "weekNumberSymbol": "weekNumberSymbol";
    "showWeekNumber": "showWeekNumber";
    "format": "format";
    "min": "min";
    "max": "max";
    "filter": "filter";
    "dayCellComponent": "dayCellComponent";
    "monthCellComponent": "monthCellComponent";
    "yearCellComponent": "yearCellComponent";
    "visibleDate": "visibleDate";
}, {}, never>;
}
/**
 * The DatePicker components itself.
 * Provides a proxy to `NbCalendar` options as well as custom picker options.
 */
export declare class NbDatepickerComponent<D> extends NbBasePickerComponent<D, D, NbCalendarComponent<D>> {
    protected pickerClass: Type<NbCalendarComponent<D>>;
    /**
     * Date which will be rendered as selected.
     * */
    date: D;
    /**
     * Emits date when selected.
     * */
    readonly dateChange: EventEmitter<D>;
    value: D | undefined;
    protected readonly pickerValueChange: Observable<D>;
    protected writeQueue(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbDatepickerComponent<any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbDatepickerComponent<any>, "nb-datepicker", never, {
    "date": "date";
}, {
    "dateChange": "dateChange";
}, never>;
}
/**
 * The RangeDatePicker components itself.
 * Provides a proxy to `NbCalendarRange` options as well as custom picker options.
 */
export declare class NbRangepickerComponent<D> extends NbBasePickerComponent<D, NbCalendarRange<D>, NbCalendarRangeComponent<D>> {
    protected pickerClass: Type<NbCalendarRangeComponent<D>>;
    /**
     * Range which will be rendered as selected.
     * */
    range: NbCalendarRange<D>;
    /**
     * Emits range when start selected and emits again when end selected.
     * */
    readonly rangeChange: EventEmitter<NbCalendarRange<D>>;
    value: NbCalendarRange<D> | undefined;
    protected readonly pickerValueChange: Observable<NbCalendarRange<D>>;
    shouldHide(): boolean;
    protected writeQueue(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbRangepickerComponent<any>>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<NbRangepickerComponent<any>, "nb-rangepicker", never, {
    "range": "range";
}, {
    "rangeChange": "rangeChange";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiZGF0ZXBpY2tlci5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7OztBQWVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE2SkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbXBvbmVudFJlZiwgT25DaGFuZ2VzLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgVHlwZSwgQWZ0ZXJWaWV3SW5pdCwgT25Jbml0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0LCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBOYk92ZXJsYXlSZWYgfSBmcm9tICcuLi9jZGsvb3ZlcmxheS9tYXBwaW5nJztcbmltcG9ydCB7IE5iQWRqdXN0YWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksIE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSB9IGZyb20gJy4uL2Nkay9vdmVybGF5L292ZXJsYXktcG9zaXRpb24nO1xuaW1wb3J0IHsgTmJPdmVybGF5U2VydmljZSB9IGZyb20gJy4uL2Nkay9vdmVybGF5L292ZXJsYXktc2VydmljZSc7XG5pbXBvcnQgeyBOYlRyaWdnZXJTdHJhdGVneSwgTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uL2Nkay9vdmVybGF5L292ZXJsYXktdHJpZ2dlcic7XG5pbXBvcnQgeyBOYkRhdGVwaWNrZXJDb250YWluZXJDb21wb25lbnQgfSBmcm9tICcuL2RhdGVwaWNrZXItY29udGFpbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOYkNhbGVuZGFyUmFuZ2UsIE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudCB9IGZyb20gJy4uL2NhbGVuZGFyL2NhbGVuZGFyLXJhbmdlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOYkNhbGVuZGFyQ29tcG9uZW50IH0gZnJvbSAnLi4vY2FsZW5kYXIvY2FsZW5kYXIuY29tcG9uZW50JztcbmltcG9ydCB7IE5iQ2FsZW5kYXJDZWxsLCBOYkNhbGVuZGFyU2l6ZSwgTmJDYWxlbmRhclZpZXdNb2RlIH0gZnJvbSAnLi4vY2FsZW5kYXIta2l0L21vZGVsJztcbmltcG9ydCB7IE5iRGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9jYWxlbmRhci1raXQvc2VydmljZXMvZGF0ZS5zZXJ2aWNlJztcbmltcG9ydCB7IE5iRGF0ZXBpY2tlciwgTmJQaWNrZXJWYWxpZGF0b3JDb25maWcgfSBmcm9tICcuL2RhdGVwaWNrZXIuZGlyZWN0aXZlJztcbi8qKlxuICogVGhlIGBOYkJhc2VQaWNrZXJgIGNvbXBvbmVudCBjb25jZW50cmF0ZXMgb3ZlcmxheSBtYW5pcHVsYXRpb24gbG9naWMuXG4gKiAqL1xuZXhwb3J0IGRlY2xhcmUgYWJzdHJhY3QgY2xhc3MgTmJCYXNlUGlja2VyPEQsIFQsIFA+IGV4dGVuZHMgTmJEYXRlcGlja2VyPFQ+IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gICAgcHJvdGVjdGVkIG92ZXJsYXk6IE5iT3ZlcmxheVNlcnZpY2U7XG4gICAgcHJvdGVjdGVkIHBvc2l0aW9uQnVpbGRlcjogTmJQb3NpdGlvbkJ1aWxkZXJTZXJ2aWNlO1xuICAgIHByb3RlY3RlZCB0cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyOiBOYlRyaWdnZXJTdHJhdGVneUJ1aWxkZXJTZXJ2aWNlO1xuICAgIHByb3RlY3RlZCBjZnI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICBwcm90ZWN0ZWQgZGF0ZVNlcnZpY2U6IE5iRGF0ZVNlcnZpY2U8RD47XG4gICAgcHJvdGVjdGVkIGRhdGVTZXJ2aWNlT3B0aW9uczogYW55O1xuICAgIC8qKlxuICAgICAqIERhdGVwaWNrZXIgZGF0ZSBmb3JtYXQuIENhbiBiZSB1c2VkIG9ubHkgd2l0aCBkYXRlIGFkYXB0ZXJzIChtb21lbnQsIGRhdGUtZm5zKSBzaW5jZSBuYXRpdmUgZGF0ZVxuICAgICAqIG9iamVjdCBkb2Vzbid0IHN1cHBvcnQgZm9ybWF0dGluZy5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IGZvcm1hdDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgaWYgd2Ugc2hvdWxkIHJlbmRlciBwcmV2aW91cyBhbmQgbmV4dCBtb250aHNcbiAgICAgKiBpbiB0aGUgY3VycmVudCBtb250aCB2aWV3LlxuICAgICAqICovXG4gICAgYWJzdHJhY3QgYm91bmRpbmdNb250aDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHN0YXJ0aW5nIHZpZXcgZm9yIGNhbGVuZGFyLlxuICAgICAqICovXG4gICAgYWJzdHJhY3Qgc3RhcnRWaWV3OiBOYkNhbGVuZGFyVmlld01vZGU7XG4gICAgLyoqXG4gICAgICogTWluaW11bSBhdmFpbGFibGUgZGF0ZSBmb3Igc2VsZWN0aW9uLlxuICAgICAqICovXG4gICAgYWJzdHJhY3QgbWluOiBUO1xuICAgIC8qKlxuICAgICAqIE1heGltdW0gYXZhaWxhYmxlIGRhdGUgZm9yIHNlbGVjdGlvbi5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IG1heDogVDtcbiAgICAvKipcbiAgICAgKiBQcmVkaWNhdGUgdGhhdCBkZWNpZGVzIHdoaWNoIGNlbGxzIHdpbGwgYmUgZGlzYWJsZWQuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBmaWx0ZXI6IChUOiBhbnkpID0+IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGRheSBjZWxsIGNvbXBvbmVudC4gSGF2ZSB0byBpbXBsZW1lbnQgYE5iQ2FsZW5kYXJDZWxsYCBpbnRlcmZhY2UuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBkYXlDZWxsQ29tcG9uZW50OiBUeXBlPE5iQ2FsZW5kYXJDZWxsPEQsIFQ+PjtcbiAgICAvKipcbiAgICAgKiBDdXN0b20gbW9udGggY2VsbCBjb21wb25lbnQuIEhhdmUgdG8gaW1wbGVtZW50IGBOYkNhbGVuZGFyQ2VsbGAgaW50ZXJmYWNlLlxuICAgICAqICovXG4gICAgYWJzdHJhY3QgbW9udGhDZWxsQ29tcG9uZW50OiBUeXBlPE5iQ2FsZW5kYXJDZWxsPEQsIFQ+PjtcbiAgICAvKipcbiAgICAgKiBDdXN0b20geWVhciBjZWxsIGNvbXBvbmVudC4gSGF2ZSB0byBpbXBsZW1lbnQgYE5iQ2FsZW5kYXJDZWxsYCBpbnRlcmZhY2UuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCB5ZWFyQ2VsbENvbXBvbmVudDogVHlwZTxOYkNhbGVuZGFyQ2VsbDxELCBUPj47XG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiB0aGUgY2FsZW5kYXIgYW5kIGVudGlyZSBjb21wb25lbnRzLlxuICAgICAqIENhbiBiZSAnbWVkaXVtJyB3aGljaCBpcyBkZWZhdWx0IG9yICdsYXJnZScuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBzaXplOiBOYkNhbGVuZGFyU2l6ZTtcbiAgICAvKipcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhpcyBkYXRlIGEgcGFydGljdWxhciBtb250aCBpcyBzZWxlY3RlZCBpbiB0aGUgY2FsZW5kYXJcbiAgICAgKi9cbiAgICBhYnN0cmFjdCB2aXNpYmxlRGF0ZTogRDtcbiAgICAvKipcbiAgICAgKiBIaWRlIHBpY2tlciB3aGVuIGEgZGF0ZSBvciBhIHJhbmdlIGlzIHNlbGVjdGVkLCBgdHJ1ZWAgYnkgZGVmYXVsdFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGFic3RyYWN0IGhpZGVPblNlbGVjdDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHNob3VsZCB3ZSBzaG93IGNhbGVuZGFycyBoZWFkZXIgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGFic3RyYWN0IHNob3dIZWFkZXI6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU2V0cyBzeW1ib2wgdXNlZCBhcyBhIGhlYWRlciBmb3Igd2VlayBudW1iZXJzIGNvbHVtblxuICAgICAqICovXG4gICAgYWJzdHJhY3Qgd2Vla051bWJlclN5bWJvbDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgd2VlayBudW1iZXJzIGNvbHVtbi5cbiAgICAgKiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqICovXG4gICAgYWJzdHJhY3Qgc2hvd1dlZWtOdW1iZXI6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQ2FsZW5kYXIgY29tcG9uZW50IGNsYXNzIHRoYXQgaGFzIHRvIGJlIGluc3RhbnRpYXRlZCBpbnNpZGUgb3ZlcmxheS5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBwaWNrZXJDbGFzczogVHlwZTxQPjtcbiAgICAvKipcbiAgICAgKiBPdmVybGF5IHJlZmVyZW5jZSBvYmplY3QuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgcmVmOiBOYk92ZXJsYXlSZWY7XG4gICAgLyoqXG4gICAgICogRGF0ZXBpY2tlciBjb250YWluZXIgdGhhdCBjb250YWlucyBpbnN0YW50aWF0ZWQgcGlja2VyLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIGNvbnRhaW5lcjogQ29tcG9uZW50UmVmPE5iRGF0ZXBpY2tlckNvbnRhaW5lckNvbXBvbmVudD47XG4gICAgLyoqXG4gICAgICogUG9zaXRpb25pbmcgc3RyYXRlZ3kgdXNlZCBieSBvdmVybGF5LlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIHBvc2l0aW9uU3RyYXRlZ3k6IE5iQWRqdXN0YWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBzdHJhdGVneSB1c2VkIGJ5IG92ZXJsYXlcbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCB0cmlnZ2VyU3RyYXRlZ3k6IE5iVHJpZ2dlclN0cmF0ZWd5O1xuICAgIC8qKlxuICAgICAqIEhUTUwgaW5wdXQgcmVmZXJlbmNlIHRvIHdoaWNoIGRhdGVwaWNrZXIgY29ubmVjdGVkLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIGhvc3RSZWY6IEVsZW1lbnRSZWY7XG4gICAgcHJvdGVjdGVkIGluaXQkOiBSZXBsYXlTdWJqZWN0PHZvaWQ+O1xuICAgIC8qKlxuICAgICAqIFN0cmVhbSBvZiBwaWNrZXIgY2hhbmdlcy4gUmVxdWlyZWQgdG8gYmUgdGhlIHN1YmplY3QgYmVjYXVzZSBwaWNrZXIgaGlkZXMgYW5kIHNob3dzIGFuZCBwaWNrZXJcbiAgICAgKiBjaGFuZ2Ugc3RyZWFtIGJlY29tZXMgcmVjcmVhdGVkLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIG9uQ2hhbmdlJDogU3ViamVjdDxUPjtcbiAgICAvKipcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHBpY2tlciBpbnN0YW5jZSBpdHNlbGYuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgcGlja2VyUmVmOiBDb21wb25lbnRSZWY8YW55PjtcbiAgICBwcm90ZWN0ZWQgYWxpdmU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogUXVldWUgY29udGFpbnMgdGhlIGxhc3QgdmFsdWUgdGhhdCB3YXMgYXBwbGllZCB0byB0aGUgcGlja2VyIHdoZW4gaXQgd2FzIGhpZGRlbi5cbiAgICAgKiBUaGlzIHZhbHVlIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBwaWNrZXIgYXMgc29vbiBhcyBpdCBzaG93bi5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBxdWV1ZTogVCB8IHVuZGVmaW5lZDtcbiAgICBwcm90ZWN0ZWQgYmx1ciQ6IFN1YmplY3Q8dm9pZD47XG4gICAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKG92ZXJsYXk6IE5iT3ZlcmxheVNlcnZpY2UsIHBvc2l0aW9uQnVpbGRlcjogTmJQb3NpdGlvbkJ1aWxkZXJTZXJ2aWNlLCB0cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyOiBOYlRyaWdnZXJTdHJhdGVneUJ1aWxkZXJTZXJ2aWNlLCBjZnI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgZGF0ZVNlcnZpY2U6IE5iRGF0ZVNlcnZpY2U8RD4sIGRhdGVTZXJ2aWNlT3B0aW9uczogYW55KTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHBpY2tlciBpbnN0YW5jZS5cbiAgICAgKiAqL1xuICAgIHJlYWRvbmx5IHBpY2tlcjogYW55O1xuICAgIC8qKlxuICAgICAqIFN0cmVhbSBvZiBwaWNrZXIgdmFsdWUgY2hhbmdlcy5cbiAgICAgKiAqL1xuICAgIHJlYWRvbmx5IHZhbHVlQ2hhbmdlOiBPYnNlcnZhYmxlPFQ+O1xuICAgIHJlYWRvbmx5IGlzU2hvd246IGJvb2xlYW47XG4gICAgcmVhZG9ubHkgaW5pdDogT2JzZXJ2YWJsZTx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIGRhdGVwaWNrZXIgbG9vc2VzIGZvY3VzLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGJsdXI6IE9ic2VydmFibGU8dm9pZD47XG4gICAgcHJvdGVjdGVkIGFic3RyYWN0IHJlYWRvbmx5IHBpY2tlclZhbHVlQ2hhbmdlOiBPYnNlcnZhYmxlPFQ+O1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQ7XG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQ7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBEYXRlcGlja2VyIGtub3dzIG5vdGhpbmcgYWJvdXQgaG9zdCBodG1sIGlucHV0IGVsZW1lbnQuXG4gICAgICogU28sIGF0dGFjaCBtZXRob2QgYXR0YWNoZXMgZGF0ZXBpY2tlciB0byB0aGUgaG9zdCBpbnB1dCBlbGVtZW50LlxuICAgICAqICovXG4gICAgYXR0YWNoKGhvc3RSZWY6IEVsZW1lbnRSZWYpOiB2b2lkO1xuICAgIGdldFZhbGlkYXRvckNvbmZpZygpOiBOYlBpY2tlclZhbGlkYXRvckNvbmZpZzxUPjtcbiAgICBzaG93KCk6IHZvaWQ7XG4gICAgc2hvdWxkSGlkZSgpOiBib29sZWFuO1xuICAgIGhpZGUoKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3Qgd3JpdGVRdWV1ZSgpOiBhbnk7XG4gICAgcHJvdGVjdGVkIGNyZWF0ZU92ZXJsYXkoKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgb3BlbkRhdGVwaWNrZXIoKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgY3JlYXRlUG9zaXRpb25TdHJhdGVneSgpOiBOYkFkanVzdGFibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5O1xuICAgIHByb3RlY3RlZCBzdWJzY3JpYmVPblBvc2l0aW9uQ2hhbmdlKCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIGNyZWF0ZVRyaWdnZXJTdHJhdGVneSgpOiBOYlRyaWdnZXJTdHJhdGVneTtcbiAgICBwcm90ZWN0ZWQgc3Vic2NyaWJlT25UcmlnZ2VycygpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBpbnN0YW50aWF0ZVBpY2tlcigpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgb24gcGlja2VyIHZhbHVlIGNoYW5nZXMgYW5kIGVtaXQgZGF0YSB0aHJvdWdoIHRoaXMub25DaGFuZ2UkIHN1YmplY3QuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgc3Vic2NyaWJlT25WYWx1ZUNoYW5nZSgpOiB2b2lkO1xuICAgIHByb3RlY3RlZCBwYXRjaFdpdGhJbnB1dHMoKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgY2hlY2tGb3JtYXQoKTogdm9pZDtcbn1cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iQmFzZVBpY2tlckNvbXBvbmVudDxELCBULCBQPiBleHRlbmRzIE5iQmFzZVBpY2tlcjxELCBULCBQPiB7XG4gICAgLyoqXG4gICAgICogRGF0ZXBpY2tlciBkYXRlIGZvcm1hdC4gQ2FuIGJlIHVzZWQgb25seSB3aXRoIGRhdGUgYWRhcHRlcnMgKG1vbWVudCwgZGF0ZS1mbnMpIHNpbmNlIG5hdGl2ZSBkYXRlXG4gICAgICogb2JqZWN0IGRvZXNuJ3Qgc3VwcG9ydCBmb3JtYXR0aW5nLlxuICAgICAqICovXG4gICAgZm9ybWF0OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBpZiB3ZSBzaG91bGQgcmVuZGVyIHByZXZpb3VzIGFuZCBuZXh0IG1vbnRoc1xuICAgICAqIGluIHRoZSBjdXJyZW50IG1vbnRoIHZpZXcuXG4gICAgICogKi9cbiAgICBib3VuZGluZ01vbnRoOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgc3RhcnRpbmcgdmlldyBmb3IgY2FsZW5kYXIuXG4gICAgICogKi9cbiAgICBzdGFydFZpZXc6IE5iQ2FsZW5kYXJWaWV3TW9kZTtcbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGF2YWlsYWJsZSBkYXRlIGZvciBzZWxlY3Rpb24uXG4gICAgICogKi9cbiAgICBtaW46IFQ7XG4gICAgLyoqXG4gICAgICogTWF4aW11bSBhdmFpbGFibGUgZGF0ZSBmb3Igc2VsZWN0aW9uLlxuICAgICAqICovXG4gICAgbWF4OiBUO1xuICAgIC8qKlxuICAgICAqIFByZWRpY2F0ZSB0aGF0IGRlY2lkZXMgd2hpY2ggY2VsbHMgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgKiAqL1xuICAgIGZpbHRlcjogKFQ6IGFueSkgPT4gYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBDdXN0b20gZGF5IGNlbGwgY29tcG9uZW50LiBIYXZlIHRvIGltcGxlbWVudCBgTmJDYWxlbmRhckNlbGxgIGludGVyZmFjZS5cbiAgICAgKiAqL1xuICAgIGRheUNlbGxDb21wb25lbnQ6IFR5cGU8TmJDYWxlbmRhckNlbGw8RCwgVD4+O1xuICAgIC8qKlxuICAgICAqIEN1c3RvbSBtb250aCBjZWxsIGNvbXBvbmVudC4gSGF2ZSB0byBpbXBsZW1lbnQgYE5iQ2FsZW5kYXJDZWxsYCBpbnRlcmZhY2UuXG4gICAgICogKi9cbiAgICBtb250aENlbGxDb21wb25lbnQ6IFR5cGU8TmJDYWxlbmRhckNlbGw8RCwgVD4+O1xuICAgIC8qKlxuICAgICAqIEN1c3RvbSB5ZWFyIGNlbGwgY29tcG9uZW50LiBIYXZlIHRvIGltcGxlbWVudCBgTmJDYWxlbmRhckNlbGxgIGludGVyZmFjZS5cbiAgICAgKiAqL1xuICAgIHllYXJDZWxsQ29tcG9uZW50OiBUeXBlPE5iQ2FsZW5kYXJDZWxsPEQsIFQ+PjtcbiAgICAvKipcbiAgICAgKiBTaXplIG9mIHRoZSBjYWxlbmRhciBhbmQgZW50aXJlIGNvbXBvbmVudHMuXG4gICAgICogQ2FuIGJlICdtZWRpdW0nIHdoaWNoIGlzIGRlZmF1bHQgb3IgJ2xhcmdlJy5cbiAgICAgKiAqL1xuICAgIHNpemU6IE5iQ2FsZW5kYXJTaXplO1xuICAgIC8qKlxuICAgICAqIERlcGVuZGluZyBvbiB0aGlzIGRhdGUgYSBwYXJ0aWN1bGFyIG1vbnRoIGlzIHNlbGVjdGVkIGluIHRoZSBjYWxlbmRhclxuICAgICAqL1xuICAgIHZpc2libGVEYXRlOiBEO1xuICAgIC8qKlxuICAgICAqIEhpZGUgcGlja2VyIHdoZW4gYSBkYXRlIG9yIGEgcmFuZ2UgaXMgc2VsZWN0ZWQsIGB0cnVlYCBieSBkZWZhdWx0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGlkZU9uU2VsZWN0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgY2FsZW5kYXJzIGhlYWRlciBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2hvd0hlYWRlcjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTZXRzIHN5bWJvbCB1c2VkIGFzIGEgaGVhZGVyIGZvciB3ZWVrIG51bWJlcnMgY29sdW1uXG4gICAgICogKi9cbiAgICB3ZWVrTnVtYmVyU3ltYm9sOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBzaG91bGQgd2Ugc2hvdyB3ZWVrIG51bWJlcnMgY29sdW1uLlxuICAgICAqIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICogKi9cbiAgICBzaG93V2Vla051bWJlcjogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgX3Nob3dXZWVrTnVtYmVyOiBib29sZWFuO1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50OiBhbnksIHBvc2l0aW9uQnVpbGRlcjogTmJQb3NpdGlvbkJ1aWxkZXJTZXJ2aWNlLCB0cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyOiBOYlRyaWdnZXJTdHJhdGVneUJ1aWxkZXJTZXJ2aWNlLCBvdmVybGF5OiBOYk92ZXJsYXlTZXJ2aWNlLCBjZnI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgZGF0ZVNlcnZpY2U6IE5iRGF0ZVNlcnZpY2U8RD4sIGRhdGVTZXJ2aWNlT3B0aW9uczogYW55KTtcbiAgICBwcm90ZWN0ZWQgcGlja2VyQ2xhc3M6IFR5cGU8UD47XG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHBpY2tlclZhbHVlQ2hhbmdlOiBPYnNlcnZhYmxlPFQ+O1xuICAgIHZhbHVlOiBUIHwgdW5kZWZpbmVkO1xuICAgIHByb3RlY3RlZCB3cml0ZVF1ZXVlKCk6IHZvaWQ7XG59XG4vKipcbiAqIFRoZSBEYXRlUGlja2VyIGNvbXBvbmVudHMgaXRzZWxmLlxuICogUHJvdmlkZXMgYSBwcm94eSB0byBgTmJDYWxlbmRhcmAgb3B0aW9ucyBhcyB3ZWxsIGFzIGN1c3RvbSBwaWNrZXIgb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTmJEYXRlcGlja2VyQ29tcG9uZW50PEQ+IGV4dGVuZHMgTmJCYXNlUGlja2VyQ29tcG9uZW50PEQsIEQsIE5iQ2FsZW5kYXJDb21wb25lbnQ8RD4+IHtcbiAgICBwcm90ZWN0ZWQgcGlja2VyQ2xhc3M6IFR5cGU8TmJDYWxlbmRhckNvbXBvbmVudDxEPj47XG4gICAgLyoqXG4gICAgICogRGF0ZSB3aGljaCB3aWxsIGJlIHJlbmRlcmVkIGFzIHNlbGVjdGVkLlxuICAgICAqICovXG4gICAgZGF0ZTogRDtcbiAgICAvKipcbiAgICAgKiBFbWl0cyBkYXRlIHdoZW4gc2VsZWN0ZWQuXG4gICAgICogKi9cbiAgICByZWFkb25seSBkYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RD47XG4gICAgdmFsdWU6IEQgfCB1bmRlZmluZWQ7XG4gICAgcHJvdGVjdGVkIHJlYWRvbmx5IHBpY2tlclZhbHVlQ2hhbmdlOiBPYnNlcnZhYmxlPEQ+O1xuICAgIHByb3RlY3RlZCB3cml0ZVF1ZXVlKCk6IHZvaWQ7XG59XG4vKipcbiAqIFRoZSBSYW5nZURhdGVQaWNrZXIgY29tcG9uZW50cyBpdHNlbGYuXG4gKiBQcm92aWRlcyBhIHByb3h5IHRvIGBOYkNhbGVuZGFyUmFuZ2VgIG9wdGlvbnMgYXMgd2VsbCBhcyBjdXN0b20gcGlja2VyIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iUmFuZ2VwaWNrZXJDb21wb25lbnQ8RD4gZXh0ZW5kcyBOYkJhc2VQaWNrZXJDb21wb25lbnQ8RCwgTmJDYWxlbmRhclJhbmdlPEQ+LCBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQ8RD4+IHtcbiAgICBwcm90ZWN0ZWQgcGlja2VyQ2xhc3M6IFR5cGU8TmJDYWxlbmRhclJhbmdlQ29tcG9uZW50PEQ+PjtcbiAgICAvKipcbiAgICAgKiBSYW5nZSB3aGljaCB3aWxsIGJlIHJlbmRlcmVkIGFzIHNlbGVjdGVkLlxuICAgICAqICovXG4gICAgcmFuZ2U6IE5iQ2FsZW5kYXJSYW5nZTxEPjtcbiAgICAvKipcbiAgICAgKiBFbWl0cyByYW5nZSB3aGVuIHN0YXJ0IHNlbGVjdGVkIGFuZCBlbWl0cyBhZ2FpbiB3aGVuIGVuZCBzZWxlY3RlZC5cbiAgICAgKiAqL1xuICAgIHJlYWRvbmx5IHJhbmdlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8TmJDYWxlbmRhclJhbmdlPEQ+PjtcbiAgICB2YWx1ZTogTmJDYWxlbmRhclJhbmdlPEQ+IHwgdW5kZWZpbmVkO1xuICAgIHByb3RlY3RlZCByZWFkb25seSBwaWNrZXJWYWx1ZUNoYW5nZTogT2JzZXJ2YWJsZTxOYkNhbGVuZGFyUmFuZ2U8RD4+O1xuICAgIHNob3VsZEhpZGUoKTogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgd3JpdGVRdWV1ZSgpOiB2b2lkO1xufVxuIl19