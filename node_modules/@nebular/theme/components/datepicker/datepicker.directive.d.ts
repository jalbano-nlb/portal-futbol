import { ElementRef, InjectionToken, OnDestroy, ChangeDetectorRef, Type } from '@angular/core';
import { ControlValueAccessor, ValidationErrors, Validator, ValidatorFn } from '@angular/forms';
import { Observable } from 'rxjs';
import { NbDateService } from '../calendar-kit/services/date.service';
/**
 * The `NbDatepickerAdapter` instances provide way how to parse, format and validate
 * different date types.
 * */
import * as ɵngcc0 from '@angular/core';
export declare abstract class NbDatepickerAdapter<D> {
    /**
     * Picker component class.
     * */
    abstract picker: Type<any>;
    /**
     * Parse date string according to the format.
     * */
    abstract parse(value: string, format: string): D;
    /**
     * Format date according to the format.
     * */
    abstract format(value: D, format: string): string;
    /**
     * Validates date string according to the passed format.
     * */
    abstract isValid(value: string, format: string): boolean;
}
/**
 * Validators config that will be used by form control to perform proper validation.
 * */
export interface NbPickerValidatorConfig<D> {
    /**
     * Minimum date available in picker.
     * */
    min: D;
    /**
     * Maximum date available in picker.
     * */
    max: D;
    /**
     * Predicate that determines is value available for picking.
     * */
    filter: (D: any) => boolean;
}
/**
 * Datepicker is an control that can pick any values anyway.
 * It has to be bound to the datepicker directive through nbDatepicker input.
 * */
export declare abstract class NbDatepicker<T> {
    /**
     * HTML input element date format.
     * */
    abstract format: string;
    abstract value: T | undefined;
    abstract readonly valueChange: Observable<T>;
    abstract readonly init: Observable<void>;
    /**
     * Attaches datepicker to the native input element.
     * */
    abstract attach(hostRef: ElementRef): any;
    /**
     * Returns validator configuration based on the input properties.
     * */
    abstract getValidatorConfig(): NbPickerValidatorConfig<T>;
    abstract show(): any;
    abstract hide(): any;
    abstract shouldHide(): boolean;
    abstract readonly isShown: boolean;
    abstract readonly blur: Observable<void>;
}
export declare const NB_DATE_ADAPTER: InjectionToken<NbDatepickerAdapter<any>>;
export declare const NB_DATE_SERVICE_OPTIONS: InjectionToken<{}>;
/**
 * The `NbDatepickerDirective` is form control that gives you ability to select dates and ranges. The datepicker
 * is shown when input receives a `focus` event.
 *
 * ```html
 * <input [nbDatepicker]="datepicker">
 * <nb-datepicker #datepicker></nb-datepicker>
 * ```
 *
 * @stacked-example(Showcase, datepicker/datepicker-showcase.component)
 *
 * ### Installation
 *
 * Import `NbDatepickerModule.forRoot()` to your root module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDatepickerModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * And `NbDatepickerModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDatepickerModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * If you want to use range selection, you have to use `NbRangepickerComponent` instead:
 *
 * ```html
 * <input [nbDatepicker]="rangepicker">
 * <nb-rangepicker #rangepicker></nb-rangepicker>
 * ```
 *
 * Both range and date pickers support all parameters as calendar, so, check `NbCalendarComponent` for additional
 * info.
 *
 * @stacked-example(Range showcase, datepicker/rangepicker-showcase.component)
 *
 * Datepicker is the form control so it can be bound with angular forms through ngModel and form controls.
 *
 * @stacked-example(Forms, datepicker/datepicker-forms.component)
 *
 * `NbDatepickerDirective` may be validated using `min` and `max` dates passed to the datepicker.
 * And `filter` predicate that receives date object and has to return a boolean value.
 *
 * @stacked-example(Validation, datepicker/datepicker-validation.component)
 *
 * The `NbDatepickerComponent` supports date formatting:
 *
 * ```html
 * <input [nbDatepicker]="datepicker">
 * <nb-datepicker #datepicker format="MM\dd\yyyy"></nb-datepicker>
 * ```
 *
 * ## Formatting Issue
 *
 * By default, datepicker uses angulars `LOCALE_ID` token for localization and `DatePipe` for dates formatting.
 * And native `Date.parse(...)` for dates parsing. But native `Date.parse` function doesn't support formats.
 * To provide custom formatting you have to use one of the following packages:
 *
 * - `@nebular/moment` - provides moment date adapter that uses moment for date objects. This means datepicker than
 * will operate only moment date objects. If you want to use it you have to install it: `npm i @nebular/moment`, and
 * import `NbMomentDateModule` from this package.
 *
 * - `@nebular/date-fns` - adapter for popular date-fns library. This way is preferred if you need only date formatting.
 * Because date-fns is treeshakable, tiny and operates native date objects. If you want to use it you have to
 * install it: `npm i @nebular/date-fns`, and import `NbDateFnsDateModule` from this package.
 *
 * ### NbDateFnsDateModule
 *
 * Format is required when using `NbDateFnsDateModule`. You can set it via `format` input on datepicker component:
 * ```html
 * <nb-datepicker format="dd.MM.yyyy"></nb-datepicker>
 * ```
 * Also format can be set globally with `NbDateFnsDateModule.forRoot({ format: 'dd.MM.yyyy' })` and
 * `NbDateFnsDateModule.forChild({ format: 'dd.MM.yyyy' })` methods.
 *
 * Please note to use some of the formatting tokens you also need to pass `{ awareOfUnicodeTokens: true }` to date-fns
 * parse and format functions. You can configure options passed this functions by setting `formatOptions` and
 * `parseOptions` of options object passed to `NbDateFnsDateModule.forRoot` and `NbDateFnsDateModule.forChild` methods.
 * ```ts
 * NbDateFnsDateModule.forRoot({
 *   parseOptions: { awareOfUnicodeTokens: true },
 *   formatOptions: { awareOfUnicodeTokens: true },
 * })
 * ```
 * Further info on `date-fns` formatting tokens could be found at
 * [date-fns docs](https://date-fns.org/v2.0.0-alpha.27/docs/Unicode-Tokens).
 *
 * You can also use `parseOptions` and `formatOptions` to provide locale.
 * ```ts
 * import { eo } from 'date-fns/locale';
 *
 * @NgModule({
 *   imports: [
 *     NbDateFnsDateModule.forRoot({
 *       parseOptions: { locale: eo },
 *       formatOptions: { locale: eo },
 *     }),
 *   ],
 * })
 * ```
 *
 * @styles
 *
 * datepicker-text-color:
 * datepicker-background-color:
 * datepicker-border-color:
 * datepicker-border-style:
 * datepicker-border-width:
 * datepicker-border-radius:
 * datepicker-shadow:
 * datepicker-arrow-size:
 * */
export declare class NbDatepickerDirective<D> implements OnDestroy, ControlValueAccessor, Validator {
    protected document: any;
    protected datepickerAdapters: NbDatepickerAdapter<D>[];
    protected hostRef: ElementRef;
    protected dateService: NbDateService<D>;
    protected changeDetector: ChangeDetectorRef;
    /**
     * Provides datepicker component.
     * */
    setPicker: NbDatepicker<D>;
    /**
     * Datepicker adapter.
     * */
    protected datepickerAdapter: NbDatepickerAdapter<D>;
    /**
     * Datepicker instance.
     * */
    protected picker: NbDatepicker<D>;
    protected alive: boolean;
    protected isDatepickerReady: boolean;
    protected queue: D | undefined;
    protected onChange: (D: any) => void;
    protected onTouched: () => void;
    /**
     * Form control validators will be called in validators context, so, we need to bind them.
     * */
    protected validator: ValidatorFn;
    constructor(document: any, datepickerAdapters: NbDatepickerAdapter<D>[], hostRef: ElementRef, dateService: NbDateService<D>, changeDetector: ChangeDetectorRef);
    /**
     * Returns html input element.
     * */
    readonly input: HTMLInputElement;
    /**
     * Returns host input value.
     * */
    readonly inputValue: string;
    ngOnDestroy(): void;
    /**
     * Writes value in picker and html input element.
     * */
    writeValue(value: D): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    setDisabledState(isDisabled: boolean): void;
    /**
     * Form control validation based on picker validator config.
     * */
    validate(): ValidationErrors | null;
    /**
     * Hides picker, focuses the input
     */
    protected hidePicker(): void;
    /**
     * Validates that we can parse value correctly.
     * */
    protected parseValidator(): ValidationErrors | null;
    /**
     * Validates passed value is greater than min.
     * */
    protected minValidator(): ValidationErrors | null;
    /**
     * Validates passed value is smaller than max.
     * */
    protected maxValidator(): ValidationErrors | null;
    /**
     * Validates passed value satisfy the filter.
     * */
    protected filterValidator(): ValidationErrors | null;
    /**
     * Chooses datepicker adapter based on passed picker component.
     * */
    protected chooseDatepickerAdapter(): void;
    /**
     * Attaches picker to the host input element and subscribes on value changes.
     * */
    protected setupPicker(): void;
    protected writePicker(value: D): void;
    protected writeInput(value: D): void;
    /**
     * Validates if no datepicker adapter provided.
     * */
    protected noDatepickerAdapterProvided(): boolean;
    protected subscribeOnInputChange(): void;
    /**
     * Parses input value and write if it isn't null.
     * */
    protected handleInputChange(value: string): void;
    protected parseInputValue(value: any): D | null;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<NbDatepickerDirective<any>>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<NbDatepickerDirective<any>, "input[nbDatepicker]", never, {
    "setPicker": "nbDatepicker";
}, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZXBpY2tlci5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsiZGF0ZXBpY2tlci5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0FBUUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa1JBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiwgSW5qZWN0aW9uVG9rZW4sIE9uRGVzdHJveSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3IsIFZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgTmJEYXRlU2VydmljZSB9IGZyb20gJy4uL2NhbGVuZGFyLWtpdC9zZXJ2aWNlcy9kYXRlLnNlcnZpY2UnO1xuLyoqXG4gKiBUaGUgYE5iRGF0ZXBpY2tlckFkYXB0ZXJgIGluc3RhbmNlcyBwcm92aWRlIHdheSBob3cgdG8gcGFyc2UsIGZvcm1hdCBhbmQgdmFsaWRhdGVcbiAqIGRpZmZlcmVudCBkYXRlIHR5cGVzLlxuICogKi9cbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIE5iRGF0ZXBpY2tlckFkYXB0ZXI8RD4ge1xuICAgIC8qKlxuICAgICAqIFBpY2tlciBjb21wb25lbnQgY2xhc3MuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBwaWNrZXI6IFR5cGU8YW55PjtcbiAgICAvKipcbiAgICAgKiBQYXJzZSBkYXRlIHN0cmluZyBhY2NvcmRpbmcgdG8gdGhlIGZvcm1hdC5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IHBhcnNlKHZhbHVlOiBzdHJpbmcsIGZvcm1hdDogc3RyaW5nKTogRDtcbiAgICAvKipcbiAgICAgKiBGb3JtYXQgZGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGZvcm1hdC5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IGZvcm1hdCh2YWx1ZTogRCwgZm9ybWF0OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGRhdGUgc3RyaW5nIGFjY29yZGluZyB0byB0aGUgcGFzc2VkIGZvcm1hdC5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IGlzVmFsaWQodmFsdWU6IHN0cmluZywgZm9ybWF0OiBzdHJpbmcpOiBib29sZWFuO1xufVxuLyoqXG4gKiBWYWxpZGF0b3JzIGNvbmZpZyB0aGF0IHdpbGwgYmUgdXNlZCBieSBmb3JtIGNvbnRyb2wgdG8gcGVyZm9ybSBwcm9wZXIgdmFsaWRhdGlvbi5cbiAqICovXG5leHBvcnQgaW50ZXJmYWNlIE5iUGlja2VyVmFsaWRhdG9yQ29uZmlnPEQ+IHtcbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGRhdGUgYXZhaWxhYmxlIGluIHBpY2tlci5cbiAgICAgKiAqL1xuICAgIG1pbjogRDtcbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIGRhdGUgYXZhaWxhYmxlIGluIHBpY2tlci5cbiAgICAgKiAqL1xuICAgIG1heDogRDtcbiAgICAvKipcbiAgICAgKiBQcmVkaWNhdGUgdGhhdCBkZXRlcm1pbmVzIGlzIHZhbHVlIGF2YWlsYWJsZSBmb3IgcGlja2luZy5cbiAgICAgKiAqL1xuICAgIGZpbHRlcjogKEQ6IGFueSkgPT4gYm9vbGVhbjtcbn1cbi8qKlxuICogRGF0ZXBpY2tlciBpcyBhbiBjb250cm9sIHRoYXQgY2FuIHBpY2sgYW55IHZhbHVlcyBhbnl3YXkuXG4gKiBJdCBoYXMgdG8gYmUgYm91bmQgdG8gdGhlIGRhdGVwaWNrZXIgZGlyZWN0aXZlIHRocm91Z2ggbmJEYXRlcGlja2VyIGlucHV0LlxuICogKi9cbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIE5iRGF0ZXBpY2tlcjxUPiB7XG4gICAgLyoqXG4gICAgICogSFRNTCBpbnB1dCBlbGVtZW50IGRhdGUgZm9ybWF0LlxuICAgICAqICovXG4gICAgYWJzdHJhY3QgZm9ybWF0OiBzdHJpbmc7XG4gICAgYWJzdHJhY3QgdmFsdWU6IFQgfCB1bmRlZmluZWQ7XG4gICAgYWJzdHJhY3QgcmVhZG9ubHkgdmFsdWVDaGFuZ2U6IE9ic2VydmFibGU8VD47XG4gICAgYWJzdHJhY3QgcmVhZG9ubHkgaW5pdDogT2JzZXJ2YWJsZTx2b2lkPjtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBkYXRlcGlja2VyIHRvIHRoZSBuYXRpdmUgaW5wdXQgZWxlbWVudC5cbiAgICAgKiAqL1xuICAgIGFic3RyYWN0IGF0dGFjaChob3N0UmVmOiBFbGVtZW50UmVmKTogYW55O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdmFsaWRhdG9yIGNvbmZpZ3VyYXRpb24gYmFzZWQgb24gdGhlIGlucHV0IHByb3BlcnRpZXMuXG4gICAgICogKi9cbiAgICBhYnN0cmFjdCBnZXRWYWxpZGF0b3JDb25maWcoKTogTmJQaWNrZXJWYWxpZGF0b3JDb25maWc8VD47XG4gICAgYWJzdHJhY3Qgc2hvdygpOiBhbnk7XG4gICAgYWJzdHJhY3QgaGlkZSgpOiBhbnk7XG4gICAgYWJzdHJhY3Qgc2hvdWxkSGlkZSgpOiBib29sZWFuO1xuICAgIGFic3RyYWN0IHJlYWRvbmx5IGlzU2hvd246IGJvb2xlYW47XG4gICAgYWJzdHJhY3QgcmVhZG9ubHkgYmx1cjogT2JzZXJ2YWJsZTx2b2lkPjtcbn1cbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE5CX0RBVEVfQURBUFRFUjogSW5qZWN0aW9uVG9rZW48TmJEYXRlcGlja2VyQWRhcHRlcjxhbnk+PjtcbmV4cG9ydCBkZWNsYXJlIGNvbnN0IE5CX0RBVEVfU0VSVklDRV9PUFRJT05TOiBJbmplY3Rpb25Ub2tlbjx7fT47XG4vKipcbiAqIFRoZSBgTmJEYXRlcGlja2VyRGlyZWN0aXZlYCBpcyBmb3JtIGNvbnRyb2wgdGhhdCBnaXZlcyB5b3UgYWJpbGl0eSB0byBzZWxlY3QgZGF0ZXMgYW5kIHJhbmdlcy4gVGhlIGRhdGVwaWNrZXJcbiAqIGlzIHNob3duIHdoZW4gaW5wdXQgcmVjZWl2ZXMgYSBgZm9jdXNgIGV2ZW50LlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBbbmJEYXRlcGlja2VyXT1cImRhdGVwaWNrZXJcIj5cbiAqIDxuYi1kYXRlcGlja2VyICNkYXRlcGlja2VyPjwvbmItZGF0ZXBpY2tlcj5cbiAqIGBgYFxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGRhdGVwaWNrZXIvZGF0ZXBpY2tlci1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJEYXRlcGlja2VyTW9kdWxlLmZvclJvb3QoKWAgdG8geW91ciByb290IG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJEYXRlcGlja2VyTW9kdWxlLmZvclJvb3QoKSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuICogYGBgXG4gKiBBbmQgYE5iRGF0ZXBpY2tlck1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJEYXRlcGlja2VyTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byB1c2UgcmFuZ2Ugc2VsZWN0aW9uLCB5b3UgaGF2ZSB0byB1c2UgYE5iUmFuZ2VwaWNrZXJDb21wb25lbnRgIGluc3RlYWQ6XG4gKlxuICogYGBgaHRtbFxuICogPGlucHV0IFtuYkRhdGVwaWNrZXJdPVwicmFuZ2VwaWNrZXJcIj5cbiAqIDxuYi1yYW5nZXBpY2tlciAjcmFuZ2VwaWNrZXI+PC9uYi1yYW5nZXBpY2tlcj5cbiAqIGBgYFxuICpcbiAqIEJvdGggcmFuZ2UgYW5kIGRhdGUgcGlja2VycyBzdXBwb3J0IGFsbCBwYXJhbWV0ZXJzIGFzIGNhbGVuZGFyLCBzbywgY2hlY2sgYE5iQ2FsZW5kYXJDb21wb25lbnRgIGZvciBhZGRpdGlvbmFsXG4gKiBpbmZvLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoUmFuZ2Ugc2hvd2Nhc2UsIGRhdGVwaWNrZXIvcmFuZ2VwaWNrZXItc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIERhdGVwaWNrZXIgaXMgdGhlIGZvcm0gY29udHJvbCBzbyBpdCBjYW4gYmUgYm91bmQgd2l0aCBhbmd1bGFyIGZvcm1zIHRocm91Z2ggbmdNb2RlbCBhbmQgZm9ybSBjb250cm9scy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEZvcm1zLCBkYXRlcGlja2VyL2RhdGVwaWNrZXItZm9ybXMuY29tcG9uZW50KVxuICpcbiAqIGBOYkRhdGVwaWNrZXJEaXJlY3RpdmVgIG1heSBiZSB2YWxpZGF0ZWQgdXNpbmcgYG1pbmAgYW5kIGBtYXhgIGRhdGVzIHBhc3NlZCB0byB0aGUgZGF0ZXBpY2tlci5cbiAqIEFuZCBgZmlsdGVyYCBwcmVkaWNhdGUgdGhhdCByZWNlaXZlcyBkYXRlIG9iamVjdCBhbmQgaGFzIHRvIHJldHVybiBhIGJvb2xlYW4gdmFsdWUuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShWYWxpZGF0aW9uLCBkYXRlcGlja2VyL2RhdGVwaWNrZXItdmFsaWRhdGlvbi5jb21wb25lbnQpXG4gKlxuICogVGhlIGBOYkRhdGVwaWNrZXJDb21wb25lbnRgIHN1cHBvcnRzIGRhdGUgZm9ybWF0dGluZzpcbiAqXG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgW25iRGF0ZXBpY2tlcl09XCJkYXRlcGlja2VyXCI+XG4gKiA8bmItZGF0ZXBpY2tlciAjZGF0ZXBpY2tlciBmb3JtYXQ9XCJNTVxcZGRcXHl5eXlcIj48L25iLWRhdGVwaWNrZXI+XG4gKiBgYGBcbiAqXG4gKiAjIyBGb3JtYXR0aW5nIElzc3VlXG4gKlxuICogQnkgZGVmYXVsdCwgZGF0ZXBpY2tlciB1c2VzIGFuZ3VsYXJzIGBMT0NBTEVfSURgIHRva2VuIGZvciBsb2NhbGl6YXRpb24gYW5kIGBEYXRlUGlwZWAgZm9yIGRhdGVzIGZvcm1hdHRpbmcuXG4gKiBBbmQgbmF0aXZlIGBEYXRlLnBhcnNlKC4uLilgIGZvciBkYXRlcyBwYXJzaW5nLiBCdXQgbmF0aXZlIGBEYXRlLnBhcnNlYCBmdW5jdGlvbiBkb2Vzbid0IHN1cHBvcnQgZm9ybWF0cy5cbiAqIFRvIHByb3ZpZGUgY3VzdG9tIGZvcm1hdHRpbmcgeW91IGhhdmUgdG8gdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHBhY2thZ2VzOlxuICpcbiAqIC0gYEBuZWJ1bGFyL21vbWVudGAgLSBwcm92aWRlcyBtb21lbnQgZGF0ZSBhZGFwdGVyIHRoYXQgdXNlcyBtb21lbnQgZm9yIGRhdGUgb2JqZWN0cy4gVGhpcyBtZWFucyBkYXRlcGlja2VyIHRoYW5cbiAqIHdpbGwgb3BlcmF0ZSBvbmx5IG1vbWVudCBkYXRlIG9iamVjdHMuIElmIHlvdSB3YW50IHRvIHVzZSBpdCB5b3UgaGF2ZSB0byBpbnN0YWxsIGl0OiBgbnBtIGkgQG5lYnVsYXIvbW9tZW50YCwgYW5kXG4gKiBpbXBvcnQgYE5iTW9tZW50RGF0ZU1vZHVsZWAgZnJvbSB0aGlzIHBhY2thZ2UuXG4gKlxuICogLSBgQG5lYnVsYXIvZGF0ZS1mbnNgIC0gYWRhcHRlciBmb3IgcG9wdWxhciBkYXRlLWZucyBsaWJyYXJ5LiBUaGlzIHdheSBpcyBwcmVmZXJyZWQgaWYgeW91IG5lZWQgb25seSBkYXRlIGZvcm1hdHRpbmcuXG4gKiBCZWNhdXNlIGRhdGUtZm5zIGlzIHRyZWVzaGFrYWJsZSwgdGlueSBhbmQgb3BlcmF0ZXMgbmF0aXZlIGRhdGUgb2JqZWN0cy4gSWYgeW91IHdhbnQgdG8gdXNlIGl0IHlvdSBoYXZlIHRvXG4gKiBpbnN0YWxsIGl0OiBgbnBtIGkgQG5lYnVsYXIvZGF0ZS1mbnNgLCBhbmQgaW1wb3J0IGBOYkRhdGVGbnNEYXRlTW9kdWxlYCBmcm9tIHRoaXMgcGFja2FnZS5cbiAqXG4gKiAjIyMgTmJEYXRlRm5zRGF0ZU1vZHVsZVxuICpcbiAqIEZvcm1hdCBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIGBOYkRhdGVGbnNEYXRlTW9kdWxlYC4gWW91IGNhbiBzZXQgaXQgdmlhIGBmb3JtYXRgIGlucHV0IG9uIGRhdGVwaWNrZXIgY29tcG9uZW50OlxuICogYGBgaHRtbFxuICogPG5iLWRhdGVwaWNrZXIgZm9ybWF0PVwiZGQuTU0ueXl5eVwiPjwvbmItZGF0ZXBpY2tlcj5cbiAqIGBgYFxuICogQWxzbyBmb3JtYXQgY2FuIGJlIHNldCBnbG9iYWxseSB3aXRoIGBOYkRhdGVGbnNEYXRlTW9kdWxlLmZvclJvb3QoeyBmb3JtYXQ6ICdkZC5NTS55eXl5JyB9KWAgYW5kXG4gKiBgTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JDaGlsZCh7IGZvcm1hdDogJ2RkLk1NLnl5eXknIH0pYCBtZXRob2RzLlxuICpcbiAqIFBsZWFzZSBub3RlIHRvIHVzZSBzb21lIG9mIHRoZSBmb3JtYXR0aW5nIHRva2VucyB5b3UgYWxzbyBuZWVkIHRvIHBhc3MgYHsgYXdhcmVPZlVuaWNvZGVUb2tlbnM6IHRydWUgfWAgdG8gZGF0ZS1mbnNcbiAqIHBhcnNlIGFuZCBmb3JtYXQgZnVuY3Rpb25zLiBZb3UgY2FuIGNvbmZpZ3VyZSBvcHRpb25zIHBhc3NlZCB0aGlzIGZ1bmN0aW9ucyBieSBzZXR0aW5nIGBmb3JtYXRPcHRpb25zYCBhbmRcbiAqIGBwYXJzZU9wdGlvbnNgIG9mIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB0byBgTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JSb290YCBhbmQgYE5iRGF0ZUZuc0RhdGVNb2R1bGUuZm9yQ2hpbGRgIG1ldGhvZHMuXG4gKiBgYGB0c1xuICogTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JSb290KHtcbiAqICAgcGFyc2VPcHRpb25zOiB7IGF3YXJlT2ZVbmljb2RlVG9rZW5zOiB0cnVlIH0sXG4gKiAgIGZvcm1hdE9wdGlvbnM6IHsgYXdhcmVPZlVuaWNvZGVUb2tlbnM6IHRydWUgfSxcbiAqIH0pXG4gKiBgYGBcbiAqIEZ1cnRoZXIgaW5mbyBvbiBgZGF0ZS1mbnNgIGZvcm1hdHRpbmcgdG9rZW5zIGNvdWxkIGJlIGZvdW5kIGF0XG4gKiBbZGF0ZS1mbnMgZG9jc10oaHR0cHM6Ly9kYXRlLWZucy5vcmcvdjIuMC4wLWFscGhhLjI3L2RvY3MvVW5pY29kZS1Ub2tlbnMpLlxuICpcbiAqIFlvdSBjYW4gYWxzbyB1c2UgYHBhcnNlT3B0aW9uc2AgYW5kIGBmb3JtYXRPcHRpb25zYCB0byBwcm92aWRlIGxvY2FsZS5cbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBlbyB9IGZyb20gJ2RhdGUtZm5zL2xvY2FsZSc7XG4gKlxuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIE5iRGF0ZUZuc0RhdGVNb2R1bGUuZm9yUm9vdCh7XG4gKiAgICAgICBwYXJzZU9wdGlvbnM6IHsgbG9jYWxlOiBlbyB9LFxuICogICAgICAgZm9ybWF0T3B0aW9uczogeyBsb2NhbGU6IGVvIH0sXG4gKiAgICAgfSksXG4gKiAgIF0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGRhdGVwaWNrZXItdGV4dC1jb2xvcjpcbiAqIGRhdGVwaWNrZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGRhdGVwaWNrZXItYm9yZGVyLWNvbG9yOlxuICogZGF0ZXBpY2tlci1ib3JkZXItc3R5bGU6XG4gKiBkYXRlcGlja2VyLWJvcmRlci13aWR0aDpcbiAqIGRhdGVwaWNrZXItYm9yZGVyLXJhZGl1czpcbiAqIGRhdGVwaWNrZXItc2hhZG93OlxuICogZGF0ZXBpY2tlci1hcnJvdy1zaXplOlxuICogKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE5iRGF0ZXBpY2tlckRpcmVjdGl2ZTxEPiBpbXBsZW1lbnRzIE9uRGVzdHJveSwgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRvciB7XG4gICAgcHJvdGVjdGVkIGRvY3VtZW50OiBhbnk7XG4gICAgcHJvdGVjdGVkIGRhdGVwaWNrZXJBZGFwdGVyczogTmJEYXRlcGlja2VyQWRhcHRlcjxEPltdO1xuICAgIHByb3RlY3RlZCBob3N0UmVmOiBFbGVtZW50UmVmO1xuICAgIHByb3RlY3RlZCBkYXRlU2VydmljZTogTmJEYXRlU2VydmljZTxEPjtcbiAgICBwcm90ZWN0ZWQgY2hhbmdlRGV0ZWN0b3I6IENoYW5nZURldGVjdG9yUmVmO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGRhdGVwaWNrZXIgY29tcG9uZW50LlxuICAgICAqICovXG4gICAgc2V0UGlja2VyOiBOYkRhdGVwaWNrZXI8RD47XG4gICAgLyoqXG4gICAgICogRGF0ZXBpY2tlciBhZGFwdGVyLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIGRhdGVwaWNrZXJBZGFwdGVyOiBOYkRhdGVwaWNrZXJBZGFwdGVyPEQ+O1xuICAgIC8qKlxuICAgICAqIERhdGVwaWNrZXIgaW5zdGFuY2UuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgcGlja2VyOiBOYkRhdGVwaWNrZXI8RD47XG4gICAgcHJvdGVjdGVkIGFsaXZlOiBib29sZWFuO1xuICAgIHByb3RlY3RlZCBpc0RhdGVwaWNrZXJSZWFkeTogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgcXVldWU6IEQgfCB1bmRlZmluZWQ7XG4gICAgcHJvdGVjdGVkIG9uQ2hhbmdlOiAoRDogYW55KSA9PiB2b2lkO1xuICAgIHByb3RlY3RlZCBvblRvdWNoZWQ6ICgpID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRm9ybSBjb250cm9sIHZhbGlkYXRvcnMgd2lsbCBiZSBjYWxsZWQgaW4gdmFsaWRhdG9ycyBjb250ZXh0LCBzbywgd2UgbmVlZCB0byBiaW5kIHRoZW0uXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgdmFsaWRhdG9yOiBWYWxpZGF0b3JGbjtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudDogYW55LCBkYXRlcGlja2VyQWRhcHRlcnM6IE5iRGF0ZXBpY2tlckFkYXB0ZXI8RD5bXSwgaG9zdFJlZjogRWxlbWVudFJlZiwgZGF0ZVNlcnZpY2U6IE5iRGF0ZVNlcnZpY2U8RD4sIGNoYW5nZURldGVjdG9yOiBDaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBodG1sIGlucHV0IGVsZW1lbnQuXG4gICAgICogKi9cbiAgICByZWFkb25seSBpbnB1dDogSFRNTElucHV0RWxlbWVudDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhvc3QgaW5wdXQgdmFsdWUuXG4gICAgICogKi9cbiAgICByZWFkb25seSBpbnB1dFZhbHVlOiBzdHJpbmc7XG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdmFsdWUgaW4gcGlja2VyIGFuZCBodG1sIGlucHV0IGVsZW1lbnQuXG4gICAgICogKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBEKTogdm9pZDtcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkO1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkO1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRm9ybSBjb250cm9sIHZhbGlkYXRpb24gYmFzZWQgb24gcGlja2VyIHZhbGlkYXRvciBjb25maWcuXG4gICAgICogKi9cbiAgICB2YWxpZGF0ZSgpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBIaWRlcyBwaWNrZXIsIGZvY3VzZXMgdGhlIGlucHV0XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGhpZGVQaWNrZXIoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhhdCB3ZSBjYW4gcGFyc2UgdmFsdWUgY29ycmVjdGx5LlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIHBhcnNlVmFsaWRhdG9yKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsO1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBwYXNzZWQgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG1pbi5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBtaW5WYWxpZGF0b3IoKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGw7XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHBhc3NlZCB2YWx1ZSBpcyBzbWFsbGVyIHRoYW4gbWF4LlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIG1heFZhbGlkYXRvcigpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbDtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgcGFzc2VkIHZhbHVlIHNhdGlzZnkgdGhlIGZpbHRlci5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBmaWx0ZXJWYWxpZGF0b3IoKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGw7XG4gICAgLyoqXG4gICAgICogQ2hvb3NlcyBkYXRlcGlja2VyIGFkYXB0ZXIgYmFzZWQgb24gcGFzc2VkIHBpY2tlciBjb21wb25lbnQuXG4gICAgICogKi9cbiAgICBwcm90ZWN0ZWQgY2hvb3NlRGF0ZXBpY2tlckFkYXB0ZXIoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBwaWNrZXIgdG8gdGhlIGhvc3QgaW5wdXQgZWxlbWVudCBhbmQgc3Vic2NyaWJlcyBvbiB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqICovXG4gICAgcHJvdGVjdGVkIHNldHVwUGlja2VyKCk6IHZvaWQ7XG4gICAgcHJvdGVjdGVkIHdyaXRlUGlja2VyKHZhbHVlOiBEKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgd3JpdGVJbnB1dCh2YWx1ZTogRCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGlmIG5vIGRhdGVwaWNrZXIgYWRhcHRlciBwcm92aWRlZC5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBub0RhdGVwaWNrZXJBZGFwdGVyUHJvdmlkZWQoKTogYm9vbGVhbjtcbiAgICBwcm90ZWN0ZWQgc3Vic2NyaWJlT25JbnB1dENoYW5nZSgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyBpbnB1dCB2YWx1ZSBhbmQgd3JpdGUgaWYgaXQgaXNuJ3QgbnVsbC5cbiAgICAgKiAqL1xuICAgIHByb3RlY3RlZCBoYW5kbGVJbnB1dENoYW5nZSh2YWx1ZTogc3RyaW5nKTogdm9pZDtcbiAgICBwcm90ZWN0ZWQgcGFyc2VJbnB1dFZhbHVlKHZhbHVlOiBhbnkpOiBEIHwgbnVsbDtcbn1cbiJdfQ==