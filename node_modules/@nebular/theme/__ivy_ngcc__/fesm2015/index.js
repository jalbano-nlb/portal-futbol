import { Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Component, ComponentFactoryResolver, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Host, HostBinding, HostListener, Inject, Injectable, InjectionToken, Injector, Input, IterableDiffers, LOCALE_ID, NgModule, NgZone, Optional, Output, PLATFORM_ID, QueryList, Renderer2, SimpleChange, TemplateRef, Type, ViewChild, ViewChildren, ViewContainerRef, forwardRef, ɵɵdefineInjectable, ɵɵinject } from '@angular/core';
import * as i0 from '@angular/core';
import { CommonModule, DOCUMENT, DatePipe, FormStyle, Location, TranslationWidth, getLocaleDayNames, getLocaleFirstDayOfWeek, getLocaleMonthNames, isPlatformBrowser } from '@angular/common';
import * as i1 from '@angular/common';
import { BehaviorSubject, EMPTY, Observable, ReplaySubject, Subject, combineLatest, forkJoin, fromEvent, interval, merge, of, timer } from 'rxjs';
import { debounceTime, delay, distinctUntilChanged, filter, map, pairwise, repeat, share, skip, startWith, switchMap, take, takeUntil, takeWhile, tap } from 'rxjs/operators';
import { AbstractControl, FormsModule, NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';
import { ActivatedRoute, NavigationEnd, Router, RouterModule } from '@angular/router';
import { FocusKeyManager, FocusTrap, FocusTrapFactory, InteractivityChecker } from '@angular/cdk/a11y';
import { CdkPortal, CdkPortalOutlet, ComponentPortal, PortalInjector, PortalModule, TemplatePortal } from '@angular/cdk/portal';
import { BlockScrollStrategy, FlexibleConnectedPositionStrategy, GlobalPositionStrategy, Overlay, OverlayContainer, OverlayModule, OverlayPositionBuilder, ScrollDispatcher, ScrollStrategyOptions, ViewportRuler } from '@angular/cdk/overlay';
import { Platform, PlatformModule } from '@angular/cdk/platform';
import { DomSanitizer } from '@angular/platform-browser';
import { animate, state, style, transition, trigger } from '@angular/animations';
import 'intersection-observer';
import { BidiModule, Directionality } from '@angular/cdk/bidi';
import { CdkCell, CdkCellDef, CdkCellOutlet, CdkColumnDef, CdkFooterCell, CdkFooterCellDef, CdkFooterRow, CdkFooterRowDef, CdkHeaderCell, CdkHeaderCellDef, CdkHeaderRow, CdkHeaderRowDef, CdkRow, CdkRowDef, CdkTable, CdkTableModule, DataRowOutlet, DataSource, FooterRowOutlet, HeaderRowOutlet } from '@angular/cdk/table';
import { ESCAPE } from '@angular/cdk/keycodes';
import * as _angular_cdk_keycodes from '@angular/cdk/keycodes';

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/cdk/a11y';
import * as ɵngcc2 from '@angular/common';
import * as ɵngcc3 from '@angular/cdk/overlay';
import * as ɵngcc4 from '@angular/platform-browser';
import * as ɵngcc5 from '@angular/router';
import * as ɵngcc6 from '@angular/forms';

function NbOverlayContainerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r4.content);
} }
function NbOverlayContainerComponent_ng_template_1_Template(rf, ctx) { }
const _c0 = ["*"];
const _c1 = [[["nb-card-header"]], [["nb-card-body"]], "*", [["nb-card-footer"]]];
const _c2 = ["nb-card-header", "nb-card-body", "*", "nb-card-footer"];
function NbRevealCardComponent_a_3_Template(rf, ctx) { if (rf & 1) {
    const _r8 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 2);
    ɵngcc0.ɵɵlistener("click", function NbRevealCardComponent_a_3_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r8); const ctx_r7 = ɵngcc0.ɵɵnextContext(); return ctx_r7.toggle(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 3);
    ɵngcc0.ɵɵelementEnd();
} }
const _c3 = [[["nb-card-front"]], [["nb-card-back"]]];
const _c4 = ["nb-card-front", "nb-card-back"];
function NbFlipCardComponent_a_3_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 4);
    ɵngcc0.ɵɵlistener("click", function NbFlipCardComponent_a_3_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.toggle(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 5);
    ɵngcc0.ɵɵelementEnd();
} }
function NbFlipCardComponent_a_6_Template(rf, ctx) { if (rf & 1) {
    const _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 4);
    ɵngcc0.ɵɵlistener("click", function NbFlipCardComponent_a_6_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.toggle(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 5);
    ɵngcc0.ɵɵelementEnd();
} }
const _c5 = [[["nb-card"]]];
const _c6 = ["nb-card"];
const _c7 = ["nbButton", ""];
function NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-calendar-week-numbers", 3);
} if (rf & 2) {
    const ctx_r15 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("weeks", ctx_r15.weeks)("size", ctx_r15.size)("weekNumberSymbol", ctx_r15.weekNumberSymbol);
} }
function NbCalendarDaysNamesComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const day_r17 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("holiday", day_r17.isHoliday);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(day_r17.name);
} }
const _c8 = function (a0, a1) { return { "nb-arrow-dropright": a0, "nb-arrow-dropleft": a1 }; };
function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template(rf, ctx) { if (rf & 1) {
    const _r21 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-calendar-picker-row", 1);
    ɵngcc0.ɵɵlistener("select", function NbCalendarPickerComponent_nb_calendar_picker_row_0_Template_nb_calendar_picker_row_select_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r21); const ctx_r20 = ɵngcc0.ɵɵnextContext(); return ctx_r20.select.emit($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const row_r19 = ctx.$implicit;
    const ctx_r18 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("row", row_r19)("visibleDate", ctx_r18.visibleDate)("selectedValue", ctx_r18.selectedValue)("component", ctx_r18.cellComponent)("min", ctx_r18.min)("max", ctx_r18.max)("filter", ctx_r18.filter);
} }
function NbCalendarPickerRowComponent_ng_template_0_Template(rf, ctx) { }
function NbCalendarWeekNumberComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const week_r24 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(week_r24);
} }
function NbBaseCalendarComponent_nb_card_header_1_Template(rf, ctx) { if (rf & 1) {
    const _r30 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-card-header");
    ɵngcc0.ɵɵelementStart(1, "nb-calendar-header", 3);
    ɵngcc0.ɵɵlistener("navigateToday", function NbBaseCalendarComponent_nb_card_header_1_Template_nb_calendar_header_navigateToday_1_listener() { ɵngcc0.ɵɵrestoreView(_r30); const ctx_r29 = ɵngcc0.ɵɵnextContext(); return ctx_r29.navigateToday(); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function NbBaseCalendarComponent_ng_container_3_nb_calendar_pageable_navigation_1_Template(rf, ctx) { if (rf & 1) {
    const _r33 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-calendar-pageable-navigation", 6);
    ɵngcc0.ɵɵlistener("next", function NbBaseCalendarComponent_ng_container_3_nb_calendar_pageable_navigation_1_Template_nb_calendar_pageable_navigation_next_0_listener() { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r32 = ɵngcc0.ɵɵnextContext(2); return ctx_r32.nextMonth(); })("prev", function NbBaseCalendarComponent_ng_container_3_nb_calendar_pageable_navigation_1_Template_nb_calendar_pageable_navigation_prev_0_listener() { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r34 = ɵngcc0.ɵɵnextContext(2); return ctx_r34.prevMonth(); })("changeMode", function NbBaseCalendarComponent_ng_container_3_nb_calendar_pageable_navigation_1_Template_nb_calendar_pageable_navigation_changeMode_0_listener() { ɵngcc0.ɵɵrestoreView(_r33); const ctx_r35 = ɵngcc0.ɵɵnextContext(2); return ctx_r35.setViewMode(ctx_r35.ViewMode.YEAR); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r31 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("date", ctx_r31.visibleDate);
} }
function NbBaseCalendarComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    const _r37 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbBaseCalendarComponent_ng_container_3_nb_calendar_pageable_navigation_1_Template, 1, 1, "nb-calendar-pageable-navigation", 4);
    ɵngcc0.ɵɵelementStart(2, "nb-calendar-day-picker", 5);
    ɵngcc0.ɵɵlistener("dateChange", function NbBaseCalendarComponent_ng_container_3_Template_nb_calendar_day_picker_dateChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r37); const ctx_r36 = ɵngcc0.ɵɵnextContext(); return ctx_r36.dateChange.emit($event); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r26 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngSwitchCase", ctx_r26.ViewMode.DATE);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("boundingMonths", ctx_r26.boundingMonth)("cellComponent", ctx_r26.dayCellComponent)("min", ctx_r26.min)("max", ctx_r26.max)("filter", ctx_r26.filter)("visibleDate", ctx_r26.visibleDate)("size", ctx_r26.size)("date", ctx_r26.date)("showWeekNumber", ctx_r26.showWeekNumber)("weekNumberSymbol", ctx_r26.weekNumberSymbol);
} }
function NbBaseCalendarComponent_ng_container_4_Template(rf, ctx) { if (rf & 1) {
    const _r39 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "nb-calendar-pageable-navigation", 6);
    ɵngcc0.ɵɵlistener("next", function NbBaseCalendarComponent_ng_container_4_Template_nb_calendar_pageable_navigation_next_1_listener() { ɵngcc0.ɵɵrestoreView(_r39); const ctx_r38 = ɵngcc0.ɵɵnextContext(); return ctx_r38.nextYears(); })("prev", function NbBaseCalendarComponent_ng_container_4_Template_nb_calendar_pageable_navigation_prev_1_listener() { ɵngcc0.ɵɵrestoreView(_r39); const ctx_r40 = ɵngcc0.ɵɵnextContext(); return ctx_r40.prevYears(); })("changeMode", function NbBaseCalendarComponent_ng_container_4_Template_nb_calendar_pageable_navigation_changeMode_1_listener() { ɵngcc0.ɵɵrestoreView(_r39); const ctx_r41 = ɵngcc0.ɵɵnextContext(); return ctx_r41.setViewMode(ctx_r41.ViewMode.DATE); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "nb-calendar-year-picker", 7);
    ɵngcc0.ɵɵlistener("yearChange", function NbBaseCalendarComponent_ng_container_4_Template_nb_calendar_year_picker_yearChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r39); const ctx_r42 = ɵngcc0.ɵɵnextContext(); ctx_r42.setVisibleDate($event); return ctx_r42.setViewMode(ctx_r42.ViewMode.MONTH); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r27 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("date", ctx_r27.visibleDate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("cellComponent", ctx_r27.yearCellComponent)("date", ctx_r27.date)("min", ctx_r27.min)("max", ctx_r27.max)("filter", ctx_r27.filter)("size", ctx_r27.size)("year", ctx_r27.visibleDate);
} }
function NbBaseCalendarComponent_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    const _r44 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "nb-calendar-navigation", 8);
    ɵngcc0.ɵɵlistener("changeMode", function NbBaseCalendarComponent_ng_container_5_Template_nb_calendar_navigation_changeMode_1_listener() { ɵngcc0.ɵɵrestoreView(_r44); const ctx_r43 = ɵngcc0.ɵɵnextContext(); return ctx_r43.setViewMode(ctx_r43.ViewMode.DATE); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(2, "nb-calendar-month-picker", 9);
    ɵngcc0.ɵɵlistener("monthChange", function NbBaseCalendarComponent_ng_container_5_Template_nb_calendar_month_picker_monthChange_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r44); const ctx_r45 = ɵngcc0.ɵɵnextContext(); ctx_r45.setVisibleDate($event); return ctx_r45.setViewMode(ctx_r45.ViewMode.DATE); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r28 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("date", ctx_r28.visibleDate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("cellComponent", ctx_r28.monthCellComponent)("min", ctx_r28.min)("max", ctx_r28.max)("filter", ctx_r28.filter)("size", ctx_r28.size)("month", ctx_r28.visibleDate);
} }
const _c9 = ["layoutTopDynamicArea"];
const _c10 = ["scrollableContainer"];
const _c11 = ["layoutContainer"];
const _c12 = [[["nb-layout-header", 3, "subheader", ""]], [["nb-sidebar"]], [["nb-layout-header", "subheader", ""]], [["nb-layout-column"]], [["nb-layout-footer"]]];
const _c13 = ["nb-layout-header:not([subheader])", "nb-sidebar", "nb-layout-header[subheader]", "nb-layout-column", "nb-layout-footer"];
const _c14 = ["nbMenuItem", ""];
function NbMenuItemComponent_span_0_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 6);
} if (rf & 2) {
    const ctx_r54 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("config", ctx_r54.menuItem.icon);
} }
function NbMenuItemComponent_span_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_span_0_nb_icon_1_Template, 1, 1, "nb-icon", 5);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r48 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r48.menuItem.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r48.menuItem.title, "\n");
} }
function NbMenuItemComponent_a_1_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 6);
} if (rf & 2) {
    const ctx_r55 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("config", ctx_r55.menuItem.icon);
} }
function NbMenuItemComponent_a_1_Template(rf, ctx) { if (rf & 1) {
    const _r57 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 7);
    ɵngcc0.ɵɵlistener("mouseenter", function NbMenuItemComponent_a_1_Template_a_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r57); const ctx_r56 = ɵngcc0.ɵɵnextContext(); return ctx_r56.onHoverItem(ctx_r56.menuItem); })("click", function NbMenuItemComponent_a_1_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r57); const ctx_r58 = ɵngcc0.ɵɵnextContext(); return ctx_r58.onItemClick(ctx_r58.menuItem); });
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_a_1_nb_icon_1_Template, 1, 1, "nb-icon", 5);
    ɵngcc0.ɵɵelementStart(2, "span", 8);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r49 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r49.menuItem.selected);
    ɵngcc0.ɵɵproperty("routerLink", ctx_r49.menuItem.link)("queryParams", ctx_r49.menuItem.queryParams)("fragment", ctx_r49.menuItem.fragment)("skipLocationChange", ctx_r49.menuItem.skipLocationChange);
    ɵngcc0.ɵɵattribute("target", ctx_r49.menuItem.target)("title", ctx_r49.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r49.menuItem.icon);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r49.menuItem.title);
} }
function NbMenuItemComponent_a_2_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 6);
} if (rf & 2) {
    const ctx_r59 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("config", ctx_r59.menuItem.icon);
} }
function NbMenuItemComponent_a_2_Template(rf, ctx) { if (rf & 1) {
    const _r61 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 9);
    ɵngcc0.ɵɵlistener("mouseenter", function NbMenuItemComponent_a_2_Template_a_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r61); const ctx_r60 = ɵngcc0.ɵɵnextContext(); return ctx_r60.onHoverItem(ctx_r60.menuItem); })("click", function NbMenuItemComponent_a_2_Template_a_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r61); const ctx_r62 = ɵngcc0.ɵɵnextContext(); return ctx_r62.onSelectItem(ctx_r62.menuItem); });
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 5);
    ɵngcc0.ɵɵelementStart(2, "span", 8);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r50 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r50.menuItem.selected);
    ɵngcc0.ɵɵattribute("href", ctx_r50.menuItem.url, ɵngcc0.ɵɵsanitizeUrl)("target", ctx_r50.menuItem.target)("title", ctx_r50.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r50.menuItem.icon);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r50.menuItem.title);
} }
function NbMenuItemComponent_a_3_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 6);
} if (rf & 2) {
    const ctx_r63 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("config", ctx_r63.menuItem.icon);
} }
function NbMenuItemComponent_a_3_Template(rf, ctx) { if (rf & 1) {
    const _r65 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 9);
    ɵngcc0.ɵɵlistener("mouseenter", function NbMenuItemComponent_a_3_Template_a_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r65); const ctx_r64 = ɵngcc0.ɵɵnextContext(); return ctx_r64.onHoverItem(ctx_r64.menuItem); })("click", function NbMenuItemComponent_a_3_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r65); const ctx_r66 = ɵngcc0.ɵɵnextContext(); $event.preventDefault(); return ctx_r66.onItemClick(ctx_r66.menuItem); });
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_a_3_nb_icon_1_Template, 1, 1, "nb-icon", 5);
    ɵngcc0.ɵɵelementStart(2, "span", 8);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r51 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r51.menuItem.selected);
    ɵngcc0.ɵɵattribute("target", ctx_r51.menuItem.target)("title", ctx_r51.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r51.menuItem.icon);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r51.menuItem.title);
} }
function NbMenuItemComponent_a_4_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 6);
} if (rf & 2) {
    const ctx_r67 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("config", ctx_r67.menuItem.icon);
} }
function NbMenuItemComponent_a_4_Template(rf, ctx) { if (rf & 1) {
    const _r69 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 10);
    ɵngcc0.ɵɵlistener("click", function NbMenuItemComponent_a_4_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r69); const ctx_r68 = ɵngcc0.ɵɵnextContext(); $event.preventDefault(); return ctx_r68.onToggleSubMenu(ctx_r68.menuItem); })("mouseenter", function NbMenuItemComponent_a_4_Template_a_mouseenter_0_listener() { ɵngcc0.ɵɵrestoreView(_r69); const ctx_r70 = ɵngcc0.ɵɵnextContext(); return ctx_r70.onHoverItem(ctx_r70.menuItem); });
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_a_4_nb_icon_1_Template, 1, 1, "nb-icon", 5);
    ɵngcc0.ɵɵelementStart(2, "span", 8);
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(4, "nb-icon", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r52 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("active", ctx_r52.menuItem.selected);
    ɵngcc0.ɵɵattribute("target", ctx_r52.menuItem.target)("title", ctx_r52.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r52.menuItem.icon);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r52.menuItem.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("icon", ctx_r52.getExpandStateIcon());
} }
function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r75 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 15);
    ɵngcc0.ɵɵlistener("hoverItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r75); const ctx_r74 = ɵngcc0.ɵɵnextContext(3); return ctx_r74.onHoverItem($event); })("toggleSubMenu", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r75); const ctx_r76 = ɵngcc0.ɵɵnextContext(3); return ctx_r76.onToggleSubMenu($event); })("selectItem", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_selectItem_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r75); const ctx_r77 = ɵngcc0.ɵɵnextContext(3); return ctx_r77.onSelectItem($event); })("itemClick", function NbMenuItemComponent_ul_5_ng_container_1_li_1_Template_li_itemClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r75); const ctx_r78 = ɵngcc0.ɵɵnextContext(3); return ctx_r78.onItemClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r72 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵclassProp("menu-group", item_r72.group);
    ɵngcc0.ɵɵproperty("menuItem", item_r72);
} }
function NbMenuItemComponent_ul_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_ul_5_ng_container_1_li_1_Template, 1, 3, "li", 14);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r72 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r72.hidden);
} }
function NbMenuItemComponent_ul_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "ul", 12);
    ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_ul_5_ng_container_1_Template, 2, 1, "ng-container", 13);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r53 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("collapsed", !(ctx_r53.menuItem.children && ctx_r53.menuItem.expanded))("expanded", ctx_r53.menuItem.expanded);
    ɵngcc0.ɵɵproperty("@toggle", ctx_r53.toggleState);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r53.menuItem.children);
} }
function NbMenuComponent_ng_container_1_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r84 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 3);
    ɵngcc0.ɵɵlistener("hoverItem", function NbMenuComponent_ng_container_1_li_1_Template_li_hoverItem_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r84); const ctx_r83 = ɵngcc0.ɵɵnextContext(2); return ctx_r83.onHoverItem($event); })("toggleSubMenu", function NbMenuComponent_ng_container_1_li_1_Template_li_toggleSubMenu_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r84); const ctx_r85 = ɵngcc0.ɵɵnextContext(2); return ctx_r85.onToggleSubMenu($event); })("selectItem", function NbMenuComponent_ng_container_1_li_1_Template_li_selectItem_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r84); const ctx_r86 = ɵngcc0.ɵɵnextContext(2); return ctx_r86.onSelectItem($event); })("itemClick", function NbMenuComponent_ng_container_1_li_1_Template_li_itemClick_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r84); const ctx_r87 = ɵngcc0.ɵɵnextContext(2); return ctx_r87.onItemClick($event); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const item_r81 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵclassProp("menu-group", item_r81.group);
    ɵngcc0.ɵɵproperty("menuItem", item_r81);
} }
function NbMenuComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbMenuComponent_ng_container_1_li_1_Template, 1, 3, "li", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const item_r81 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !item_r81.hidden);
} }
function NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 8);
} if (rf & 2) {
    const tab_r90 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵproperty("config", tab_r90.icon);
} }
function NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r90 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(tab_r90.title);
} }
function NbRouteTabsetComponent_ng_container_1_li_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "li", 4);
    ɵngcc0.ɵɵelementStart(1, "a", 5);
    ɵngcc0.ɵɵtemplate(2, NbRouteTabsetComponent_ng_container_1_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 6);
    ɵngcc0.ɵɵtemplate(3, NbRouteTabsetComponent_ng_container_1_li_1_span_3_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r90 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵclassProp("responsive", tab_r90.responsive);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", tab_r90.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r90.title);
} }
function NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 12);
} if (rf & 2) {
    const tab_r90 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵproperty("icon", tab_r90.icon);
} }
function NbRouteTabsetComponent_ng_container_1_ng_template_2_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 9);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r90 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(tab_r90.title);
} }
function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    const _r104 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 10);
    ɵngcc0.ɵɵlistener("click", function NbRouteTabsetComponent_ng_container_1_ng_template_2_Template_li_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r104); const tab_r90 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r103 = ɵngcc0.ɵɵnextContext(); $event.preventDefault(); return ctx_r103.selectTab(tab_r90); });
    ɵngcc0.ɵɵelementStart(1, "a", 5);
    ɵngcc0.ɵɵtemplate(2, NbRouteTabsetComponent_ng_container_1_ng_template_2_nb_icon_2_Template, 1, 1, "nb-icon", 11);
    ɵngcc0.ɵɵtemplate(3, NbRouteTabsetComponent_ng_container_1_ng_template_2_span_3_Template, 2, 1, "span", 7);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r90 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r93 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("responsive", tab_r90.responsive);
    ɵngcc0.ɵɵproperty("routerLink", tab_r90.route)("routerLinkActiveOptions", ctx_r93.activeLinkOptions);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", tab_r90.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r90.title);
} }
function NbRouteTabsetComponent_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbRouteTabsetComponent_ng_container_1_li_1_Template, 4, 4, "li", 2);
    ɵngcc0.ɵɵtemplate(2, NbRouteTabsetComponent_ng_container_1_ng_template_2_Template, 4, 6, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const tab_r90 = ctx.$implicit;
    const _r92 = ɵngcc0.ɵɵreference(3);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r90.disabled)("ngIfElse", _r92);
} }
const _c15 = [[["nb-sidebar-header"]], "*", [["nb-sidebar-footer"]]];
const _c16 = ["nb-sidebar-header", "*", "nb-sidebar-footer"];
function NbTabComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function NbTabsetComponent_li_1_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} if (rf & 2) {
    const tab_r109 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("config", tab_r109.tabIcon);
} }
function NbTabsetComponent_li_1_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 8);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r109 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(tab_r109.tabTitle);
} }
function NbTabsetComponent_li_1_nb_badge_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-badge", 9);
} if (rf & 2) {
    const tab_r109 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("text", tab_r109.badgeText)("status", tab_r109.badgeStatus)("position", tab_r109.badgePosition);
} }
function NbTabsetComponent_li_1_Template(rf, ctx) { if (rf & 1) {
    const _r117 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "li", 2);
    ɵngcc0.ɵɵlistener("click", function NbTabsetComponent_li_1_Template_li_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r117); const tab_r109 = ctx.$implicit; const ctx_r116 = ɵngcc0.ɵɵnextContext(); return ctx_r116.selectTab(tab_r109); })("keyup.space", function NbTabsetComponent_li_1_Template_li_keyup_space_0_listener() { ɵngcc0.ɵɵrestoreView(_r117); const tab_r109 = ctx.$implicit; const ctx_r118 = ɵngcc0.ɵɵnextContext(); return ctx_r118.selectTab(tab_r109); })("keyup.enter", function NbTabsetComponent_li_1_Template_li_keyup_enter_0_listener() { ɵngcc0.ɵɵrestoreView(_r117); const tab_r109 = ctx.$implicit; const ctx_r119 = ɵngcc0.ɵɵnextContext(); return ctx_r119.selectTab(tab_r109); });
    ɵngcc0.ɵɵelementStart(1, "a", 3);
    ɵngcc0.ɵɵlistener("click", function NbTabsetComponent_li_1_Template_a_click_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r117); return $event.preventDefault(); });
    ɵngcc0.ɵɵtemplate(2, NbTabsetComponent_li_1_nb_icon_2_Template, 1, 1, "nb-icon", 4);
    ɵngcc0.ɵɵtemplate(3, NbTabsetComponent_li_1_span_3_Template, 2, 1, "span", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, NbTabsetComponent_li_1_nb_badge_4_Template, 1, 3, "nb-badge", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const tab_r109 = ctx.$implicit;
    ɵngcc0.ɵɵclassProp("responsive", tab_r109.responsive)("active", tab_r109.active)("disabled", tab_r109.disabled);
    ɵngcc0.ɵɵattribute("tabindex", tab_r109.disabled ? 0 - 1 : 0);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", tab_r109.tabIcon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r109.tabTitle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", tab_r109.badgeText);
} }
const _c17 = [[["nb-tab"]]];
const _c18 = ["nb-tab"];
function NbUserComponent_div_1_nb_badge_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-badge", 8);
} if (rf & 2) {
    const ctx_r125 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("text", ctx_r125.badgeText)("status", ctx_r125.badgeStatus)("position", ctx_r125.badgePosition);
} }
function NbUserComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtemplate(1, NbUserComponent_div_1_nb_badge_1_Template, 1, 3, "nb-badge", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r121 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("background-image", ctx_r121.imageBackgroundStyle, ɵngcc0.ɵɵdefaultStyleSanitizer);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r121.badgeText);
} }
function NbUserComponent_div_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r126 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r126.getInitials(), " ");
} }
function NbUserComponent_div_2_nb_badge_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-badge", 8);
} if (rf & 2) {
    const ctx_r127 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("text", ctx_r127.badgeText)("status", ctx_r127.badgeStatus)("position", ctx_r127.badgePosition);
} }
function NbUserComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 9);
    ɵngcc0.ɵɵtemplate(1, NbUserComponent_div_2_ng_container_1_Template, 2, 1, "ng-container", 10);
    ɵngcc0.ɵɵtemplate(2, NbUserComponent_div_2_nb_badge_2_Template, 1, 3, "nb-badge", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r122 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("background-color", ctx_r122.color);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r122.showInitials);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r122.badgeText);
} }
function NbUserComponent_div_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r123 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r123.name);
} }
function NbUserComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 12);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r124 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r124.title);
} }
function NbActionComponent_ng_container_0_a_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 6);
    ɵngcc0.ɵɵelement(1, "nb-icon", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r132 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("routerLink", ctx_r132.link)("title", ctx_r132.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("config", ctx_r132.icon);
} }
function NbActionComponent_ng_container_0_a_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 8);
    ɵngcc0.ɵɵelement(1, "nb-icon", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r133 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("href", ctx_r133.href, ɵngcc0.ɵɵsanitizeUrl)("title", ctx_r133.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("config", ctx_r133.icon);
} }
function NbActionComponent_ng_container_0_a_3_Template(rf, ctx) { if (rf & 1) {
    const _r136 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "a", 9);
    ɵngcc0.ɵɵlistener("click", function NbActionComponent_ng_container_0_a_3_Template_a_click_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r136); return $event.preventDefault(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r134 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("title", ctx_r134.title);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("config", ctx_r134.icon);
} }
function NbActionComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbActionComponent_ng_container_0_a_1_Template, 2, 3, "a", 3);
    ɵngcc0.ɵɵtemplate(2, NbActionComponent_ng_container_0_a_2_Template, 2, 3, "a", 4);
    ɵngcc0.ɵɵtemplate(3, NbActionComponent_ng_container_0_a_3_Template, 2, 2, "a", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r128 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r128.link);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r128.href && !ctx_r128.link);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r128.href && !ctx_r128.link);
} }
function NbActionComponent_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function NbActionComponent_nb_badge_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-badge", 10);
} if (rf & 2) {
    const ctx_r131 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("text", ctx_r131.badgeText)("status", ctx_r131.badgeStatus)("position", ctx_r131.badgePosition);
} }
const _c19 = [[["nb-action"]]];
const _c20 = ["nb-action"];
const _c21 = ["searchInput"];
const _c22 = ["searchButton"];
function NbSearchComponent_nb_search_field_3_Template(rf, ctx) { if (rf & 1) {
    const _r142 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "nb-search-field", 4);
    ɵngcc0.ɵɵlistener("search", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_search_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r142); const ctx_r141 = ɵngcc0.ɵɵnextContext(); return ctx_r141.search($event); })("searchInput", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_searchInput_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r142); const ctx_r143 = ɵngcc0.ɵɵnextContext(); return ctx_r143.emitInput($event); })("close", function NbSearchComponent_nb_search_field_3_Template_nb_search_field_close_0_listener() { ɵngcc0.ɵɵrestoreView(_r142); const ctx_r144 = ɵngcc0.ɵɵnextContext(); return ctx_r144.emitDeactivate(); });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r140 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("show", ctx_r140.showSearchField)("type", ctx_r140.type)("placeholder", ctx_r140.placeholder)("hint", ctx_r140.hint);
} }
function NbCheckboxComponent_nb_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 6);
} }
function NbCheckboxComponent_nb_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} }
function NbProgressBarComponent_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r147 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r147.value, "%");
} }
function NbAlertComponent_button_0_Template(rf, ctx) { if (rf & 1) {
    const _r150 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 1);
    ɵngcc0.ɵɵlistener("click", function NbAlertComponent_button_0_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r150); const ctx_r149 = ɵngcc0.ɵɵnextContext(); return ctx_r149.onClose(); });
    ɵngcc0.ɵɵelementStart(1, "span", 2);
    ɵngcc0.ɵɵtext(2, "\u00D7");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function NbChatFormComponent_div_0_ng_container_1_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r159 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div");
    ɵngcc0.ɵɵelementStart(1, "span", 8);
    ɵngcc0.ɵɵlistener("click", function NbChatFormComponent_div_0_ng_container_1_div_1_Template_span_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r159); const file_r154 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r157 = ɵngcc0.ɵɵnextContext(2); return ctx_r157.removeFile(file_r154); });
    ɵngcc0.ɵɵtext(2, "\u00D7");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const file_r154 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵstyleProp("background-image", file_r154.urlStyle, ɵngcc0.ɵɵdefaultStyleSanitizer);
} }
function NbChatFormComponent_div_0_ng_container_1_nb_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 9);
} }
function NbChatFormComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    const _r162 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbChatFormComponent_div_0_ng_container_1_div_1_Template, 3, 2, "div", 6);
    ɵngcc0.ɵɵelementStart(2, "div");
    ɵngcc0.ɵɵtemplate(3, NbChatFormComponent_div_0_ng_container_1_nb_icon_3_Template, 1, 0, "nb-icon", 7);
    ɵngcc0.ɵɵelementStart(4, "span", 8);
    ɵngcc0.ɵɵlistener("click", function NbChatFormComponent_div_0_ng_container_1_Template_span_click_4_listener() { ɵngcc0.ɵɵrestoreView(_r162); const file_r154 = ctx.$implicit; const ctx_r161 = ɵngcc0.ɵɵnextContext(2); return ctx_r161.removeFile(file_r154); });
    ɵngcc0.ɵɵtext(5, "\u00D7");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const file_r154 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", file_r154.urlStyle);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !file_r154.urlStyle);
} }
function NbChatFormComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵtemplate(1, NbChatFormComponent_div_0_ng_container_1_Template, 6, 2, "ng-container", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r151 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r151.droppedFiles);
} }
function NbChatFormComponent_button_3_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 13);
} if (rf & 2) {
    const ctx_r163 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("icon", ctx_r163.buttonIcon);
} }
function NbChatFormComponent_button_3_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r165 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r165.buttonTitle);
} }
function NbChatFormComponent_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r167 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 10);
    ɵngcc0.ɵɵlistener("click", function NbChatFormComponent_button_3_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r167); const ctx_r166 = ɵngcc0.ɵɵnextContext(); return ctx_r166.sendMessage(); });
    ɵngcc0.ɵɵtemplate(1, NbChatFormComponent_button_3_nb_icon_1_Template, 1, 1, "nb-icon", 11);
    ɵngcc0.ɵɵtemplate(2, NbChatFormComponent_button_3_ng_template_2_Template, 1, 1, "ng-template", null, 12, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const _r164 = ɵngcc0.ɵɵreference(3);
    const ctx_r152 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("with-icon", !ctx_r152.buttonTitle);
    ɵngcc0.ɵɵproperty("status", ctx_r152.getButtonStatus());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r152.buttonTitle)("ngIfElse", _r164);
} }
function NbChatMessageComponent_div_0_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r173 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r173.getInitials(), " ");
} }
function NbChatMessageComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtemplate(1, NbChatMessageComponent_div_0_ng_container_1_Template, 2, 1, "ng-container", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r168 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("background-image", ctx_r168.avatarStyle, ɵngcc0.ɵɵdefaultStyleSanitizer);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r168.avatarStyle);
} }
function NbChatMessageComponent_nb_chat_message_file_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-chat-message-file", 9);
} if (rf & 2) {
    const ctx_r169 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("sender", ctx_r169.sender)("date", ctx_r169.date)("message", ctx_r169.message)("files", ctx_r169.files);
} }
function NbChatMessageComponent_nb_chat_message_quote_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-chat-message-quote", 10);
} if (rf & 2) {
    const ctx_r170 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("sender", ctx_r170.sender)("date", ctx_r170.date)("message", ctx_r170.message)("quote", ctx_r170.quote);
} }
function NbChatMessageComponent_nb_chat_message_map_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-chat-message-map", 11);
} if (rf & 2) {
    const ctx_r171 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("sender", ctx_r171.sender)("date", ctx_r171.date)("message", ctx_r171.message)("latitude", ctx_r171.latitude)("longitude", ctx_r171.longitude);
} }
function NbChatMessageComponent_nb_chat_message_text_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-chat-message-text", 12);
} if (rf & 2) {
    const ctx_r172 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("sender", ctx_r172.sender)("date", ctx_r172.date)("message", ctx_r172.message);
} }
const _c23 = ["scrollable"];
function NbChatComponent_p_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 6);
    ɵngcc0.ɵɵtext(1, "No messages yet.");
    ɵngcc0.ɵɵelementEnd();
} }
const _c24 = [[["nb-chat-message"]], [["nb-chat-form"]]];
const _c25 = ["nb-chat-message", "nb-chat-form"];
const _c26 = function (a0) { return [a0]; };
function NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} if (rf & 2) {
    const file_r179 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵproperty("icon", file_r179.icon);
} }
function NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div");
} if (rf & 2) {
    const file_r179 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵstyleProp("background-image", file_r179.urlStyle, ɵngcc0.ɵɵdefaultStyleSanitizer);
} }
function NbChatMessageFileComponent_ng_container_2_a_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "a", 4);
    ɵngcc0.ɵɵtemplate(1, NbChatMessageFileComponent_ng_container_2_a_2_nb_icon_1_Template, 1, 1, "nb-icon", 5);
    ɵngcc0.ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_a_2_div_2_Template, 1, 2, "div", 6);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const file_r179 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("href", file_r179.url, ɵngcc0.ɵɵsanitizeUrl);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !file_r179.urlStyle && file_r179.icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", file_r179.urlStyle);
} }
function NbChatMessageFileComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "div", 2);
    ɵngcc0.ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_a_2_Template, 3, 3, "a", 3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r176 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r176.readyFiles);
} }
function NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 7);
} if (rf & 2) {
    const ctx_r184 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("icon", ctx_r184.readyFiles[0].icon);
} }
function NbChatMessageFileComponent_ng_container_3_div_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div");
} if (rf & 2) {
    const ctx_r185 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("background-image", ctx_r185.readyFiles[0].urlStyle, ɵngcc0.ɵɵdefaultStyleSanitizer);
} }
function NbChatMessageFileComponent_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵelementStart(1, "a", 4);
    ɵngcc0.ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_3_nb_icon_2_Template, 1, 1, "nb-icon", 5);
    ɵngcc0.ɵɵtemplate(3, NbChatMessageFileComponent_ng_container_3_div_3_Template, 1, 2, "div", 6);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r177 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("href", ctx_r177.readyFiles[0].url, ɵngcc0.ɵɵsanitizeUrl);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r177.readyFiles[0].urlStyle && ctx_r177.readyFiles[0].icon);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r177.readyFiles[0].urlStyle);
} }
function NbChatMessageQuoteComponent_p_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementStart(2, "time");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "date");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r186 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r186.sender, " ");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind2(4, 2, ctx_r186.date, "shortTime"));
} }
function NbChatMessageTextComponent_p_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementStart(2, "time");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵpipe(4, "date");
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r187 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1("", ctx_r187.sender, " ");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind2(4, 2, ctx_r187.date, "shortTime"));
} }
function NbChatMessageTextComponent_p_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "p", 3);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r188 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r188.message);
} }
function NbSpinnerComponent_span_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span", 2);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r189 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r189.message);
} }
function NbStepComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function NbStepperComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵprojection(0);
} }
function NbStepperComponent_ng_container_2_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 6);
} if (rf & 2) {
    const index_r194 = ɵngcc0.ɵɵnextContext().index;
    const ctx_r196 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("connector-past", index_r194 <= ctx_r196.selectedIndex);
} }
function NbStepperComponent_ng_container_2_div_2_span_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const index_r194 = ɵngcc0.ɵɵnextContext(2).index;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(index_r194 + 1);
} }
function NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 12);
} }
function NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainer(0);
} }
function NbStepperComponent_ng_container_2_div_2_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbStepperComponent_ng_container_2_div_2_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 13);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const step_r193 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", step_r193.label);
} }
function NbStepperComponent_ng_container_2_div_2_span_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const step_r193 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(step_r193.label);
} }
function NbStepperComponent_ng_container_2_div_2_Template(rf, ctx) { if (rf & 1) {
    const _r208 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵlistener("click", function NbStepperComponent_ng_container_2_div_2_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r208); const step_r193 = ɵngcc0.ɵɵnextContext().$implicit; const ctx_r207 = ɵngcc0.ɵɵnextContext(); return !ctx_r207.disableStepNavigation && step_r193.select(); });
    ɵngcc0.ɵɵelementStart(1, "div", 8);
    ɵngcc0.ɵɵtemplate(2, NbStepperComponent_ng_container_2_div_2_span_2_Template, 2, 1, "span", 9);
    ɵngcc0.ɵɵtemplate(3, NbStepperComponent_ng_container_2_div_2_nb_icon_3_Template, 1, 0, "nb-icon", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(4, "div", 11);
    ɵngcc0.ɵɵtemplate(5, NbStepperComponent_ng_container_2_div_2_ng_container_5_Template, 2, 1, "ng-container", 9);
    ɵngcc0.ɵɵtemplate(6, NbStepperComponent_ng_container_2_div_2_span_6_Template, 2, 1, "span", 9);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const step_r193 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r197 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassProp("selected", ctx_r197.isStepSelected(step_r193))("completed", !ctx_r197.isStepSelected(step_r193) && step_r193.completed)("noninteractive", ctx_r197.disableStepNavigation);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", !step_r193.completed || ctx_r197.isStepSelected(step_r193));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r197.isStepSelected(step_r193) && step_r193.completed);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", step_r193.isLabelTemplate);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !step_r193.isLabelTemplate);
} }
function NbStepperComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbStepperComponent_ng_container_2_div_1_Template, 1, 2, "div", 4);
    ɵngcc0.ɵɵtemplate(2, NbStepperComponent_ng_container_2_div_2_Template, 7, 10, "div", 5);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const step_r193 = ctx.$implicit;
    const first_r195 = ctx.first;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !first_r195 && !step_r193.hidden);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !step_r193.hidden);
} }
const _c27 = [[["nb-step"]]];
const _c28 = ["nb-step"];
const _c29 = [[["nb-accordion-item"]]];
const _c30 = ["nb-accordion-item"];
const _c31 = [[["nb-accordion-item-header"]], [["nb-accordion-item-body"]]];
const _c32 = ["nb-accordion-item-header", "nb-accordion-item-body"];
const _c33 = function (a0) { return { value: a0 }; };
function NbAccordionItemHeaderComponent_nb_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 1);
} if (rf & 2) {
    const ctx_r211 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@expansionIndicator", ctx_r211.state);
} }
const _c34 = [[["nb-accordion-item-title"]], [["nb-accordion-item-description"]], "*"];
const _c35 = ["nb-accordion-item-title", "nb-accordion-item-description", "*"];
const _c36 = [[["nb-list-item"]]];
const _c37 = ["nb-list-item"];
function NbDialogContainerComponent_ng_template_0_Template(rf, ctx) { }
function NbToastComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 4);
    ɵngcc0.ɵɵelement(1, "nb-icon", 5);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r213 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("config", ctx_r213.iconConfig);
} }
function NbToastrContainerComponent_nb_toast_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-toast", 1);
} if (rf & 2) {
    const toast_r215 = ctx.$implicit;
    const ctx_r214 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("@fadeIn", ctx_r214.fadeIn)("toast", toast_r215);
} }
function NbTooltipComponent_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 4);
} if (rf & 2) {
    const ctx_r216 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("config", ctx_r216.context.icon);
} }
function NbTooltipComponent_span_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "span");
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r217 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r217.content);
} }
function NbOptionComponent_nb_checkbox_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-checkbox", 1);
} if (rf & 2) {
    const ctx_r218 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("checked", ctx_r218.selected)("disabled", ctx_r218.disabled);
} }
const _c38 = ["selectButton"];
function NbSelectComponent_ng_container_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵprojection(1);
    ɵngcc0.ɵɵelementContainerEnd();
} }
function NbSelectComponent_ng_container_2_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r226 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵtextInterpolate(ctx_r226.selectionView);
} }
function NbSelectComponent_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbSelectComponent_ng_container_2_ng_container_1_Template, 2, 0, "ng-container", 2);
    ɵngcc0.ɵɵtemplate(2, NbSelectComponent_ng_container_2_ng_template_2_Template, 1, 1, "ng-template", null, 6, ɵngcc0.ɵɵtemplateRefExtractor);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const _r225 = ɵngcc0.ɵɵreference(3);
    const ctx_r220 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r220.customLabel)("ngIfElse", _r225);
} }
function NbSelectComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtext(0);
} if (rf & 2) {
    const ctx_r222 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵtextInterpolate(ctx_r222.placeholder);
} }
function NbSelectComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵelementStart(1, "ul", 8);
    ɵngcc0.ɵɵprojection(2, 1);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r223 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("width", ctx_r223.hostWidth, "px");
    ɵngcc0.ɵɵproperty("ngClass", ctx_r223.optionsListClasses);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵclassProp("full-width", ctx_r223.fullWidth);
} }
const _c39 = [[["nb-select-label"]], [["nb-option"], ["nb-option-group"]]];
const _c40 = ["nb-select-label", "nb-option, nb-option-group"];
const _c41 = [[["nb-option"], ["ng-container"]]];
const _c42 = ["nb-option, ng-container"];
const _c43 = ["viewContainerRef"];
function NbWindowComponent_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r232 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function NbWindowComponent_button_7_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r232); const ctx_r231 = ɵngcc0.ɵɵnextContext(); return ctx_r231.maximize(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 7);
    ɵngcc0.ɵɵelementEnd();
} }
function NbWindowComponent_button_8_Template(rf, ctx) { if (rf & 1) {
    const _r234 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 2);
    ɵngcc0.ɵɵlistener("click", function NbWindowComponent_button_8_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r234); const ctx_r233 = ɵngcc0.ɵɵnextContext(); return ctx_r233.maximizeOrFullScreen(); });
    ɵngcc0.ɵɵelement(1, "nb-icon", 8);
    ɵngcc0.ɵɵelementEnd();
} }
function NbWindowComponent_nb_card_body_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "nb-card-body");
    ɵngcc0.ɵɵelement(1, "nb-overlay-container");
    ɵngcc0.ɵɵelementEnd();
} }
const _c44 = [[["nb-radio"]]];
const _c45 = ["nb-radio"];
function NbSortIconComponent_ng_container_0_nb_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 3);
} }
function NbSortIconComponent_ng_container_0_nb_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 4);
} }
function NbSortIconComponent_ng_container_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtemplate(1, NbSortIconComponent_ng_container_0_nb_icon_1_Template, 1, 0, "nb-icon", 1);
    ɵngcc0.ɵɵtemplate(2, NbSortIconComponent_ng_container_0_nb_icon_2_Template, 1, 0, "nb-icon", 2);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const ctx_r235 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r235.isAscending());
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r235.isDescending());
} }
const _c46 = ["nbSortHeader", ""];
function NbSortHeaderComponent_nb_sort_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-sort-icon", 4);
} if (rf & 2) {
    const ctx_r238 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("direction", ctx_r238.direction);
} }
function NbSortHeaderComponent_ng_template_3_Template(rf, ctx) { }
const _c47 = ["nbTreeGridRow", ""];
const _c48 = ["nbTreeGridHeaderRow", ""];
const _c49 = ["nbTreeGridFooterRow", ""];
const _c50 = ["nbTreeGrid", ""];
function NbToggleComponent_nb_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "nb-icon", 6);
} }
const NB_THEME_OPTIONS = new InjectionToken('Nebular Theme Options');
const NB_MEDIA_BREAKPOINTS = new InjectionToken('Nebular Media Breakpoints');
const NB_BUILT_IN_JS_THEMES = new InjectionToken('Nebular Built-in JS Themes');
const NB_JS_THEMES = new InjectionToken('Nebular JS Themes');
/**
 * We're providing browser apis with tokens to improve testing capabilities.
 * */
const NB_WINDOW = new InjectionToken('Window');
const NB_DOCUMENT = new InjectionToken('Document');

const palette = {
    primary: '#3366ff',
    success: '#00d68f',
    info: '#0095ff',
    warning: '#ffaa00',
    danger: '#ff3d71',
};
const DEFAULT_THEME = {
    name: 'default',
    variables: {
        fontMain: 'Open Sans, sans-serif',
        fontSecondary: 'Raleway, sans-serif',
        bg: '#ffffff',
        bg2: '#f7f9fc',
        bg3: '#edf1f7',
        bg4: '#e4e9f2',
        border: '#ffffff',
        border2: '#f7f9fc',
        border3: '#edf1f7',
        border4: '#e4e9f2',
        border5: '#c5cee0',
        fg: '#8f9bb3',
        fgHeading: '#1a2138',
        fgText: '#1a2138',
        fgHighlight: palette.primary,
        layoutBg: '#f7f9fc',
        separator: '#edf1f7',
        primary: palette.primary,
        success: palette.success,
        info: palette.info,
        warning: palette.warning,
        danger: palette.danger,
        primaryLight: '#598bff',
        successLight: '#2ce69b',
        infoLight: '#42aaff',
        warningLight: '#ffc94d',
        dangerLight: '#ff708d',
    },
};

const palette$1 = {
    primary: '#a16eff',
    success: '#00d68f',
    info: '#0095ff',
    warning: '#ffaa00',
    danger: '#ff3d71',
};
const COSMIC_THEME = {
    name: 'cosmic',
    variables: {
        fontMain: 'Open Sans, sans-serif',
        fontSecondary: 'Raleway, sans-serif',
        bg: '#323259',
        bg2: '#252547',
        bg3: '#1b1b38',
        bg4: '#13132b',
        border: '#323259',
        border2: '#252547',
        border3: '#1b1b38',
        border4: '#13132b',
        border5: '#13132b',
        fg: '#b4b4db',
        fgHeading: '#ffffff',
        fgText: '#ffffff',
        fgHighlight: palette$1.primary,
        layoutBg: '#151a30',
        separator: '#151a30',
        primary: palette$1.primary,
        success: palette$1.success,
        info: palette$1.info,
        warning: palette$1.warning,
        danger: palette$1.danger,
        primaryLight: '#b18aff',
        successLight: '#2ce69b',
        infoLight: '#42aaff',
        warningLight: '#ffc94d',
        dangerLight: '#ff708d',
    },
};

const palette$2 = {
    primary: '#73a1ff',
    success: '#5dcfe3',
    info: '#ba7fec',
    warning: '#ffa36b',
    danger: '#ff6b83',
};
const CORPORATE_THEME = {
    name: 'corporate',
    base: 'default',
    variables: {
        fontMain: 'Open Sans, sans-serif',
        fontSecondary: 'Raleway, sans-serif',
        bg: '#ffffff',
        bg2: '#f7f9fc',
        bg3: '#edf1f7',
        bg4: '#e4e9f2',
        border: '#ffffff',
        border2: '#f7f9fc',
        border3: '#edf1f7',
        border4: '#e4e9f2',
        border5: '#c5cee0',
        fg: '#8f9bb3',
        fgHeading: '#1a2138',
        fgText: '#1a2138',
        fgHighlight: palette$2.primary,
        layoutBg: '#f7f9fc',
        separator: '#edf1f7',
        primary: palette$2.primary,
        success: palette$2.success,
        info: palette$2.info,
        warning: palette$2.warning,
        danger: palette$2.danger,
        primaryLight: '#598bff',
        successLight: '#2ce69b',
        infoLight: '#42aaff',
        warningLight: '#ffc94d',
        dangerLight: '#ff708d',
    },
};

const palette$3 = {
    primary: '#3366ff',
    success: '#00d68f',
    info: '#0095ff',
    warning: '#ffaa00',
    danger: '#ff3d71',
};
const DARK_THEME = {
    name: 'dark',
    variables: {
        fontMain: 'Open Sans, sans-serif',
        fontSecondary: 'Raleway, sans-serif',
        bg: '#222b45',
        bg2: '#1a2138',
        bg3: '#151a30',
        bg4: '#101426',
        border: '#222b45',
        border2: '#1a2138',
        border3: '#151a30',
        border4: '#101426',
        border5: '#101426',
        fg: '#8f9bb3',
        fgHeading: '#ffffff',
        fgText: '#ffffff',
        fgHighlight: palette$3.primary,
        layoutBg: '#1b1b38',
        separator: '#1b1b38',
        primary: palette$3.primary,
        success: palette$3.success,
        info: palette$3.info,
        warning: palette$3.warning,
        danger: palette$3.danger,
        primaryLight: '#598bff',
        successLight: '#2ce69b',
        infoLight: '#42aaff',
        warningLight: '#ffc94d',
        dangerLight: '#ff708d',
    },
};

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$2 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$1 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
const BUILT_IN_THEMES = [
    DEFAULT_THEME,
    COSMIC_THEME,
    CORPORATE_THEME,
    DARK_THEME,
];
/**
 * Js Themes registry - provides access to the JS themes' variables.
 * Usually shouldn't be used directly, but through the NbThemeService class methods (getJsTheme).
 */
let NbJSThemesRegistry = class NbJSThemesRegistry {
    constructor(builtInThemes, newThemes = []) {
        this.themes = {};
        const themes = this.combineByNames(newThemes, builtInThemes);
        themes.forEach((theme) => {
            this.register(theme, theme.name, theme.base);
        });
    }
    /**
     * Registers a new JS theme
     * @param config any
     * @param themeName string
     * @param baseTheme string
     */
    register(config, themeName, baseTheme) {
        const base = this.has(baseTheme) ? this.get(baseTheme) : {};
        this.themes[themeName] = this.mergeDeep({}, base, config);
    }
    /**
     * Checks whether the theme is registered
     * @param themeName
     * @returns boolean
     */
    has(themeName) {
        return !!this.themes[themeName];
    }
    /**
     * Return a theme
     * @param themeName
     * @returns NbJSThemeOptions
     */
    get(themeName) {
        if (!this.themes[themeName]) {
            throw Error(`NbThemeConfig: no theme '${themeName}' found registered.`);
        }
        return JSON.parse(JSON.stringify(this.themes[themeName]));
    }
    combineByNames(newThemes, oldThemes) {
        if (newThemes) {
            const mergedThemes = [];
            newThemes.forEach((theme) => {
                const sameOld = oldThemes.find((tm) => tm.name === theme.name)
                    || {};
                const mergedTheme = this.mergeDeep({}, sameOld, theme);
                mergedThemes.push(mergedTheme);
            });
            oldThemes.forEach((theme) => {
                if (!mergedThemes.find((tm) => tm.name === theme.name)) {
                    mergedThemes.push(theme);
                }
            });
            return mergedThemes;
        }
        return oldThemes;
    }
    isObject(item) {
        return item && typeof item === 'object' && !Array.isArray(item);
    }
    // TODO: move to helpers
    mergeDeep(target, ...sources) {
        if (!sources.length) {
            return target;
        }
        const source = sources.shift();
        if (this.isObject(target) && this.isObject(source)) {
            for (const key in source) {
                if (this.isObject(source[key])) {
                    if (!target[key]) {
                        Object.assign(target, { [key]: {} });
                    }
                    this.mergeDeep(target[key], source[key]);
                }
                else {
                    Object.assign(target, { [key]: source[key] });
                }
            }
        }
        return this.mergeDeep(target, ...sources);
    }
};
NbJSThemesRegistry.ɵfac = function NbJSThemesRegistry_Factory(t) { return new (t || NbJSThemesRegistry)(ɵngcc0.ɵɵinject(NB_BUILT_IN_JS_THEMES), ɵngcc0.ɵɵinject(NB_JS_THEMES)); };
NbJSThemesRegistry.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbJSThemesRegistry, factory: NbJSThemesRegistry.ɵfac });
NbJSThemesRegistry = __decorate$2([ __param$1(0, Inject(NB_BUILT_IN_JS_THEMES)),
    __param$1(1, Inject(NB_JS_THEMES)),
    __metadata$1("design:paramtypes", [Array, Array])
], NbJSThemesRegistry);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$3 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$2 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
const DEFAULT_MEDIA_BREAKPOINTS = [
    {
        name: 'xs',
        width: 0,
    },
    {
        name: 'is',
        width: 400,
    },
    {
        name: 'sm',
        width: 576,
    },
    {
        name: 'md',
        width: 768,
    },
    {
        name: 'lg',
        width: 992,
    },
    {
        name: 'xl',
        width: 1200,
    },
    {
        name: 'xxl',
        width: 1400,
    },
    {
        name: 'xxxl',
        width: 1600,
    },
];
/**
 * Manages media breakpoints
 *
 * Provides access to available media breakpoints to convert window width to a configured breakpoint,
 * e.g. 200px - *xs* breakpoint
 */
let NbMediaBreakpointsService = class NbMediaBreakpointsService {
    constructor(breakpoints) {
        this.breakpoints = breakpoints;
        this.breakpointsMap = this.breakpoints.reduce((res, b) => {
            res[b.name] = b.width;
            return res;
        }, {});
    }
    /**
     * Returns a configured breakpoint by width
     * @param width number
     * @returns {Z|{name: string, width: number}}
     */
    getByWidth(width) {
        const unknown = { name: 'unknown', width: width };
        const breakpoints = this.getBreakpoints();
        return breakpoints
            .find((point, index) => {
            const next = breakpoints[index + 1];
            return width >= point.width && (!next || width < next.width);
        }) || unknown;
    }
    /**
     * Returns a configured breakpoint by name
     * @param name string
     * @returns NbMediaBreakpoint
     */
    getByName(name) {
        const unknown = { name: 'unknown', width: NaN };
        const breakpoints = this.getBreakpoints();
        return breakpoints.find((point) => name === point.name) || unknown;
    }
    /**
     * Returns a list of configured breakpoints for the theme
     * @returns NbMediaBreakpoint[]
     */
    getBreakpoints() {
        return this.breakpoints;
    }
    /**
     * Returns a map of configured breakpoints for the theme
     * @returns {[p: string]: number}
     */
    getBreakpointsMap() {
        return this.breakpointsMap;
    }
};
NbMediaBreakpointsService.ɵfac = function NbMediaBreakpointsService_Factory(t) { return new (t || NbMediaBreakpointsService)(ɵngcc0.ɵɵinject(NB_MEDIA_BREAKPOINTS)); };
NbMediaBreakpointsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbMediaBreakpointsService, factory: NbMediaBreakpointsService.ɵfac });
NbMediaBreakpointsService = __decorate$3([ __param$2(0, Inject(NB_MEDIA_BREAKPOINTS)),
    __metadata$2("design:paramtypes", [Object])
], NbMediaBreakpointsService);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$1 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Main Nebular service. Includes various helper methods.
 */
let NbThemeService = class NbThemeService {
    constructor(options, breakpointService, jsThemesRegistry) {
        this.options = options;
        this.breakpointService = breakpointService;
        this.jsThemesRegistry = jsThemesRegistry;
        this.themeChanges$ = new ReplaySubject(1);
        this.appendLayoutClass$ = new Subject();
        this.removeLayoutClass$ = new Subject();
        this.changeWindowWidth$ = new ReplaySubject(2);
        if (options && options.name) {
            this.changeTheme(options.name);
        }
    }
    /**
     * Change current application theme
     * @param {string} name
     */
    changeTheme(name) {
        this.themeChanges$.next({ name, previous: this.currentTheme });
        this.currentTheme = name;
    }
    changeWindowWidth(width) {
        this.changeWindowWidth$.next(width);
    }
    /**
     * Returns a theme object with variables (color/paddings/etc) on a theme change.
     * Once subscribed - returns current theme.
     *
     * @returns {Observable<NbJSThemeOptions>}
     */
    getJsTheme() {
        return this.onThemeChange().pipe(map((theme) => {
            return this.jsThemesRegistry.get(theme.name);
        }));
    }
    /**
     * Triggers media query breakpoint change
     * Returns a pair where the first item is previous media breakpoint and the second item is current breakpoit.
     * ```ts
     *  [{ name: 'xs', width: 0 }, { name: 'md', width: 768 }] // change from `xs` to `md`
     * ```
     * @returns {Observable<[NbMediaBreakpoint, NbMediaBreakpoint]>}
     */
    onMediaQueryChange() {
        return this.changeWindowWidth$
            .pipe(startWith(undefined), pairwise(), map(([prevWidth, width]) => {
            return [
                this.breakpointService.getByWidth(prevWidth),
                this.breakpointService.getByWidth(width),
            ];
        }), filter(([prevPoint, point]) => {
            return prevPoint.name !== point.name;
        }), distinctUntilChanged(null, params => params[0].name + params[1].name), share());
    }
    /**
     * Triggered when current theme is changed
     * @returns {Observable<any>}
     */
    onThemeChange() {
        return this.themeChanges$.pipe(share());
    }
    /**
     * Append a class to nb-layout
     * @param {string} className
     */
    appendLayoutClass(className) {
        this.appendLayoutClass$.next(className);
    }
    /**
     * Triggered when a new class is added to nb-layout through `appendLayoutClass` method
     * @returns {Observable<any>}
     */
    onAppendLayoutClass() {
        return this.appendLayoutClass$.pipe(share());
    }
    /**
     * Removes a class from nb-layout
     * @param {string} className
     */
    removeLayoutClass(className) {
        this.removeLayoutClass$.next(className);
    }
    /**
     * Triggered when a class is removed from nb-layout through `removeLayoutClass` method
     * @returns {Observable<any>}
     */
    onRemoveLayoutClass() {
        return this.removeLayoutClass$.pipe(share());
    }
};
NbThemeService.ɵfac = function NbThemeService_Factory(t) { return new (t || NbThemeService)(ɵngcc0.ɵɵinject(NB_THEME_OPTIONS), ɵngcc0.ɵɵinject(NbMediaBreakpointsService), ɵngcc0.ɵɵinject(NbJSThemesRegistry)); };
NbThemeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbThemeService, factory: NbThemeService.ɵfac });
NbThemeService = __decorate$1([ __param(0, Inject(NB_THEME_OPTIONS)),
    __metadata("design:paramtypes", [Object, NbMediaBreakpointsService,
        NbJSThemesRegistry])
], NbThemeService);

var __decorate$4 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$3 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$3 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * Service to control the global page spinner.
 */
let NbSpinnerService = class NbSpinnerService {
    constructor(document) {
        this.document = document;
        this.loaders = [];
        this.selector = 'nb-global-spinner';
    }
    /**
     * Appends new loader to the list of loader to be completed before
     * spinner will be hidden
     * @param method Promise<any>
     */
    registerLoader(method) {
        this.loaders.push(method);
    }
    /**
     * Clears the list of loader
     */
    clear() {
        this.loaders = [];
    }
    /**
     * Start the loader process, show spinnder and execute loaders
     */
    load() {
        this.showSpinner();
        this.executeAll();
    }
    executeAll(done = () => { }) {
        Promise.all(this.loaders).then((values) => {
            this.hideSpinner();
            done.call(null, values);
        })
            .catch((error) => {
            // TODO: Promise.reject
            console.error(error);
        });
    }
    // TODO is there any better way of doing this?
    showSpinner() {
        const el = this.getSpinnerElement();
        if (el) {
            el.style['display'] = 'block';
        }
    }
    hideSpinner() {
        const el = this.getSpinnerElement();
        if (el) {
            el.style['display'] = 'none';
        }
    }
    getSpinnerElement() {
        return this.document.getElementById(this.selector);
    }
};
NbSpinnerService.ɵfac = function NbSpinnerService_Factory(t) { return new (t || NbSpinnerService)(ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbSpinnerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbSpinnerService, factory: NbSpinnerService.ɵfac });
NbSpinnerService = __decorate$4([ __param$3(0, Inject(NB_DOCUMENT)),
    __metadata$3("design:paramtypes", [Object])
], NbSpinnerService);

var __decorate$5 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$4 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$4 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Layout direction.
 * */
var NbLayoutDirection;
(function (NbLayoutDirection) {
    NbLayoutDirection["LTR"] = "ltr";
    NbLayoutDirection["RTL"] = "rtl";
})(NbLayoutDirection || (NbLayoutDirection = {}));

/**
 * Layout direction setting injection token.
 * */
const NB_LAYOUT_DIRECTION = new InjectionToken('Layout direction');
/**
 * Layout Direction Service.
 * Allows to set or get layout direction and listen to its changes
 */
let NbLayoutDirectionService = class NbLayoutDirectionService {
    constructor(direction = NbLayoutDirection.LTR) {
        this.direction = direction;
        this.$directionChange = new ReplaySubject(1);
        this.setDirection(direction);
    }
    /**
     * Returns true if layout direction set to left to right.
     * @returns boolean.
     * */
    isLtr() {
        return this.direction === NbLayoutDirection.LTR;
    }
    /**
     * Returns true if layout direction set to right to left.
     * @returns boolean.
     * */
    isRtl() {
        return this.direction === NbLayoutDirection.RTL;
    }
    /**
     * Returns current layout direction.
     * @returns NbLayoutDirection.
     * */
    getDirection() {
        return this.direction;
    }
    /**
     * Sets layout direction
     * @param {NbLayoutDirection} direction
     */
    setDirection(direction) {
        this.direction = direction;
        this.$directionChange.next(direction);
    }
    /**
     * Triggered when direction was changed.
     * @returns Observable<NbLayoutDirection>.
     */
    onDirectionChange() {
        return this.$directionChange.pipe(share());
    }
};
NbLayoutDirectionService.ɵfac = function NbLayoutDirectionService_Factory(t) { return new (t || NbLayoutDirectionService)(ɵngcc0.ɵɵinject(NB_LAYOUT_DIRECTION, 8)); };
NbLayoutDirectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbLayoutDirectionService, factory: NbLayoutDirectionService.ɵfac });
NbLayoutDirectionService = __decorate$5([ __param$4(0, Optional()), __param$4(0, Inject(NB_LAYOUT_DIRECTION)),
    __metadata$4("design:paramtypes", [Object])
], NbLayoutDirectionService);

var __decorate$6 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Layout scroll service. Provides information about current scroll position,
 * as well as methods to update position of the scroll.
 *
 * The reason we added this service is that in Nebular there are two scroll modes:
 * - the default mode when scroll is on body
 * - and the `withScroll` mode, when scroll is removed from the body and moved to an element inside of the
 * `nb-layout` component
 */
let NbLayoutScrollService = class NbLayoutScrollService {
    /**
     * Layout scroll service. Provides information about current scroll position,
     * as well as methods to update position of the scroll.
     *
     * The reason we added this service is that in Nebular there are two scroll modes:
     * - the default mode when scroll is on body
     * - and the `withScroll` mode, when scroll is removed from the body and moved to an element inside of the
     * `nb-layout` component
     */
    constructor() {
        this.scrollPositionReq$ = new Subject();
        this.manualScroll$ = new Subject();
        this.scroll$ = new Subject();
        this.scrollable$ = new Subject();
    }
    /**
     * Returns scroll position
     *
     * @returns {Observable<NbScrollPosition>}
     */
    getPosition() {
        return Observable.create((observer) => {
            const listener = new Subject();
            listener.subscribe(observer);
            this.scrollPositionReq$.next({ listener });
            return () => listener.complete();
        });
    }
    /**
     * Sets scroll position
     *
     * @param {number} x
     * @param {number} y
     */
    scrollTo(x = null, y = null) {
        this.manualScroll$.next({ x, y });
    }
    /**
     * Returns a stream of scroll events
     *
     * @returns {Observable<any>}
     */
    onScroll() {
        return this.scroll$.pipe(share());
    }
    /**
     * @private
     * @returns Observable<NbScrollPosition>.
     */
    onManualScroll() {
        return this.manualScroll$.pipe(share());
    }
    /**
     * @private
     * @returns {Subject<any>}
     */
    onGetPosition() {
        return this.scrollPositionReq$;
    }
    onScrollableChange() {
        return this.scrollable$.pipe(share());
    }
    /**
     * @private
     * @param {any} event
     */
    fireScrollChange(event) {
        this.scroll$.next(event);
    }
    scrollable(scrollable) {
        this.scrollable$.next(scrollable);
    }
};
NbLayoutScrollService.ɵfac = function NbLayoutScrollService_Factory(t) { return new (t || NbLayoutScrollService)(); };
NbLayoutScrollService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbLayoutScrollService, factory: NbLayoutScrollService.ɵfac });

var __decorate$7 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Simple helper service to return Layout dimensions
 * Depending of current Layout scroll mode (default or `withScroll` when scroll is moved to an element
 * inside of the layout) corresponding dimensions will be returns  - of `documentElement` in first case and
 * `.scrollable-container` in the second.
 */
let NbLayoutRulerService = class NbLayoutRulerService {
    /**
     * Simple helper service to return Layout dimensions
     * Depending of current Layout scroll mode (default or `withScroll` when scroll is moved to an element
     * inside of the layout) corresponding dimensions will be returns  - of `documentElement` in first case and
     * `.scrollable-container` in the second.
     */
    constructor() {
        this.contentDimensionsReq$ = new Subject();
    }
    /**
     * Content dimensions
     * @returns {Observable<NbLayoutDimensions>}
     */
    getDimensions() {
        return Observable.create((observer) => {
            const listener = new Subject();
            listener.subscribe(observer);
            this.contentDimensionsReq$.next({ listener });
            return () => listener.complete();
        });
    }
    /**
     * @private
     * @returns {Subject<any>}
     */
    onGetDimensions() {
        return this.contentDimensionsReq$;
    }
};
NbLayoutRulerService.ɵfac = function NbLayoutRulerService_Factory(t) { return new (t || NbLayoutRulerService)(); };
NbLayoutRulerService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbLayoutRulerService, factory: NbLayoutRulerService.ɵfac });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$9 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbSharedModule = class NbSharedModule {
};
NbSharedModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSharedModule });
NbSharedModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbSharedModule_Factory(t) { return new (t || NbSharedModule)(); }, imports: [CommonModule,
        // TODO: probably we don't need FormsModule in SharedModule
        FormsModule,
        RouterModule] });

var __decorate$11 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$5 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$5 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Overrides angular cdk focus trap to keep restore functionality inside trap.
 * */
class NbFocusTrap extends FocusTrap {
    constructor(element, checker, ngZone, document, deferAnchors) {
        super(element, checker, ngZone, document, deferAnchors);
        this.element = element;
        this.checker = checker;
        this.ngZone = ngZone;
        this.document = document;
        this.savePreviouslyFocusedElement();
    }
    restoreFocus() {
        this.previouslyFocusedElement.focus();
        this.destroy();
    }
    blurPreviouslyFocusedElement() {
        this.previouslyFocusedElement.blur();
    }
    savePreviouslyFocusedElement() {
        this.previouslyFocusedElement = this.document.activeElement;
    }
}
let NbFocusTrapFactoryService = class NbFocusTrapFactoryService extends FocusTrapFactory {
    constructor(checker, ngZone, document) {
        super(checker, ngZone, document);
        this.checker = checker;
        this.ngZone = ngZone;
        this.document = document;
    }
    create(element, deferCaptureElements) {
        return new NbFocusTrap(element, this.checker, this.ngZone, this.document, deferCaptureElements);
    }
};
NbFocusTrapFactoryService.ɵfac = function NbFocusTrapFactoryService_Factory(t) { return new (t || NbFocusTrapFactoryService)(ɵngcc0.ɵɵinject(ɵngcc1.InteractivityChecker), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbFocusTrapFactoryService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbFocusTrapFactoryService, factory: NbFocusTrapFactoryService.ɵfac });
NbFocusTrapFactoryService = __decorate$11([ __param$5(2, Inject(NB_DOCUMENT)),
    __metadata$5("design:paramtypes", [InteractivityChecker,
        NgZone, Object])
], NbFocusTrapFactoryService);

class NbFocusKeyManager extends FocusKeyManager {
}
class NbFocusKeyManagerFactoryService {
    create(items) {
        return new NbFocusKeyManager(items);
    }
}

var __decorate$10 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbA11yModule_1;
let NbA11yModule = NbA11yModule_1 = class NbA11yModule {
    static forRoot() {
        return {
            ngModule: NbA11yModule_1,
            providers: [
                NbFocusTrapFactoryService,
                NbFocusKeyManagerFactoryService,
            ],
        };
    }
};
NbA11yModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbA11yModule });
NbA11yModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbA11yModule_Factory(t) { return new (t || NbA11yModule)(); } });

var __decorate$12 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbCdkMappingModule_1;
let NbPortalDirective = class NbPortalDirective extends CdkPortal {
};
NbPortalDirective.ɵfac = function NbPortalDirective_Factory(t) { return ɵNbPortalDirective_BaseFactory(t || NbPortalDirective); };
NbPortalDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbPortalDirective, selectors: [["", "nbPortal", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
let NbPortalOutletDirective = class NbPortalOutletDirective extends CdkPortalOutlet {
};
NbPortalOutletDirective.ɵfac = function NbPortalOutletDirective_Factory(t) { return ɵNbPortalOutletDirective_BaseFactory(t || NbPortalOutletDirective); };
NbPortalOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbPortalOutletDirective, selectors: [["", "nbPortalOutlet", ""]], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
class NbComponentPortal extends ComponentPortal {
}
let NbOverlay = class NbOverlay extends Overlay {
};
NbOverlay.ɵfac = function NbOverlay_Factory(t) { return ɵNbOverlay_BaseFactory(t || NbOverlay); };
NbOverlay.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbOverlay, factory: NbOverlay.ɵfac });
let NbPlatform = class NbPlatform extends Platform {
};
NbPlatform.ɵfac = function NbPlatform_Factory(t) { return ɵNbPlatform_BaseFactory(t || NbPlatform); };
NbPlatform.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbPlatform, factory: NbPlatform.ɵfac });
let NbOverlayPositionBuilder = class NbOverlayPositionBuilder extends OverlayPositionBuilder {
};
NbOverlayPositionBuilder.ɵfac = function NbOverlayPositionBuilder_Factory(t) { return ɵNbOverlayPositionBuilder_BaseFactory(t || NbOverlayPositionBuilder); };
NbOverlayPositionBuilder.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbOverlayPositionBuilder, factory: NbOverlayPositionBuilder.ɵfac });
class NbTemplatePortal extends TemplatePortal {
    constructor(template, viewContainerRef, context) {
        super(template, viewContainerRef, context);
    }
}
class NbOverlayContainer extends OverlayContainer {
}
NbOverlayContainer.ngInjectableDef = ɵɵdefineInjectable({ factory: function NbOverlayContainer_Factory() { return new NbOverlayContainer(ɵɵinject(DOCUMENT)); }, token: NbOverlayContainer, providedIn: "root" });
class NbFlexibleConnectedPositionStrategy extends FlexibleConnectedPositionStrategy {
}
class NbPortalInjector extends PortalInjector {
}
const CDK_MODULES = [OverlayModule, PortalModule];
/**
 * This module helps us to keep all angular/cdk deps inside our cdk module via providing aliases.
 * Approach will help us move cdk in separate npm package and refactor nebular/theme code.
 * */
let NbCdkMappingModule = NbCdkMappingModule_1 = class NbCdkMappingModule {
    static forRoot() {
        return {
            ngModule: NbCdkMappingModule_1,
            providers: [
                NbOverlay,
                NbPlatform,
                NbOverlayPositionBuilder,
            ],
        };
    }
};
NbCdkMappingModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCdkMappingModule });
NbCdkMappingModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbCdkMappingModule_Factory(t) { return new (t || NbCdkMappingModule)(); }, imports: [[...CDK_MODULES],
        OverlayModule, PortalModule] });

var __decorate$14 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Provides nb-layout as overlay container.
 * Container has to be cleared when layout destroys.
 * Another way previous version of the container will be used
 * but it isn't inserted in DOM and exists in memory only.
 * This case important only if you switch between multiple layouts.
 * */
let NbOverlayContainerAdapter = class NbOverlayContainerAdapter extends NbOverlayContainer {
    setContainer(container) {
        this.container = container;
    }
    clearContainer() {
        this.container = null;
        this._containerElement = null;
    }
    _createContainer() {
        const container = this._document.createElement('div');
        container.classList.add('cdk-overlay-container');
        this.container.appendChild(container);
        this._containerElement = container;
    }
};
NbOverlayContainerAdapter.ɵfac = function NbOverlayContainerAdapter_Factory(t) { return ɵNbOverlayContainerAdapter_BaseFactory(t || NbOverlayContainerAdapter); };
NbOverlayContainerAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbOverlayContainerAdapter, factory: NbOverlayContainerAdapter.ɵfac });

var __decorate$15 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$7 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbViewportRulerAdapter = class NbViewportRulerAdapter extends ViewportRuler {
    constructor(platform, ngZone, ruler, scroll) {
        super(platform, ngZone);
        this.ruler = ruler;
        this.scroll = scroll;
    }
    getViewportSize() {
        let res;
        /*
        * getDimensions call is really synchronous operation.
        * And we have to conform with the interface of the original service.
        * */
        this.ruler.getDimensions()
            .pipe(map(dimensions => ({ width: dimensions.clientWidth, height: dimensions.clientHeight })))
            .subscribe(rect => res = rect);
        return res;
    }
    getViewportScrollPosition() {
        let res;
        /*
        * getPosition call is really synchronous operation.
        * And we have to conform with the interface of the original service.
        * */
        this.scroll.getPosition()
            .pipe(map((position) => ({ top: position.y, left: position.x })))
            .subscribe(position => res = position);
        return res;
    }
};
NbViewportRulerAdapter.ɵfac = function NbViewportRulerAdapter_Factory(t) { return new (t || NbViewportRulerAdapter)(ɵngcc0.ɵɵinject(NbPlatform), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NbLayoutRulerService), ɵngcc0.ɵɵinject(NbLayoutScrollService)); };
NbViewportRulerAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbViewportRulerAdapter, factory: NbViewportRulerAdapter.ɵfac });
NbViewportRulerAdapter = __decorate$15([ __metadata$7("design:paramtypes", [NbPlatform, NgZone,
        NbLayoutRulerService,
        NbLayoutScrollService])
], NbViewportRulerAdapter);

var __decorate$16 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$8 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NbGlobalLogicalPosition;
(function (NbGlobalLogicalPosition) {
    NbGlobalLogicalPosition["TOP_START"] = "top-start";
    NbGlobalLogicalPosition["TOP_END"] = "top-end";
    NbGlobalLogicalPosition["BOTTOM_START"] = "bottom-start";
    NbGlobalLogicalPosition["BOTTOM_END"] = "bottom-end";
})(NbGlobalLogicalPosition || (NbGlobalLogicalPosition = {}));
var NbGlobalPhysicalPosition;
(function (NbGlobalPhysicalPosition) {
    NbGlobalPhysicalPosition["TOP_RIGHT"] = "top-right";
    NbGlobalPhysicalPosition["TOP_LEFT"] = "top-left";
    NbGlobalPhysicalPosition["BOTTOM_RIGHT"] = "bottom-right";
    NbGlobalPhysicalPosition["BOTTOM_LEFT"] = "bottom-left";
})(NbGlobalPhysicalPosition || (NbGlobalPhysicalPosition = {}));
let NbPositionHelper = class NbPositionHelper {
    constructor(layoutDirection) {
        this.layoutDirection = layoutDirection;
    }
    toLogicalPosition(position) {
        if (Object.values(NbGlobalLogicalPosition).includes(position)) {
            return position;
        }
        if (this.layoutDirection.isLtr()) {
            return this.toLogicalPositionWhenLtr(position);
        }
        else {
            return this.toLogicalPositionWhenRtl(position);
        }
    }
    toPhysicalPosition(position) {
        if (Object.values(NbGlobalPhysicalPosition).includes(position)) {
            return position;
        }
        if (this.layoutDirection.isLtr()) {
            return this.toPhysicalPositionWhenLtr(position);
        }
        else {
            return this.toPhysicalPositionWhenRtl(position);
        }
    }
    isTopPosition(position) {
        const logicalPosition = this.toLogicalPosition(position);
        return logicalPosition === NbGlobalLogicalPosition.TOP_END
            || logicalPosition === NbGlobalLogicalPosition.TOP_START;
    }
    isRightPosition(position) {
        const physicalPosition = this.toPhysicalPosition(position);
        return physicalPosition === NbGlobalPhysicalPosition.TOP_RIGHT
            || physicalPosition === NbGlobalPhysicalPosition.BOTTOM_RIGHT;
    }
    toLogicalPositionWhenLtr(position) {
        switch (position) {
            case NbGlobalPhysicalPosition.TOP_RIGHT:
                return NbGlobalLogicalPosition.TOP_END;
            case NbGlobalPhysicalPosition.TOP_LEFT:
                return NbGlobalLogicalPosition.TOP_START;
            case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
                return NbGlobalLogicalPosition.BOTTOM_END;
            case NbGlobalPhysicalPosition.BOTTOM_LEFT:
                return NbGlobalLogicalPosition.BOTTOM_START;
        }
    }
    toLogicalPositionWhenRtl(position) {
        switch (position) {
            case NbGlobalPhysicalPosition.TOP_RIGHT:
                return NbGlobalLogicalPosition.TOP_START;
            case NbGlobalPhysicalPosition.TOP_LEFT:
                return NbGlobalLogicalPosition.TOP_END;
            case NbGlobalPhysicalPosition.BOTTOM_RIGHT:
                return NbGlobalLogicalPosition.BOTTOM_START;
            case NbGlobalPhysicalPosition.BOTTOM_LEFT:
                return NbGlobalLogicalPosition.BOTTOM_END;
        }
    }
    toPhysicalPositionWhenLtr(position) {
        switch (position) {
            case NbGlobalLogicalPosition.TOP_START:
                return NbGlobalPhysicalPosition.TOP_LEFT;
            case NbGlobalLogicalPosition.TOP_END:
                return NbGlobalPhysicalPosition.TOP_RIGHT;
            case NbGlobalLogicalPosition.BOTTOM_START:
                return NbGlobalPhysicalPosition.BOTTOM_LEFT;
            case NbGlobalLogicalPosition.BOTTOM_END:
                return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
        }
    }
    toPhysicalPositionWhenRtl(position) {
        switch (position) {
            case NbGlobalLogicalPosition.TOP_START:
                return NbGlobalPhysicalPosition.TOP_RIGHT;
            case NbGlobalLogicalPosition.TOP_END:
                return NbGlobalPhysicalPosition.TOP_LEFT;
            case NbGlobalLogicalPosition.BOTTOM_START:
                return NbGlobalPhysicalPosition.BOTTOM_RIGHT;
            case NbGlobalLogicalPosition.BOTTOM_END:
                return NbGlobalPhysicalPosition.BOTTOM_LEFT;
        }
    }
};
NbPositionHelper.ɵfac = function NbPositionHelper_Factory(t) { return new (t || NbPositionHelper)(ɵngcc0.ɵɵinject(NbLayoutDirectionService)); };
NbPositionHelper.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbPositionHelper, factory: NbPositionHelper.ɵfac });
NbPositionHelper = __decorate$16([ __metadata$8("design:paramtypes", [NbLayoutDirectionService])
], NbPositionHelper);

var __decorate$13 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$6 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$6 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NbAdjustment;
(function (NbAdjustment) {
    NbAdjustment["NOOP"] = "noop";
    NbAdjustment["CLOCKWISE"] = "clockwise";
    NbAdjustment["COUNTERCLOCKWISE"] = "counterclockwise";
    NbAdjustment["VERTICAL"] = "vertical";
    NbAdjustment["HORIZONTAL"] = "horizontal";
})(NbAdjustment || (NbAdjustment = {}));
var NbPosition;
(function (NbPosition) {
    NbPosition["TOP"] = "top";
    NbPosition["BOTTOM"] = "bottom";
    NbPosition["LEFT"] = "left";
    NbPosition["RIGHT"] = "right";
    NbPosition["START"] = "start";
    NbPosition["END"] = "end";
    NbPosition["TOP_END"] = "top-end";
    NbPosition["TOP_START"] = "top-start";
    NbPosition["BOTTOM_END"] = "bottom-end";
    NbPosition["BOTTOM_START"] = "bottom-start";
    NbPosition["END_TOP"] = "end-top";
    NbPosition["END_BOTTOM"] = "end-bottom";
    NbPosition["START_TOP"] = "start-top";
    NbPosition["START_BOTTOM"] = "start-bottom";
})(NbPosition || (NbPosition = {}));
const POSITIONS = {
    [NbPosition.RIGHT](offset) {
        return { originX: 'end', originY: 'center', overlayX: 'start', overlayY: 'center', offsetX: offset };
    },
    [NbPosition.BOTTOM](offset) {
        return { originX: 'center', originY: 'bottom', overlayX: 'center', overlayY: 'top', offsetY: offset };
    },
    [NbPosition.LEFT](offset) {
        return { originX: 'start', originY: 'center', overlayX: 'end', overlayY: 'center', offsetX: -offset };
    },
    [NbPosition.TOP](offset) {
        return { originX: 'center', originY: 'top', overlayX: 'center', overlayY: 'bottom', offsetY: -offset };
    },
    [NbPosition.START](offset) {
        return this[NbPosition.LEFT](offset);
    },
    [NbPosition.END](offset) {
        return this[NbPosition.RIGHT](offset);
    },
    [NbPosition.END_TOP](offset) {
        return { originX: 'end', originY: 'bottom', overlayX: 'start', overlayY: 'bottom', offsetX: offset };
    },
    [NbPosition.END_BOTTOM](offset) {
        return { originX: 'end', originY: 'top', overlayX: 'start', overlayY: 'top', offsetX: offset };
    },
    [NbPosition.BOTTOM_START](offset) {
        return { originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top', offsetY: offset };
    },
    [NbPosition.BOTTOM_END](offset) {
        return { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top', offsetY: offset };
    },
    [NbPosition.START_TOP](offset) {
        return { originX: 'start', originY: 'bottom', overlayX: 'end', overlayY: 'bottom', offsetX: -offset };
    },
    [NbPosition.START_BOTTOM](offset) {
        return { originX: 'start', originY: 'top', overlayX: 'end', overlayY: 'top', offsetX: -offset };
    },
    [NbPosition.TOP_START](offset) {
        return { originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', offsetY: -offset };
    },
    [NbPosition.TOP_END](offset) {
        return { originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', offsetY: -offset };
    },
};
const COUNTER_CLOCKWISE_POSITIONS = [
    NbPosition.TOP,
    NbPosition.TOP_END,
    NbPosition.TOP_START,
    NbPosition.START,
    NbPosition.START_TOP,
    NbPosition.START_BOTTOM,
    NbPosition.BOTTOM,
    NbPosition.BOTTOM_START,
    NbPosition.BOTTOM_END,
    NbPosition.END,
    NbPosition.END_BOTTOM,
    NbPosition.END_TOP,
];
const CLOCKWISE_POSITIONS = [
    NbPosition.TOP,
    NbPosition.TOP_START,
    NbPosition.TOP_END,
    NbPosition.END,
    NbPosition.END_TOP,
    NbPosition.END_BOTTOM,
    NbPosition.BOTTOM,
    NbPosition.BOTTOM_END,
    NbPosition.BOTTOM_START,
    NbPosition.START,
    NbPosition.START_BOTTOM,
    NbPosition.START_TOP,
];
const VERTICAL_POSITIONS = [NbPosition.BOTTOM, NbPosition.TOP];
const HORIZONTAL_POSITIONS = [NbPosition.START, NbPosition.END];
function comparePositions(p1, p2) {
    return p1.originX === p2.originX
        && p1.originY === p2.originY
        && p1.overlayX === p2.overlayX
        && p1.overlayY === p2.overlayY;
}
/**
 * The main idea of the adjustable connected strategy is to provide predefined set of positions for your overlay.
 * You have to provide adjustment and appropriate strategy will be chosen in runtime.
 * */
class NbAdjustableConnectedPositionStrategy extends NbFlexibleConnectedPositionStrategy {
    constructor() {
        super(...arguments);
        this._offset = 15;
        this.positionChange = this.positionChanges.pipe(map((positionChange) => positionChange.connectionPair), map((connectionPair) => {
            return this.appliedPositions.find(({ connectedPosition }) => {
                return comparePositions(connectedPosition, connectionPair);
            }).key;
        }));
    }
    attach(overlayRef) {
        /**
         * We have to apply positions before attach because super.attach() validates positions and crashes app
         * if no positions provided.
         * */
        this.applyPositions();
        super.attach(overlayRef);
    }
    apply() {
        this.applyPositions();
        super.apply();
    }
    position(position) {
        this._position = position;
        return this;
    }
    adjustment(adjustment) {
        this._adjustment = adjustment;
        return this;
    }
    offset(offset) {
        this._offset = offset;
        return this;
    }
    applyPositions() {
        const positions = this.createPositions();
        this.persistChosenPositions(positions);
        this.withPositions(this.appliedPositions.map(({ connectedPosition }) => connectedPosition));
    }
    createPositions() {
        switch (this._adjustment) {
            case NbAdjustment.NOOP:
                return [this._position];
            case NbAdjustment.CLOCKWISE:
                return this.reorderPreferredPositions(CLOCKWISE_POSITIONS);
            case NbAdjustment.COUNTERCLOCKWISE:
                return this.reorderPreferredPositions(COUNTER_CLOCKWISE_POSITIONS);
            case NbAdjustment.HORIZONTAL:
                return this.reorderPreferredPositions(HORIZONTAL_POSITIONS);
            case NbAdjustment.VERTICAL:
                return this.reorderPreferredPositions(VERTICAL_POSITIONS);
        }
    }
    persistChosenPositions(positions) {
        this.appliedPositions = positions.map(position => ({
            key: position,
            connectedPosition: POSITIONS[position](this._offset),
        }));
    }
    reorderPreferredPositions(positions) {
        // Physical positions should be mapped to logical as adjustments use logical positions.
        const startPositionIndex = positions.indexOf(this.mapToLogicalPosition(this._position));
        const firstPart = positions.slice(startPositionIndex);
        const secondPart = positions.slice(0, startPositionIndex);
        return firstPart.concat(secondPart);
    }
    mapToLogicalPosition(position) {
        if (position === NbPosition.LEFT) {
            return NbPosition.START;
        }
        if (position === NbPosition.RIGHT) {
            return NbPosition.END;
        }
        return position;
    }
}
class NbGlobalPositionStrategy extends GlobalPositionStrategy {
    position(position) {
        switch (position) {
            case NbGlobalLogicalPosition.TOP_START:
                return this.top().left();
            case NbGlobalLogicalPosition.TOP_END:
                return this.top().right();
            case NbGlobalLogicalPosition.BOTTOM_START:
                return this.bottom().left();
            case NbGlobalLogicalPosition.BOTTOM_END:
                return this.bottom().right();
        }
    }
}
let NbPositionBuilderService = class NbPositionBuilderService {
    constructor(document, viewportRuler, platform, positionBuilder, overlayContainer) {
        this.document = document;
        this.viewportRuler = viewportRuler;
        this.platform = platform;
        this.positionBuilder = positionBuilder;
        this.overlayContainer = overlayContainer;
    }
    global() {
        return new NbGlobalPositionStrategy();
    }
    connectedTo(elementRef) {
        return new NbAdjustableConnectedPositionStrategy(elementRef, this.viewportRuler, this.document, this.platform, this.overlayContainer)
            .withFlexibleDimensions(false)
            .withPush(false);
    }
};
NbPositionBuilderService.ɵfac = function NbPositionBuilderService_Factory(t) { return new (t || NbPositionBuilderService)(ɵngcc0.ɵɵinject(NB_DOCUMENT), ɵngcc0.ɵɵinject(NbViewportRulerAdapter), ɵngcc0.ɵɵinject(NbPlatform), ɵngcc0.ɵɵinject(NbOverlayPositionBuilder), ɵngcc0.ɵɵinject(NbOverlayContainerAdapter)); };
NbPositionBuilderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbPositionBuilderService, factory: NbPositionBuilderService.ɵfac });
NbPositionBuilderService = __decorate$13([ __param$6(0, Inject(NB_DOCUMENT)),
    __metadata$6("design:paramtypes", [Object, NbViewportRulerAdapter,
        NbPlatform,
        NbOverlayPositionBuilder,
        NbOverlayContainerAdapter])
], NbPositionBuilderService);

var __decorate$17 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$9 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbPositionedContainer = 
// @breaking-change @5.0.0 Rename to NbPositionedContainerComponent and enable ts lint
// tslint:disable-next-line
class NbPositionedContainer {
    get top() {
        return this.position === NbPosition.TOP;
    }
    get topStart() {
        return this.position === NbPosition.TOP_START;
    }
    get topEnd() {
        return this.position === NbPosition.TOP_END;
    }
    get right() {
        return this.position === NbPosition.RIGHT || this.position === NbPosition.END;
    }
    get endTop() {
        return this.position === NbPosition.END_TOP;
    }
    get endBottom() {
        return this.position === NbPosition.END_BOTTOM;
    }
    get bottom() {
        return this.position === NbPosition.BOTTOM;
    }
    get bottomStart() {
        return this.position === NbPosition.BOTTOM_START;
    }
    get bottomEnd() {
        return this.position === NbPosition.BOTTOM_END;
    }
    get left() {
        return this.position === NbPosition.LEFT || this.position === NbPosition.START;
    }
    get startTop() {
        return this.position === NbPosition.START_TOP;
    }
    get startBottom() {
        return this.position === NbPosition.START_BOTTOM;
    }
};
NbPositionedContainer.ɵfac = function NbPositionedContainer_Factory(t) { return new (t || NbPositionedContainer)(); };
NbPositionedContainer.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbPositionedContainer, selectors: [["ng-component"]], hostVars: 24, hostBindings: function NbPositionedContainer_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nb-overlay-top", ctx.top)("nb-overlay-top-start", ctx.topStart)("nb-overlay-top-end", ctx.topEnd)("nb-overlay-right", ctx.right)("nb-overlay-end-top", ctx.endTop)("nb-overlay-end-bottom", ctx.endBottom)("nb-overlay-bottom", ctx.bottom)("nb-overlay-bottom-start", ctx.bottomStart)("nb-overlay-bottom-end", ctx.bottomEnd)("nb-overlay-left", ctx.left)("nb-overlay-start-top", ctx.startTop)("nb-overlay-start-bottom", ctx.startBottom);
    } }, inputs: { position: "position" }, decls: 0, vars: 0, template: function NbPositionedContainer_Template(rf, ctx) { }, encapsulation: 2 });
__decorate$17([
    Input(),
    __metadata$9("design:type", String)
], NbPositionedContainer.prototype, "position", void 0);
__decorate$17([
    HostBinding('class.nb-overlay-top'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "top", null);
__decorate$17([
    HostBinding('class.nb-overlay-top-start'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "topStart", null);
__decorate$17([
    HostBinding('class.nb-overlay-top-end'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "topEnd", null);
__decorate$17([
    HostBinding('class.nb-overlay-right'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "right", null);
__decorate$17([
    HostBinding('class.nb-overlay-end-top'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "endTop", null);
__decorate$17([
    HostBinding('class.nb-overlay-end-bottom'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "endBottom", null);
__decorate$17([
    HostBinding('class.nb-overlay-bottom'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "bottom", null);
__decorate$17([
    HostBinding('class.nb-overlay-bottom-start'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "bottomStart", null);
__decorate$17([
    HostBinding('class.nb-overlay-bottom-end'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "bottomEnd", null);
__decorate$17([
    HostBinding('class.nb-overlay-left'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "left", null);
__decorate$17([
    HostBinding('class.nb-overlay-start-top'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "startTop", null);
__decorate$17([
    HostBinding('class.nb-overlay-start-bottom'),
    __metadata$9("design:type", Boolean),
    __metadata$9("design:paramtypes", [])
], NbPositionedContainer.prototype, "startBottom", null);
let NbOverlayContainerComponent = class NbOverlayContainerComponent {
    constructor(vcr, injector, changeDetectorRef) {
        this.vcr = vcr;
        this.injector = injector;
        this.changeDetectorRef = changeDetectorRef;
        this.isAttached = false;
    }
    get isStringContent() {
        return !!this.content;
    }
    attachComponentPortal(portal, context) {
        portal.injector = this.createChildInjector(portal.componentFactoryResolver);
        const componentRef = this.portalOutlet.attachComponentPortal(portal);
        if (context) {
            Object.assign(componentRef.instance, context);
        }
        componentRef.changeDetectorRef.markForCheck();
        componentRef.changeDetectorRef.detectChanges();
        this.isAttached = true;
        return componentRef;
    }
    attachTemplatePortal(portal) {
        const templateRef = this.portalOutlet.attachTemplatePortal(portal);
        templateRef.detectChanges();
        this.isAttached = true;
        return templateRef;
    }
    attachStringContent(content) {
        this.content = content;
        this.changeDetectorRef.markForCheck();
        this.changeDetectorRef.detectChanges();
        this.isAttached = true;
    }
    detach() {
        if (this.portalOutlet.hasAttached()) {
            this.portalOutlet.detach();
        }
        this.attachStringContent(null);
        this.isAttached = false;
    }
    createChildInjector(cfr) {
        return new NbPortalInjector(this.injector, new WeakMap([
            [ComponentFactoryResolver, cfr],
        ]));
    }
};
NbOverlayContainerComponent.ɵfac = function NbOverlayContainerComponent_Factory(t) { return new (t || NbOverlayContainerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbOverlayContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbOverlayContainerComponent, selectors: [["nb-overlay-container"]], viewQuery: function NbOverlayContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(NbPortalOutletDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    } }, decls: 2, vars: 1, consts: [["class", "primitive-overlay", 4, "ngIf"], ["nbPortalOutlet", ""], [1, "primitive-overlay"]], template: function NbOverlayContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbOverlayContainerComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵtemplate(1, NbOverlayContainerComponent_ng_template_1_Template, 0, 0, "ng-template", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isStringContent);
    } }, directives: [ɵngcc2.NgIf, NbPortalOutletDirective], encapsulation: 2 });
__decorate$17([
    ViewChild(NbPortalOutletDirective, { static: true }),
    __metadata$9("design:type", NbPortalOutletDirective)
], NbOverlayContainerComponent.prototype, "portalOutlet", void 0);
NbOverlayContainerComponent = __decorate$17([ __metadata$9("design:paramtypes", [ViewContainerRef,
        Injector, ChangeDetectorRef])
], NbOverlayContainerComponent);

var __decorate$18 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$10 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
function patch(container, containerContext) {
    Object.assign(container.instance, containerContext);
    container.changeDetectorRef.detectChanges();
    return container;
}
function createContainer(ref, container, context, componentFactoryResolver) {
    const containerRef = ref.attach(new NbComponentPortal(container, null, null, componentFactoryResolver));
    patch(containerRef, context);
    return containerRef;
}
let NbOverlayService = class NbOverlayService {
    constructor(overlay, layoutDirection) {
        this.overlay = overlay;
        this.layoutDirection = layoutDirection;
    }
    get scrollStrategies() {
        return this.overlay.scrollStrategies;
    }
    create(config) {
        const overlayRef = this.overlay.create(config);
        this.layoutDirection.onDirectionChange()
            .subscribe(dir => overlayRef.setDirection(dir));
        return overlayRef;
    }
};
NbOverlayService.ɵfac = function NbOverlayService_Factory(t) { return new (t || NbOverlayService)(ɵngcc0.ɵɵinject(NbOverlay), ɵngcc0.ɵɵinject(NbLayoutDirectionService)); };
NbOverlayService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbOverlayService, factory: NbOverlayService.ɵfac });
NbOverlayService = __decorate$18([ __metadata$10("design:paramtypes", [NbOverlay, NbLayoutDirectionService])
], NbOverlayService);

var __decorate$20 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$11 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbScrollDispatcherAdapter = class NbScrollDispatcherAdapter extends ScrollDispatcher {
    constructor(ngZone, platform, scrollService) {
        super(ngZone, platform);
        this.scrollService = scrollService;
    }
    scrolled(auditTimeInMs) {
        return this.scrollService.onScroll();
    }
};
NbScrollDispatcherAdapter.ɵfac = function NbScrollDispatcherAdapter_Factory(t) { return new (t || NbScrollDispatcherAdapter)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NbPlatform), ɵngcc0.ɵɵinject(NbLayoutScrollService)); };
NbScrollDispatcherAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbScrollDispatcherAdapter, factory: NbScrollDispatcherAdapter.ɵfac });
NbScrollDispatcherAdapter = __decorate$20([ __metadata$11("design:paramtypes", [NgZone, NbPlatform, NbLayoutScrollService])
], NbScrollDispatcherAdapter);

var __decorate$21 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$12 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$7 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Overrides default block scroll strategy because default strategy blocks scrolling on the body only.
 * But Nebular has its own scrollable container - nb-layout. So, we need to block scrolling in it to.
 * */
let NbBlockScrollStrategyAdapter = class NbBlockScrollStrategyAdapter extends BlockScrollStrategy {
    constructor(document, viewportRuler, scrollService) {
        super(viewportRuler, document);
        this.scrollService = scrollService;
    }
    enable() {
        super.enable();
        this.scrollService.scrollable(false);
    }
    disable() {
        super.disable();
        this.scrollService.scrollable(true);
    }
};
NbBlockScrollStrategyAdapter.ɵfac = function NbBlockScrollStrategyAdapter_Factory(t) { return new (t || NbBlockScrollStrategyAdapter)(ɵngcc0.ɵɵinject(NB_DOCUMENT), ɵngcc0.ɵɵinject(NbViewportRulerAdapter), ɵngcc0.ɵɵinject(NbLayoutScrollService)); };
NbBlockScrollStrategyAdapter.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbBlockScrollStrategyAdapter, factory: NbBlockScrollStrategyAdapter.ɵfac });
NbBlockScrollStrategyAdapter = __decorate$21([ __param$7(0, Inject(NB_DOCUMENT)),
    __metadata$12("design:paramtypes", [Object, NbViewportRulerAdapter,
        NbLayoutScrollService])
], NbBlockScrollStrategyAdapter);
let NbScrollStrategyOptions = class NbScrollStrategyOptions extends ScrollStrategyOptions {
    constructor(scrollService, scrollDispatcher, viewportRuler, ngZone, document) {
        super(scrollDispatcher, viewportRuler, ngZone, document);
        this.scrollService = scrollService;
        this.scrollDispatcher = scrollDispatcher;
        this.viewportRuler = viewportRuler;
        this.ngZone = ngZone;
        this.document = document;
        this.block = () => new NbBlockScrollStrategyAdapter(this.document, this.viewportRuler, this.scrollService);
    }
};
NbScrollStrategyOptions.ɵfac = function NbScrollStrategyOptions_Factory(t) { return new (t || NbScrollStrategyOptions)(ɵngcc0.ɵɵinject(NbLayoutScrollService), ɵngcc0.ɵɵinject(ɵngcc3.ScrollDispatcher), ɵngcc0.ɵɵinject(NbViewportRulerAdapter), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbScrollStrategyOptions.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbScrollStrategyOptions, factory: NbScrollStrategyOptions.ɵfac });
NbScrollStrategyOptions = __decorate$21([ __param$7(4, Inject(NB_DOCUMENT)),
    __metadata$12("design:paramtypes", [NbLayoutScrollService,
        ScrollDispatcher,
        NbViewportRulerAdapter,
        NgZone, Object])
], NbScrollStrategyOptions);

var __decorate$19 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbCdkAdapterModule_1;
let NbCdkAdapterModule = NbCdkAdapterModule_1 = class NbCdkAdapterModule {
    static forRoot() {
        return {
            ngModule: NbCdkAdapterModule_1,
            providers: [
                NbViewportRulerAdapter,
                NbOverlayContainerAdapter,
                NbBlockScrollStrategyAdapter,
                { provide: OverlayContainer, useExisting: NbOverlayContainerAdapter },
                { provide: NbOverlayContainer, useExisting: NbOverlayContainerAdapter },
                { provide: ScrollDispatcher, useClass: NbScrollDispatcherAdapter },
                { provide: ScrollStrategyOptions, useClass: NbScrollStrategyOptions },
            ],
        };
    }
};
NbCdkAdapterModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCdkAdapterModule });
NbCdkAdapterModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbCdkAdapterModule_Factory(t) { return new (t || NbCdkAdapterModule)(); } });

var __decorate$22 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$13 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$8 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NbTrigger;
(function (NbTrigger) {
    NbTrigger["NOOP"] = "noop";
    NbTrigger["CLICK"] = "click";
    NbTrigger["HOVER"] = "hover";
    NbTrigger["HINT"] = "hint";
    NbTrigger["FOCUS"] = "focus";
})(NbTrigger || (NbTrigger = {}));
/**
 * TODO maybe we have to use renderer.listen instead of observableFromEvent?
 * Renderer provides capability use it in service worker, ssr and so on.
 * */
class NbTriggerStrategyBase {
    constructor(document, host, container) {
        this.document = document;
        this.host = host;
        this.container = container;
        this.destroyed$ = new Subject();
    }
    destroy() {
        this.destroyed$.next();
    }
    isNotOnHostOrContainer(event) {
        return !this.isOnHost(event) && !this.isOnContainer(event);
    }
    isOnHostOrContainer(event) {
        return this.isOnHost(event) || this.isOnContainer(event);
    }
    isOnHost({ target }) {
        return this.host.contains(target);
    }
    isOnContainer({ target }) {
        return this.container() && this.container().location.nativeElement.contains(target);
    }
}
/**
 * Creates show and hide event streams.
 * Fires toggle event when the click was performed on the host element.
 * Fires close event when the click was performed on the document but
 * not on the host or container.
 * */
class NbClickTriggerStrategy extends NbTriggerStrategyBase {
    constructor() {
        super(...arguments);
        // since we should track click for both SHOW and HIDE event we firstly need to track the click and the state
        // of the container and then later on decide should we hide it or show
        // if we track the click & state separately this will case a behavior when the container is getting shown
        // and then hidden right away
        this.click$ = fromEvent(this.document, 'click')
            .pipe(map((event) => [!this.container() && this.isOnHost(event), event]), share(), takeUntil(this.destroyed$));
        this.show$ = this.click$
            .pipe(filter(([shouldShow]) => shouldShow), map(([, event]) => event), takeUntil(this.destroyed$));
        this.hide$ = this.click$
            .pipe(filter(([shouldShow, event]) => !shouldShow && !this.isOnContainer(event)), map(([, event]) => event), takeUntil(this.destroyed$));
    }
}
/**
 * Creates show and hide event streams.
 * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.
 * Fires close event when the mouse leaves the host element and stops out of the host and popover container.
 * */
class NbHoverTriggerStrategy extends NbTriggerStrategyBase {
    constructor() {
        super(...arguments);
        this.show$ = fromEvent(this.host, 'mouseenter')
            .pipe(filter(() => !this.container()), delay(100), takeUntil(fromEvent(this.host, 'mouseleave')), repeat(), takeUntil(this.destroyed$));
        this.hide$ = fromEvent(this.host, 'mouseleave')
            .pipe(switchMap(() => fromEvent(this.document, 'mousemove')
            .pipe(debounceTime(100), takeWhile(() => !!this.container()), filter(event => this.isNotOnHostOrContainer(event)))), takeUntil(this.destroyed$));
    }
}
/**
 * Creates show and hide event streams.
 * Fires open event when a mouse hovers over the host element and stay over at least 100 milliseconds.
 * Fires close event when the mouse leaves the host element.
 * */
class NbHintTriggerStrategy extends NbTriggerStrategyBase {
    constructor() {
        super(...arguments);
        this.show$ = fromEvent(this.host, 'mouseenter')
            .pipe(delay(100), takeUntil(merge(fromEvent(this.host, 'mouseleave'), this.destroyed$)), 
        // this `delay & takeUntil & repeat` operators combination is a synonym for `conditional debounce`
        // meaning that if one event occurs in some time after the initial one we won't react to it
        repeat());
        this.hide$ = fromEvent(this.host, 'mouseleave')
            .pipe(takeUntil(this.destroyed$));
    }
}
/**
 * Creates show and hide event streams.
 * Fires open event when a focus is on the host element and stay over at least 100 milliseconds.
 * Fires close event when the focus leaves the host element.
 * */
class NbFocusTriggerStrategy extends NbTriggerStrategyBase {
    constructor() {
        super(...arguments);
        this.focusOut$ = fromEvent(this.host, 'focusout')
            .pipe(switchMap(() => fromEvent(this.document, 'focusin')
            .pipe(takeWhile(() => !!this.container()), filter(event => this.isNotOnHostOrContainer(event)))), takeUntil(this.destroyed$));
        this.clickIn$ = fromEvent(this.host, 'click')
            .pipe(filter(() => !this.container()), takeUntil(this.destroyed$));
        this.clickOut$ = fromEvent(this.document, 'click')
            .pipe(filter(() => !!this.container()), filter(event => this.isNotOnHostOrContainer(event)), takeUntil(this.destroyed$));
        this.tabKeyPress$ = fromEvent(this.document, 'keydown')
            .pipe(filter((event) => event.keyCode === 9), filter(() => !!this.container()), takeUntil(this.destroyed$));
        this.show$ = merge(fromEvent(this.host, 'focusin'), this.clickIn$)
            .pipe(filter(() => !this.container()), debounceTime(100), takeUntil(merge(fromEvent(this.host, 'focusout'), this.destroyed$)), repeat());
        this.hide$ = merge(this.focusOut$, this.tabKeyPress$, this.clickOut$)
            .pipe(takeUntil(this.destroyed$));
    }
}
/**
 * Creates empty show and hide event streams.
 * */
class NbNoopTriggerStrategy extends NbTriggerStrategyBase {
    constructor() {
        super(...arguments);
        this.show$ = EMPTY;
        this.hide$ = EMPTY;
    }
}
let NbTriggerStrategyBuilderService = class NbTriggerStrategyBuilderService {
    constructor(_document) {
        this._document = _document;
    }
    trigger(trigger$$1) {
        this._trigger = trigger$$1;
        return this;
    }
    host(host) {
        this._host = host;
        return this;
    }
    container(container) {
        this._container = container;
        return this;
    }
    build() {
        switch (this._trigger) {
            case NbTrigger.CLICK:
                return new NbClickTriggerStrategy(this._document, this._host, this._container);
            case NbTrigger.HINT:
                return new NbHintTriggerStrategy(this._document, this._host, this._container);
            case NbTrigger.HOVER:
                return new NbHoverTriggerStrategy(this._document, this._host, this._container);
            case NbTrigger.FOCUS:
                return new NbFocusTriggerStrategy(this._document, this._host, this._container);
            case NbTrigger.NOOP:
                return new NbNoopTriggerStrategy(this._document, this._host, this._container);
            default:
                throw new Error('Trigger have to be provided');
        }
    }
};
NbTriggerStrategyBuilderService.ɵfac = function NbTriggerStrategyBuilderService_Factory(t) { return new (t || NbTriggerStrategyBuilderService)(ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbTriggerStrategyBuilderService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTriggerStrategyBuilderService, factory: NbTriggerStrategyBuilderService.ɵfac });
NbTriggerStrategyBuilderService = __decorate$22([ __param$8(0, Inject(NB_DOCUMENT)),
    __metadata$13("design:paramtypes", [Object])
], NbTriggerStrategyBuilderService);

var __decorate$8 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbOverlayModule_1;
let NbOverlayModule = NbOverlayModule_1 = class NbOverlayModule {
    static forRoot() {
        return {
            ngModule: NbOverlayModule_1,
            providers: [
                NbPositionBuilderService,
                NbTriggerStrategyBuilderService,
                NbOverlayService,
                NbPositionHelper,
                ...NbCdkMappingModule.forRoot().providers,
                ...NbCdkAdapterModule.forRoot().providers,
                ...NbA11yModule.forRoot().providers,
            ],
        };
    }
};
NbOverlayModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbOverlayModule });
NbOverlayModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbOverlayModule_Factory(t) { return new (t || NbOverlayModule)(); }, imports: [[
            NbCdkMappingModule,
            NbSharedModule,
        ],
        NbCdkMappingModule,
        NbCdkAdapterModule] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbThemeModule_1;
function windowFactory(platformId) {
    if (isPlatformBrowser(platformId)) {
        return window;
    }
    // Provide undefined to get the error when trying to access the window as it
    // shouldn't be used outside the browser. Those who need to provide something
    // instead of window (e.g. domino window when running in node) could override
    // NB_WINDOW token.
    return undefined;
}
let NbThemeModule = NbThemeModule_1 = class NbThemeModule {
    // TODO: check the options (throw exception?)
    /**
     * Main Theme Module
     *
     * @param nbThemeOptions {NbThemeOptions} Main theme options
     * @param nbJSThemes {NbJSThemeOptions[]} List of JS Themes, will be merged with default themes
     * @param nbMediaBreakpoints {NbMediaBreakpoint} Available media breakpoints
     * @param layoutDirection {NbLayoutDirection} Layout direction
     *
     * @returns {ModuleWithProviders}
     */
    static forRoot(nbThemeOptions = { name: 'default' }, nbJSThemes, nbMediaBreakpoints, layoutDirection) {
        return {
            ngModule: NbThemeModule_1,
            providers: [
                { provide: NB_THEME_OPTIONS, useValue: nbThemeOptions || {} },
                { provide: NB_BUILT_IN_JS_THEMES, useValue: BUILT_IN_THEMES },
                { provide: NB_JS_THEMES, useValue: nbJSThemes || [] },
                { provide: NB_MEDIA_BREAKPOINTS, useValue: nbMediaBreakpoints || DEFAULT_MEDIA_BREAKPOINTS },
                { provide: NB_DOCUMENT, useExisting: DOCUMENT },
                { provide: NB_WINDOW, useFactory: windowFactory, deps: [PLATFORM_ID] },
                NbJSThemesRegistry,
                NbThemeService,
                NbMediaBreakpointsService,
                NbSpinnerService,
                { provide: NB_LAYOUT_DIRECTION, useValue: layoutDirection || NbLayoutDirection.LTR },
                NbLayoutDirectionService,
                NbLayoutScrollService,
                NbLayoutRulerService,
                ...NbOverlayModule.forRoot().providers,
            ],
        };
    }
};
NbThemeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbThemeModule });
NbThemeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbThemeModule_Factory(t) { return new (t || NbThemeModule)(); }, imports: [[
            CommonModule,
        ]] });

class NbColorHelper {
    static shade(color, weight) {
        return NbColorHelper.mix('#000000', color, weight);
    }
    static tint(color, weight) {
        return NbColorHelper.mix('#ffffff', color, weight);
    }
    static mix(color1, color2, weight) {
        const d2h = (d) => d.toString(16);
        const h2d = (h) => parseInt(h, 16);
        let result = '#';
        for (let i = 1; i < 7; i += 2) {
            const firstPart = h2d(color1.substr(i, 2));
            const secondPart = h2d(color2.substr(i, 2));
            const resultPart = d2h(Math.floor(secondPart + (firstPart - secondPart) * (weight / 100.0)));
            result += ('0' + resultPart).slice(-2);
        }
        return result;
    }
    static hexToRgbA(hex, alpha) {
        let c;
        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
            c = hex.substring(1).split('');
            if (c.length === 3) {
                c = [c[0], c[0], c[1], c[1], c[2], c[2]];
            }
            c = '0x' + c.join('');
            return 'rgba(' + [(c >> 16) & 255, (c >> 8) & 255, c & 255].join(',') + ',' + alpha + ')';
        }
        throw new Error('Bad Hex');
    }
}

var NbIconPackType;
(function (NbIconPackType) {
    NbIconPackType["SVG"] = "svg";
    NbIconPackType["FONT"] = "font";
})(NbIconPackType || (NbIconPackType = {}));

class NbFontIcon {
    constructor(name, content, params = {}) {
        this.name = name;
        this.content = content;
        this.params = params;
    }
    getClasses(options) {
        const classes = [];
        if (this.params.packClass) {
            classes.push(this.params.packClass);
        }
        const name = this.params.iconClassPrefix ? `${this.params.iconClassPrefix}-${this.name}` : this.name;
        classes.push(name);
        return classes;
    }
    getContent(options) {
        return this.content;
    }
}
class NbSvgIcon {
    constructor(name, content, params = {}) {
        this.name = name;
        this.content = content;
        this.params = params;
    }
    getClasses(options) {
        const classes = [];
        if (this.params.packClass) {
            classes.push(this.params.packClass);
        }
        return classes;
    }
    getContent(options) {
        return this.content;
    }
}

var __decorate$26 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbIconDefinition {
}
function throwPackNotFoundError(name) {
    throw Error(`Icon Pack '${name}' is not registered`);
}
function throwNoDefaultPackError() {
    throw Error('Default pack is not registered.');
}
function throwIconNotFoundError(name, pack) {
    throw Error(`Icon '${name}' is not registered in pack '${pack}'. Check icon name or consider switching icon pack.`);
}
function throwWrongPackTypeError(name, type, desiredType) {
    throw Error(`Pack '${name}' is not an '${desiredType}' Pack and its type is '${type}'`);
}
/**
 * This service allows to register multiple icon packs to use them later within `<nb-icon></nb-icon>` component.
 */
let NbIconLibraries = class NbIconLibraries {
    /**
     * This service allows to register multiple icon packs to use them later within `<nb-icon></nb-icon>` component.
     */
    constructor() {
        this.packs = new Map();
    }
    /**
     * Registers new Svg icon pack
     * @param {string} name
     * @param {NbIcon} icons
     * @param {NbIconPackParams} params
     */
    registerSvgPack(name, icons, params = {}) {
        this.packs.set(name, {
            name,
            icons: new Map(Object.entries(icons)),
            params,
            type: NbIconPackType.SVG,
        });
    }
    /**
     * Registers new font pack
     * @param {string} name
     * @param {NbIconPackParams} params
     */
    registerFontPack(name, params = {}) {
        this.packs.set(name, {
            name,
            params,
            icons: new Map(),
            type: NbIconPackType.FONT,
        });
    }
    /**
     * Returns pack by name
     * @param {string} name
     */
    getPack(name) {
        return this.packs.get(name);
    }
    /**
     * Sets pack as a default
     * @param {string} name
     */
    setDefaultPack(name) {
        if (!this.packs.has(name)) {
            throwPackNotFoundError(name);
        }
        this.defaultPack = this.packs.get(name);
    }
    /**
     * Returns Svg icon
     * @param {string} name
     * @param {string} pack
     *
     * @returns NbIconDefinition
     */
    getSvgIcon(name, pack) {
        const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
        if (iconsPack.type !== NbIconPackType.SVG) {
            throwWrongPackTypeError(iconsPack.name, iconsPack.type, 'SVG');
        }
        const icon = this.getIconFromPack(name, iconsPack);
        return {
            name,
            pack: iconsPack.name,
            type: NbIconPackType.SVG,
            icon: this.createSvgIcon(name, icon, iconsPack.params),
        };
    }
    /**
     * Returns Font icon
     * @param {string} name
     * @param {string} pack
     *
     * @returns NbIconDefinition
     */
    getFontIcon(name, pack) {
        const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
        if (iconsPack.type !== NbIconPackType.FONT) {
            throwWrongPackTypeError(iconsPack.name, iconsPack.type, 'Font');
        }
        const icon = this.getIconFromPack(name, iconsPack, false);
        return {
            name,
            pack: iconsPack.name,
            type: NbIconPackType.FONT,
            icon: this.createFontIcon(name, icon ? icon : '', iconsPack.params),
        };
    }
    /**
     * Returns an icon
     * @param {string} name
     * @param {string} pack
     *
     * @returns NbIconDefinition
     */
    getIcon(name, pack) {
        const iconsPack = pack ? this.getPackOrThrow(pack) : this.getDefaultPackOrThrow();
        if (iconsPack.type === NbIconPackType.SVG) {
            return this.getSvgIcon(name, pack);
        }
        return this.getFontIcon(name, pack);
    }
    createSvgIcon(name, content, params) {
        return content instanceof NbSvgIcon ? content : new NbSvgIcon(name, content, params);
    }
    createFontIcon(name, content, params) {
        return content instanceof NbFontIcon ? content : new NbFontIcon(name, content, params);
    }
    getPackOrThrow(name) {
        const pack = this.packs.get(name);
        if (!pack) {
            throwPackNotFoundError(name);
        }
        return pack;
    }
    getDefaultPackOrThrow() {
        if (!this.defaultPack) {
            throwNoDefaultPackError();
        }
        return this.defaultPack;
    }
    getIconFromPack(name, pack, shouldThrow = true) {
        if (shouldThrow && !pack.icons.has(name)) {
            throwIconNotFoundError(name, pack.name);
        }
        return pack.icons.get(name);
    }
};
NbIconLibraries.ɵfac = function NbIconLibraries_Factory(t) { return new (t || NbIconLibraries)(); };
NbIconLibraries.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbIconLibraries, factory: NbIconLibraries.ɵfac, providedIn: 'root' });
NbIconLibraries.ngInjectableDef = ɵɵdefineInjectable({ factory: function NbIconLibraries_Factory() { return new NbIconLibraries(); }, token: NbIconLibraries, providedIn: "root" });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$25 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$15 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Icon component. Allows to render both `svg` and `font` icons.
 * Starting from Nebular 4.0 uses [Eva Icons](https://akveo.github.io/eva-icons/) pack by default.
 *
 * Basic icon example:
 * @stacked-example(Showcase, icon/icon-showcase.component)
 *
 * Icon configuration:
 *
 * ```html
 * <nb-icon icon="star"></nb-icon>
 * ```
 * ### Installation
 *
 * By default Nebular comes without any pre-installed icon pack.
 * Starting with Nebular 4.0.0 we ship separate package called `@nebular/eva-icons`
 * which integrates SVG [Eva Icons](https://akveo.github.io/eva-icons/) pack to Nebular. To add it to your
 * project run:
 * ```sh
 * npm i @nebular/eva-icons
 * ```
 * This command will install Eva Icons pack. Then register `NbEvaIconsModule` into your app module:
 * ```ts
 * import { NbEvaIconsModule } from '@nebular/eva-icons';
 *
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbEvaIconsModule,
 *   ],
 * })
 * export class AppModule { }
 * ```
 * Last thing, import `NbIconModule` to your feature module where you need to show an icon:
 * ```ts
 * import { NbIconModule } from '@nebular/theme';
 *
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbIconModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Icon can be colored using `status` input:
 * ```html
 * <nb-icon icon="star" status="warning"></nb-icon>
 * ```
 *
 * Colored icons:
 * @stacked-example(Colored Icons, icon/icon-colors.component)
 *
 * In case you need to specify an icon from a specific icon pack, this could be done using `pack` input property:
 * ```html
 * <nb-icon icon="star" pack="font-awesome"></nb-icon>
 * ```
 * Additional icon settings (if available by the icon pack) could be passed using `options` input:
 *
 * ```html
 * <nb-icon icon="star" [options]="{ animation: { type: 'zoom' } }"></nb-icon>
 * ```
 *
 * @styles
 *
 * icon-font-size:
 * icon-line-height:
 * icon-width:
 * icon-height:
 * icon-svg-vertical-align:
 * icon-basic-color:
 * icon-primary-color:
 * icon-info-color:
 * icon-success-color:
 * icon-warning-color:
 * icon-danger-color:
 * icon-control-color:
 */
let NbIconComponent = class NbIconComponent {
    constructor(sanitizer, iconLibrary, el, renderer) {
        this.sanitizer = sanitizer;
        this.iconLibrary = iconLibrary;
        this.el = el;
        this.renderer = renderer;
        this.prevClasses = [];
        this.html = '';
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    /**
     * Sets all icon configurable properties via config object.
     * If passed value is a string set icon name.
     * @docs-private
     */
    get config() {
        return this._config;
    }
    set config(value) {
        if (!value) {
            return;
        }
        this._config = value;
        if (typeof value === 'string') {
            this.icon = value;
        }
        else {
            this.icon = value.icon;
            this.pack = value.pack;
            this.status = value.status;
            this.options = value.options;
        }
    }
    ngOnInit() {
        this.iconDef = this.renderIcon(this.icon, this.pack, this.options);
    }
    ngOnChanges() {
        if (this.iconDef) {
            this.iconDef = this.renderIcon(this.icon, this.pack, this.options);
        }
    }
    renderIcon(name, pack, options) {
        const iconDefinition = this.iconLibrary.getIcon(name, pack);
        const content = iconDefinition.icon.getContent(options);
        if (content) {
            this.html = this.sanitizer.bypassSecurityTrustHtml(content);
        }
        this.assignClasses(iconDefinition.icon.getClasses(options));
        return iconDefinition;
    }
    assignClasses(classes) {
        this.prevClasses.forEach((className) => {
            this.renderer.removeClass(this.el.nativeElement, className);
        });
        classes.forEach((className) => {
            this.renderer.addClass(this.el.nativeElement, className);
        });
        this.prevClasses = classes;
    }
};
NbIconComponent.ɵfac = function NbIconComponent_Factory(t) { return new (t || NbIconComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer), ɵngcc0.ɵɵdirectiveInject(NbIconLibraries), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NbIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbIconComponent, selectors: [["nb-icon"]], hostVars: 15, hostBindings: function NbIconComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("innerHtml", ctx.html, ɵngcc0.ɵɵsanitizeHtml);
        ɵngcc0.ɵɵclassProp("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    } }, inputs: { config: "config", icon: "icon", pack: "pack", status: "status", options: "options" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], decls: 0, vars: 0, template: function NbIconComponent_Template(rf, ctx) { }, styles: ["[_nghost-%COMP%]{display:inline-block}"], changeDetection: 0 });
__decorate$25([
    HostBinding('innerHtml'),
    __metadata$15("design:type", Object)
], NbIconComponent.prototype, "html", void 0);
__decorate$25([
    HostBinding('class.status-primary'),
    __metadata$15("design:type", Object),
    __metadata$15("design:paramtypes", [])
], NbIconComponent.prototype, "primary", null);
__decorate$25([
    HostBinding('class.status-info'),
    __metadata$15("design:type", Object),
    __metadata$15("design:paramtypes", [])
], NbIconComponent.prototype, "info", null);
__decorate$25([
    HostBinding('class.status-success'),
    __metadata$15("design:type", Object),
    __metadata$15("design:paramtypes", [])
], NbIconComponent.prototype, "success", null);
__decorate$25([
    HostBinding('class.status-warning'),
    __metadata$15("design:type", Object),
    __metadata$15("design:paramtypes", [])
], NbIconComponent.prototype, "warning", null);
__decorate$25([
    HostBinding('class.status-danger'),
    __metadata$15("design:type", Object),
    __metadata$15("design:paramtypes", [])
], NbIconComponent.prototype, "danger", null);
__decorate$25([
    HostBinding('class.status-basic'),
    __metadata$15("design:type", Object),
    __metadata$15("design:paramtypes", [])
], NbIconComponent.prototype, "basic", null);
__decorate$25([
    HostBinding('class.status-control'),
    __metadata$15("design:type", Object),
    __metadata$15("design:paramtypes", [])
], NbIconComponent.prototype, "control", null);
__decorate$25([
    Input(),
    __metadata$15("design:type", String)
], NbIconComponent.prototype, "icon", void 0);
__decorate$25([
    Input(),
    __metadata$15("design:type", String)
], NbIconComponent.prototype, "pack", void 0);
__decorate$25([
    Input(),
    __metadata$15("design:type", Object)
], NbIconComponent.prototype, "options", void 0);
__decorate$25([
    Input(),
    __metadata$15("design:type", String)
], NbIconComponent.prototype, "status", void 0);
__decorate$25([
    Input(),
    __metadata$15("design:type", Object),
    __metadata$15("design:paramtypes", [Object])
], NbIconComponent.prototype, "config", null);
NbIconComponent = __decorate$25([ __metadata$15("design:paramtypes", [DomSanitizer,
        NbIconLibraries,
        ElementRef,
        Renderer2])
], NbIconComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$24 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$14 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbIconModule = class NbIconModule {
    constructor(iconsLibrary) {
        this.iconsLibrary = iconsLibrary;
        this.essentialsPackName = 'nebular-essentials';
        // in case of consequent calls we don't need to enable `nebular-essentials` pack again
        if (this.iconsLibrary.getPack(this.essentialsPackName)) {
            return;
        }
        // tslint:disable:max-line-length
        this.iconsLibrary.registerSvgPack(this.essentialsPackName, {
            'chevron-down-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-down"><rect width="24" height="24" opacity="0"/><path d="M12 15.5a1 1 0 0 1-.71-.29l-4-4a1 1 0 1 1 1.42-1.42L12 13.1l3.3-3.18a1 1 0 1 1 1.38 1.44l-4 3.86a1 1 0 0 1-.68.28z"/></g></g></svg>',
            'chevron-up-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-up"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M16 14.5a1 1 0 0 1-.71-.29L12 10.9l-3.3 3.18a1 1 0 0 1-1.41 0 1 1 0 0 1 0-1.42l4-3.86a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1 0 1.42 1 1 0 0 1-.69.28z"/></g></g></svg>',
            'chevron-left-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-left"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M13.36 17a1 1 0 0 1-.72-.31l-3.86-4a1 1 0 0 1 0-1.4l4-4a1 1 0 1 1 1.42 1.42L10.9 12l3.18 3.3a1 1 0 0 1 0 1.41 1 1 0 0 1-.72.29z"/></g></g></svg>',
            'chevron-right-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="chevron-right"><rect width="24" height="24" transform="rotate(-90 12 12)" opacity="0"/><path d="M10.5 17a1 1 0 0 1-.71-.29 1 1 0 0 1 0-1.42L13.1 12 9.92 8.69a1 1 0 0 1 0-1.41 1 1 0 0 1 1.42 0l3.86 4a1 1 0 0 1 0 1.4l-4 4a1 1 0 0 1-.7.32z"/></g></g></svg>',
            'checkmark-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="checkmark"><rect width="24" height="24" opacity="0"/><path d="M9.86 18a1 1 0 0 1-.73-.32l-4.86-5.17a1 1 0 1 1 1.46-1.37l4.12 4.39 8.41-9.2a1 1 0 1 1 1.48 1.34l-9.14 10a1 1 0 0 1-.73.33z"/></g></g></svg>',
            'paper-plane-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="paper-plane"><rect width="24" height="24" opacity="0"/><path d="M21 4a1.31 1.31 0 0 0-.06-.27v-.09a1 1 0 0 0-.2-.3 1 1 0 0 0-.29-.19h-.09a.86.86 0 0 0-.31-.15H20a1 1 0 0 0-.3 0l-18 6a1 1 0 0 0 0 1.9l8.53 2.84 2.84 8.53a1 1 0 0 0 1.9 0l6-18A1 1 0 0 0 21 4zm-4.7 2.29l-5.57 5.57L5.16 10zM14 18.84l-1.86-5.57 5.57-5.57z"/></g></g></svg>',
            'file-text-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="file-text"><rect width="24" height="24" opacity="0"/><path d="M15 16H9a1 1 0 0 0 0 2h6a1 1 0 0 0 0-2z"/><path d="M9 14h3a1 1 0 0 0 0-2H9a1 1 0 0 0 0 2z"/><path d="M19.74 8.33l-5.44-6a1 1 0 0 0-.74-.33h-7A2.53 2.53 0 0 0 4 4.5v15A2.53 2.53 0 0 0 6.56 22h10.88A2.53 2.53 0 0 0 20 19.5V9a1 1 0 0 0-.26-.67zM14 5l2.74 3h-2a.79.79 0 0 1-.74-.85zm3.44 15H6.56a.53.53 0 0 1-.56-.5v-15a.53.53 0 0 1 .56-.5H12v3.15A2.79 2.79 0 0 0 14.71 10H18v9.5a.53.53 0 0 1-.56.5z"/></g></g></svg>',
            'alert-triangle-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="alert-triangle"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M22.56 16.3L14.89 3.58a3.43 3.43 0 0 0-5.78 0L1.44 16.3a3 3 0 0 0-.05 3A3.37 3.37 0 0 0 4.33 21h15.34a3.37 3.37 0 0 0 2.94-1.66 3 3 0 0 0-.05-3.04zm-1.7 2.05a1.31 1.31 0 0 1-1.19.65H4.33a1.31 1.31 0 0 1-1.19-.65 1 1 0 0 1 0-1l7.68-12.73a1.48 1.48 0 0 1 2.36 0l7.67 12.72a1 1 0 0 1 .01 1.01z"/><circle cx="12" cy="16" r="1"/><path d="M12 8a1 1 0 0 0-1 1v4a1 1 0 0 0 2 0V9a1 1 0 0 0-1-1z"/></g></g></svg>',
            'question-mark-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="question-mark"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M17 9A5 5 0 0 0 7 9a1 1 0 0 0 2 0 3 3 0 1 1 3 3 1 1 0 0 0-1 1v2a1 1 0 0 0 2 0v-1.1A5 5 0 0 0 17 9z"/><circle cx="12" cy="19" r="1"/></g></g></svg>',
            'email-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="email"><rect width="24" height="24" opacity="0"/><path d="M19 4H5a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3zm-.67 2L12 10.75 5.67 6zM19 18H5a1 1 0 0 1-1-1V7.25l7.4 5.55a1 1 0 0 0 .6.2 1 1 0 0 0 .6-.2L20 7.25V17a1 1 0 0 1-1 1z"/></g></g></svg>',
            'flash-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="flash"><rect width="24" height="24" opacity="0"/><path d="M11.11 23a1 1 0 0 1-.34-.06 1 1 0 0 1-.65-1.05l.77-7.09H5a1 1 0 0 1-.83-1.56l7.89-11.8a1 1 0 0 1 1.17-.38 1 1 0 0 1 .65 1l-.77 7.14H19a1 1 0 0 1 .83 1.56l-7.89 11.8a1 1 0 0 1-.83.44zM6.87 12.8H12a1 1 0 0 1 .74.33 1 1 0 0 1 .25.78l-.45 4.15 4.59-6.86H12a1 1 0 0 1-1-1.11l.45-4.15z"/></g></g></svg>',
            'search-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="search"><rect width="24" height="24" opacity="0"/><path d="M20.71 19.29l-3.4-3.39A7.92 7.92 0 0 0 19 11a8 8 0 1 0-8 8 7.92 7.92 0 0 0 4.9-1.69l3.39 3.4a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42zM5 11a6 6 0 1 1 6 6 6 6 0 0 1-6-6z"/></g></g></svg>',
            'close-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="close"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M13.41 12l4.3-4.29a1 1 0 1 0-1.42-1.42L12 10.59l-4.29-4.3a1 1 0 0 0-1.42 1.42l4.3 4.29-4.3 4.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0l4.29-4.3 4.29 4.3a1 1 0 0 0 1.42 0 1 1 0 0 0 0-1.42z"/></g></g></svg>',
            'collapse-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="collapse"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 9h-2.58l3.29-3.29a1 1 0 1 0-1.42-1.42L15 7.57V5a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2z"/><path d="M10 13H5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L9 16.42V19a1 1 0 0 0 1 1 1 1 0 0 0 1-1v-5a1 1 0 0 0-1-1z"/></g></g></svg>',
            'expand-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="expand"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M20 5a1 1 0 0 0-1-1h-5a1 1 0 0 0 0 2h2.57l-3.28 3.29a1 1 0 0 0 0 1.42 1 1 0 0 0 1.42 0L18 7.42V10a1 1 0 0 0 1 1 1 1 0 0 0 1-1z"/><path d="M10.71 13.29a1 1 0 0 0-1.42 0L6 16.57V14a1 1 0 0 0-1-1 1 1 0 0 0-1 1v5a1 1 0 0 0 1 1h5a1 1 0 0 0 0-2H7.42l3.29-3.29a1 1 0 0 0 0-1.42z"/></g></g></svg>',
            'minus-outline': '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" width="100%" height="100%" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="minus"><rect width="24" height="24" transform="rotate(180 12 12)" opacity="0"/><path d="M19 13H5a1 1 0 0 1 0-2h14a1 1 0 0 1 0 2z"/></g></g></svg>',
            'minus-bold-outline': '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 2" width="100%" height="100%"><defs><rect id="nb-mbo" y="3" width="8" height="2" rx="1"/></defs><use xlink:href="#nb-mbo" transform="translate(0 -3)" fill-rule="evenodd"/></svg>',
            'checkmark-bold-outline': '<svg xmlns:xlink="http://www.w3.org/1999/xlink" fill="currentColor" viewBox="0 0 8 7" width="100%" height="100%"><defs><path id="nb-cbo" d="M6.039 1.43a1.11 1.11 0 0 1 1.517-.228c.483.342.588.998.234 1.466L4.431 7.1a1 1 0 0 1-1.492.115L.317 4.677a1.023 1.023 0 0 1 .002-1.483 1.113 1.113 0 0 1 1.535.002l1.641 1.59L6.04 1.428z"/></defs><use xlink:href="#nb-cbo" transform="translate(0 -1)" fill-rule="evenodd"/></svg>',
            'arrow-back': '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><g data-name="Layer 2"><g data-name="arrow-back"><rect width="24" height="24" transform="rotate(90 12 12)" opacity="0"/><path d="M19 11H7.14l3.63-4.36a1 1 0 1 0-1.54-1.28l-5 6a1.19 1.19 0 0 0-.09.15c0 .05 0 .08-.07.13A1 1 0 0 0 4 12a1 1 0 0 0 .07.36c0 .05 0 .08.07.13a1.19 1.19 0 0 0 .09.15l5 6A1 1 0 0 0 10 19a1 1 0 0 0 .64-.23 1 1 0 0 0 .13-1.41L7.14 13H19a1 1 0 0 0 0-2z"/></g></g></svg>',
        });
        // tslint:enable:max-line-length
    }
};
NbIconModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbIconModule });
NbIconModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbIconModule_Factory(t) { return new (t || NbIconModule)(ɵngcc0.ɵɵinject(NbIconLibraries)); }, imports: [[
            CommonModule,
        ]] });
NbIconModule = __decorate$24([ __metadata$14("design:paramtypes", [NbIconLibraries])
], NbIconModule);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$27 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$16 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Component intended to be used within the `<nb-card>` component.
 * It adds styles for a preset header section.
 *
 * @styles
 *
 * card-header-text-color:
 * card-header-text-font-family:
 * card-header-text-font-size:
 * card-header-text-font-weight:
 * card-header-text-line-height:
 * card-header-basic-background-color:
 * card-header-basic-text-color:
 * card-header-primary-background-color:
 * card-header-primary-text-color:
 * card-header-info-background-color:
 * card-header-info-text-color:
 * card-header-success-background-color:
 * card-header-success-text-color:
 * card-header-warning-background-color:
 * card-header-warning-text-color:
 * card-header-danger-background-color:
 * card-header-danger-text-color:
 * card-header-control-background-color:
 * card-header-control-text-color:
 */
let NbCardHeaderComponent = class NbCardHeaderComponent {
};
NbCardHeaderComponent.ɵfac = function NbCardHeaderComponent_Factory(t) { return new (t || NbCardHeaderComponent)(); };
NbCardHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardHeaderComponent, selectors: [["nb-card-header"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbCardHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/**
 * Component intended to be used within  the `<nb-card>` component.
 * Adds styles for a preset body section.
 */
let NbCardBodyComponent = class NbCardBodyComponent {
};
NbCardBodyComponent.ɵfac = function NbCardBodyComponent_Factory(t) { return new (t || NbCardBodyComponent)(); };
NbCardBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardBodyComponent, selectors: [["nb-card-body"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbCardBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/**
 * Component intended to be used within  the `<nb-card>` component.
 * Adds styles for a preset footer section.
 */
let NbCardFooterComponent = class NbCardFooterComponent {
};
NbCardFooterComponent.ɵfac = function NbCardFooterComponent_Factory(t) { return new (t || NbCardFooterComponent)(); };
NbCardFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardFooterComponent, selectors: [["nb-card-footer"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbCardFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/**
 * Basic content container component.
 *
 * Basic card example:
 * @stacked-example(Showcase, card/card-showcase.component)
 *
 * Basic card configuration:
 *
 * ```html
 * <nb-card>
 *   <nb-card-body>
 *     Card
 *   </nb-card-body>
 * </nb-card>
 * ```
 *
 * ### Installation
 *
 * Import `NbCardModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCardModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Card with header and footer:
 * @stacked-example(With Header & Footer, card/card-full.component)
 *
 * Most of the time main card content goes to `nb-card-body`,
 * so it is styled and aligned in accordance with the header and footer.
 * In case you need a higher level of control, you can pass contend directly to `nb-card`,
 * so `nb-card-body` styling will not be applied.
 *
 * Consider an example with `nb-list` component:
 * @stacked-example(Card with list, card/card-without-body.component)
 *
 * Colored cards could be simply configured by providing a `status` property:
 * @stacked-example(Colored Card, card/card-colors.component)
 *
 * It is also possible to assign an `accent` property for a slight card highlight
 * as well as combine it with `status`:
 * @stacked-example(Accent Card, card/card-accents.component)
 *
 * Cards of smaller sizes could be combined and put on the same row with a bigger card so they have the same heights.
 * @stacked-example(Card sizes combinations, card/card-sizes-combinations.component)
 *
 * @additional-example(Multiple Sizes, card/card-sizes.component)
 *
 * @styles
 *
 * card-background-color:
 * card-text-color:
 * card-text-font-family:
 * card-text-font-size:
 * card-text-font-weight:
 * card-text-line-height:
 * card-border-width:
 * card-border-style:
 * card-border-color:
 * card-border-radius:
 * card-padding:
 * card-shadow:
 * card-divider-color:
 * card-divider-style:
 * card-divider-width:
 * card-height-tiny:
 * card-height-small:
 * card-height-medium:
 * card-height-large:
 * card-height-giant:
 * card-margin-bottom:
 * card-scrollbar-color:
 * card-scrollbar-background-color:
 * card-scrollbar-width:
 */
let NbCardComponent = class NbCardComponent {
    /**
     * Basic content container component.
     *
     * Basic card example:
     * @stacked-example(Showcase, card/card-showcase.component)
     *
     * Basic card configuration:
     *
     * ```html
     * <nb-card>
     *   <nb-card-body>
     *     Card
     *   </nb-card-body>
     * </nb-card>
     * ```
     *
     * ### Installation
     *
     * Import `NbCardModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbCardModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * Card with header and footer:
     * @stacked-example(With Header & Footer, card/card-full.component)
     *
     * Most of the time main card content goes to `nb-card-body`,
     * so it is styled and aligned in accordance with the header and footer.
     * In case you need a higher level of control, you can pass contend directly to `nb-card`,
     * so `nb-card-body` styling will not be applied.
     *
     * Consider an example with `nb-list` component:
     * @stacked-example(Card with list, card/card-without-body.component)
     *
     * Colored cards could be simply configured by providing a `status` property:
     * @stacked-example(Colored Card, card/card-colors.component)
     *
     * It is also possible to assign an `accent` property for a slight card highlight
     * as well as combine it with `status`:
     * @stacked-example(Accent Card, card/card-accents.component)
     *
     * Cards of smaller sizes could be combined and put on the same row with a bigger card so they have the same heights.
     * @stacked-example(Card sizes combinations, card/card-sizes-combinations.component)
     *
     * @additional-example(Multiple Sizes, card/card-sizes.component)
     *
     * @styles
     *
     * card-background-color:
     * card-text-color:
     * card-text-font-family:
     * card-text-font-size:
     * card-text-font-weight:
     * card-text-line-height:
     * card-border-width:
     * card-border-style:
     * card-border-color:
     * card-border-radius:
     * card-padding:
     * card-shadow:
     * card-divider-color:
     * card-divider-style:
     * card-divider-width:
     * card-height-tiny:
     * card-height-small:
     * card-height-medium:
     * card-height-large:
     * card-height-giant:
     * card-margin-bottom:
     * card-scrollbar-color:
     * card-scrollbar-background-color:
     * card-scrollbar-width:
     */
    constructor() {
        this._size = '';
        /**
         * Card status:
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`
         */
        this.status = '';
        /**
         * Card accent (color of the top border):
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`
         */
        this.accent = '';
    }
    /**
     * Card size, available sizes:
     * tiny, small, medium, large, giant
     */
    get size() {
        return this._size;
    }
    set size(value) {
        this._size = value;
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get hasAccent() {
        return this.accent;
    }
    get primaryAccent() {
        return this.accent === 'primary';
    }
    get infoAccent() {
        return this.accent === 'info';
    }
    get successAccent() {
        return this.accent === 'success';
    }
    get warningAccent() {
        return this.accent === 'warning';
    }
    get dangerAccent() {
        return this.accent === 'danger';
    }
    get basicAccent() {
        return this.accent === 'basic';
    }
    get controlAccent() {
        return this.accent === 'control';
    }
};
NbCardComponent.ɵfac = function NbCardComponent_Factory(t) { return new (t || NbCardComponent)(); };
NbCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardComponent, selectors: [["nb-card"]], hostVars: 40, hostBindings: function NbCardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent", ctx.hasAccent)("accent-primary", ctx.primaryAccent)("accent-info", ctx.infoAccent)("accent-success", ctx.successAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent);
    } }, inputs: { status: "status", accent: "accent", size: "size" }, ngContentSelectors: _c2, decls: 4, vars: 0, template: function NbCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c1);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
        ɵngcc0.ɵɵprojection(2, 2);
        ɵngcc0.ɵɵprojection(3, 3);
    } }, styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column}"] });
__decorate$27([
    Input(),
    __metadata$16("design:type", String),
    __metadata$16("design:paramtypes", [String])
], NbCardComponent.prototype, "size", null);
__decorate$27([
    Input(),
    __metadata$16("design:type", String)
], NbCardComponent.prototype, "status", void 0);
__decorate$27([
    Input(),
    __metadata$16("design:type", String)
], NbCardComponent.prototype, "accent", void 0);
__decorate$27([
    HostBinding('class.size-tiny'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "tiny", null);
__decorate$27([
    HostBinding('class.size-small'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "small", null);
__decorate$27([
    HostBinding('class.size-medium'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "medium", null);
__decorate$27([
    HostBinding('class.size-large'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "large", null);
__decorate$27([
    HostBinding('class.size-giant'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "giant", null);
__decorate$27([
    HostBinding('class.status-primary'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "primary", null);
__decorate$27([
    HostBinding('class.status-info'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "info", null);
__decorate$27([
    HostBinding('class.status-success'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "success", null);
__decorate$27([
    HostBinding('class.status-warning'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "warning", null);
__decorate$27([
    HostBinding('class.status-danger'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "danger", null);
__decorate$27([
    HostBinding('class.status-basic'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "basic", null);
__decorate$27([
    HostBinding('class.status-control'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "control", null);
__decorate$27([
    HostBinding('class.accent'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "hasAccent", null);
__decorate$27([
    HostBinding('class.accent-primary'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "primaryAccent", null);
__decorate$27([
    HostBinding('class.accent-info'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "infoAccent", null);
__decorate$27([
    HostBinding('class.accent-success'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "successAccent", null);
__decorate$27([
    HostBinding('class.accent-warning'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "warningAccent", null);
__decorate$27([
    HostBinding('class.accent-danger'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "dangerAccent", null);
__decorate$27([
    HostBinding('class.accent-basic'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "basicAccent", null);
__decorate$27([
    HostBinding('class.accent-control'),
    __metadata$16("design:type", Object),
    __metadata$16("design:paramtypes", [])
], NbCardComponent.prototype, "controlAccent", null);

var __decorate$28 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$17 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 *
 * Reveal card example:
 * @stacked-example(My example, reveal-card/reveal-card-showcase.component)
 *
 * As a content Reveal card accepts two instances of `nb-card` - for front and back sides.
 *
 * Basic reveal card configuration:
 *
 * ```html
 * <nb-reveal-card>
 *   <nb-card-front>
 *     <nb-card>
 *       <nb-card-body>
 *         Front
 *       </nb-card-body>
 *     </nb-card>
 *   </nb-card-front>
 *   <nb-card-back>
 *     <nb-card>
 *       <nb-card-body>
 *         Back
 *       </nb-card-body>
 *     </nb-card>
 *   </nb-card-back>
 * </nb-reveal-card>
 * ```
 *
 * ### Installation
 *
 * Import `NbCardModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCardModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Reveal Card with header and footer:
 * @stacked-example(With Header & Footer, reveal-card/reveal-card-full.component)
 *
 * Colored reveal-cards could be simply configured by providing a `status` property:
 * @stacked-example(Colored Card, reveal-card/reveal-card-colors.component)
 *
 * It is also possible to assign an `accent` property for a slight card highlight
 * as well as combine it with `status`:
 * @stacked-example(Accent Card, reveal-card/reveal-card-accents.component)
 *
 * @additional-example(Multiple Sizes, reveal-card/reveal-card-sizes.component)
 */
let NbRevealCardComponent = class NbRevealCardComponent {
    /**
     *
     * Reveal card example:
     * @stacked-example(My example, reveal-card/reveal-card-showcase.component)
     *
     * As a content Reveal card accepts two instances of `nb-card` - for front and back sides.
     *
     * Basic reveal card configuration:
     *
     * ```html
     * <nb-reveal-card>
     *   <nb-card-front>
     *     <nb-card>
     *       <nb-card-body>
     *         Front
     *       </nb-card-body>
     *     </nb-card>
     *   </nb-card-front>
     *   <nb-card-back>
     *     <nb-card>
     *       <nb-card-body>
     *         Back
     *       </nb-card-body>
     *     </nb-card>
     *   </nb-card-back>
     * </nb-reveal-card>
     * ```
     *
     * ### Installation
     *
     * Import `NbCardModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbCardModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * Reveal Card with header and footer:
     * @stacked-example(With Header & Footer, reveal-card/reveal-card-full.component)
     *
     * Colored reveal-cards could be simply configured by providing a `status` property:
     * @stacked-example(Colored Card, reveal-card/reveal-card-colors.component)
     *
     * It is also possible to assign an `accent` property for a slight card highlight
     * as well as combine it with `status`:
     * @stacked-example(Accent Card, reveal-card/reveal-card-accents.component)
     *
     * @additional-example(Multiple Sizes, reveal-card/reveal-card-sizes.component)
     */
    constructor() {
        /**
         * Reveal state
         * @type boolean
         */
        this.revealed = false;
        /**
         * Show/hide toggle button to be able to control toggle from your code
         * @type {boolean}
         */
        this.showToggleButton = true;
    }
    toggle() {
        this.revealed = !this.revealed;
    }
};
NbRevealCardComponent.ɵfac = function NbRevealCardComponent_Factory(t) { return new (t || NbRevealCardComponent)(); };
NbRevealCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRevealCardComponent, selectors: [["nb-reveal-card"]], hostVars: 2, hostBindings: function NbRevealCardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("revealed", ctx.revealed);
    } }, inputs: { revealed: "revealed", showToggleButton: "showToggleButton" }, ngContentSelectors: _c4, decls: 4, vars: 1, consts: [[1, "second-card-container"], ["class", "reveal-button", 3, "click", 4, "ngIf"], [1, "reveal-button", 3, "click"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"]], template: function NbRevealCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c3);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵprojection(2, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, NbRevealCardComponent_a_3_Template, 2, 0, "a", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToggleButton);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{display:block;position:relative;overflow:hidden}[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s 0.5s}[_nghost-%COMP%]     nb-card-front nb-card, [_nghost-%COMP%]     nb-card-back nb-card{box-shadow:none;margin:0}[_nghost-%COMP%]     nb-card-front{display:block;height:100%}[_nghost-%COMP%]     nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top 0.5s}[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform 0.3s}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]{top:0;transition:none}.revealed[_nghost-%COMP%]   .second-card-container[_ngcontent-%COMP%]     nb-card-back{top:0}.revealed[_nghost-%COMP%]   .reveal-button[_ngcontent-%COMP%]{transform:none}"] });
__decorate$28([
    Input(),
    HostBinding('class.revealed'),
    __metadata$17("design:type", Boolean)
], NbRevealCardComponent.prototype, "revealed", void 0);
__decorate$28([
    Input(),
    __metadata$17("design:type", Object)
], NbRevealCardComponent.prototype, "showToggleButton", void 0);

var __decorate$29 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$18 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 *
 * Flip card example:
 * @stacked-example(Showcase, flip-card/flip-card-showcase.component)
 *
 * As a content Flip card accepts two instances of `nb-card` - for front and back sides.
 *
 * Basic flip card configuration:
 *
 * ```html
 * <nb-flip-card>
 *   <nb-card-front>
 *     <nb-card>
 *       <nb-card-body>
 *         Front
 *       </nb-card-body>
 *     </nb-card>
 *   </nb-card-front>
 *   <nb-card-back>
 *     <nb-card>
 *       <nb-card-body>
 *         Back
 *       </nb-card-body>
 *     </nb-card>
 *   </nb-card-back>
 * </nb-flip-card>
 * ```
 *
 * ### Installation
 *
 * Import `NbCardModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCardModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Flip Card with header and footer:
 * @stacked-example(With Header & Footer, flip-card/flip-card-full.component.ts)
 *
 * Colored flip-cards could be simply configured by providing a `status` property:
 * @stacked-example(Colored Card, flip-card/flip-card-colors.component)
 *
 * It is also possible to assign an `accent` property for a slight card highlight
 * as well as combine it with `status`:
 * @stacked-example(Accent Card, flip-card/flip-card-accents.component)
 *
 * @additional-example(Multiple Sizes, flip-card/flip-card-sizes.component)
 *
 */
let NbFlipCardComponent = class NbFlipCardComponent {
    /**
     *
     * Flip card example:
     * @stacked-example(Showcase, flip-card/flip-card-showcase.component)
     *
     * As a content Flip card accepts two instances of `nb-card` - for front and back sides.
     *
     * Basic flip card configuration:
     *
     * ```html
     * <nb-flip-card>
     *   <nb-card-front>
     *     <nb-card>
     *       <nb-card-body>
     *         Front
     *       </nb-card-body>
     *     </nb-card>
     *   </nb-card-front>
     *   <nb-card-back>
     *     <nb-card>
     *       <nb-card-body>
     *         Back
     *       </nb-card-body>
     *     </nb-card>
     *   </nb-card-back>
     * </nb-flip-card>
     * ```
     *
     * ### Installation
     *
     * Import `NbCardModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbCardModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * Flip Card with header and footer:
     * @stacked-example(With Header & Footer, flip-card/flip-card-full.component.ts)
     *
     * Colored flip-cards could be simply configured by providing a `status` property:
     * @stacked-example(Colored Card, flip-card/flip-card-colors.component)
     *
     * It is also possible to assign an `accent` property for a slight card highlight
     * as well as combine it with `status`:
     * @stacked-example(Accent Card, flip-card/flip-card-accents.component)
     *
     * @additional-example(Multiple Sizes, flip-card/flip-card-sizes.component)
     *
     */
    constructor() {
        /**
         * Flip state
         * @type boolean
         */
        this.flipped = false;
        /**
         * Show/hide toggle button to be able to control toggle from your code
         * @type {boolean}
         */
        this.showToggleButton = true;
    }
    toggle() {
        this.flipped = !this.flipped;
    }
};
NbFlipCardComponent.ɵfac = function NbFlipCardComponent_Factory(t) { return new (t || NbFlipCardComponent)(); };
NbFlipCardComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbFlipCardComponent, selectors: [["nb-flip-card"]], hostVars: 2, hostBindings: function NbFlipCardComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("flipped", ctx.flipped);
    } }, inputs: { flipped: "flipped", showToggleButton: "showToggleButton" }, ngContentSelectors: _c4, decls: 7, vars: 2, consts: [[1, "flipcard-body"], [1, "front-container"], ["class", "flip-button", 3, "click", 4, "ngIf"], [1, "back-container"], [1, "flip-button", 3, "click"], ["icon", "chevron-left-outline", "pack", "nebular-essentials", "aria-hidden", "true"]], template: function NbFlipCardComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c3);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵtemplate(3, NbFlipCardComponent_a_3_Template, 2, 0, "a", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵprojection(5, 1);
        ɵngcc0.ɵɵtemplate(6, NbFlipCardComponent_a_6_Template, 2, 0, "a", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToggleButton);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToggleButton);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{display:block;perspective:1200px;position:relative}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]{transform:rotateY(-180deg)}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{opacity:0;transition:opacity 0s 0.25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{opacity:0;z-index:-1}.flipped[_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%], .flipped   [_nghost-%COMP%]   .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body[_ngcontent-%COMP%]{display:flex;transition:transform 0.5s;transform-style:preserve-3d}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{flex:1}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%], .flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]   .flip-button[_ngcontent-%COMP%]{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s 0.15s}.flipcard-body[_ngcontent-%COMP%]   .front-container[_ngcontent-%COMP%]{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s 0.2s}.flipcard-body[_ngcontent-%COMP%]   .back-container[_ngcontent-%COMP%]{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}"] });
__decorate$29([
    Input(),
    HostBinding('class.flipped'),
    __metadata$18("design:type", Boolean)
], NbFlipCardComponent.prototype, "flipped", void 0);
__decorate$29([
    Input(),
    __metadata$18("design:type", Object)
], NbFlipCardComponent.prototype, "showToggleButton", void 0);

var __decorate$30 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Component intended to be used within the `<nb-flip-card>` and `<nb-reveal-card>` components.
 *
 * Use it as a container for the front card.
 */
let NbCardFrontComponent = class NbCardFrontComponent {
};
NbCardFrontComponent.ɵfac = function NbCardFrontComponent_Factory(t) { return new (t || NbCardFrontComponent)(); };
NbCardFrontComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardFrontComponent, selectors: [["nb-card-front"]], ngContentSelectors: _c6, decls: 1, vars: 0, template: function NbCardFrontComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/**
 * Component intended to be used within the `<nb-flip-card>` and `<nb-reveal-card>` components.
 *
 * Use it as a container for the back card.
 */
let NbCardBackComponent = class NbCardBackComponent {
};
NbCardBackComponent.ɵfac = function NbCardBackComponent_Factory(t) { return new (t || NbCardBackComponent)(); };
NbCardBackComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCardBackComponent, selectors: [["nb-card-back"]], ngContentSelectors: _c6, decls: 1, vars: 0, template: function NbCardBackComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c5);
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$23 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const NB_CARD_COMPONENTS = [
    NbCardComponent,
    NbCardBodyComponent,
    NbCardFooterComponent,
    NbCardHeaderComponent,
    NbRevealCardComponent,
    NbFlipCardComponent,
    NbCardFrontComponent,
    NbCardBackComponent,
];
let NbCardModule = class NbCardModule {
};
NbCardModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCardModule });
NbCardModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbCardModule_Factory(t) { return new (t || NbCardModule)(); }, imports: [[
            NbSharedModule,
            NbIconModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var NbCalendarViewMode;
(function (NbCalendarViewMode) {
    NbCalendarViewMode["YEAR"] = "year";
    NbCalendarViewMode["MONTH"] = "month";
    NbCalendarViewMode["DATE"] = "date";
})(NbCalendarViewMode || (NbCalendarViewMode = {}));
var NbCalendarSize;
(function (NbCalendarSize) {
    NbCalendarSize["MEDIUM"] = "medium";
    NbCalendarSize["LARGE"] = "large";
})(NbCalendarSize || (NbCalendarSize = {}));

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
function convertToBoolProperty(val) {
    if (typeof val === 'string') {
        val = val.toLowerCase().trim();
        return (val === 'true' || val === '');
    }
    return !!val;
}

function firstChildNotComment(node) {
    const children = Array
        .from(node.childNodes)
        .filter((child) => child.nodeType !== Node.COMMENT_NODE);
    return children[0];
}
function lastChildNotComment(node) {
    const children = Array
        .from(node.childNodes)
        .filter((child) => child.nodeType !== Node.COMMENT_NODE);
    return children[children.length - 1];
}
/*
 * @breaking-change Remove @5.0.0
 */
function emptyStatusWarning(source) {
    console.warn(`${source}: Using empty string as a status is deprecated. Use \`basic\` instead.`);
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$32 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$19 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Calendar component provides a capability to choose a date.
 *
 * ```html
 * <nb-calendar [(date)]="date"></nb-calendar>
 * <nb-calendar [date]="date" (dateChange)="handleDateChange($event)"></nb-calendar>
 * ```
 *
 * Basic usage example
 * @stacked-example(Showcase, calendar/calendar-showcase.component)
 *
 * ### Installation
 *
 * Import `NbCalendarModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCalendarModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * If you want to select ranges you can use `NbCalendarRangeComponent`.
 *
 * ```html
 * <nb-calendar-range [(range)]="range"></nb-calendar-range>
 * <nb-calendar-range [range]="range" (rangeChange)="handleRangeChange($event)"></nb-calendar-range>
 * ```
 *
 * In order to use it, you have to import `NbCalendarRangeModule`.
 * @stacked-example(Range, calendar/calendar-range-showcase.component)
 *
 * The calendar component is supplied with a calendar header that contains navigate today button.
 * If you do not want to use it you can hide calendar header using `showHeader` property.
 * @stacked-example(Header, calendar/calendar-without-header.component)
 *
 * As you can see in the basic usage example calendar contains previous and next month days
 * which can be disabled using `boundingMonth` property.
 * @stacked-example(Bounding months, calendar/calendar-bounding-month.component)
 *
 * You can define starting view of the calendar by setting `startView` property.
 * Available values: year, month and date.
 * @stacked-example(Start view, calendar/calendar-start-view.component)
 *
 * You can use a larger version of the calendar by defining size property.
 * Available values: medium(which is default) and large.
 * @stacked-example(Size, calendar/calendar-size.component)
 *
 * Calendar supports min and max dates which disables values out of min-max range.
 * @stacked-example(Borders, calendar/calendar-min-max.component)
 *
 * Also, you can define custom filter property that should be predicate which receives
 * date and returns false if this date has to be disabled. In this example, we provide the filter
 * which disables weekdays.
 * @stacked-example(Filter, calendar/calendar-filter.component)
 *
 * Week numbers column could be enabled via `showWeekNumber` binding:
 * @stacked-example(Week number, calendar/calendar-week-number.component)
 *
 * If you need create custom cells you can easily provide custom components for
 * calendar. For examples if you want to show any average price under each date you can
 * just provide custom `dayCellComponent`. Custom cells for month and year can be provided
 * the same way, check API reference.
 * @stacked-example(Custom day cell, calendar/calendar-custom-day-cell-showcase.component)
 *
 * @styles
 *
 * calendar-width:
 * calendar-body-height:
 * calendar-border-radius:
 * calendar-text-color:
 * calendar-text-font-family:
 * calendar-text-font-size:
 * calendar-text-font-weight:
 * calendar-text-line-height:
 * calendar-header-text-color:
 * calendar-header-text-font-family:
 * calendar-header-title-text-font-size:
 * calendar-header-title-text-font-weight:
 * calendar-header-title-text-line-height:
 * calendar-header-sub-title-text-font-size:
 * calendar-header-sub-title-text-font-weight:
 * calendar-header-sub-title-text-line-height:
 * calendar-navigation-button-width:
 * calendar-cell-inactive-text-color:
 * calendar-cell-in-range-background-color:
 * calendar-cell-disabled-background-color:
 * calendar-cell-disabled-text-color:
 * calendar-cell-selected-background-color:
 * calendar-cell-selected-text-color:
 * calendar-cell-selected-text-font-size:
 * calendar-cell-selected-text-font-weight:
 * calendar-cell-selected-text-line-height:
 * calendar-cell-hover-background-color:
 * calendar-cell-hover-text-color:
 * calendar-cell-hover-text-font-size:
 * calendar-cell-hover-text-font-weight:
 * calendar-cell-hover-text-line-height:
 * calendar-cell-active-background-color:
 * calendar-cell-active-text-color:
 * calendar-cell-active-text-font-size:
 * calendar-cell-active-text-font-weight:
 * calendar-cell-active-text-line-height:
 * calendar-cell-today-background-color:
 * calendar-cell-today-text-color:
 * calendar-cell-today-text-font-size:
 * calendar-cell-today-text-font-weight:
 * calendar-cell-today-text-line-height:
 * calendar-day-cell-width:
 * calendar-day-cell-height:
 * calendar-month-cell-width:
 * calendar-month-cell-height:
 * calendar-year-cell-width:
 * calendar-year-cell-height:
 * calendar-weekday-background:
 * calendar-weekday-divider-color:
 * calendar-weekday-text-color:
 * calendar-weekday-text-font-size:
 * calendar-weekday-text-font-weight:
 * calendar-weekday-text-line-height:
 * calendar-weekday-holiday-text-color:
 * calendar-weekday-height:
 * calendar-weekday-width:
 * calendar-weeknumber-background:
 * calendar-weeknumber-divider-color:
 * calendar-weeknumber-divider-width:
 * calendar-weeknumber-text-color:
 * calendar-weeknumber-text-font-size:
 * calendar-weeknumber-text-font-weight:
 * calendar-weeknumber-text-line-height:
 * calendar-weeknumber-height:
 * calendar-weeknumber-width:
 * calendar-large-width:
 * calendar-large-body-height:
 * calendar-day-cell-large-width:
 * calendar-day-cell-large-height:
 * calendar-weekday-large-height:
 * calendar-weekday-large-width:
 * calendar-month-cell-large-width:
 * calendar-month-cell-large-height:
 * calendar-year-cell-large-width:
 * calendar-year-cell-large-height:
 * */
let NbCalendarComponent = class NbCalendarComponent {
    /**
     * Calendar component provides a capability to choose a date.
     *
     * ```html
     * <nb-calendar [(date)]="date"></nb-calendar>
     * <nb-calendar [date]="date" (dateChange)="handleDateChange($event)"></nb-calendar>
     * ```
     *
     * Basic usage example
     * @stacked-example(Showcase, calendar/calendar-showcase.component)
     *
     * ### Installation
     *
     * Import `NbCalendarModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbCalendarModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * If you want to select ranges you can use `NbCalendarRangeComponent`.
     *
     * ```html
     * <nb-calendar-range [(range)]="range"></nb-calendar-range>
     * <nb-calendar-range [range]="range" (rangeChange)="handleRangeChange($event)"></nb-calendar-range>
     * ```
     *
     * In order to use it, you have to import `NbCalendarRangeModule`.
     * @stacked-example(Range, calendar/calendar-range-showcase.component)
     *
     * The calendar component is supplied with a calendar header that contains navigate today button.
     * If you do not want to use it you can hide calendar header using `showHeader` property.
     * @stacked-example(Header, calendar/calendar-without-header.component)
     *
     * As you can see in the basic usage example calendar contains previous and next month days
     * which can be disabled using `boundingMonth` property.
     * @stacked-example(Bounding months, calendar/calendar-bounding-month.component)
     *
     * You can define starting view of the calendar by setting `startView` property.
     * Available values: year, month and date.
     * @stacked-example(Start view, calendar/calendar-start-view.component)
     *
     * You can use a larger version of the calendar by defining size property.
     * Available values: medium(which is default) and large.
     * @stacked-example(Size, calendar/calendar-size.component)
     *
     * Calendar supports min and max dates which disables values out of min-max range.
     * @stacked-example(Borders, calendar/calendar-min-max.component)
     *
     * Also, you can define custom filter property that should be predicate which receives
     * date and returns false if this date has to be disabled. In this example, we provide the filter
     * which disables weekdays.
     * @stacked-example(Filter, calendar/calendar-filter.component)
     *
     * Week numbers column could be enabled via `showWeekNumber` binding:
     * @stacked-example(Week number, calendar/calendar-week-number.component)
     *
     * If you need create custom cells you can easily provide custom components for
     * calendar. For examples if you want to show any average price under each date you can
     * just provide custom `dayCellComponent`. Custom cells for month and year can be provided
     * the same way, check API reference.
     * @stacked-example(Custom day cell, calendar/calendar-custom-day-cell-showcase.component)
     *
     * @styles
     *
     * calendar-width:
     * calendar-body-height:
     * calendar-border-radius:
     * calendar-text-color:
     * calendar-text-font-family:
     * calendar-text-font-size:
     * calendar-text-font-weight:
     * calendar-text-line-height:
     * calendar-header-text-color:
     * calendar-header-text-font-family:
     * calendar-header-title-text-font-size:
     * calendar-header-title-text-font-weight:
     * calendar-header-title-text-line-height:
     * calendar-header-sub-title-text-font-size:
     * calendar-header-sub-title-text-font-weight:
     * calendar-header-sub-title-text-line-height:
     * calendar-navigation-button-width:
     * calendar-cell-inactive-text-color:
     * calendar-cell-in-range-background-color:
     * calendar-cell-disabled-background-color:
     * calendar-cell-disabled-text-color:
     * calendar-cell-selected-background-color:
     * calendar-cell-selected-text-color:
     * calendar-cell-selected-text-font-size:
     * calendar-cell-selected-text-font-weight:
     * calendar-cell-selected-text-line-height:
     * calendar-cell-hover-background-color:
     * calendar-cell-hover-text-color:
     * calendar-cell-hover-text-font-size:
     * calendar-cell-hover-text-font-weight:
     * calendar-cell-hover-text-line-height:
     * calendar-cell-active-background-color:
     * calendar-cell-active-text-color:
     * calendar-cell-active-text-font-size:
     * calendar-cell-active-text-font-weight:
     * calendar-cell-active-text-line-height:
     * calendar-cell-today-background-color:
     * calendar-cell-today-text-color:
     * calendar-cell-today-text-font-size:
     * calendar-cell-today-text-font-weight:
     * calendar-cell-today-text-line-height:
     * calendar-day-cell-width:
     * calendar-day-cell-height:
     * calendar-month-cell-width:
     * calendar-month-cell-height:
     * calendar-year-cell-width:
     * calendar-year-cell-height:
     * calendar-weekday-background:
     * calendar-weekday-divider-color:
     * calendar-weekday-text-color:
     * calendar-weekday-text-font-size:
     * calendar-weekday-text-font-weight:
     * calendar-weekday-text-line-height:
     * calendar-weekday-holiday-text-color:
     * calendar-weekday-height:
     * calendar-weekday-width:
     * calendar-weeknumber-background:
     * calendar-weeknumber-divider-color:
     * calendar-weeknumber-divider-width:
     * calendar-weeknumber-text-color:
     * calendar-weeknumber-text-font-size:
     * calendar-weeknumber-text-font-weight:
     * calendar-weeknumber-text-line-height:
     * calendar-weeknumber-height:
     * calendar-weeknumber-width:
     * calendar-large-width:
     * calendar-large-body-height:
     * calendar-day-cell-large-width:
     * calendar-day-cell-large-height:
     * calendar-weekday-large-height:
     * calendar-weekday-large-width:
     * calendar-month-cell-large-width:
     * calendar-month-cell-large-height:
     * calendar-year-cell-large-width:
     * calendar-year-cell-large-height:
     * */
    constructor() {
        /**
         * Defines if we should render previous and next months
         * in the current month view.
         * */
        this.boundingMonth = true;
        /**
         * Defines starting view for calendar.
         * */
        this.startView = NbCalendarViewMode.DATE;
        /**
         * Size of the calendar and entire components.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        /**
         * Determines should we show calendars header or not.
         * */
        this.showHeader = true;
        this._showWeekNumber = false;
        /**
         * Sets symbol used as a header for week numbers column
         * */
        this.weekNumberSymbol = '#';
        /**
         * Emits date when selected.
         * */
        this.dateChange = new EventEmitter();
    }
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber() {
        return this._showWeekNumber;
    }
    set showWeekNumber(value) {
        this._showWeekNumber = convertToBoolProperty(value);
    }
};
NbCalendarComponent.ɵfac = function NbCalendarComponent_Factory(t) { return new (t || NbCalendarComponent)(); };
NbCalendarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarComponent, selectors: [["nb-calendar"]], inputs: { boundingMonth: "boundingMonth", startView: "startView", size: "size", showHeader: "showHeader", weekNumberSymbol: "weekNumberSymbol", showWeekNumber: "showWeekNumber", min: "min", max: "max", filter: "filter", dayCellComponent: "dayCellComponent", monthCellComponent: "monthCellComponent", yearCellComponent: "yearCellComponent", visibleDate: "visibleDate", date: "date" }, outputs: { dateChange: "dateChange" }, decls: 1, vars: 14, consts: [[3, "boundingMonth", "startView", "date", "min", "max", "filter", "dayCellComponent", "monthCellComponent", "yearCellComponent", "size", "visibleDate", "showHeader", "showWeekNumber", "weekNumberSymbol", "dateChange"]], template: function NbCalendarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-base-calendar", 0);
        ɵngcc0.ɵɵlistener("dateChange", function NbCalendarComponent_Template_nb_base_calendar_dateChange_0_listener($event) { return ctx.dateChange.emit($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("boundingMonth", ctx.boundingMonth)("startView", ctx.startView)("date", ctx.date)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("size", ctx.size)("visibleDate", ctx.visibleDate)("showHeader", ctx.showHeader)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol);
    } }, directives: function () { return [NbBaseCalendarComponent]; }, encapsulation: 2 });
__decorate$32([
    Input(),
    __metadata$19("design:type", Boolean)
], NbCalendarComponent.prototype, "boundingMonth", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", String)
], NbCalendarComponent.prototype, "startView", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", Object)
], NbCalendarComponent.prototype, "min", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", Object)
], NbCalendarComponent.prototype, "max", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", Function)
], NbCalendarComponent.prototype, "filter", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", Type)
], NbCalendarComponent.prototype, "dayCellComponent", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", Type)
], NbCalendarComponent.prototype, "monthCellComponent", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", Type)
], NbCalendarComponent.prototype, "yearCellComponent", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", String)
], NbCalendarComponent.prototype, "size", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", Object)
], NbCalendarComponent.prototype, "visibleDate", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", Boolean)
], NbCalendarComponent.prototype, "showHeader", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", Object)
], NbCalendarComponent.prototype, "date", void 0);
__decorate$32([
    Input(),
    __metadata$19("design:type", Boolean),
    __metadata$19("design:paramtypes", [Boolean])
], NbCalendarComponent.prototype, "showWeekNumber", null);
__decorate$32([
    Input(),
    __metadata$19("design:type", String)
], NbCalendarComponent.prototype, "weekNumberSymbol", void 0);
__decorate$32([
    Output(),
    __metadata$19("design:type", EventEmitter)
], NbCalendarComponent.prototype, "dateChange", void 0);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$36 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$20 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Basic button component.
 *
 * Default button size is `medium` and status color is `primary`:
 * @stacked-example(Button Showcase, button/button-showcase.component)
 *
 * ```html
 * <button nbButton></button>
 * ```
 * ### Installation
 *
 * Import `NbButtonModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbButtonModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Buttons are available in multiple colors using `status` property:
 * @stacked-example(Button Colors, button/button-colors.component.html)
 *
 * There are three button sizes:
 *
 * @stacked-example(Button Sizes, button/button-sizes.component.html)
 *
 * And two additional style types - `outline`:
 *
 * @stacked-example(Outline Buttons, button/button-outline.component.html)
 *
 * and `hero`:
 *
 * @stacked-example(Button Hero, button/button-hero.component.html)
 *
 * Buttons available in different shapes, which could be combined with the other properties:
 * @stacked-example(Button Shapes, button/button-shapes.component)
 *
 * `nbButton` could be applied to the following selectors - `button`, `input[type="button"]`, `input[type="submit"]`
 * and `a`:
 * @stacked-example(Button Elements, button/button-types.component.html)
 *
 * Button can be made `fullWidth`:
 * @stacked-example(Full Width Button, button/button-full-width.component.html)
 *
 * Icon can be placed inside of a button as a child element:
 * @stacked-example(Icon Button, button/button-icon.component.html)
 *
 * @additional-example(Interactive example, button/button-interactive.component)
 *
 * @styles
 *
 * button-cursor:
 * button-outline-width:
 * button-outline-color:
 * button-text-font-family:
 * button-text-font-weight:
 * button-disabled-cursor:
 * button-tiny-text-font-size:
 * button-tiny-text-line-height:
 * button-small-text-font-size:
 * button-small-text-line-height:
 * button-medium-text-font-size:
 * button-medium-text-line-height:
 * button-large-text-font-size:
 * button-large-text-line-height:
 * button-giant-text-font-size:
 * button-giant-text-line-height:
 * button-rectangle-border-radius:
 * button-semi-round-border-radius:
 * button-round-border-radius:
 * button-filled-border-style:
 * button-filled-border-width:
 * button-filled-text-transform:
 * button-filled-tiny-padding:
 * button-filled-small-padding:
 * button-filled-medium-padding:
 * button-filled-large-padding:
 * button-filled-giant-padding:
 * button-filled-basic-background-color:
 * button-filled-basic-border-color:
 * button-filled-basic-text-color:
 * button-filled-basic-focus-background-color:
 * button-filled-basic-focus-border-color:
 * button-filled-basic-hover-background-color:
 * button-filled-basic-hover-border-color:
 * button-filled-basic-active-background-color:
 * button-filled-basic-active-border-color:
 * button-filled-basic-disabled-background-color:
 * button-filled-basic-disabled-border-color:
 * button-filled-basic-disabled-text-color:
 * button-filled-primary-background-color:
 * button-filled-primary-border-color:
 * button-filled-primary-text-color:
 * button-filled-primary-focus-background-color:
 * button-filled-primary-focus-border-color:
 * button-filled-primary-hover-background-color:
 * button-filled-primary-hover-border-color:
 * button-filled-primary-active-background-color:
 * button-filled-primary-active-border-color:
 * button-filled-primary-disabled-background-color:
 * button-filled-primary-disabled-border-color:
 * button-filled-primary-disabled-text-color:
 * button-filled-success-background-color:
 * button-filled-success-border-color:
 * button-filled-success-text-color:
 * button-filled-success-focus-background-color:
 * button-filled-success-focus-border-color:
 * button-filled-success-hover-background-color:
 * button-filled-success-hover-border-color:
 * button-filled-success-active-background-color:
 * button-filled-success-active-border-color:
 * button-filled-success-disabled-background-color:
 * button-filled-success-disabled-border-color:
 * button-filled-success-disabled-text-color:
 * button-filled-info-background-color:
 * button-filled-info-border-color:
 * button-filled-info-text-color:
 * button-filled-info-focus-background-color:
 * button-filled-info-focus-border-color:
 * button-filled-info-hover-background-color:
 * button-filled-info-hover-border-color:
 * button-filled-info-active-background-color:
 * button-filled-info-active-border-color:
 * button-filled-info-disabled-background-color:
 * button-filled-info-disabled-border-color:
 * button-filled-info-disabled-text-color:
 * button-filled-warning-background-color:
 * button-filled-warning-border-color:
 * button-filled-warning-text-color:
 * button-filled-warning-focus-background-color:
 * button-filled-warning-focus-border-color:
 * button-filled-warning-hover-background-color:
 * button-filled-warning-hover-border-color:
 * button-filled-warning-active-background-color:
 * button-filled-warning-active-border-color:
 * button-filled-warning-disabled-background-color:
 * button-filled-warning-disabled-border-color:
 * button-filled-warning-disabled-text-color:
 * button-filled-danger-background-color:
 * button-filled-danger-border-color:
 * button-filled-danger-text-color:
 * button-filled-danger-focus-background-color:
 * button-filled-danger-focus-border-color:
 * button-filled-danger-hover-background-color:
 * button-filled-danger-hover-border-color:
 * button-filled-danger-active-background-color:
 * button-filled-danger-active-border-color:
 * button-filled-danger-disabled-background-color:
 * button-filled-danger-disabled-border-color:
 * button-filled-danger-disabled-text-color:
 * button-filled-control-background-color:
 * button-filled-control-border-color:
 * button-filled-control-text-color:
 * button-filled-control-focus-background-color:
 * button-filled-control-focus-border-color:
 * button-filled-control-hover-background-color:
 * button-filled-control-hover-border-color:
 * button-filled-control-active-background-color:
 * button-filled-control-active-border-color:
 * button-filled-control-disabled-background-color:
 * button-filled-control-disabled-border-color:
 * button-filled-control-disabled-text-color:
 * button-outline-border-style:
 * button-outline-border-width:
 * button-outline-text-transform:
 * button-outline-tiny-padding:
 * button-outline-small-padding:
 * button-outline-medium-padding:
 * button-outline-large-padding:
 * button-outline-giant-padding:
 * button-outline-basic-background-color:
 * button-outline-basic-border-color:
 * button-outline-basic-text-color:
 * button-outline-basic-focus-background-color:
 * button-outline-basic-focus-border-color:
 * button-outline-basic-focus-text-color:
 * button-outline-basic-hover-background-color:
 * button-outline-basic-hover-border-color:
 * button-outline-basic-hover-text-color:
 * button-outline-basic-active-background-color:
 * button-outline-basic-active-border-color:
 * button-outline-basic-active-text-color:
 * button-outline-basic-disabled-background-color:
 * button-outline-basic-disabled-border-color:
 * button-outline-basic-disabled-text-color:
 * button-outline-primary-background-color:
 * button-outline-primary-border-color:
 * button-outline-primary-text-color:
 * button-outline-primary-focus-background-color:
 * button-outline-primary-focus-border-color:
 * button-outline-primary-focus-text-color:
 * button-outline-primary-hover-background-color:
 * button-outline-primary-hover-border-color:
 * button-outline-primary-hover-text-color:
 * button-outline-primary-active-background-color:
 * button-outline-primary-active-border-color:
 * button-outline-primary-active-text-color:
 * button-outline-primary-disabled-background-color:
 * button-outline-primary-disabled-border-color:
 * button-outline-primary-disabled-text-color:
 * button-outline-success-background-color:
 * button-outline-success-border-color:
 * button-outline-success-text-color:
 * button-outline-success-focus-background-color:
 * button-outline-success-focus-border-color:
 * button-outline-success-focus-text-color:
 * button-outline-success-hover-background-color:
 * button-outline-success-hover-border-color:
 * button-outline-success-hover-text-color:
 * button-outline-success-active-background-color:
 * button-outline-success-active-border-color:
 * button-outline-success-active-text-color:
 * button-outline-success-disabled-background-color:
 * button-outline-success-disabled-border-color:
 * button-outline-success-disabled-text-color:
 * button-outline-info-background-color:
 * button-outline-info-border-color:
 * button-outline-info-text-color:
 * button-outline-info-focus-background-color:
 * button-outline-info-focus-border-color:
 * button-outline-info-focus-text-color:
 * button-outline-info-hover-background-color:
 * button-outline-info-hover-border-color:
 * button-outline-info-hover-text-color:
 * button-outline-info-active-background-color:
 * button-outline-info-active-border-color:
 * button-outline-info-active-text-color:
 * button-outline-info-disabled-background-color:
 * button-outline-info-disabled-border-color:
 * button-outline-info-disabled-text-color:
 * button-outline-warning-background-color:
 * button-outline-warning-border-color:
 * button-outline-warning-text-color:
 * button-outline-warning-focus-background-color:
 * button-outline-warning-focus-border-color:
 * button-outline-warning-focus-text-color:
 * button-outline-warning-hover-background-color:
 * button-outline-warning-hover-border-color:
 * button-outline-warning-hover-text-color:
 * button-outline-warning-active-background-color:
 * button-outline-warning-active-border-color:
 * button-outline-warning-active-text-color:
 * button-outline-warning-disabled-background-color:
 * button-outline-warning-disabled-border-color:
 * button-outline-warning-disabled-text-color:
 * button-outline-danger-background-color:
 * button-outline-danger-border-color:
 * button-outline-danger-text-color:
 * button-outline-danger-focus-background-color:
 * button-outline-danger-focus-border-color:
 * button-outline-danger-focus-text-color:
 * button-outline-danger-hover-background-color:
 * button-outline-danger-hover-border-color:
 * button-outline-danger-hover-text-color:
 * button-outline-danger-active-background-color:
 * button-outline-danger-active-border-color:
 * button-outline-danger-active-text-color:
 * button-outline-danger-disabled-background-color:
 * button-outline-danger-disabled-border-color:
 * button-outline-danger-disabled-text-color:
 * button-outline-control-background-color:
 * button-outline-control-border-color:
 * button-outline-control-text-color:
 * button-outline-control-focus-background-color:
 * button-outline-control-focus-border-color:
 * button-outline-control-focus-text-color:
 * button-outline-control-hover-background-color:
 * button-outline-control-hover-border-color:
 * button-outline-control-hover-text-color:
 * button-outline-control-active-background-color:
 * button-outline-control-active-border-color:
 * button-outline-control-active-text-color:
 * button-outline-control-disabled-background-color:
 * button-outline-control-disabled-border-color:
 * button-outline-control-disabled-text-color:
 * button-ghost-background-color:
 * button-ghost-border-color:
 * button-ghost-border-style:
 * button-ghost-border-width:
 * button-ghost-text-transform:
 * button-ghost-tiny-padding:
 * button-ghost-small-padding:
 * button-ghost-medium-padding:
 * button-ghost-large-padding:
 * button-ghost-giant-padding:
 * button-ghost-basic-text-color:
 * button-ghost-basic-focus-background-color:
 * button-ghost-basic-focus-border-color:
 * button-ghost-basic-focus-text-color:
 * button-ghost-basic-hover-background-color:
 * button-ghost-basic-hover-border-color:
 * button-ghost-basic-hover-text-color:
 * button-ghost-basic-active-background-color:
 * button-ghost-basic-active-border-color:
 * button-ghost-basic-active-text-color:
 * button-ghost-basic-disabled-background-color:
 * button-ghost-basic-disabled-border-color:
 * button-ghost-basic-disabled-text-color:
 * button-ghost-primary-text-color:
 * button-ghost-primary-focus-background-color:
 * button-ghost-primary-focus-border-color:
 * button-ghost-primary-focus-text-color:
 * button-ghost-primary-hover-background-color:
 * button-ghost-primary-hover-border-color:
 * button-ghost-primary-hover-text-color:
 * button-ghost-primary-active-background-color:
 * button-ghost-primary-active-border-color:
 * button-ghost-primary-active-text-color:
 * button-ghost-primary-disabled-background-color:
 * button-ghost-primary-disabled-border-color:
 * button-ghost-primary-disabled-text-color:
 * button-ghost-success-text-color:
 * button-ghost-success-focus-background-color:
 * button-ghost-success-focus-border-color:
 * button-ghost-success-focus-text-color:
 * button-ghost-success-hover-background-color:
 * button-ghost-success-hover-border-color:
 * button-ghost-success-hover-text-color:
 * button-ghost-success-active-background-color:
 * button-ghost-success-active-border-color:
 * button-ghost-success-active-text-color:
 * button-ghost-success-disabled-background-color:
 * button-ghost-success-disabled-border-color:
 * button-ghost-success-disabled-text-color:
 * button-ghost-info-text-color:
 * button-ghost-info-focus-background-color:
 * button-ghost-info-focus-border-color:
 * button-ghost-info-focus-text-color:
 * button-ghost-info-hover-background-color:
 * button-ghost-info-hover-border-color:
 * button-ghost-info-hover-text-color:
 * button-ghost-info-active-background-color:
 * button-ghost-info-active-border-color:
 * button-ghost-info-active-text-color:
 * button-ghost-info-disabled-background-color:
 * button-ghost-info-disabled-border-color:
 * button-ghost-info-disabled-text-color:
 * button-ghost-warning-text-color:
 * button-ghost-warning-focus-background-color:
 * button-ghost-warning-focus-border-color:
 * button-ghost-warning-focus-text-color:
 * button-ghost-warning-hover-background-color:
 * button-ghost-warning-hover-border-color:
 * button-ghost-warning-hover-text-color:
 * button-ghost-warning-active-background-color:
 * button-ghost-warning-active-border-color:
 * button-ghost-warning-active-text-color:
 * button-ghost-warning-disabled-background-color:
 * button-ghost-warning-disabled-border-color:
 * button-ghost-warning-disabled-text-color:
 * button-ghost-danger-text-color:
 * button-ghost-danger-focus-background-color:
 * button-ghost-danger-focus-border-color:
 * button-ghost-danger-focus-text-color:
 * button-ghost-danger-hover-background-color:
 * button-ghost-danger-hover-border-color:
 * button-ghost-danger-hover-text-color:
 * button-ghost-danger-active-background-color:
 * button-ghost-danger-active-border-color:
 * button-ghost-danger-active-text-color:
 * button-ghost-danger-disabled-background-color:
 * button-ghost-danger-disabled-border-color:
 * button-ghost-danger-disabled-text-color:
 * button-ghost-control-text-color:
 * button-ghost-control-focus-background-color:
 * button-ghost-control-focus-border-color:
 * button-ghost-control-focus-text-color:
 * button-ghost-control-hover-background-color:
 * button-ghost-control-hover-border-color:
 * button-ghost-control-hover-text-color:
 * button-ghost-control-active-background-color:
 * button-ghost-control-active-border-color:
 * button-ghost-control-active-text-color:
 * button-ghost-control-disabled-background-color:
 * button-ghost-control-disabled-border-color:
 * button-ghost-control-disabled-text-color:
 * button-hero-border-color:
 * button-hero-border-style:
 * button-hero-border-width:
 * button-hero-text-transform:
 * button-hero-tiny-padding:
 * button-hero-small-padding:
 * button-hero-medium-padding:
 * button-hero-large-padding:
 * button-hero-giant-padding:
 * button-hero-shadow:
 * button-hero-text-shadow:
 * button-hero-bevel-size:
 * button-hero-glow-size:
 * button-hero-outline-color:
 * button-hero-outline-width:
 * button-hero-basic-text-color:
 * button-hero-basic-bevel-color:
 * button-hero-basic-glow-color:
 * button-hero-basic-left-background-color:
 * button-hero-basic-right-background-color:
 * button-hero-basic-focus-left-background-color:
 * button-hero-basic-focus-right-background-color:
 * button-hero-basic-hover-left-background-color:
 * button-hero-basic-hover-right-background-color:
 * button-hero-basic-active-left-background-color:
 * button-hero-basic-active-right-background-color:
 * button-hero-basic-disabled-background-color:
 * button-hero-basic-disabled-text-color:
 * button-hero-primary-text-color:
 * button-hero-primary-bevel-color:
 * button-hero-primary-glow-color:
 * button-hero-primary-left-background-color:
 * button-hero-primary-right-background-color:
 * button-hero-primary-focus-left-background-color:
 * button-hero-primary-focus-right-background-color:
 * button-hero-primary-hover-left-background-color:
 * button-hero-primary-hover-right-background-color:
 * button-hero-primary-active-left-background-color:
 * button-hero-primary-active-right-background-color:
 * button-hero-primary-disabled-background-color:
 * button-hero-primary-disabled-text-color:
 * button-hero-success-text-color:
 * button-hero-success-bevel-color:
 * button-hero-success-glow-color:
 * button-hero-success-left-background-color:
 * button-hero-success-right-background-color:
 * button-hero-success-focus-left-background-color:
 * button-hero-success-focus-right-background-color:
 * button-hero-success-hover-left-background-color:
 * button-hero-success-hover-right-background-color:
 * button-hero-success-active-left-background-color:
 * button-hero-success-active-right-background-color:
 * button-hero-success-disabled-background-color:
 * button-hero-success-disabled-text-color:
 * button-hero-info-text-color:
 * button-hero-info-bevel-color:
 * button-hero-info-glow-color:
 * button-hero-info-left-background-color:
 * button-hero-info-right-background-color:
 * button-hero-info-focus-left-background-color:
 * button-hero-info-focus-right-background-color:
 * button-hero-info-hover-left-background-color:
 * button-hero-info-hover-right-background-color:
 * button-hero-info-active-left-background-color:
 * button-hero-info-active-right-background-color:
 * button-hero-info-disabled-background-color:
 * button-hero-info-disabled-text-color:
 * button-hero-warning-text-color:
 * button-hero-warning-bevel-color:
 * button-hero-warning-glow-color:
 * button-hero-warning-left-background-color:
 * button-hero-warning-right-background-color:
 * button-hero-warning-focus-left-background-color:
 * button-hero-warning-focus-right-background-color:
 * button-hero-warning-hover-left-background-color:
 * button-hero-warning-hover-right-background-color:
 * button-hero-warning-active-left-background-color:
 * button-hero-warning-active-right-background-color:
 * button-hero-warning-disabled-background-color:
 * button-hero-warning-disabled-text-color:
 * button-hero-danger-text-color:
 * button-hero-danger-bevel-color:
 * button-hero-danger-glow-color:
 * button-hero-danger-left-background-color:
 * button-hero-danger-right-background-color:
 * button-hero-danger-focus-left-background-color:
 * button-hero-danger-focus-right-background-color:
 * button-hero-danger-hover-left-background-color:
 * button-hero-danger-hover-right-background-color:
 * button-hero-danger-active-left-background-color:
 * button-hero-danger-active-right-background-color:
 * button-hero-danger-disabled-background-color:
 * button-hero-danger-disabled-text-color:
 * button-hero-control-text-color:
 * button-hero-control-bevel-color:
 * button-hero-control-glow-color:
 * button-hero-control-left-background-color:
 * button-hero-control-right-background-color:
 * button-hero-control-focus-left-background-color:
 * button-hero-control-focus-right-background-color:
 * button-hero-control-hover-left-background-color:
 * button-hero-control-hover-right-background-color:
 * button-hero-control-active-left-background-color:
 * button-hero-control-active-right-background-color:
 * button-hero-control-disabled-background-color:
 * button-hero-control-disabled-text-color:
 */
let NbButtonComponent = class NbButtonComponent {
    constructor(renderer, hostElement, cd) {
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.cd = cd;
        this.isInitialized = false;
        /**
         * Button size, available sizes:
         * `tiny`, `small`, `medium`, `large`, `giant`
         */
        this.size = 'medium';
        /**
         * Button status (adds specific styles):
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`.
         */
        this.status = 'primary';
        /**
         * Button shapes: `rectangle`, `round`, `semi-round`
         */
        this.shape = 'rectangle';
        /**
         * Button appearance: `filled`, `outline`, `ghost`, `hero`
         */
        this.appearance = 'filled';
        this._fullWidth = false;
        this._disabled = false;
    }
    /**
     * Sets `filled` appearance
     */
    get filled() {
        return this.appearance === 'filled';
    }
    set filled(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'filled';
        }
    }
    /**
     * Sets `outline` appearance
     */
    get outline() {
        return this.appearance === 'outline';
    }
    set outline(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'outline';
        }
    }
    /**
     * Sets `ghost` appearance
     */
    get ghost() {
        return this.appearance === 'ghost';
    }
    set ghost(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'ghost';
        }
    }
    /**
     * Sets `hero` appearance
     */
    get hero() {
        return this.appearance === 'hero';
    }
    set hero(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'hero';
        }
    }
    /**
     * If set element will fill its container
     */
    get fullWidth() {
        return this._fullWidth;
    }
    set fullWidth(value) {
        this._fullWidth = convertToBoolProperty(value);
    }
    /**
     * Disables the button
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
        this.renderer.setProperty(this.hostElement.nativeElement, 'disabled', this.disabled);
    }
    // issue #794
    get tabbable() {
        return this.disabled ? '-1' : '0';
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get rectangle() {
        return this.shape === 'rectangle';
    }
    get round() {
        return this.shape === 'round';
    }
    get semiRound() {
        return this.shape === 'semi-round';
    }
    get iconLeft() {
        const el = this.hostElement.nativeElement;
        const icon = this.iconElement;
        return !!(icon && firstChildNotComment(el) === icon);
    }
    get iconRight() {
        const el = this.hostElement.nativeElement;
        const icon = this.iconElement;
        return !!(icon && lastChildNotComment(el) === icon);
    }
    get transitions() {
        return this.isInitialized;
    }
    /**
     * @private
     * Keep this handler to partially support anchor disabling.
     * Unlike button, anchor doesn't have 'disabled' DOM property,
     * so handler will be called anyway. We preventing navigation and bubbling.
     * Disabling is partial due to click handlers precedence. Consider example:
     * <a nbButton [disabled]="true" (click)="clickHandler()">...</a>
     * 'clickHandler' will be called before our host listener below. We can't prevent
     * such handlers call.
     */
    onClick(event) {
        if (this.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
        }
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.isInitialized = true;
            this.cd.markForCheck();
        });
    }
    get iconElement() {
        const el = this.hostElement.nativeElement;
        return el.querySelector('nb-icon');
    }
};
NbButtonComponent.ɵfac = function NbButtonComponent_Factory(t) { return new (t || NbButtonComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbButtonComponent, selectors: [["button", "nbButton", ""], ["a", "nbButton", ""], ["input", "type", "button", "nbButton", ""], ["input", "type", "submit", "nbButton", ""]], hostVars: 50, hostBindings: function NbButtonComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbButtonComponent_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabled)("tabindex", ctx.tabbable);
        ɵngcc0.ɵɵclassProp("appearance-filled", ctx.filled)("appearance-outline", ctx.outline)("appearance-ghost", ctx.ghost)("appearance-hero", ctx.hero)("full-width", ctx.fullWidth)("btn-disabled", ctx.disabled)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound)("icon-start", ctx.iconLeft)("icon-end", ctx.iconRight)("transitions", ctx.transitions);
    } }, inputs: { size: "size", status: "status", shape: "shape", appearance: "appearance", filled: "filled", outline: "outline", ghost: "ghost", hero: "hero", fullWidth: "fullWidth", disabled: "disabled" }, attrs: _c7, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{appearance:none;text-align:center;text-decoration:none;display:inline-flex;align-items:center;justify-content:center;white-space:nowrap;vertical-align:middle;user-select:none}[_nghost-%COMP%]:hover, [_nghost-%COMP%]:focus{text-decoration:none}.full-width[_nghost-%COMP%]{width:100%}[_nghost-%COMP%]     nb-icon{vertical-align:top}[dir=ltr]   .icon-start[_nghost-%COMP%]:not(.icon-end)     nb-icon{margin-right:.75rem}[dir=rtl]   .icon-start[_nghost-%COMP%]:not(.icon-end)     nb-icon{margin-left:.75rem}[dir=ltr]   .icon-end[_nghost-%COMP%]:not(.icon-start)     nb-icon{margin-left:.75rem}[dir=rtl]   .icon-end[_nghost-%COMP%]:not(.icon-start)     nb-icon{margin-right:.75rem}.transitions[_nghost-%COMP%]{transition-duration:0.15s;transition-property:background-color,border-color,box-shadow,color;transition-timing-function:ease-in}"], changeDetection: 0 });
__decorate$36([
    Input(),
    __metadata$20("design:type", String)
], NbButtonComponent.prototype, "size", void 0);
__decorate$36([
    Input(),
    __metadata$20("design:type", String)
], NbButtonComponent.prototype, "status", void 0);
__decorate$36([
    Input(),
    __metadata$20("design:type", String)
], NbButtonComponent.prototype, "shape", void 0);
__decorate$36([
    Input(),
    __metadata$20("design:type", String)
], NbButtonComponent.prototype, "appearance", void 0);
__decorate$36([
    Input(),
    HostBinding('class.appearance-filled'),
    __metadata$20("design:type", Boolean),
    __metadata$20("design:paramtypes", [Boolean])
], NbButtonComponent.prototype, "filled", null);
__decorate$36([
    Input(),
    HostBinding('class.appearance-outline'),
    __metadata$20("design:type", Boolean),
    __metadata$20("design:paramtypes", [Boolean])
], NbButtonComponent.prototype, "outline", null);
__decorate$36([
    Input(),
    HostBinding('class.appearance-ghost'),
    __metadata$20("design:type", Boolean),
    __metadata$20("design:paramtypes", [Boolean])
], NbButtonComponent.prototype, "ghost", null);
__decorate$36([
    Input(),
    HostBinding('class.appearance-hero'),
    __metadata$20("design:type", Boolean),
    __metadata$20("design:paramtypes", [Boolean])
], NbButtonComponent.prototype, "hero", null);
__decorate$36([
    Input(),
    HostBinding('class.full-width'),
    __metadata$20("design:type", Boolean),
    __metadata$20("design:paramtypes", [Boolean])
], NbButtonComponent.prototype, "fullWidth", null);
__decorate$36([
    Input(),
    HostBinding('attr.aria-disabled'),
    HostBinding('class.btn-disabled'),
    __metadata$20("design:type", Boolean),
    __metadata$20("design:paramtypes", [Boolean])
], NbButtonComponent.prototype, "disabled", null);
__decorate$36([
    HostBinding('attr.tabindex'),
    __metadata$20("design:type", String),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "tabbable", null);
__decorate$36([
    HostBinding('class.size-tiny'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "tiny", null);
__decorate$36([
    HostBinding('class.size-small'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "small", null);
__decorate$36([
    HostBinding('class.size-medium'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "medium", null);
__decorate$36([
    HostBinding('class.size-large'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "large", null);
__decorate$36([
    HostBinding('class.size-giant'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "giant", null);
__decorate$36([
    HostBinding('class.status-primary'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "primary", null);
__decorate$36([
    HostBinding('class.status-info'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "info", null);
__decorate$36([
    HostBinding('class.status-success'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "success", null);
__decorate$36([
    HostBinding('class.status-warning'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "warning", null);
__decorate$36([
    HostBinding('class.status-danger'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "danger", null);
__decorate$36([
    HostBinding('class.status-basic'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "basic", null);
__decorate$36([
    HostBinding('class.status-control'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "control", null);
__decorate$36([
    HostBinding('class.shape-rectangle'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "rectangle", null);
__decorate$36([
    HostBinding('class.shape-round'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "round", null);
__decorate$36([
    HostBinding('class.shape-semi-round'),
    __metadata$20("design:type", Object),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "semiRound", null);
__decorate$36([
    HostBinding('class.icon-start'),
    __metadata$20("design:type", Boolean),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "iconLeft", null);
__decorate$36([
    HostBinding('class.icon-end'),
    __metadata$20("design:type", Boolean),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "iconRight", null);
__decorate$36([
    HostBinding('class.transitions'),
    __metadata$20("design:type", Boolean),
    __metadata$20("design:paramtypes", [])
], NbButtonComponent.prototype, "transitions", null);
__decorate$36([
    HostListener('click', ['$event']),
    __metadata$20("design:type", Function),
    __metadata$20("design:paramtypes", [Object]),
    __metadata$20("design:returntype", void 0)
], NbButtonComponent.prototype, "onClick", null);
NbButtonComponent = __decorate$36([ __metadata$20("design:paramtypes", [Renderer2,
        ElementRef,
        ChangeDetectorRef])
], NbButtonComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$35 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const NB_BUTTON_COMPONENTS = [
    NbButtonComponent,
];
let NbButtonModule = class NbButtonModule {
};
NbButtonModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbButtonModule });
NbButtonModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbButtonModule_Factory(t) { return new (t || NbButtonModule)(); }, imports: [[
            NbSharedModule,
        ]] });

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbDateService {
    constructor() {
        this.DAYS_IN_WEEK = 7;
    }
    setLocale(locale) {
        this.locale = locale;
    }
    /**
     * Checks if the date is between the start date and the end date.
     * */
    isBetween(date, start, end) {
        return this.compareDates(date, start) > 0 && this.compareDates(date, end) < 0;
    }
    ;
    /**
     * Checks is two dates have the same day.
     * */
    isSameDaySafe(date1, date2) {
        return date1 && date2 && this.isSameDay(date1, date2);
    }
    ;
    /**
     * Checks is two dates have the same month.
     * */
    isSameMonthSafe(date1, date2) {
        return date1 && date2 && this.isSameMonth(date1, date2);
    }
    /**
     * Checks is two dates have the same year.
     * */
    isSameYearSafe(date1, date2) {
        return date1 && date2 && this.isSameYear(date1, date2);
    }
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const batch = (target, batchSize, offset = 0) => {
    return target.reduce((res, item, index) => {
        const chunkIndex = Math.floor((index + offset) / batchSize);
        if (!res[chunkIndex]) {
            res[chunkIndex] = [];
        }
        res[chunkIndex].push(item);
        return res;
    }, []);
};
/**
 * returns array with numbers from zero to bound.
 * */
const range = (bound, producer = i => i) => {
    const arr = [];
    for (let i = 0; i < bound; i++) {
        arr.push(producer(i));
    }
    return arr;
};

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$37 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$21 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarMonthModelService = class NbCalendarMonthModelService {
    constructor(dateService) {
        this.dateService = dateService;
    }
    createDaysGrid(activeMonth, boundingMonth = true) {
        const weeks = this.createDates(activeMonth);
        return this.withBoundingMonths(weeks, activeMonth, boundingMonth);
    }
    createDates(activeMonth) {
        const days = this.createDateRangeForMonth(activeMonth);
        const startOfWeekDayDiff = this.getStartOfWeekDayDiff(activeMonth);
        return batch(days, this.dateService.DAYS_IN_WEEK, startOfWeekDayDiff);
    }
    withBoundingMonths(weeks, activeMonth, boundingMonth) {
        let withBoundingMonths = weeks;
        if (this.isShouldAddPrevBoundingMonth(withBoundingMonths)) {
            withBoundingMonths = this.addPrevBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
        }
        if (this.isShouldAddNextBoundingMonth(withBoundingMonths)) {
            withBoundingMonths = this.addNextBoundingMonth(withBoundingMonths, activeMonth, boundingMonth);
        }
        return withBoundingMonths;
    }
    addPrevBoundingMonth(weeks, activeMonth, boundingMonth) {
        const firstWeek = weeks.shift();
        const requiredItems = this.dateService.DAYS_IN_WEEK - firstWeek.length;
        firstWeek.unshift(...this.createPrevBoundingDays(activeMonth, boundingMonth, requiredItems));
        return [firstWeek, ...weeks];
    }
    addNextBoundingMonth(weeks, activeMonth, boundingMonth) {
        const lastWeek = weeks.pop();
        const requiredItems = this.dateService.DAYS_IN_WEEK - lastWeek.length;
        lastWeek.push(...this.createNextBoundingDays(activeMonth, boundingMonth, requiredItems));
        return [...weeks, lastWeek];
    }
    createPrevBoundingDays(activeMonth, boundingMonth, requiredItems) {
        const month = this.dateService.addMonth(activeMonth, -1);
        const daysInMonth = this.dateService.getNumberOfDaysInMonth(month);
        return this.createDateRangeForMonth(month)
            .slice(daysInMonth - requiredItems)
            .map(date => boundingMonth ? date : null);
    }
    createNextBoundingDays(activeMonth, boundingMonth, requiredItems) {
        const month = this.dateService.addMonth(activeMonth, 1);
        return this.createDateRangeForMonth(month)
            .slice(0, requiredItems)
            .map(date => boundingMonth ? date : null);
    }
    getStartOfWeekDayDiff(date) {
        const startOfMonth = this.dateService.getMonthStart(date);
        return this.getWeekStartDiff(startOfMonth);
    }
    getWeekStartDiff(date) {
        return (7 - this.dateService.getFirstDayOfWeek() + this.dateService.getDayOfWeek(date)) % 7;
    }
    isShouldAddPrevBoundingMonth(weeks) {
        return weeks[0].length < this.dateService.DAYS_IN_WEEK;
    }
    isShouldAddNextBoundingMonth(weeks) {
        return weeks[weeks.length - 1].length < this.dateService.DAYS_IN_WEEK;
    }
    createDateRangeForMonth(date) {
        const daysInMonth = this.dateService.getNumberOfDaysInMonth(date);
        return range(daysInMonth, i => {
            const year = this.dateService.getYear(date);
            const month = this.dateService.getMonth(date);
            return this.dateService.createDate(year, month, i + 1);
        });
    }
};
NbCalendarMonthModelService.ɵfac = function NbCalendarMonthModelService_Factory(t) { return new (t || NbCalendarMonthModelService)(ɵngcc0.ɵɵinject(NbDateService)); };
NbCalendarMonthModelService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbCalendarMonthModelService, factory: NbCalendarMonthModelService.ɵfac });
NbCalendarMonthModelService = __decorate$37([ __metadata$21("design:paramtypes", [NbDateService])
], NbCalendarMonthModelService);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$38 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$22 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarDayCellComponent = class NbCalendarDayCellComponent {
    constructor(dateService) {
        this.dateService = dateService;
        this.select = new EventEmitter(true);
    }
    get today() {
        return this.dateService.isSameDaySafe(this.date, this.dateService.today());
    }
    get boundingMonth() {
        return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
    }
    get selected() {
        return this.dateService.isSameDaySafe(this.date, this.selectedValue);
    }
    get empty() {
        return !this.date;
    }
    get disabled() {
        return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
    }
    get day() {
        return this.date && this.dateService.getDate(this.date);
    }
    onClick() {
        if (this.disabled || this.empty) {
            return;
        }
        this.select.emit(this.date);
    }
    smallerThanMin() {
        return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
    }
    greaterThanMax() {
        return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
    }
    dontFitFilter() {
        return this.date && this.filter && !this.filter(this.date);
    }
};
NbCalendarDayCellComponent.ɵfac = function NbCalendarDayCellComponent_Factory(t) { return new (t || NbCalendarDayCellComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarDayCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarDayCellComponent, selectors: [["nb-calendar-day-cell"]], hostAttrs: [1, "day-cell"], hostVars: 10, hostBindings: function NbCalendarDayCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbCalendarDayCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("today", ctx.today)("bounding-month", ctx.boundingMonth)("selected", ctx.selected)("empty", ctx.empty)("disabled", ctx.disabled);
    } }, inputs: { date: "date", selectedValue: "selectedValue", visibleDate: "visibleDate", min: "min", max: "max", filter: "filter" }, outputs: { select: "select" }, decls: 1, vars: 1, template: function NbCalendarDayCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate(ctx.day);
    } }, encapsulation: 2, changeDetection: 0 });
__decorate$38([
    Input(),
    __metadata$22("design:type", Object)
], NbCalendarDayCellComponent.prototype, "date", void 0);
__decorate$38([
    Input(),
    __metadata$22("design:type", Object)
], NbCalendarDayCellComponent.prototype, "selectedValue", void 0);
__decorate$38([
    Input(),
    __metadata$22("design:type", Object)
], NbCalendarDayCellComponent.prototype, "visibleDate", void 0);
__decorate$38([
    Input(),
    __metadata$22("design:type", Object)
], NbCalendarDayCellComponent.prototype, "min", void 0);
__decorate$38([
    Input(),
    __metadata$22("design:type", Object)
], NbCalendarDayCellComponent.prototype, "max", void 0);
__decorate$38([
    Input(),
    __metadata$22("design:type", Function)
], NbCalendarDayCellComponent.prototype, "filter", void 0);
__decorate$38([
    Output(),
    __metadata$22("design:type", EventEmitter)
], NbCalendarDayCellComponent.prototype, "select", void 0);
__decorate$38([
    HostBinding('class.today'),
    __metadata$22("design:type", Boolean),
    __metadata$22("design:paramtypes", [])
], NbCalendarDayCellComponent.prototype, "today", null);
__decorate$38([
    HostBinding('class.bounding-month'),
    __metadata$22("design:type", Boolean),
    __metadata$22("design:paramtypes", [])
], NbCalendarDayCellComponent.prototype, "boundingMonth", null);
__decorate$38([
    HostBinding('class.selected'),
    __metadata$22("design:type", Boolean),
    __metadata$22("design:paramtypes", [])
], NbCalendarDayCellComponent.prototype, "selected", null);
__decorate$38([
    HostBinding('class.empty'),
    __metadata$22("design:type", Boolean),
    __metadata$22("design:paramtypes", [])
], NbCalendarDayCellComponent.prototype, "empty", null);
__decorate$38([
    HostBinding('class.disabled'),
    __metadata$22("design:type", Boolean),
    __metadata$22("design:paramtypes", [])
], NbCalendarDayCellComponent.prototype, "disabled", null);
__decorate$38([
    HostListener('click'),
    __metadata$22("design:type", Function),
    __metadata$22("design:paramtypes", []),
    __metadata$22("design:returntype", void 0)
], NbCalendarDayCellComponent.prototype, "onClick", null);
NbCalendarDayCellComponent = __decorate$38([ __metadata$22("design:paramtypes", [NbDateService])
], NbCalendarDayCellComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$39 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$23 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Provides capability pick days.
 * */
let NbCalendarDayPickerComponent = class NbCalendarDayPickerComponent {
    constructor(monthModel) {
        this.monthModel = monthModel;
        /**
         * Defines if we should render previous and next months
         * in the current month view.
         * */
        this.boundingMonths = true;
        this.cellComponent = NbCalendarDayCellComponent;
        /**
         * Size of the component.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        this._showWeekNumber = false;
        /**
         * Fires newly selected date.
         * */
        this.dateChange = new EventEmitter();
    }
    /**
     * Custom day cell component. Have to implement `NbCalendarCell` interface.
     * */
    set setCellComponent(cellComponent) {
        if (cellComponent) {
            this.cellComponent = cellComponent;
        }
    }
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber() {
        return this._showWeekNumber;
    }
    set showWeekNumber(value) {
        this._showWeekNumber = convertToBoolProperty(value);
    }
    get medium() {
        return this.size === NbCalendarSize.MEDIUM;
    }
    get large() {
        return this.size === NbCalendarSize.LARGE;
    }
    ngOnChanges({ visibleDate }) {
        if (visibleDate) {
            this.weeks = this.monthModel.createDaysGrid(this.visibleDate, this.boundingMonths);
        }
    }
    onSelect(day) {
        this.dateChange.emit(day);
    }
};
NbCalendarDayPickerComponent.ɵfac = function NbCalendarDayPickerComponent_Factory(t) { return new (t || NbCalendarDayPickerComponent)(ɵngcc0.ɵɵdirectiveInject(NbCalendarMonthModelService)); };
NbCalendarDayPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarDayPickerComponent, selectors: [["nb-calendar-day-picker"]], hostVars: 4, hostBindings: function NbCalendarDayPickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("medium", ctx.medium)("large", ctx.large);
    } }, inputs: { boundingMonths: "boundingMonths", size: "size", setCellComponent: ["cellComponent", "setCellComponent"], showWeekNumber: "showWeekNumber", visibleDate: "visibleDate", min: "min", max: "max", filter: "filter", date: "date", weekNumberSymbol: "weekNumberSymbol" }, outputs: { dateChange: "dateChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], decls: 4, vars: 8, consts: [[3, "weeks", "size", "weekNumberSymbol", 4, "ngIf"], [1, "days-container"], [3, "data", "visibleDate", "selectedValue", "cellComponent", "min", "max", "filter", "select"], [3, "weeks", "size", "weekNumberSymbol"]], template: function NbCalendarDayPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbCalendarDayPickerComponent_nb_calendar_week_numbers_0_Template, 1, 3, "nb-calendar-week-numbers", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelement(2, "nb-calendar-days-names");
        ɵngcc0.ɵɵelementStart(3, "nb-calendar-picker", 2);
        ɵngcc0.ɵɵlistener("select", function NbCalendarDayPickerComponent_Template_nb_calendar_picker_select_3_listener($event) { return ctx.onSelect($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.showWeekNumber);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("data", ctx.weeks)("visibleDate", ctx.visibleDate)("selectedValue", ctx.date)("cellComponent", ctx.cellComponent)("min", ctx.min)("max", ctx.max)("filter", ctx.filter);
    } }, directives: function () { return [ɵngcc2.NgIf, NbCalendarDaysNamesComponent,
        NbCalendarPickerComponent,
        NbCalendarWeekNumberComponent]; }, styles: ["[_nghost-%COMP%]{display:flex}.days-container[_ngcontent-%COMP%]{width:100%}"], changeDetection: 0 });
__decorate$39([
    Input(),
    __metadata$23("design:type", Object)
], NbCalendarDayPickerComponent.prototype, "visibleDate", void 0);
__decorate$39([
    Input(),
    __metadata$23("design:type", Boolean)
], NbCalendarDayPickerComponent.prototype, "boundingMonths", void 0);
__decorate$39([
    Input(),
    __metadata$23("design:type", Object)
], NbCalendarDayPickerComponent.prototype, "min", void 0);
__decorate$39([
    Input(),
    __metadata$23("design:type", Object)
], NbCalendarDayPickerComponent.prototype, "max", void 0);
__decorate$39([
    Input(),
    __metadata$23("design:type", Function)
], NbCalendarDayPickerComponent.prototype, "filter", void 0);
__decorate$39([
    Input('cellComponent'),
    __metadata$23("design:type", Type),
    __metadata$23("design:paramtypes", [Type])
], NbCalendarDayPickerComponent.prototype, "setCellComponent", null);
__decorate$39([
    Input(),
    __metadata$23("design:type", String)
], NbCalendarDayPickerComponent.prototype, "size", void 0);
__decorate$39([
    Input(),
    __metadata$23("design:type", Object)
], NbCalendarDayPickerComponent.prototype, "date", void 0);
__decorate$39([
    Input(),
    __metadata$23("design:type", Boolean),
    __metadata$23("design:paramtypes", [Boolean])
], NbCalendarDayPickerComponent.prototype, "showWeekNumber", null);
__decorate$39([
    Input(),
    __metadata$23("design:type", String)
], NbCalendarDayPickerComponent.prototype, "weekNumberSymbol", void 0);
__decorate$39([
    Output(),
    __metadata$23("design:type", Object)
], NbCalendarDayPickerComponent.prototype, "dateChange", void 0);
__decorate$39([
    HostBinding('class.medium'),
    __metadata$23("design:type", Object),
    __metadata$23("design:paramtypes", [])
], NbCalendarDayPickerComponent.prototype, "medium", null);
__decorate$39([
    HostBinding('class.large'),
    __metadata$23("design:type", Object),
    __metadata$23("design:paramtypes", [])
], NbCalendarDayPickerComponent.prototype, "large", null);
NbCalendarDayPickerComponent = __decorate$39([ __metadata$23("design:paramtypes", [NbCalendarMonthModelService])
], NbCalendarDayPickerComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$40 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$24 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarDaysNamesComponent = class NbCalendarDaysNamesComponent {
    constructor(dateService) {
        this.dateService = dateService;
    }
    ngOnInit() {
        const days = this.createDaysNames();
        this.days = this.shiftStartOfWeek(days);
    }
    createDaysNames() {
        return this.dateService.getDayOfWeekNames()
            .map(this.markIfHoliday);
    }
    shiftStartOfWeek(days) {
        for (let i = 0; i < this.dateService.getFirstDayOfWeek(); i++) {
            days.push(days.shift());
        }
        return days;
    }
    markIfHoliday(name, i) {
        return { name, isHoliday: i % 6 === 0 };
    }
};
NbCalendarDaysNamesComponent.ɵfac = function NbCalendarDaysNamesComponent_Factory(t) { return new (t || NbCalendarDaysNamesComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarDaysNamesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarDaysNamesComponent, selectors: [["nb-calendar-days-names"]], decls: 1, vars: 1, consts: [["class", "day", 3, "holiday", 4, "ngFor", "ngForOf"], [1, "day"]], template: function NbCalendarDaysNamesComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbCalendarDaysNamesComponent_div_0_Template, 2, 3, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.days);
    } }, directives: [ɵngcc2.NgForOf], styles: ["[_nghost-%COMP%]{display:flex;justify-content:space-between}[_nghost-%COMP%]   .day[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}"], changeDetection: 0 });
NbCalendarDaysNamesComponent = __decorate$40([ __metadata$24("design:paramtypes", [NbDateService])
], NbCalendarDaysNamesComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$41 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$25 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarHeaderComponent = class NbCalendarHeaderComponent {
    constructor(directionService, dateService) {
        this.directionService = directionService;
        this.dateService = dateService;
        this.navigateToday = new EventEmitter();
        this.date = this.dateService.today();
    }
    get isRtl() {
        return this.directionService.isRtl();
    }
    get isLtr() {
        return this.directionService.isLtr();
    }
};
NbCalendarHeaderComponent.ɵfac = function NbCalendarHeaderComponent_Factory(t) { return new (t || NbCalendarHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService), ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarHeaderComponent, selectors: [["nb-calendar-header"]], inputs: { date: "date" }, outputs: { navigateToday: "navigateToday" }, decls: 7, vars: 8, consts: [[1, "header"], [1, "title", 3, "click"], [3, "ngClass"], [1, "sub-title"]], template: function NbCalendarHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "span", 1);
        ɵngcc0.ɵɵlistener("click", function NbCalendarHeaderComponent_Template_span_click_1_listener() { return ctx.navigateToday.emit(); });
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵpipe(3, "date");
        ɵngcc0.ɵɵelement(4, "i", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "span", 3);
        ɵngcc0.ɵɵtext(6, "Today");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind2(3, 2, ctx.date, "mediumDate"), " ");
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction2(5, _c8, ctx.isLtr, ctx.isRtl));
    } }, directives: [ɵngcc2.NgClass], pipes: [ɵngcc2.DatePipe], encapsulation: 2 });
__decorate$41([
    Input(),
    __metadata$25("design:type", Object)
], NbCalendarHeaderComponent.prototype, "date", void 0);
__decorate$41([
    Output(),
    __metadata$25("design:type", EventEmitter)
], NbCalendarHeaderComponent.prototype, "navigateToday", void 0);
NbCalendarHeaderComponent = __decorate$41([ __metadata$25("design:paramtypes", [NbLayoutDirectionService, NbDateService])
], NbCalendarHeaderComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$42 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$26 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarMonthCellComponent = class NbCalendarMonthCellComponent {
    constructor(dateService) {
        this.dateService = dateService;
        this.select = new EventEmitter(true);
    }
    get selected() {
        return this.dateService.isSameMonthSafe(this.date, this.selectedValue);
    }
    get today() {
        return this.dateService.isSameMonthSafe(this.date, this.dateService.today());
    }
    get disabled() {
        return this.smallerThanMin() || this.greaterThanMax();
    }
    get month() {
        return this.dateService.getMonthName(this.date);
    }
    onClick() {
        if (this.disabled) {
            return;
        }
        this.select.emit(this.date);
    }
    smallerThanMin() {
        return this.date && this.min && this.dateService.compareDates(this.monthEnd(), this.min) < 0;
    }
    greaterThanMax() {
        return this.date && this.max && this.dateService.compareDates(this.monthStart(), this.max) > 0;
    }
    monthStart() {
        return this.dateService.getMonthStart(this.date);
    }
    monthEnd() {
        return this.dateService.getMonthEnd(this.date);
    }
};
NbCalendarMonthCellComponent.ɵfac = function NbCalendarMonthCellComponent_Factory(t) { return new (t || NbCalendarMonthCellComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarMonthCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarMonthCellComponent, selectors: [["nb-calendar-month-cell"]], hostAttrs: [1, "month-cell"], hostVars: 6, hostBindings: function NbCalendarMonthCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbCalendarMonthCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled);
    } }, inputs: { date: "date", selectedValue: "selectedValue", min: "min", max: "max" }, outputs: { select: "select" }, decls: 1, vars: 1, template: function NbCalendarMonthCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate(ctx.month);
    } }, encapsulation: 2, changeDetection: 0 });
__decorate$42([
    Input(),
    __metadata$26("design:type", Object)
], NbCalendarMonthCellComponent.prototype, "date", void 0);
__decorate$42([
    Input(),
    __metadata$26("design:type", Object)
], NbCalendarMonthCellComponent.prototype, "selectedValue", void 0);
__decorate$42([
    Input(),
    __metadata$26("design:type", Object)
], NbCalendarMonthCellComponent.prototype, "min", void 0);
__decorate$42([
    Input(),
    __metadata$26("design:type", Object)
], NbCalendarMonthCellComponent.prototype, "max", void 0);
__decorate$42([
    Output(),
    __metadata$26("design:type", EventEmitter)
], NbCalendarMonthCellComponent.prototype, "select", void 0);
__decorate$42([
    HostBinding('class.selected'),
    __metadata$26("design:type", Boolean),
    __metadata$26("design:paramtypes", [])
], NbCalendarMonthCellComponent.prototype, "selected", null);
__decorate$42([
    HostBinding('class.today'),
    __metadata$26("design:type", Boolean),
    __metadata$26("design:paramtypes", [])
], NbCalendarMonthCellComponent.prototype, "today", null);
__decorate$42([
    HostBinding('class.disabled'),
    __metadata$26("design:type", Boolean),
    __metadata$26("design:paramtypes", [])
], NbCalendarMonthCellComponent.prototype, "disabled", null);
__decorate$42([
    HostListener('click'),
    __metadata$26("design:type", Function),
    __metadata$26("design:paramtypes", []),
    __metadata$26("design:returntype", void 0)
], NbCalendarMonthCellComponent.prototype, "onClick", null);
NbCalendarMonthCellComponent = __decorate$42([ __metadata$26("design:paramtypes", [NbDateService])
], NbCalendarMonthCellComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$43 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$27 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
const MONTHS_IN_VIEW = 12;
const MONTHS_IN_COLUMN = 4;
let NbCalendarMonthPickerComponent = class NbCalendarMonthPickerComponent {
    constructor(dateService) {
        this.dateService = dateService;
        this.size = NbCalendarSize.MEDIUM;
        this.monthChange = new EventEmitter();
        this.cellComponent = NbCalendarMonthCellComponent;
    }
    set _cellComponent(cellComponent) {
        if (cellComponent) {
            this.cellComponent = cellComponent;
        }
    }
    get medium() {
        return this.size === NbCalendarSize.MEDIUM;
    }
    get large() {
        return this.size === NbCalendarSize.LARGE;
    }
    ngOnInit() {
        this.initMonths();
    }
    initMonths() {
        const date = this.dateService.getDate(this.month);
        const year = this.dateService.getYear(this.month);
        const firstMonth = this.dateService.createDate(year, 0, date);
        const months = [firstMonth];
        for (let monthIndex = 1; monthIndex < MONTHS_IN_VIEW; monthIndex++) {
            months.push(this.dateService.addMonth(firstMonth, monthIndex));
        }
        this.months = batch(months, MONTHS_IN_COLUMN);
    }
    onSelect(month) {
        this.monthChange.emit(month);
    }
};
NbCalendarMonthPickerComponent.ɵfac = function NbCalendarMonthPickerComponent_Factory(t) { return new (t || NbCalendarMonthPickerComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarMonthPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarMonthPickerComponent, selectors: [["nb-calendar-month-picker"]], hostVars: 4, hostBindings: function NbCalendarMonthPickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("medium", ctx.medium)("large", ctx.large);
    } }, inputs: { size: "size", _cellComponent: ["cellComponent", "_cellComponent"], min: "min", max: "max", filter: "filter", month: "month" }, outputs: { monthChange: "monthChange" }, decls: 1, vars: 6, consts: [[3, "data", "min", "max", "filter", "selectedValue", "cellComponent", "select"]], template: function NbCalendarMonthPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-calendar-picker", 0);
        ɵngcc0.ɵɵlistener("select", function NbCalendarMonthPickerComponent_Template_nb_calendar_picker_select_0_listener($event) { return ctx.onSelect($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("data", ctx.months)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.month)("cellComponent", ctx.cellComponent);
    } }, directives: function () { return [NbCalendarPickerComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate$43([
    Input(),
    __metadata$27("design:type", Object)
], NbCalendarMonthPickerComponent.prototype, "min", void 0);
__decorate$43([
    Input(),
    __metadata$27("design:type", Object)
], NbCalendarMonthPickerComponent.prototype, "max", void 0);
__decorate$43([
    Input(),
    __metadata$27("design:type", Function)
], NbCalendarMonthPickerComponent.prototype, "filter", void 0);
__decorate$43([
    Input(),
    __metadata$27("design:type", String)
], NbCalendarMonthPickerComponent.prototype, "size", void 0);
__decorate$43([
    Input(),
    __metadata$27("design:type", Object)
], NbCalendarMonthPickerComponent.prototype, "month", void 0);
__decorate$43([
    Output(),
    __metadata$27("design:type", EventEmitter)
], NbCalendarMonthPickerComponent.prototype, "monthChange", void 0);
__decorate$43([
    Input('cellComponent'),
    __metadata$27("design:type", Type),
    __metadata$27("design:paramtypes", [Type])
], NbCalendarMonthPickerComponent.prototype, "_cellComponent", null);
__decorate$43([
    HostBinding('class.medium'),
    __metadata$27("design:type", Object),
    __metadata$27("design:paramtypes", [])
], NbCalendarMonthPickerComponent.prototype, "medium", null);
__decorate$43([
    HostBinding('class.large'),
    __metadata$27("design:type", Object),
    __metadata$27("design:paramtypes", [])
], NbCalendarMonthPickerComponent.prototype, "large", null);
NbCalendarMonthPickerComponent = __decorate$43([ __metadata$27("design:paramtypes", [NbDateService])
], NbCalendarMonthPickerComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$44 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$28 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarNavigationComponent = class NbCalendarNavigationComponent {
    constructor() {
        this.changeMode = new EventEmitter(true);
    }
};
NbCalendarNavigationComponent.ɵfac = function NbCalendarNavigationComponent_Factory(t) { return new (t || NbCalendarNavigationComponent)(); };
NbCalendarNavigationComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarNavigationComponent, selectors: [["nb-calendar-navigation"]], inputs: { date: "date" }, outputs: { changeMode: "changeMode" }, decls: 3, vars: 4, consts: [["nbButton", "", 3, "click"]], template: function NbCalendarNavigationComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function NbCalendarNavigationComponent_Template_button_click_0_listener() { return ctx.changeMode.emit(); });
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵpipe(2, "date");
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ɵngcc0.ɵɵpipeBind2(2, 1, ctx.date, "MMM yyyy"), " ");
    } }, directives: [NbButtonComponent], pipes: [ɵngcc2.DatePipe], styles: ["[_nghost-%COMP%] {\n      display: flex;\n      justify-content: center;\n    }\n\n    [_nghost-%COMP%]   button[_ngcontent-%COMP%] {\n      height: 3.125rem;\n    }"], changeDetection: 0 });
__decorate$44([
    Input(),
    __metadata$28("design:type", Object)
], NbCalendarNavigationComponent.prototype, "date", void 0);
__decorate$44([
    Output(),
    __metadata$28("design:type", Object)
], NbCalendarNavigationComponent.prototype, "changeMode", void 0);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$45 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$29 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarPageableNavigationComponent = class NbCalendarPageableNavigationComponent {
    constructor(directionService) {
        this.directionService = directionService;
        this.changeMode = new EventEmitter();
        this.next = new EventEmitter();
        this.prev = new EventEmitter();
    }
    get isRtl() {
        return this.directionService.isRtl();
    }
    get isLtr() {
        return this.directionService.isLtr();
    }
};
NbCalendarPageableNavigationComponent.ɵfac = function NbCalendarPageableNavigationComponent_Factory(t) { return new (t || NbCalendarPageableNavigationComponent)(ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService)); };
NbCalendarPageableNavigationComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarPageableNavigationComponent, selectors: [["nb-calendar-pageable-navigation"]], inputs: { date: "date" }, outputs: { changeMode: "changeMode", next: "next", prev: "prev" }, decls: 5, vars: 3, consts: [["nbButton", "", "ghost", "", "size", "small", 1, "prev-month", 3, "click"], ["pack", "nebular-essentials", 3, "icon"], [3, "date", "changeMode"], ["nbButton", "", "ghost", "", "size", "small", 1, "next-month", 3, "click"]], template: function NbCalendarPageableNavigationComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function NbCalendarPageableNavigationComponent_Template_button_click_0_listener() { return ctx.prev.emit(); });
        ɵngcc0.ɵɵelement(1, "nb-icon", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "nb-calendar-navigation", 2);
        ɵngcc0.ɵɵlistener("changeMode", function NbCalendarPageableNavigationComponent_Template_nb_calendar_navigation_changeMode_2_listener() { return ctx.changeMode.emit(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "button", 3);
        ɵngcc0.ɵɵlistener("click", function NbCalendarPageableNavigationComponent_Template_button_click_3_listener() { return ctx.next.emit(); });
        ɵngcc0.ɵɵelement(4, "nb-icon", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("icon", ctx.isLtr ? "chevron-left-outline" : "chevron-right-outline");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("date", ctx.date);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("icon", ctx.isLtr ? "chevron-right-outline" : "chevron-left-outline");
    } }, directives: [NbButtonComponent,
        NbIconComponent,
        NbCalendarNavigationComponent], styles: ["[_nghost-%COMP%]{display:flex;align-items:center;justify-content:space-between}[dir=ltr]   [_nghost-%COMP%]   .prev-month[_ngcontent-%COMP%]{margin-left:auto;margin-right:0.4rem}[dir=rtl]   [_nghost-%COMP%]   .prev-month[_ngcontent-%COMP%]{margin-left:0.4rem;margin-right:auto}[dir=ltr]   [_nghost-%COMP%]   .next-month[_ngcontent-%COMP%]{margin-left:0.4rem;margin-right:auto}[dir=rtl]   [_nghost-%COMP%]   .next-month[_ngcontent-%COMP%]{margin-left:auto;margin-right:0.4rem}nb-calendar-navigation[_ngcontent-%COMP%]{margin:0 0.5rem}"] });
__decorate$45([
    Input(),
    __metadata$29("design:type", Object)
], NbCalendarPageableNavigationComponent.prototype, "date", void 0);
__decorate$45([
    Output(),
    __metadata$29("design:type", Object)
], NbCalendarPageableNavigationComponent.prototype, "changeMode", void 0);
__decorate$45([
    Output(),
    __metadata$29("design:type", Object)
], NbCalendarPageableNavigationComponent.prototype, "next", void 0);
__decorate$45([
    Output(),
    __metadata$29("design:type", Object)
], NbCalendarPageableNavigationComponent.prototype, "prev", void 0);
NbCalendarPageableNavigationComponent = __decorate$45([ __metadata$29("design:paramtypes", [NbLayoutDirectionService])
], NbCalendarPageableNavigationComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$46 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$30 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarPickerComponent = class NbCalendarPickerComponent {
    constructor() {
        this.select = new EventEmitter();
    }
};
NbCalendarPickerComponent.ɵfac = function NbCalendarPickerComponent_Factory(t) { return new (t || NbCalendarPickerComponent)(); };
NbCalendarPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarPickerComponent, selectors: [["nb-calendar-picker"]], inputs: { data: "data", visibleDate: "visibleDate", selectedValue: "selectedValue", cellComponent: "cellComponent", min: "min", max: "max", filter: "filter" }, outputs: { select: "select" }, decls: 1, vars: 1, consts: [[3, "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "select", 4, "ngFor", "ngForOf"], [3, "row", "visibleDate", "selectedValue", "component", "min", "max", "filter", "select"]], template: function NbCalendarPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbCalendarPickerComponent_nb_calendar_picker_row_0_Template, 1, 7, "nb-calendar-picker-row", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.data);
    } }, directives: function () { return [ɵngcc2.NgForOf, NbCalendarPickerRowComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate$46([
    Input(),
    __metadata$30("design:type", Array)
], NbCalendarPickerComponent.prototype, "data", void 0);
__decorate$46([
    Input(),
    __metadata$30("design:type", Object)
], NbCalendarPickerComponent.prototype, "visibleDate", void 0);
__decorate$46([
    Input(),
    __metadata$30("design:type", Object)
], NbCalendarPickerComponent.prototype, "selectedValue", void 0);
__decorate$46([
    Input(),
    __metadata$30("design:type", Type)
], NbCalendarPickerComponent.prototype, "cellComponent", void 0);
__decorate$46([
    Input(),
    __metadata$30("design:type", Object)
], NbCalendarPickerComponent.prototype, "min", void 0);
__decorate$46([
    Input(),
    __metadata$30("design:type", Object)
], NbCalendarPickerComponent.prototype, "max", void 0);
__decorate$46([
    Input(),
    __metadata$30("design:type", Function)
], NbCalendarPickerComponent.prototype, "filter", void 0);
__decorate$46([
    Output(),
    __metadata$30("design:type", EventEmitter)
], NbCalendarPickerComponent.prototype, "select", void 0);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$47 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$31 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarPickerRowComponent = class NbCalendarPickerRowComponent {
    constructor(cfr) {
        this.cfr = cfr;
        this.select = new EventEmitter();
    }
    ngOnChanges() {
        const factory = this.cfr.resolveComponentFactory(this.component);
        this.containerRef.clear();
        this.row.forEach((date) => {
            const component = this.containerRef.createComponent(factory);
            this.patchWithContext(component.instance, date);
            component.changeDetectorRef.detectChanges();
        });
    }
    patchWithContext(component, date) {
        component.visibleDate = this.visibleDate;
        component.selectedValue = this.selectedValue;
        component.date = date;
        component.min = this.min;
        component.max = this.max;
        component.filter = this.filter;
        component.select.subscribe(this.select.emit.bind(this.select));
    }
};
NbCalendarPickerRowComponent.ɵfac = function NbCalendarPickerRowComponent_Factory(t) { return new (t || NbCalendarPickerRowComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver)); };
NbCalendarPickerRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarPickerRowComponent, selectors: [["nb-calendar-picker-row"]], viewQuery: function NbCalendarPickerRowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(TemplateRef, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.containerRef = _t.first);
    } }, inputs: { row: "row", selectedValue: "selectedValue", visibleDate: "visibleDate", component: "component", min: "min", max: "max", filter: "filter" }, outputs: { select: "select" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], decls: 1, vars: 0, template: function NbCalendarPickerRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbCalendarPickerRowComponent_ng_template_0_Template, 0, 0, "ng-template");
    } }, styles: ["[_nghost-%COMP%] {\n      display: flex;\n      justify-content: space-between;\n    }"], changeDetection: 0 });
__decorate$47([
    Input(),
    __metadata$31("design:type", Array)
], NbCalendarPickerRowComponent.prototype, "row", void 0);
__decorate$47([
    Input(),
    __metadata$31("design:type", Object)
], NbCalendarPickerRowComponent.prototype, "selectedValue", void 0);
__decorate$47([
    Input(),
    __metadata$31("design:type", Object)
], NbCalendarPickerRowComponent.prototype, "visibleDate", void 0);
__decorate$47([
    Input(),
    __metadata$31("design:type", Type)
], NbCalendarPickerRowComponent.prototype, "component", void 0);
__decorate$47([
    Input(),
    __metadata$31("design:type", Object)
], NbCalendarPickerRowComponent.prototype, "min", void 0);
__decorate$47([
    Input(),
    __metadata$31("design:type", Object)
], NbCalendarPickerRowComponent.prototype, "max", void 0);
__decorate$47([
    Input(),
    __metadata$31("design:type", Function)
], NbCalendarPickerRowComponent.prototype, "filter", void 0);
__decorate$47([
    Output(),
    __metadata$31("design:type", EventEmitter)
], NbCalendarPickerRowComponent.prototype, "select", void 0);
__decorate$47([
    ViewChild(TemplateRef, { read: ViewContainerRef, static: true }),
    __metadata$31("design:type", ViewContainerRef)
], NbCalendarPickerRowComponent.prototype, "containerRef", void 0);
NbCalendarPickerRowComponent = __decorate$47([ __metadata$31("design:paramtypes", [ComponentFactoryResolver])
], NbCalendarPickerRowComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$48 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$32 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarYearCellComponent = class NbCalendarYearCellComponent {
    constructor(dateService) {
        this.dateService = dateService;
        this.select = new EventEmitter(true);
    }
    get selected() {
        return this.dateService.isSameYearSafe(this.date, this.selectedValue);
    }
    get today() {
        return this.dateService.isSameYearSafe(this.date, this.dateService.today());
    }
    get disabled() {
        return this.smallerThanMin() || this.greaterThanMax();
    }
    get year() {
        return this.dateService.getYear(this.date);
    }
    onClick() {
        if (this.disabled) {
            return;
        }
        this.select.emit(this.date);
    }
    smallerThanMin() {
        return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
    }
    greaterThanMax() {
        return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
    }
    yearStart() {
        return this.dateService.getYearStart(this.date);
    }
    yearEnd() {
        return this.dateService.getYearEnd(this.date);
    }
};
NbCalendarYearCellComponent.ɵfac = function NbCalendarYearCellComponent_Factory(t) { return new (t || NbCalendarYearCellComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarYearCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarYearCellComponent, selectors: [["nb-calendar-year-cell"]], hostAttrs: [1, "year-cell"], hostVars: 6, hostBindings: function NbCalendarYearCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbCalendarYearCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled);
    } }, inputs: { date: "date", min: "min", max: "max", selectedValue: "selectedValue" }, outputs: { select: "select" }, decls: 1, vars: 1, template: function NbCalendarYearCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate(ctx.year);
    } }, encapsulation: 2, changeDetection: 0 });
__decorate$48([
    Input(),
    __metadata$32("design:type", Object)
], NbCalendarYearCellComponent.prototype, "date", void 0);
__decorate$48([
    Input(),
    __metadata$32("design:type", Object)
], NbCalendarYearCellComponent.prototype, "min", void 0);
__decorate$48([
    Input(),
    __metadata$32("design:type", Object)
], NbCalendarYearCellComponent.prototype, "max", void 0);
__decorate$48([
    Input(),
    __metadata$32("design:type", Object)
], NbCalendarYearCellComponent.prototype, "selectedValue", void 0);
__decorate$48([
    Output(),
    __metadata$32("design:type", EventEmitter)
], NbCalendarYearCellComponent.prototype, "select", void 0);
__decorate$48([
    HostBinding('class.selected'),
    __metadata$32("design:type", Boolean),
    __metadata$32("design:paramtypes", [])
], NbCalendarYearCellComponent.prototype, "selected", null);
__decorate$48([
    HostBinding('class.today'),
    __metadata$32("design:type", Boolean),
    __metadata$32("design:paramtypes", [])
], NbCalendarYearCellComponent.prototype, "today", null);
__decorate$48([
    HostBinding('class.disabled'),
    __metadata$32("design:type", Boolean),
    __metadata$32("design:paramtypes", [])
], NbCalendarYearCellComponent.prototype, "disabled", null);
__decorate$48([
    HostListener('click'),
    __metadata$32("design:type", Function),
    __metadata$32("design:paramtypes", []),
    __metadata$32("design:returntype", void 0)
], NbCalendarYearCellComponent.prototype, "onClick", null);
NbCalendarYearCellComponent = __decorate$48([ __metadata$32("design:paramtypes", [NbDateService])
], NbCalendarYearCellComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$49 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$33 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
const YEARS_IN_VIEW = 20;
const YEARS_IN_COLUMN = 4;
let NbCalendarYearPickerComponent = class NbCalendarYearPickerComponent {
    constructor(dateService) {
        this.dateService = dateService;
        this.cellComponent = NbCalendarYearCellComponent;
        this.size = NbCalendarSize.MEDIUM;
        this.yearChange = new EventEmitter();
    }
    set _cellComponent(cellComponent) {
        if (cellComponent) {
            this.cellComponent = cellComponent;
        }
    }
    get medium() {
        return this.size === NbCalendarSize.MEDIUM;
    }
    get large() {
        return this.size === NbCalendarSize.LARGE;
    }
    ngOnChanges() {
        this.initYears();
    }
    initYears() {
        const selectedYear = this.dateService.getYear(this.year);
        const startYear = Math.ceil(selectedYear - YEARS_IN_VIEW / 2);
        const years = range(YEARS_IN_VIEW).map(i => this.createYearDateByIndex(i + startYear));
        this.years = batch(years, YEARS_IN_COLUMN);
    }
    onSelect(year) {
        this.yearChange.emit(year);
    }
    createYearDateByIndex(i) {
        return this.dateService.createDate(i, this.dateService.getMonth(this.year), this.dateService.getDate(this.year));
    }
};
NbCalendarYearPickerComponent.ɵfac = function NbCalendarYearPickerComponent_Factory(t) { return new (t || NbCalendarYearPickerComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarYearPickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarYearPickerComponent, selectors: [["nb-calendar-year-picker"]], hostVars: 4, hostBindings: function NbCalendarYearPickerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("medium", ctx.medium)("large", ctx.large);
    } }, inputs: { size: "size", _cellComponent: ["cellComponent", "_cellComponent"], date: "date", min: "min", max: "max", filter: "filter", year: "year" }, outputs: { yearChange: "yearChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], decls: 1, vars: 7, consts: [[3, "data", "min", "max", "filter", "selectedValue", "visibleDate", "cellComponent", "select"]], template: function NbCalendarYearPickerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-calendar-picker", 0);
        ɵngcc0.ɵɵlistener("select", function NbCalendarYearPickerComponent_Template_nb_calendar_picker_select_0_listener($event) { return ctx.onSelect($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("data", ctx.years)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("selectedValue", ctx.date)("visibleDate", ctx.year)("cellComponent", ctx.cellComponent);
    } }, directives: [NbCalendarPickerComponent], encapsulation: 2, changeDetection: 0 });
__decorate$49([
    Input(),
    __metadata$33("design:type", Object)
], NbCalendarYearPickerComponent.prototype, "date", void 0);
__decorate$49([
    Input(),
    __metadata$33("design:type", Object)
], NbCalendarYearPickerComponent.prototype, "min", void 0);
__decorate$49([
    Input(),
    __metadata$33("design:type", Object)
], NbCalendarYearPickerComponent.prototype, "max", void 0);
__decorate$49([
    Input(),
    __metadata$33("design:type", Function)
], NbCalendarYearPickerComponent.prototype, "filter", void 0);
__decorate$49([
    Input('cellComponent'),
    __metadata$33("design:type", Type),
    __metadata$33("design:paramtypes", [Type])
], NbCalendarYearPickerComponent.prototype, "_cellComponent", null);
__decorate$49([
    Input(),
    __metadata$33("design:type", String)
], NbCalendarYearPickerComponent.prototype, "size", void 0);
__decorate$49([
    Input(),
    __metadata$33("design:type", Object)
], NbCalendarYearPickerComponent.prototype, "year", void 0);
__decorate$49([
    Output(),
    __metadata$33("design:type", Object)
], NbCalendarYearPickerComponent.prototype, "yearChange", void 0);
__decorate$49([
    HostBinding('class.medium'),
    __metadata$33("design:type", Object),
    __metadata$33("design:paramtypes", [])
], NbCalendarYearPickerComponent.prototype, "medium", null);
__decorate$49([
    HostBinding('class.large'),
    __metadata$33("design:type", Object),
    __metadata$33("design:paramtypes", [])
], NbCalendarYearPickerComponent.prototype, "large", null);
NbCalendarYearPickerComponent = __decorate$49([ __metadata$33("design:paramtypes", [NbDateService])
], NbCalendarYearPickerComponent);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$50 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$34 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarWeekNumberComponent = class NbCalendarWeekNumberComponent {
    constructor(dateService) {
        this.dateService = dateService;
    }
    get isMedium() {
        return this.size === NbCalendarSize.MEDIUM;
    }
    get isLarge() {
        return this.size === NbCalendarSize.LARGE;
    }
    getWeeks() {
        return this.weeks.map((week) => {
            // Find last defined day as week could contain null days in case
            // boundingMonth set to false
            const lastDay = [...week].reverse().find((day) => !!day);
            // Use last day of the week to determine week number.
            // This way weeks which span between sibling years is marked first
            return this.dateService.getWeekNumber(lastDay);
        });
    }
};
NbCalendarWeekNumberComponent.ɵfac = function NbCalendarWeekNumberComponent_Factory(t) { return new (t || NbCalendarWeekNumberComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarWeekNumberComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarWeekNumberComponent, selectors: [["nb-calendar-week-numbers"]], hostVars: 4, hostBindings: function NbCalendarWeekNumberComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-medium", ctx.isMedium)("size-large", ctx.isLarge);
    } }, inputs: { weeks: "weeks", size: "size", weekNumberSymbol: "weekNumberSymbol" }, decls: 3, vars: 2, consts: [[1, "sign"], ["class", "week-cell", 4, "ngFor", "ngForOf"], [1, "week-cell"]], template: function NbCalendarWeekNumberComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NbCalendarWeekNumberComponent_div_2_Template, 2, 1, "div", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.weekNumberSymbol);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.getWeeks());
    } }, directives: [ɵngcc2.NgForOf], styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column}"], changeDetection: 0 });
__decorate$50([
    Input(),
    __metadata$34("design:type", Array)
], NbCalendarWeekNumberComponent.prototype, "weeks", void 0);
__decorate$50([
    Input(),
    __metadata$34("design:type", String)
], NbCalendarWeekNumberComponent.prototype, "size", void 0);
__decorate$50([
    Input(),
    __metadata$34("design:type", String)
], NbCalendarWeekNumberComponent.prototype, "weekNumberSymbol", void 0);
__decorate$50([
    HostBinding('class.size-medium'),
    __metadata$34("design:type", Object),
    __metadata$34("design:paramtypes", [])
], NbCalendarWeekNumberComponent.prototype, "isMedium", null);
__decorate$50([
    HostBinding('class.size-large'),
    __metadata$34("design:type", Object),
    __metadata$34("design:paramtypes", [])
], NbCalendarWeekNumberComponent.prototype, "isLarge", null);
NbCalendarWeekNumberComponent = __decorate$50([ __metadata$34("design:paramtypes", [NbDateService])
], NbCalendarWeekNumberComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$51 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$35 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$9 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * The `NbNativeDateService` is basic implementation of `NbDateService` using
 * native js date objects and angular localization services.
 * */
let NbNativeDateService = class NbNativeDateService extends NbDateService {
    constructor(locale) {
        super();
        this.setLocale(locale);
    }
    setLocale(locale) {
        super.setLocale(locale);
        this.datePipe = new DatePipe(locale);
    }
    isValidDateString(date, format) {
        return !isNaN(this.parse(date, format).getTime());
    }
    today() {
        return new Date();
    }
    getDate(date) {
        return date.getDate();
    }
    getMonth(date) {
        return date.getMonth();
    }
    getYear(date) {
        return date.getFullYear();
    }
    getDayOfWeek(date) {
        return date.getDay();
    }
    /**
     * returns first day of the week, it can be 1 if week starts from monday
     * and 0 if from sunday and so on.
     * */
    getFirstDayOfWeek() {
        return getLocaleFirstDayOfWeek(this.locale);
    }
    getMonthName(date, style$$1 = TranslationWidth.Abbreviated) {
        const index = date.getMonth();
        return this.getMonthNameByIndex(index, style$$1);
    }
    getMonthNameByIndex(index, style$$1 = TranslationWidth.Abbreviated) {
        return getLocaleMonthNames(this.locale, FormStyle.Format, style$$1)[index];
    }
    getDayOfWeekNames() {
        return getLocaleDayNames(this.locale, FormStyle.Format, TranslationWidth.Short);
    }
    format(date, format) {
        return this.datePipe.transform(date, format);
    }
    /**
     * We haven't got capability to parse date using formatting without third party libraries.
     * */
    parse(date, format) {
        return new Date(Date.parse(date));
    }
    addDay(date, num) {
        return this.createDate(date.getFullYear(), date.getMonth(), date.getDate() + num);
    }
    addMonth(date, num) {
        const month = this.createDate(date.getFullYear(), date.getMonth() + num, 1);
        // In case of date has more days than calculated month js Date will change that month to the next one
        // because of the date overflow.
        month.setDate(Math.min(date.getDate(), this.getMonthEnd(month).getDate()));
        return month;
    }
    addYear(date, num) {
        return this.createDate(date.getFullYear() + num, date.getMonth(), date.getDate());
    }
    clone(date) {
        return new Date(date.getTime());
    }
    compareDates(date1, date2) {
        return date1.getTime() - date2.getTime();
    }
    createDate(year, month, date) {
        const result = new Date(year, month, date);
        // We need to correct for the fact that JS native Date treats years in range [0, 99] as
        // abbreviations for 19xx.
        if (year >= 0 && year < 100) {
            result.setFullYear(result.getFullYear() - 1900);
        }
        return result;
    }
    getMonthEnd(date) {
        return this.createDate(date.getFullYear(), date.getMonth() + 1, 0);
    }
    getMonthStart(date) {
        return this.createDate(date.getFullYear(), date.getMonth(), 1);
    }
    getNumberOfDaysInMonth(date) {
        return this.getMonthEnd(date).getDate();
    }
    getYearEnd(date) {
        return this.createDate(date.getFullYear(), 11, 31);
    }
    getYearStart(date) {
        return this.createDate(date.getFullYear(), 0, 1);
    }
    isSameDay(date1, date2) {
        return this.isSameMonth(date1, date2) &&
            date1.getDate() === date2.getDate();
    }
    isSameMonth(date1, date2) {
        return this.isSameYear(date1, date2) &&
            date1.getMonth() === date2.getMonth();
    }
    isSameYear(date1, date2) {
        return date1.getFullYear() === date2.getFullYear();
    }
    getId() {
        return 'native';
    }
    getWeekNumber(date) {
        return parseInt(this.datePipe.transform(date, 'w'), 10);
    }
};
NbNativeDateService.ɵfac = function NbNativeDateService_Factory(t) { return new (t || NbNativeDateService)(ɵngcc0.ɵɵinject(LOCALE_ID)); };
NbNativeDateService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbNativeDateService, factory: NbNativeDateService.ɵfac });
NbNativeDateService = __decorate$51([ __param$9(0, Inject(LOCALE_ID)),
    __metadata$35("design:paramtypes", [String])
], NbNativeDateService);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$34 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const SERVICES = [
    { provide: NbDateService, useClass: NbNativeDateService },
    DatePipe,
    NbCalendarMonthModelService,
];
const COMPONENTS = [
    NbCalendarHeaderComponent,
    NbCalendarNavigationComponent,
    NbCalendarPageableNavigationComponent,
    NbCalendarDaysNamesComponent,
    NbCalendarYearPickerComponent,
    NbCalendarMonthPickerComponent,
    NbCalendarDayPickerComponent,
    NbCalendarDayCellComponent,
    NbCalendarMonthCellComponent,
    NbCalendarYearCellComponent,
    NbCalendarPickerRowComponent,
    NbCalendarPickerComponent,
    NbCalendarWeekNumberComponent,
];
/**
 * `NbCalendarKitModule` is a module that contains multiple useful components for building custom calendars.
 * So if you think our calendars is not enough powerful for you just use calendar-kit and build your own calendar!
 *
 * Available components:
 * - `NbCalendarDayPicker`
 * - `NbCalendarDayCell`
 * - `NbCalendarMonthPicker`
 * - `NbCalendarMonthCell`
 * - `NbCalendarYearPicker`
 * - `NbCalendarYearCell`
 * - `NbCalendarHeader`
 * - `NbCalendarNavigation`
 * - `NbCalendarPageableNavigation`
 *
 * For example you can easily build full calendar:
 * @stacked-example(Full calendar, calendar-kit/calendar-kit-full-calendar.component)
 * */
let NbCalendarKitModule = class NbCalendarKitModule {
};
NbCalendarKitModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCalendarKitModule });
NbCalendarKitModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbCalendarKitModule_Factory(t) { return new (t || NbCalendarKitModule)(); }, providers: [...SERVICES], imports: [[NbSharedModule, NbButtonModule, NbIconModule]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$52 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$36 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * The basis for calendar and range calendar components.
 * Encapsulates common behavior - store calendar state and perform navigation
 * between pickers.
 * */
let NbBaseCalendarComponent = class NbBaseCalendarComponent {
    constructor(dateService) {
        this.dateService = dateService;
        /**
         * Defines if we should render previous and next months
         * in the current month view.
         * */
        this.boundingMonth = true;
        /**
         * Defines active view for calendar.
         * */
        this.activeViewMode = NbCalendarViewMode.DATE;
        /**
         * Size of the calendar and entire components.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        /**
         * Determines should we show calendars header or not.
         * */
        this.showHeader = true;
        this._showWeekNumber = false;
        /**
         * Emits date when selected.
         * */
        this.dateChange = new EventEmitter();
        this.ViewMode = NbCalendarViewMode;
    }
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber() {
        return this._showWeekNumber;
    }
    set showWeekNumber(value) {
        this._showWeekNumber = convertToBoolProperty(value);
    }
    ngOnInit() {
        if (!this.visibleDate) {
            this.visibleDate = this.dateService.today();
        }
    }
    get medium() {
        return this.size === NbCalendarSize.MEDIUM;
    }
    get large() {
        return this.size === NbCalendarSize.LARGE;
    }
    setViewMode(viewMode) {
        this.activeViewMode = viewMode;
    }
    setVisibleDate(visibleDate) {
        this.visibleDate = visibleDate;
    }
    prevMonth() {
        this.changeVisibleMonth(-1);
    }
    nextMonth() {
        this.changeVisibleMonth(1);
    }
    prevYears() {
        this.changeVisibleYear(-1);
    }
    nextYears() {
        this.changeVisibleYear(1);
    }
    navigateToday() {
        this.setViewMode(NbCalendarViewMode.DATE);
        this.visibleDate = this.dateService.today();
    }
    changeVisibleMonth(direction) {
        this.visibleDate = this.dateService.addMonth(this.visibleDate, direction);
    }
    changeVisibleYear(direction) {
        this.visibleDate = this.dateService.addYear(this.visibleDate, direction * YEARS_IN_VIEW);
    }
};
NbBaseCalendarComponent.ɵfac = function NbBaseCalendarComponent_Factory(t) { return new (t || NbBaseCalendarComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbBaseCalendarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbBaseCalendarComponent, selectors: [["nb-base-calendar"]], hostVars: 6, hostBindings: function NbBaseCalendarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("has-week-number", ctx.showWeekNumber)("medium", ctx.medium)("large", ctx.large);
    } }, inputs: { boundingMonth: "boundingMonth", activeViewMode: ["startView", "activeViewMode"], size: "size", showHeader: "showHeader", showWeekNumber: "showWeekNumber", visibleDate: "visibleDate", min: "min", max: "max", filter: "filter", dayCellComponent: "dayCellComponent", monthCellComponent: "monthCellComponent", yearCellComponent: "yearCellComponent", date: "date", weekNumberSymbol: "weekNumberSymbol" }, outputs: { dateChange: "dateChange" }, decls: 6, vars: 5, consts: [[4, "ngIf"], [3, "ngSwitch"], [4, "ngSwitchCase"], [3, "navigateToday"], [3, "date", "next", "prev", "changeMode", 4, "ngSwitchCase"], [3, "boundingMonths", "cellComponent", "min", "max", "filter", "visibleDate", "size", "date", "showWeekNumber", "weekNumberSymbol", "dateChange"], [3, "date", "next", "prev", "changeMode"], [3, "cellComponent", "date", "min", "max", "filter", "size", "year", "yearChange"], [3, "date", "changeMode"], [3, "cellComponent", "min", "max", "filter", "size", "month", "monthChange"]], template: function NbBaseCalendarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-card");
        ɵngcc0.ɵɵtemplate(1, NbBaseCalendarComponent_nb_card_header_1_Template, 2, 0, "nb-card-header", 0);
        ɵngcc0.ɵɵelementStart(2, "nb-card-body", 1);
        ɵngcc0.ɵɵtemplate(3, NbBaseCalendarComponent_ng_container_3_Template, 3, 11, "ng-container", 2);
        ɵngcc0.ɵɵtemplate(4, NbBaseCalendarComponent_ng_container_4_Template, 3, 8, "ng-container", 2);
        ɵngcc0.ɵɵtemplate(5, NbBaseCalendarComponent_ng_container_5_Template, 3, 7, "ng-container", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showHeader);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.activeViewMode);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.ViewMode.DATE);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.ViewMode.YEAR);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", ctx.ViewMode.MONTH);
    } }, directives: [NbCardComponent, ɵngcc2.NgIf, NbCardBodyComponent, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, NbCardHeaderComponent,
        NbCalendarHeaderComponent,
        NbCalendarDayPickerComponent,
        NbCalendarPageableNavigationComponent,
        NbCalendarYearPickerComponent,
        NbCalendarNavigationComponent,
        NbCalendarMonthPickerComponent], encapsulation: 2 });
__decorate$52([
    Input(),
    __metadata$36("design:type", Boolean)
], NbBaseCalendarComponent.prototype, "boundingMonth", void 0);
__decorate$52([
    Input('startView'),
    __metadata$36("design:type", String)
], NbBaseCalendarComponent.prototype, "activeViewMode", void 0);
__decorate$52([
    Input(),
    __metadata$36("design:type", Object)
], NbBaseCalendarComponent.prototype, "min", void 0);
__decorate$52([
    Input(),
    __metadata$36("design:type", Object)
], NbBaseCalendarComponent.prototype, "max", void 0);
__decorate$52([
    Input(),
    __metadata$36("design:type", Function)
], NbBaseCalendarComponent.prototype, "filter", void 0);
__decorate$52([
    Input(),
    __metadata$36("design:type", Type)
], NbBaseCalendarComponent.prototype, "dayCellComponent", void 0);
__decorate$52([
    Input(),
    __metadata$36("design:type", Type)
], NbBaseCalendarComponent.prototype, "monthCellComponent", void 0);
__decorate$52([
    Input(),
    __metadata$36("design:type", Type)
], NbBaseCalendarComponent.prototype, "yearCellComponent", void 0);
__decorate$52([
    Input(),
    __metadata$36("design:type", String)
], NbBaseCalendarComponent.prototype, "size", void 0);
__decorate$52([
    Input(),
    __metadata$36("design:type", Object)
], NbBaseCalendarComponent.prototype, "visibleDate", void 0);
__decorate$52([
    Input(),
    __metadata$36("design:type", Boolean)
], NbBaseCalendarComponent.prototype, "showHeader", void 0);
__decorate$52([
    Input(),
    __metadata$36("design:type", Object)
], NbBaseCalendarComponent.prototype, "date", void 0);
__decorate$52([
    Input(),
    HostBinding('class.has-week-number'),
    __metadata$36("design:type", Boolean),
    __metadata$36("design:paramtypes", [Boolean])
], NbBaseCalendarComponent.prototype, "showWeekNumber", null);
__decorate$52([
    Input(),
    __metadata$36("design:type", String)
], NbBaseCalendarComponent.prototype, "weekNumberSymbol", void 0);
__decorate$52([
    Output(),
    __metadata$36("design:type", EventEmitter)
], NbBaseCalendarComponent.prototype, "dateChange", void 0);
__decorate$52([
    HostBinding('class.medium'),
    __metadata$36("design:type", Object),
    __metadata$36("design:paramtypes", [])
], NbBaseCalendarComponent.prototype, "medium", null);
__decorate$52([
    HostBinding('class.large'),
    __metadata$36("design:type", Object),
    __metadata$36("design:paramtypes", [])
], NbBaseCalendarComponent.prototype, "large", null);
NbBaseCalendarComponent = __decorate$52([ __metadata$36("design:paramtypes", [NbDateService])
], NbBaseCalendarComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$33 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbBaseCalendarModule = class NbBaseCalendarModule {
};
NbBaseCalendarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbBaseCalendarModule });
NbBaseCalendarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbBaseCalendarModule_Factory(t) { return new (t || NbBaseCalendarModule)(); }, imports: [[NbCalendarKitModule, NbSharedModule, NbCardModule]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$31 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbCalendarModule = class NbCalendarModule {
};
NbCalendarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCalendarModule });
NbCalendarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbCalendarModule_Factory(t) { return new (t || NbCalendarModule)(); }, imports: [[NbBaseCalendarModule]] });

var __decorate$55 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$38 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbCalendarRangeDayCellComponent = class NbCalendarRangeDayCellComponent {
    constructor(dateService) {
        this.dateService = dateService;
        this.select = new EventEmitter(true);
    }
    get inRange() {
        return this.date && this.selectedValue
            && (this.selectedValue.start && this.dateService.compareDates(this.date, this.selectedValue.start) >= 0)
            && (this.selectedValue.end && this.dateService.compareDates(this.date, this.selectedValue.end) <= 0);
    }
    get start() {
        return this.date && this.selectedValue && this.selectedValue.end
            && (this.selectedValue.start && this.dateService.isSameDay(this.date, this.selectedValue.start));
    }
    get end() {
        return this.date && this.selectedValue &&
            (this.selectedValue.end && this.dateService.isSameDay(this.date, this.selectedValue.end));
    }
    get today() {
        return this.date && this.dateService.isSameDay(this.date, this.dateService.today());
    }
    get boundingMonth() {
        return !this.dateService.isSameMonthSafe(this.date, this.visibleDate);
    }
    get selected() {
        return this.date && this.selectedValue
            && (this.selectedValue.start && this.dateService.isSameDay(this.date, this.selectedValue.start)) || this.end;
    }
    get empty() {
        return !this.date;
    }
    get disabled() {
        return this.smallerThanMin() || this.greaterThanMax() || this.dontFitFilter();
    }
    get day() {
        return this.date && this.dateService.getDate(this.date);
    }
    onClick() {
        if (this.disabled || this.empty) {
            return;
        }
        this.select.emit(this.date);
    }
    smallerThanMin() {
        return this.date && this.min && this.dateService.compareDates(this.date, this.min) < 0;
    }
    greaterThanMax() {
        return this.date && this.max && this.dateService.compareDates(this.date, this.max) > 0;
    }
    dontFitFilter() {
        return this.date && this.filter && !this.filter(this.date);
    }
};
NbCalendarRangeDayCellComponent.ɵfac = function NbCalendarRangeDayCellComponent_Factory(t) { return new (t || NbCalendarRangeDayCellComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarRangeDayCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarRangeDayCellComponent, selectors: [["nb-calendar-range-day-cell"]], hostAttrs: [1, "range-cell"], hostVars: 6, hostBindings: function NbCalendarRangeDayCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbCalendarRangeDayCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("in-range", ctx.inRange)("start", ctx.start)("end", ctx.end);
    } }, inputs: { date: "date", selectedValue: "selectedValue", visibleDate: "visibleDate", min: "min", max: "max", filter: "filter" }, outputs: { select: "select" }, decls: 2, vars: 15, consts: [[1, "day-cell"]], template: function NbCalendarRangeDayCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("today", ctx.today)("selected", ctx.selected)("bounding-month", ctx.boundingMonth)("start", ctx.start)("end", ctx.end)("in-range", ctx.inRange)("disabled", ctx.disabled);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.day, " ");
    } }, encapsulation: 2, changeDetection: 0 });
__decorate$55([
    Input(),
    __metadata$38("design:type", Object)
], NbCalendarRangeDayCellComponent.prototype, "date", void 0);
__decorate$55([
    Input(),
    __metadata$38("design:type", Object)
], NbCalendarRangeDayCellComponent.prototype, "selectedValue", void 0);
__decorate$55([
    Input(),
    __metadata$38("design:type", Object)
], NbCalendarRangeDayCellComponent.prototype, "visibleDate", void 0);
__decorate$55([
    Input(),
    __metadata$38("design:type", Object)
], NbCalendarRangeDayCellComponent.prototype, "min", void 0);
__decorate$55([
    Input(),
    __metadata$38("design:type", Object)
], NbCalendarRangeDayCellComponent.prototype, "max", void 0);
__decorate$55([
    Input(),
    __metadata$38("design:type", Function)
], NbCalendarRangeDayCellComponent.prototype, "filter", void 0);
__decorate$55([
    Output(),
    __metadata$38("design:type", EventEmitter)
], NbCalendarRangeDayCellComponent.prototype, "select", void 0);
__decorate$55([
    HostBinding('class.in-range'),
    __metadata$38("design:type", Boolean),
    __metadata$38("design:paramtypes", [])
], NbCalendarRangeDayCellComponent.prototype, "inRange", null);
__decorate$55([
    HostBinding('class.start'),
    __metadata$38("design:type", Boolean),
    __metadata$38("design:paramtypes", [])
], NbCalendarRangeDayCellComponent.prototype, "start", null);
__decorate$55([
    HostBinding('class.end'),
    __metadata$38("design:type", Boolean),
    __metadata$38("design:paramtypes", [])
], NbCalendarRangeDayCellComponent.prototype, "end", null);
NbCalendarRangeDayCellComponent = __decorate$55([ __metadata$38("design:paramtypes", [NbDateService])
], NbCalendarRangeDayCellComponent);
let NbCalendarRangeYearCellComponent = class NbCalendarRangeYearCellComponent {
    constructor(dateService) {
        this.dateService = dateService;
        this.select = new EventEmitter(true);
    }
    get selected() {
        return this.selectedValue && this.dateService.isSameYear(this.date, this.selectedValue.start);
    }
    get today() {
        return this.date && this.dateService.isSameYear(this.date, this.dateService.today());
    }
    get disabled() {
        return this.smallerThanMin() || this.greaterThanMax();
    }
    get year() {
        return this.dateService.getYear(this.date);
    }
    onClick() {
        if (this.disabled) {
            return;
        }
        this.select.emit(this.date);
    }
    smallerThanMin() {
        return this.date && this.min && this.dateService.compareDates(this.yearEnd(), this.min) < 0;
    }
    greaterThanMax() {
        return this.date && this.max && this.dateService.compareDates(this.yearStart(), this.max) > 0;
    }
    yearStart() {
        return this.dateService.getYearStart(this.date);
    }
    yearEnd() {
        return this.dateService.getYearEnd(this.date);
    }
};
NbCalendarRangeYearCellComponent.ɵfac = function NbCalendarRangeYearCellComponent_Factory(t) { return new (t || NbCalendarRangeYearCellComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarRangeYearCellComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarRangeYearCellComponent, selectors: [["nb-calendar-range-year-cell"]], hostAttrs: [1, "year-cell"], hostVars: 6, hostBindings: function NbCalendarRangeYearCellComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbCalendarRangeYearCellComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("selected", ctx.selected)("today", ctx.today)("disabled", ctx.disabled);
    } }, inputs: { date: "date", min: "min", max: "max", selectedValue: "selectedValue" }, outputs: { select: "select" }, decls: 1, vars: 1, template: function NbCalendarRangeYearCellComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate(ctx.year);
    } }, encapsulation: 2, changeDetection: 0 });
__decorate$55([
    Input(),
    __metadata$38("design:type", Object)
], NbCalendarRangeYearCellComponent.prototype, "date", void 0);
__decorate$55([
    Input(),
    __metadata$38("design:type", Object)
], NbCalendarRangeYearCellComponent.prototype, "min", void 0);
__decorate$55([
    Input(),
    __metadata$38("design:type", Object)
], NbCalendarRangeYearCellComponent.prototype, "max", void 0);
__decorate$55([
    Input(),
    __metadata$38("design:type", Object)
], NbCalendarRangeYearCellComponent.prototype, "selectedValue", void 0);
__decorate$55([
    Output(),
    __metadata$38("design:type", EventEmitter)
], NbCalendarRangeYearCellComponent.prototype, "select", void 0);
__decorate$55([
    HostBinding('class.selected'),
    __metadata$38("design:type", Boolean),
    __metadata$38("design:paramtypes", [])
], NbCalendarRangeYearCellComponent.prototype, "selected", null);
__decorate$55([
    HostBinding('class.today'),
    __metadata$38("design:type", Boolean),
    __metadata$38("design:paramtypes", [])
], NbCalendarRangeYearCellComponent.prototype, "today", null);
__decorate$55([
    HostBinding('class.disabled'),
    __metadata$38("design:type", Boolean),
    __metadata$38("design:paramtypes", [])
], NbCalendarRangeYearCellComponent.prototype, "disabled", null);
__decorate$55([
    HostListener('click'),
    __metadata$38("design:type", Function),
    __metadata$38("design:paramtypes", []),
    __metadata$38("design:returntype", void 0)
], NbCalendarRangeYearCellComponent.prototype, "onClick", null);
NbCalendarRangeYearCellComponent = __decorate$55([ __metadata$38("design:paramtypes", [NbDateService])
], NbCalendarRangeYearCellComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$54 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$37 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * CalendarRange component provides a capability to choose a date range.
 *
 * ```html
 * <nb-calendar [(date)]="date"></nb-calendar>
 * <nb-calendar [date]="date" (dateChange)="handleDateChange($event)"></nb-calendar>
 * ```
 *
 * Basic usage example
 * @stacked-example(Range, calendar/calendar-range-showcase.component)
 *
 * ### Installation
 *
 * Import `NbCalendarRangeModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCalendarRangeModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * ### Usage
 *
 * CalendarRange component supports all of the Calendar component customization properties. More defails can be found
 * in the [Calendar component docs](docs/components/calendar).
 *
 * @styles
 *
 * calendar-width:
 * calendar-body-height:
 * calendar-border-radius:
 * calendar-text-color:
 * calendar-text-font-family:
 * calendar-text-font-size:
 * calendar-text-font-weight:
 * calendar-text-line-height:
 * calendar-header-text-color:
 * calendar-header-text-font-family:
 * calendar-header-title-text-font-size:
 * calendar-header-title-text-font-weight:
 * calendar-header-title-text-line-height:
 * calendar-header-sub-title-text-font-size:
 * calendar-header-sub-title-text-font-weight:
 * calendar-header-sub-title-text-line-height:
 * calendar-navigation-button-width:
 * calendar-cell-inactive-text-color:
 * calendar-cell-in-range-background-color:
 * calendar-cell-disabled-background-color:
 * calendar-cell-disabled-text-color:
 * calendar-cell-selected-background-color:
 * calendar-cell-selected-text-color:
 * calendar-cell-selected-text-font-size:
 * calendar-cell-selected-text-font-weight:
 * calendar-cell-selected-text-line-height:
 * calendar-cell-hover-background-color:
 * calendar-cell-hover-text-color:
 * calendar-cell-hover-text-font-size:
 * calendar-cell-hover-text-font-weight:
 * calendar-cell-hover-text-line-height:
 * calendar-cell-active-background-color:
 * calendar-cell-active-text-color:
 * calendar-cell-active-text-font-size:
 * calendar-cell-active-text-font-weight:
 * calendar-cell-active-text-line-height:
 * calendar-cell-today-background-color:
 * calendar-cell-today-text-color:
 * calendar-cell-today-text-font-size:
 * calendar-cell-today-text-font-weight:
 * calendar-cell-today-text-line-height:
 * calendar-day-cell-width:
 * calendar-day-cell-height:
 * calendar-month-cell-width:
 * calendar-month-cell-height:
 * calendar-year-cell-width:
 * calendar-year-cell-height:
 * calendar-weekday-background:
 * calendar-weekday-divider-color:
 * calendar-weekday-text-color:
 * calendar-weekday-text-font-size:
 * calendar-weekday-text-font-weight:
 * calendar-weekday-text-line-height:
 * calendar-weekday-holiday-text-color:
 * calendar-weekday-height:
 * calendar-weekday-width:
 * calendar-weeknumber-background:
 * calendar-weeknumber-divider-color:
 * calendar-weeknumber-divider-width:
 * calendar-weeknumber-text-color:
 * calendar-weeknumber-text-font-size:
 * calendar-weeknumber-text-font-weight:
 * calendar-weeknumber-text-line-height:
 * calendar-weeknumber-height:
 * calendar-weeknumber-width:
 * calendar-large-width:
 * calendar-large-body-height:
 * calendar-day-cell-large-width:
 * calendar-day-cell-large-height:
 * calendar-weekday-large-height:
 * calendar-weekday-large-width:
 * calendar-month-cell-large-width:
 * calendar-month-cell-large-height:
 * calendar-year-cell-large-width:
 * calendar-year-cell-large-height:
 * */
let NbCalendarRangeComponent = class NbCalendarRangeComponent {
    constructor(dateService) {
        this.dateService = dateService;
        /**
         * Defines if we should render previous and next months
         * in the current month view.
         * */
        this.boundingMonth = true;
        /**
         * Defines starting view for the calendar.
         * */
        this.startView = NbCalendarViewMode.DATE;
        this.dayCellComponent = NbCalendarRangeDayCellComponent;
        this.yearCellComponent = NbCalendarRangeYearCellComponent;
        /**
         * Size of the calendar and entire components.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        /**
         * Determines should we show calendars header or not.
         * */
        this.showHeader = true;
        this._showWeekNumber = false;
        /**
         * Sets symbol used as a header for week numbers column
         * */
        this.weekNumberSymbol = '#';
        /**
         * Emits range when start selected and emits again when end selected.
         * */
        this.rangeChange = new EventEmitter();
    }
    /**
     * Custom day cell component. Have to implement `NbCalendarCell` interface.
     * */
    set _cellComponent(cellComponent) {
        if (cellComponent) {
            this.dayCellComponent = cellComponent;
        }
    }
    /**
     * Custom year cell component. Have to implement `NbCalendarCell` interface.
     * */
    set _yearCellComponent(cellComponent) {
        if (cellComponent) {
            this.yearCellComponent = cellComponent;
        }
    }
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber() {
        return this._showWeekNumber;
    }
    set showWeekNumber(value) {
        this._showWeekNumber = convertToBoolProperty(value);
    }
    onChange(date) {
        this.initDateIfNull();
        this.handleSelected(date);
    }
    initDateIfNull() {
        if (!this.range) {
            this.range = { start: null, end: null };
        }
    }
    handleSelected(date) {
        if (this.selectionStarted()) {
            this.selectEnd(date);
        }
        else {
            this.selectStart(date);
        }
    }
    selectionStarted() {
        const { start, end } = this.range;
        return start && !end;
    }
    selectStart(start) {
        this.selectRange({ start });
    }
    selectEnd(date) {
        const { start } = this.range;
        if (this.dateService.compareDates(date, start) > 0) {
            this.selectRange({ start, end: date });
        }
        else {
            this.selectRange({ start: date, end: start });
        }
    }
    selectRange(range) {
        this.range = range;
        this.rangeChange.emit(range);
    }
};
NbCalendarRangeComponent.ɵfac = function NbCalendarRangeComponent_Factory(t) { return new (t || NbCalendarRangeComponent)(ɵngcc0.ɵɵdirectiveInject(NbDateService)); };
NbCalendarRangeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCalendarRangeComponent, selectors: [["nb-calendar-range"]], inputs: { boundingMonth: "boundingMonth", startView: "startView", size: "size", showHeader: "showHeader", weekNumberSymbol: "weekNumberSymbol", _cellComponent: ["dayCellComponent", "_cellComponent"], _yearCellComponent: ["yearCellComponent", "_yearCellComponent"], showWeekNumber: "showWeekNumber", range: "range", min: "min", max: "max", filter: "filter", monthCellComponent: "monthCellComponent", visibleDate: "visibleDate" }, outputs: { rangeChange: "rangeChange" }, decls: 1, vars: 14, consts: [[3, "date", "min", "max", "filter", "startView", "boundingMonth", "dayCellComponent", "monthCellComponent", "yearCellComponent", "visibleDate", "showHeader", "size", "showWeekNumber", "weekNumberSymbol", "dateChange"]], template: function NbCalendarRangeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-base-calendar", 0);
        ɵngcc0.ɵɵlistener("dateChange", function NbCalendarRangeComponent_Template_nb_base_calendar_dateChange_0_listener($event) { return ctx.onChange($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("date", ctx.range)("min", ctx.min)("max", ctx.max)("filter", ctx.filter)("startView", ctx.startView)("boundingMonth", ctx.boundingMonth)("dayCellComponent", ctx.dayCellComponent)("monthCellComponent", ctx.monthCellComponent)("yearCellComponent", ctx.yearCellComponent)("visibleDate", ctx.visibleDate)("showHeader", ctx.showHeader)("size", ctx.size)("showWeekNumber", ctx.showWeekNumber)("weekNumberSymbol", ctx.weekNumberSymbol);
    } }, directives: [NbBaseCalendarComponent], encapsulation: 2 });
__decorate$54([
    Input(),
    __metadata$37("design:type", Boolean)
], NbCalendarRangeComponent.prototype, "boundingMonth", void 0);
__decorate$54([
    Input(),
    __metadata$37("design:type", String)
], NbCalendarRangeComponent.prototype, "startView", void 0);
__decorate$54([
    Input(),
    __metadata$37("design:type", Object)
], NbCalendarRangeComponent.prototype, "min", void 0);
__decorate$54([
    Input(),
    __metadata$37("design:type", Object)
], NbCalendarRangeComponent.prototype, "max", void 0);
__decorate$54([
    Input(),
    __metadata$37("design:type", Function)
], NbCalendarRangeComponent.prototype, "filter", void 0);
__decorate$54([
    Input('dayCellComponent'),
    __metadata$37("design:type", Type),
    __metadata$37("design:paramtypes", [Type])
], NbCalendarRangeComponent.prototype, "_cellComponent", null);
__decorate$54([
    Input(),
    __metadata$37("design:type", Type)
], NbCalendarRangeComponent.prototype, "monthCellComponent", void 0);
__decorate$54([
    Input('yearCellComponent'),
    __metadata$37("design:type", Type),
    __metadata$37("design:paramtypes", [Type])
], NbCalendarRangeComponent.prototype, "_yearCellComponent", null);
__decorate$54([
    Input(),
    __metadata$37("design:type", String)
], NbCalendarRangeComponent.prototype, "size", void 0);
__decorate$54([
    Input(),
    __metadata$37("design:type", Object)
], NbCalendarRangeComponent.prototype, "visibleDate", void 0);
__decorate$54([
    Input(),
    __metadata$37("design:type", Boolean)
], NbCalendarRangeComponent.prototype, "showHeader", void 0);
__decorate$54([
    Input(),
    __metadata$37("design:type", Object)
], NbCalendarRangeComponent.prototype, "range", void 0);
__decorate$54([
    Input(),
    __metadata$37("design:type", Boolean),
    __metadata$37("design:paramtypes", [Boolean])
], NbCalendarRangeComponent.prototype, "showWeekNumber", null);
__decorate$54([
    Input(),
    __metadata$37("design:type", String)
], NbCalendarRangeComponent.prototype, "weekNumberSymbol", void 0);
__decorate$54([
    Output(),
    __metadata$37("design:type", EventEmitter)
], NbCalendarRangeComponent.prototype, "rangeChange", void 0);
NbCalendarRangeComponent = __decorate$54([ __metadata$37("design:paramtypes", [NbDateService])
], NbCalendarRangeComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$53 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbCalendarRangeModule = class NbCalendarRangeModule {
};
NbCalendarRangeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCalendarRangeModule });
NbCalendarRangeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbCalendarRangeModule_Factory(t) { return new (t || NbCalendarRangeModule)(); }, imports: [[NbBaseCalendarModule]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
function isUrlPathEqual(path, link) {
    const locationPath = getPathPartOfUrl(path);
    return link === locationPath;
}
function isUrlPathContain(path, link) {
    const locationPath = getPathPartOfUrl(path);
    const endOfUrlSegmentRegExp = /\/|^$/;
    return locationPath.startsWith(link) &&
        locationPath.slice(link.length).charAt(0).search(endOfUrlSegmentRegExp) !== -1;
}
function getPathPartOfUrl(url) {
    return url.match(/.*?(?=[?;#]|$)/)[0];
}
function getFragmentPartOfUrl(url) {
    const matched = url.match(/#(.+)/);
    return matched ? matched[1] : '';
}
function isFragmentEqual(path, fragment) {
    return getFragmentPartOfUrl(path) === fragment;
}
function isFragmentContain(path, fragment) {
    return getFragmentPartOfUrl(path).includes(fragment);
}

var __decorate$58 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$40 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * This service determines whether we should scroll the layout back to top.
 * This occurs when the page is changed, so when current url PATH is not equal to the previous one.
 *
 *  TODO: this is most likely a temporary solutions as recently Angular introduces ViewportScroll
 *  and scroll restoration process
 */
let NbRestoreScrollTopHelper = class NbRestoreScrollTopHelper {
    constructor(router) {
        this.router = router;
    }
    shouldRestore() {
        return this.router.events
            .pipe(startWith(null), filter(event => event === null || event instanceof NavigationEnd), pairwise(), map(([prev, current]) => this.pageChanged(prev, current)), filter(res => !!res));
    }
    pageChanged(prev, current) {
        return !prev || getPathPartOfUrl(prev.url) !== getPathPartOfUrl(current.url);
    }
};
NbRestoreScrollTopHelper.ɵfac = function NbRestoreScrollTopHelper_Factory(t) { return new (t || NbRestoreScrollTopHelper)(ɵngcc0.ɵɵinject(ɵngcc5.Router)); };
NbRestoreScrollTopHelper.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbRestoreScrollTopHelper, factory: NbRestoreScrollTopHelper.ɵfac });
NbRestoreScrollTopHelper = __decorate$58([ __metadata$40("design:paramtypes", [Router])
], NbRestoreScrollTopHelper);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$57 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$39 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$10 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Layout container component.
 * When using with Nebular Theme System it is required that all child components should be placed inside.
 *
 * Basic example of two column layout with header:
 *
 * @stacked-example(Showcase, layout/layout-showcase.component)
 *
 * Can contain the following components inside:
 *
 * ```html
 * <nb-layout>
 *  <nb-layout-header></nb-layout-header>
 *  <nb-layout-footer></nb-layout-footer>
 *  <nb-layout-column></nb-layout-column>
 *  <nb-sidebar></nb-sidebar>
 * </nb-layout>
 * ```
 * ### Installation
 *
 * Import `NbLayoutModule` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbLayoutModule,
 *   ],
 * })
 * export class AppModule { }
 * ```
 * ### Usage
 * By default the layout fills up the whole view-port.
 * The window scrollbars are disabled on the body and moved inside of the nb-layout, so that the scrollbars
 * won't mess with the fixed nb-header.
 *
 * The child components are projected into a flexible layout structure allowing to adjust the layout behavior
 * based on the settings provided.
 *
 * The layout content (columns) becomes centered when the window width is more than
 * the value specified in the theme variable `layout-content-width`.
 *
 * The layout also contains the area on the very top (the first child of the nb-layout), which could be used
 * to dynamically append some components like modals or spinners/loaders
 * so that they are located on top of the elements hierarchy.
 * More details are under the `ThemeService` section.
 *
 * The layout component is also responsible for changing application themes.
 * It listens to the `themeChange` event and change a theme CSS class appended to body.
 * Based on the class appended, specific CSS-theme is applied to the application.
 * More details of the Theme System could be found here [Enabling Theme System](#/docs/concepts/theme-system)
 *
 * A simple layout with footer:
 *
 * @stacked-example(Layout With Footer, layout/layout-w-footer.component)
 *
 * It is possible to ask the layout to center the columns (notice: we added a `center` attribute
 * to the layout:
 *
 * ```html
 * <nb-layout center>
 *   <nb-layout-header>Awesome Company</nb-layout-header>
 *
 *   <nb-layout-column>
 *     Hello World!
 *   </nb-layout-column>
 *
 *   <nb-layout-footer>Contact us</nb-layout-footer>
 * </nb-layout>
 * ```
 *
 * @styles
 *
 * layout-background-color:
 * layout-text-color:
 * layout-text-font-family:
 * layout-text-font-size:
 * layout-text-font-weight:
 * layout-text-line-height:
 * layout-min-height:
 * layout-content-width:
 * layout-window-mode-min-width:
 * layout-window-mode-max-width:
 * layout-window-mode-background-color:
 * layout-window-mode-padding-top:
 * layout-window-shadow:
 * layout-padding:
 * layout-medium-padding:
 * layout-small-padding:
 * layout-scrollbar-background-color:
 * layout-scrollbar-color:
 * layout-scrollbar-width:
 */
let NbLayoutComponent = class NbLayoutComponent {
    constructor(themeService, spinnerService, elementRef, renderer, window, document, platformId, layoutDirectionService, scrollService, rulerService, scrollTop, overlayContainer) {
        this.themeService = themeService;
        this.spinnerService = spinnerService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.window = window;
        this.document = document;
        this.platformId = platformId;
        this.layoutDirectionService = layoutDirectionService;
        this.scrollService = scrollService;
        this.rulerService = rulerService;
        this.scrollTop = scrollTop;
        this.overlayContainer = overlayContainer;
        this.scrollBlockClass = 'nb-global-scrollblock';
        this.isScrollBlocked = false;
        this.centerValue = false;
        this.restoreScrollTopValue = true;
        this.windowModeValue = false;
        this.withScrollValue = false;
        this.withSubheader = false;
        this.afterViewInit$ = new BehaviorSubject(null);
        this.alive = true;
        this.registerAsOverlayContainer();
        this.themeService.onThemeChange()
            .pipe(takeWhile(() => this.alive))
            .subscribe((theme) => {
            const body = this.document.getElementsByTagName('body')[0];
            if (theme.previous) {
                this.renderer.removeClass(body, `nb-theme-${theme.previous}`);
            }
            this.renderer.addClass(body, `nb-theme-${theme.name}`);
        });
        this.themeService.onAppendLayoutClass()
            .pipe(takeWhile(() => this.alive))
            .subscribe((className) => {
            this.renderer.addClass(this.elementRef.nativeElement, className);
        });
        this.themeService.onRemoveLayoutClass()
            .pipe(takeWhile(() => this.alive))
            .subscribe((className) => {
            this.renderer.removeClass(this.elementRef.nativeElement, className);
        });
        this.spinnerService.registerLoader(new Promise((resolve, reject) => {
            this.afterViewInit$
                .pipe(takeWhile(() => this.alive))
                .subscribe((_) => resolve());
        }));
        this.spinnerService.load();
        this.rulerService.onGetDimensions()
            .pipe(takeWhile(() => this.alive))
            .subscribe(({ listener }) => {
            listener.next(this.getDimensions());
            listener.complete();
        });
        this.scrollService.onGetPosition()
            .pipe(takeWhile(() => this.alive))
            .subscribe(({ listener }) => {
            listener.next(this.getScrollPosition());
            listener.complete();
        });
        this.scrollTop
            .shouldRestore()
            .pipe(filter(() => this.restoreScrollTopValue), takeWhile(() => this.alive))
            .subscribe(() => {
            this.scroll(0, 0);
        });
        this.scrollService
            .onScrollableChange()
            .pipe(filter(() => this.withScrollValue))
            .subscribe((scrollable) => {
            /**
             * In case when Nebular Layout custom scroll `withScroll` mode is enabled
             * we need to disable default CDK scroll blocker (@link NbBlockScrollStrategyAdapter) on HTML element
             * so that it won't add additional positioning.
             */
            if (scrollable) {
                this.enableScroll();
            }
            else {
                this.blockScroll();
            }
        });
        if (isPlatformBrowser(this.platformId)) {
            // trigger first time so that after the change we have the initial value
            this.themeService.changeWindowWidth(this.window.innerWidth);
        }
    }
    /**
     * Defines whether the layout columns will be centered after some width
     * @param {boolean} val
     */
    set center(val) {
        this.centerValue = convertToBoolProperty(val);
    }
    /**
     * Defines whether the layout enters a 'window' mode, when the layout content (including sidebars and fixed header)
     * becomes centered by width with a margin from the top of the screen, like a floating window.
     * Automatically enables `withScroll` mode, as in the window mode scroll must be inside the layout and cannot be on
     * window. (TODO: check this)
     * @param {boolean} val
     */
    set windowMode(val) {
        this.windowModeValue = convertToBoolProperty(val);
        this.withScroll = this.windowModeValue;
    }
    /**
     * Defines whether to move the scrollbars to layout or leave it at the body level.
     * Automatically set to true when `windowMode` is enabled.
     * @param {boolean} val
     */
    set withScroll(val) {
        this.withScrollValue = convertToBoolProperty(val);
        // TODO: is this the best way of doing it? as we don't have access to body from theme styles
        // TODO: add e2e test
        const body = this.document.getElementsByTagName('body')[0];
        if (this.withScrollValue) {
            this.renderer.setStyle(body, 'overflow', 'hidden');
        }
        else {
            this.renderer.setStyle(body, 'overflow', 'initial');
        }
    }
    /**
     * Restores scroll to the top of the page after navigation
     * @param {boolean} val
     */
    set restoreScrollTop(val) {
        this.restoreScrollTopValue = convertToBoolProperty(val);
    }
    ngAfterViewInit() {
        this.layoutDirectionService.onDirectionChange()
            .pipe(takeWhile(() => this.alive))
            .subscribe(direction => this.document.dir = direction);
        this.scrollService.onManualScroll()
            .pipe(takeWhile(() => this.alive))
            .subscribe(({ x, y }) => this.scroll(x, y));
        this.afterViewInit$.next(true);
    }
    ngOnDestroy() {
        this.alive = false;
        this.unregisterAsOverlayContainer();
    }
    onScroll($event) {
        this.scrollService.fireScrollChange($event);
    }
    onResize(event) {
        this.themeService.changeWindowWidth(event.target.innerWidth);
    }
    /**
     * Returns scroll and client height/width
     *
     * Depending on the current scroll mode (`withScroll=true`) returns sizes from the body element
     * or from the `.scrollable-container`
     * @returns {NbLayoutDimensions}
     */
    getDimensions() {
        let clientWidth, clientHeight, scrollWidth, scrollHeight = 0;
        if (this.withScrollValue) {
            const container = this.scrollableContainerRef.nativeElement;
            clientWidth = container.clientWidth;
            clientHeight = container.clientHeight;
            scrollWidth = container.scrollWidth;
            scrollHeight = container.scrollHeight;
        }
        else {
            const { documentElement, body } = this.document;
            clientWidth = documentElement.clientWidth || body.clientWidth;
            clientHeight = documentElement.clientHeight || body.clientHeight;
            scrollWidth = documentElement.scrollWidth || body.scrollWidth;
            scrollHeight = documentElement.scrollHeight || body.scrollHeight;
        }
        return {
            clientWidth,
            clientHeight,
            scrollWidth,
            scrollHeight,
        };
    }
    /**
     * Returns scroll position of current scroll container.
     *
     * If `withScroll` = true, returns scroll position of the `.scrollable-container` element,
     * otherwise - of the scrollable element of the window (which may be different depending of a browser)
     *
     * @returns {NbScrollPosition}
     */
    getScrollPosition() {
        if (!isPlatformBrowser(this.platformId)) {
            return { x: 0, y: 0 };
        }
        if (this.withScrollValue) {
            const container = this.scrollableContainerRef.nativeElement;
            return { x: container.scrollLeft, y: container.scrollTop };
        }
        const documentRect = this.document.documentElement.getBoundingClientRect();
        const x = -documentRect.left || this.document.body.scrollLeft || this.window.scrollX ||
            this.document.documentElement.scrollLeft || 0;
        const y = -documentRect.top || this.document.body.scrollTop || this.window.scrollY ||
            this.document.documentElement.scrollTop || 0;
        return { x, y };
    }
    registerAsOverlayContainer() {
        if (this.overlayContainer.setContainer) {
            this.overlayContainer.setContainer(this.elementRef.nativeElement);
        }
    }
    unregisterAsOverlayContainer() {
        if (this.overlayContainer.clearContainer) {
            this.overlayContainer.clearContainer();
        }
    }
    scroll(x = null, y = null) {
        const { x: currentX, y: currentY } = this.getScrollPosition();
        x = x == null ? currentX : x;
        y = y == null ? currentY : y;
        if (!isPlatformBrowser(this.platformId)) {
            return;
        }
        if (this.withScrollValue) {
            const scrollable = this.scrollableContainerRef.nativeElement;
            if (scrollable.scrollTo) {
                scrollable.scrollTo(x, y);
            }
            else {
                scrollable.scrollLeft = x;
                scrollable.scrollTop = y;
            }
        }
        else {
            this.window.scrollTo(x, y);
        }
    }
    // TODO: Extract into block scroll strategy
    blockScroll() {
        if (this.isScrollBlocked) {
            return;
        }
        this.isScrollBlocked = true;
        this.renderer.addClass(this.document.documentElement, this.scrollBlockClass);
        const scrollableContainerElement = this.scrollableContainerRef.nativeElement;
        const layoutElement = this.layoutContainerRef.nativeElement;
        const layoutWithScrollWidth = layoutElement.clientWidth;
        this.scrollableContainerOverflowOldValue = scrollableContainerElement.style.overflow;
        scrollableContainerElement.style.overflow = 'hidden';
        const layoutWithoutScrollWidth = layoutElement.clientWidth;
        const scrollWidth = layoutWithoutScrollWidth - layoutWithScrollWidth;
        if (!scrollWidth) {
            return;
        }
        this.layoutPaddingOldValue = {
            left: layoutElement.style.paddingLeft,
            right: layoutElement.style.paddingRight,
        };
        if (this.layoutDirectionService.isLtr()) {
            layoutElement.style.paddingRight = `${scrollWidth}px`;
        }
        else {
            layoutElement.style.paddingLeft = `${scrollWidth}px`;
        }
    }
    enableScroll() {
        if (this.isScrollBlocked) {
            this.isScrollBlocked = false;
            this.renderer.removeClass(this.document.documentElement, this.scrollBlockClass);
            this.scrollableContainerRef.nativeElement.style.overflow = this.scrollableContainerOverflowOldValue;
            if (this.layoutPaddingOldValue) {
                const layoutElement = this.layoutContainerRef.nativeElement;
                layoutElement.style.paddingLeft = this.layoutPaddingOldValue.left;
                layoutElement.style.paddingRight = this.layoutPaddingOldValue.right;
                this.layoutPaddingOldValue = null;
            }
        }
    }
};
NbLayoutComponent.ɵfac = function NbLayoutComponent_Factory(t) { return new (t || NbLayoutComponent)(ɵngcc0.ɵɵdirectiveInject(NbThemeService), ɵngcc0.ɵɵdirectiveInject(NbSpinnerService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NB_WINDOW), ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService), ɵngcc0.ɵɵdirectiveInject(NbLayoutScrollService), ɵngcc0.ɵɵdirectiveInject(NbLayoutRulerService), ɵngcc0.ɵɵdirectiveInject(NbRestoreScrollTopHelper), ɵngcc0.ɵɵdirectiveInject(NbOverlayContainerAdapter)); };
NbLayoutComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbLayoutComponent, selectors: [["nb-layout"]], viewQuery: function NbLayoutComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c9, true, ViewContainerRef);
        ɵngcc0.ɵɵviewQuery(_c10, true, ElementRef);
        ɵngcc0.ɵɵviewQuery(_c11, true, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.veryTopRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.scrollableContainerRef = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.layoutContainerRef = _t.first);
    } }, hostVars: 6, hostBindings: function NbLayoutComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("scroll", function NbLayoutComponent_scroll_HostBindingHandler($event) { return ctx.onScroll($event); }, false, ɵngcc0.ɵɵresolveWindow)("resize", function NbLayoutComponent_resize_HostBindingHandler($event) { return ctx.onResize($event); }, false, ɵngcc0.ɵɵresolveWindow);
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("window-mode", ctx.windowModeValue)("with-scroll", ctx.withScrollValue)("with-subheader", ctx.withSubheader);
    } }, inputs: { center: "center", windowMode: "windowMode", withScroll: "withScroll", restoreScrollTop: "restoreScrollTop" }, ngContentSelectors: _c13, decls: 12, vars: 2, consts: [[1, "scrollable-container", 3, "scroll"], ["scrollableContainer", ""], [1, "layout"], ["layoutContainer", ""], [1, "layout-container"], [1, "content"], [1, "columns"]], template: function NbLayoutComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c12);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵlistener("scroll", function NbLayoutComponent_Template_div_scroll_0_listener($event) { return ctx.onScroll($event); });
        ɵngcc0.ɵɵelementStart(2, "div", 2, 3);
        ɵngcc0.ɵɵprojection(4);
        ɵngcc0.ɵɵelementStart(5, "div", 4);
        ɵngcc0.ɵɵprojection(6, 1);
        ɵngcc0.ɵɵelementStart(7, "div", 5);
        ɵngcc0.ɵɵprojection(8, 2);
        ɵngcc0.ɵɵelementStart(9, "div", 6);
        ɵngcc0.ɵɵprojection(10, 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(11, 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(7);
        ɵngcc0.ɵɵclassProp("center", ctx.centerValue);
    } }, styles: ["[_nghost-%COMP%]{-webkit-font-smoothing:antialiased}[dir=ltr]   [_nghost-%COMP%]{text-align:left}[dir=rtl]   [_nghost-%COMP%]{text-align:right}[_nghost-%COMP%]   .layout[_ngcontent-%COMP%]{display:flex;flex-direction:column}[_nghost-%COMP%]     nb-layout-header{display:block}[_nghost-%COMP%]     nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}[_nghost-%COMP%]     nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.left{order:2}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:2}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.right{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar.end{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]     nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content.center[_ngcontent-%COMP%]{max-width:100%;position:relative;margin-left:auto;margin-right:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:0}[dir=rtl]   [_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.left{order:2}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]   .columns[_ngcontent-%COMP%]     nb-layout-column.start{order:0}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer{display:block;margin-top:auto}[_nghost-%COMP%]   .layout-container[_ngcontent-%COMP%]   .content[_ngcontent-%COMP%]     nb-layout-footer nav{justify-content:center;display:flex}"] });
__decorate$57([
    HostBinding('class.window-mode'),
    __metadata$39("design:type", Boolean)
], NbLayoutComponent.prototype, "windowModeValue", void 0);
__decorate$57([
    HostBinding('class.with-scroll'),
    __metadata$39("design:type", Boolean)
], NbLayoutComponent.prototype, "withScrollValue", void 0);
__decorate$57([
    HostBinding('class.with-subheader'),
    __metadata$39("design:type", Boolean)
], NbLayoutComponent.prototype, "withSubheader", void 0);
__decorate$57([
    Input(),
    __metadata$39("design:type", Boolean),
    __metadata$39("design:paramtypes", [Boolean])
], NbLayoutComponent.prototype, "center", null);
__decorate$57([
    Input(),
    __metadata$39("design:type", Boolean),
    __metadata$39("design:paramtypes", [Boolean])
], NbLayoutComponent.prototype, "windowMode", null);
__decorate$57([
    Input(),
    __metadata$39("design:type", Boolean),
    __metadata$39("design:paramtypes", [Boolean])
], NbLayoutComponent.prototype, "withScroll", null);
__decorate$57([
    Input(),
    __metadata$39("design:type", Boolean),
    __metadata$39("design:paramtypes", [Boolean])
], NbLayoutComponent.prototype, "restoreScrollTop", null);
__decorate$57([
    ViewChild('layoutTopDynamicArea', { read: ViewContainerRef, static: false }),
    __metadata$39("design:type", ViewContainerRef)
], NbLayoutComponent.prototype, "veryTopRef", void 0);
__decorate$57([
    ViewChild('scrollableContainer', { read: ElementRef, static: false }),
    __metadata$39("design:type", ElementRef)
], NbLayoutComponent.prototype, "scrollableContainerRef", void 0);
__decorate$57([
    ViewChild('layoutContainer', { read: ElementRef, static: false }),
    __metadata$39("design:type", ElementRef)
], NbLayoutComponent.prototype, "layoutContainerRef", void 0);
__decorate$57([
    HostListener('window:scroll', ['$event']),
    __metadata$39("design:type", Function),
    __metadata$39("design:paramtypes", [Object]),
    __metadata$39("design:returntype", void 0)
], NbLayoutComponent.prototype, "onScroll", null);
__decorate$57([
    HostListener('window:resize', ['$event']),
    __metadata$39("design:type", Function),
    __metadata$39("design:paramtypes", [Object]),
    __metadata$39("design:returntype", void 0)
], NbLayoutComponent.prototype, "onResize", null);
NbLayoutComponent = __decorate$57([ __param$10(4, Inject(NB_WINDOW)),
    __param$10(5, Inject(NB_DOCUMENT)),
    __param$10(6, Inject(PLATFORM_ID)),
    __metadata$39("design:paramtypes", [NbThemeService,
        NbSpinnerService,
        ElementRef,
        Renderer2, Object, Object, Object,
        NbLayoutDirectionService,
        NbLayoutScrollService,
        NbLayoutRulerService,
        NbRestoreScrollTopHelper,
        NbOverlayContainerAdapter])
], NbLayoutComponent);
/**
 * A container component which determines a content position inside of the layout.
 * The layout could contain unlimited columns (not including the sidebars).
 *
 * By default the columns are ordered from the left to the right,
 * but it's also possible to overwrite this behavior by setting a `left` attribute to the column,
 * moving it to the very first position:
 *
 * @stacked-example(Column Left, layout/layout-column-left.component)
 */
let NbLayoutColumnComponent = class NbLayoutColumnComponent {
    /**
     * Move the column to the very left position in the layout.
     * @param {boolean} val
     */
    set left(val) {
        this.leftValue = convertToBoolProperty(val);
        this.startValue = false;
    }
    /**
     * Make column first in the layout.
     * @param {boolean} val
     */
    set start(val) {
        this.startValue = convertToBoolProperty(val);
        this.leftValue = false;
    }
};
NbLayoutColumnComponent.ɵfac = function NbLayoutColumnComponent_Factory(t) { return new (t || NbLayoutColumnComponent)(); };
NbLayoutColumnComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbLayoutColumnComponent, selectors: [["nb-layout-column"]], hostVars: 4, hostBindings: function NbLayoutColumnComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("left", ctx.leftValue)("start", ctx.startValue);
    } }, inputs: { left: "left", start: "start" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbLayoutColumnComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
__decorate$57([
    HostBinding('class.left'),
    __metadata$39("design:type", Boolean)
], NbLayoutColumnComponent.prototype, "leftValue", void 0);
__decorate$57([
    HostBinding('class.start'),
    __metadata$39("design:type", Boolean)
], NbLayoutColumnComponent.prototype, "startValue", void 0);
__decorate$57([
    Input(),
    __metadata$39("design:type", Boolean),
    __metadata$39("design:paramtypes", [Boolean])
], NbLayoutColumnComponent.prototype, "left", null);
__decorate$57([
    Input(),
    __metadata$39("design:type", Boolean),
    __metadata$39("design:paramtypes", [Boolean])
], NbLayoutColumnComponent.prototype, "start", null);
/**
 * Page header component.
 * Located on top of the page above the layout columns and sidebars.
 * Could be made `fixed` by setting the corresponding property. In the fixed mode the header becomes
 * sticky to the top of the nb-layout (to of the page). Here's an example:
 *
 * @stacked-example(Fixed Header, layout/layout-fixed-header.component)
 *
 * In a pair with sidebar it is possible to setup a configuration when header is placed on a side of the sidebar
 * and not on top of it. To achieve this simply put a `subheader` property to the header like this:
 * ```html
 * <nb-layout-header subheader></nb-layout-header>
 * ```
 * @stacked-example(Subheader, layout/layout-sidebar-subheader.component)
 * Note that in such configuration sidebar shadow is removed and header cannot be make `fixed`.
 *
 * Same way you can put both `fixed` and `clipped` headers adding creating a sub-header for your app:
 *
 * @stacked-example(Subheader, layout/layout-subheader.component)
 *
 * @styles
 *
 * header-background-color:
 * header-text-color:
 * header-text-font-family:
 * header-text-font-size:
 * header-text-font-weight:
 * header-text-line-height:
 * header-height:
 * header-padding:
 * header-shadow:
 */
let NbLayoutHeaderComponent = class NbLayoutHeaderComponent {
    constructor(layout) {
        this.layout = layout;
    }
    /**
     * Makes the header sticky to the top of the nb-layout.
     * @param {boolean} val
     */
    set fixed(val) {
        this.fixedValue = convertToBoolProperty(val);
    }
    /**
     * Places header on a side of the sidebar, and not above.
     * Disables fixed mode for this header and remove a shadow from the sidebar.
     * @param {boolean} val
     */
    set subheader(val) {
        this.subheaderValue = convertToBoolProperty(val);
        this.fixedValue = false;
        this.layout.withSubheader = this.subheaderValue;
    }
};
NbLayoutHeaderComponent.ɵfac = function NbLayoutHeaderComponent_Factory(t) { return new (t || NbLayoutHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(NbLayoutComponent)); };
NbLayoutHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbLayoutHeaderComponent, selectors: [["nb-layout-header"]], hostVars: 4, hostBindings: function NbLayoutHeaderComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("fixed", ctx.fixedValue)("subheader", ctx.subheaderValue);
    } }, inputs: { fixed: "fixed", subheader: "subheader" }, ngContentSelectors: _c0, decls: 2, vars: 2, template: function NbLayoutHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "nav");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("fixed", ctx.fixedValue);
    } }, encapsulation: 2 });
__decorate$57([
    HostBinding('class.fixed'),
    __metadata$39("design:type", Boolean)
], NbLayoutHeaderComponent.prototype, "fixedValue", void 0);
__decorate$57([
    HostBinding('class.subheader'),
    __metadata$39("design:type", Boolean)
], NbLayoutHeaderComponent.prototype, "subheaderValue", void 0);
__decorate$57([
    Input(),
    __metadata$39("design:type", Boolean),
    __metadata$39("design:paramtypes", [Boolean])
], NbLayoutHeaderComponent.prototype, "fixed", null);
__decorate$57([
    Input(),
    __metadata$39("design:type", Boolean),
    __metadata$39("design:paramtypes", [Boolean])
], NbLayoutHeaderComponent.prototype, "subheader", null);
NbLayoutHeaderComponent = __decorate$57([ __metadata$39("design:paramtypes", [NbLayoutComponent])
], NbLayoutHeaderComponent);
/**
 * Page footer.
 * Located under the nb-layout content (specifically, under the columns).
 * Could be made `fixed`, becoming sticky to the bottom of the view port (window).
 *
 * @styles
 *
 * footer-background-color:
 * footer-text-color:
 * footer-text-font-family:
 * footer-text-font-size:
 * footer-text-font-weight:
 * footer-text-line-height:
 * footer-text-highlight-color:
 * footer-height:
 * footer-padding:
 * footer-divider-color:
 * footer-divider-style:
 * footer-divider-width:
 * footer-shadow:
 */
let NbLayoutFooterComponent = class NbLayoutFooterComponent {
    /**
     * Makes the footer sticky to the bottom of the window.
     * @param {boolean} val
     */
    set fixed(val) {
        this.fixedValue = convertToBoolProperty(val);
    }
};
NbLayoutFooterComponent.ɵfac = function NbLayoutFooterComponent_Factory(t) { return new (t || NbLayoutFooterComponent)(); };
NbLayoutFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbLayoutFooterComponent, selectors: [["nb-layout-footer"]], hostVars: 2, hostBindings: function NbLayoutFooterComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("fixed", ctx.fixedValue);
    } }, inputs: { fixed: "fixed" }, ngContentSelectors: _c0, decls: 2, vars: 2, template: function NbLayoutFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "nav");
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("fixed", ctx.fixedValue);
    } }, encapsulation: 2 });
__decorate$57([
    HostBinding('class.fixed'),
    __metadata$39("design:type", Boolean)
], NbLayoutFooterComponent.prototype, "fixedValue", void 0);
__decorate$57([
    Input(),
    __metadata$39("design:type", Boolean),
    __metadata$39("design:paramtypes", [Boolean])
], NbLayoutFooterComponent.prototype, "fixed", null);

var __decorate$56 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_LAYOUT_COMPONENTS = [
    NbLayoutComponent,
    NbLayoutColumnComponent,
    NbLayoutFooterComponent,
    NbLayoutHeaderComponent,
];
let NbLayoutModule = class NbLayoutModule {
};
NbLayoutModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbLayoutModule });
NbLayoutModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbLayoutModule_Factory(t) { return new (t || NbLayoutModule)(); }, providers: [
        NbRestoreScrollTopHelper,
    ], imports: [[
            NbSharedModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$61 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$42 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
const itemClick$ = new Subject();
const addItems$ = new ReplaySubject(1);
const navigateHome$ = new ReplaySubject(1);
const getSelectedItem$ = new ReplaySubject(1);
const itemSelect$ = new ReplaySubject(1);
const itemHover$ = new ReplaySubject(1);
const submenuToggle$ = new ReplaySubject(1);
const collapseAll$ = new ReplaySubject(1);
// TODO: check if we need both URL and LINK
/**
 *
 *
 * Menu Item options example
 * @stacked-example(Menu Link Parameters, menu/menu-link-params.component)
 *
 *
 */
class NbMenuItem {
    constructor() {
        /**
         * Item is selected when partly or fully equal to the current url
         * @type {string}
         */
        this.pathMatch = 'full';
    }
    /**
     * @returns item parents in top-down order
     */
    static getParents(item) {
        const parents = [];
        let parent = item.parent;
        while (parent) {
            parents.unshift(parent);
            parent = parent.parent;
        }
        return parents;
    }
    static isParent(item, possibleChild) {
        return possibleChild.parent
            ? possibleChild.parent === item || this.isParent(item, possibleChild.parent)
            : false;
    }
}
// TODO: map select events to router change events
// TODO: review the interface
/**
 *
 *
 * Menu Service. Allows you to listen to menu events, or to interact with a menu.
 * @stacked-example(Menu Service, menu/menu-service.component)
 *
 *
 */
let NbMenuService = class NbMenuService {
    /**
     * Add items to the end of the menu items list
     * @param {List<NbMenuItem>} items
     * @param {string} tag
     */
    addItems(items, tag) {
        addItems$.next({ tag, items });
    }
    /**
     * Collapses all menu items
     * @param {string} tag
     */
    collapseAll(tag) {
        collapseAll$.next({ tag });
    }
    /**
     * Navigate to the home menu item
     * @param {string} tag
     */
    navigateHome(tag) {
        navigateHome$.next({ tag });
    }
    /**
     * Returns currently selected item. Won't subscribe to the future events.
     * @param {string} tag
     * @returns {Observable<{tag: string; item: NbMenuItem}>}
     */
    getSelectedItem(tag) {
        const listener = new BehaviorSubject(null);
        getSelectedItem$.next({ tag, listener });
        return listener.asObservable();
    }
    onItemClick() {
        return itemClick$.pipe(share());
    }
    onItemSelect() {
        return itemSelect$.pipe(share());
    }
    onItemHover() {
        return itemHover$.pipe(share());
    }
    onSubmenuToggle() {
        return submenuToggle$.pipe(share());
    }
};
NbMenuService.ɵfac = function NbMenuService_Factory(t) { return new (t || NbMenuService)(); };
NbMenuService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbMenuService, factory: NbMenuService.ɵfac });
let NbMenuInternalService = class NbMenuInternalService {
    constructor(location) {
        this.location = location;
    }
    prepareItems(items) {
        const defaultItem = new NbMenuItem();
        items.forEach(i => {
            this.applyDefaults(i, defaultItem);
            this.setParent(i);
        });
    }
    selectFromUrl(items, tag, collapseOther = false) {
        const selectedItem = this.findItemByUrl(items);
        if (selectedItem) {
            this.selectItem(selectedItem, items, collapseOther, tag);
        }
    }
    selectItem(item, items, collapseOther = false, tag) {
        const unselectedItems = this.resetSelection(items);
        const collapsedItems = collapseOther ? this.collapseItems(items) : [];
        for (const parent of NbMenuItem.getParents(item)) {
            parent.selected = true;
            // emit event only for items that weren't selected before ('unselectedItems' contains items that were selected)
            if (!unselectedItems.includes(parent)) {
                this.itemSelect(parent, tag);
            }
            const wasNotExpanded = !parent.expanded;
            parent.expanded = true;
            const i = collapsedItems.indexOf(parent);
            // emit event only for items that weren't expanded before.
            // 'collapsedItems' contains items that were expanded, so no need to emit event.
            // in case 'collapseOther' is false, 'collapsedItems' will be empty,
            // so also check if item isn't expanded already ('wasNotExpanded').
            if (i === -1 && wasNotExpanded) {
                this.submenuToggle(parent, tag);
            }
            else {
                collapsedItems.splice(i, 1);
            }
        }
        item.selected = true;
        // emit event only for items that weren't selected before ('unselectedItems' contains items that were selected)
        if (!unselectedItems.includes(item)) {
            this.itemSelect(item, tag);
        }
        // remaining items which wasn't expanded back after expanding all currently selected items
        for (const collapsedItem of collapsedItems) {
            this.submenuToggle(collapsedItem, tag);
        }
    }
    collapseAll(items, tag, except) {
        const collapsedItems = this.collapseItems(items, except);
        for (const item of collapsedItems) {
            this.submenuToggle(item, tag);
        }
    }
    onAddItem() {
        return addItems$.pipe(share());
    }
    onNavigateHome() {
        return navigateHome$.pipe(share());
    }
    onCollapseAll() {
        return collapseAll$.pipe(share());
    }
    onGetSelectedItem() {
        return getSelectedItem$.pipe(share());
    }
    itemHover(item, tag) {
        itemHover$.next({ tag, item });
    }
    submenuToggle(item, tag) {
        submenuToggle$.next({ tag, item });
    }
    itemSelect(item, tag) {
        itemSelect$.next({ tag, item });
    }
    itemClick(item, tag) {
        itemClick$.next({ tag, item });
    }
    /**
     * Unselect all given items deeply.
     * @param items array of items to unselect.
     * @returns items which selected value was changed.
     */
    resetSelection(items) {
        const unselectedItems = [];
        for (const item of items) {
            if (item.selected) {
                unselectedItems.push(item);
            }
            item.selected = false;
            if (item.children) {
                unselectedItems.push(...this.resetSelection(item.children));
            }
        }
        return unselectedItems;
    }
    /**
     * Collapse all given items deeply.
     * @param items array of items to collapse.
     * @param except menu item which shouldn't be collapsed, also disables collapsing for parents of this item.
     * @returns items which expanded value was changed.
     */
    collapseItems(items, except) {
        const collapsedItems = [];
        for (const item of items) {
            if (except && (item === except || NbMenuItem.isParent(item, except))) {
                continue;
            }
            if (item.expanded) {
                collapsedItems.push(item);
            }
            item.expanded = false;
            if (item.children) {
                collapsedItems.push(...this.collapseItems(item.children));
            }
        }
        return collapsedItems;
    }
    applyDefaults(item, defaultItem) {
        const menuItem = Object.assign({}, item);
        Object.assign(item, defaultItem, menuItem);
        item.children && item.children.forEach(child => {
            this.applyDefaults(child, defaultItem);
        });
    }
    setParent(item) {
        item.children && item.children.forEach(child => {
            child.parent = item;
            this.setParent(child);
        });
    }
    /**
     * Find deepest item which link matches current URL path.
     * @param items array of items to search in.
     * @returns found item of undefined.
     */
    findItemByUrl(items) {
        let selectedItem;
        items.some(item => {
            if (item.children) {
                selectedItem = this.findItemByUrl(item.children);
            }
            if (!selectedItem && this.isSelectedInUrl(item)) {
                selectedItem = item;
            }
            return selectedItem;
        });
        return selectedItem;
    }
    isSelectedInUrl(item) {
        const exact = item.pathMatch === 'full';
        const link = item.link;
        const isSelectedInPath = exact
            ? isUrlPathEqual(this.location.path(), link)
            : isUrlPathContain(this.location.path(), link);
        if (isSelectedInPath && item.fragment != null) {
            return exact
                ? isFragmentEqual(this.location.path(true), item.fragment)
                : isFragmentContain(this.location.path(true), item.fragment);
        }
        return isSelectedInPath;
    }
};
NbMenuInternalService.ɵfac = function NbMenuInternalService_Factory(t) { return new (t || NbMenuInternalService)(ɵngcc0.ɵɵinject(ɵngcc2.Location)); };
NbMenuInternalService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbMenuInternalService, factory: NbMenuInternalService.ɵfac });
NbMenuInternalService = __decorate$61([ __metadata$42("design:paramtypes", [Location])
], NbMenuInternalService);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$60 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$41 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$11 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NbToggleStates;
(function (NbToggleStates) {
    NbToggleStates["Expanded"] = "expanded";
    NbToggleStates["Collapsed"] = "collapsed";
})(NbToggleStates || (NbToggleStates = {}));
let NbMenuItemComponent = class NbMenuItemComponent {
    constructor(menuService, directionService) {
        this.menuService = menuService;
        this.directionService = directionService;
        this.menuItem = null;
        this.hoverItem = new EventEmitter();
        this.toggleSubMenu = new EventEmitter();
        this.selectItem = new EventEmitter();
        this.itemClick = new EventEmitter();
        this.alive = true;
    }
    ngDoCheck() {
        this.toggleState = this.menuItem.expanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed;
    }
    ngAfterViewInit() {
        this.menuService.onSubmenuToggle()
            .pipe(takeWhile(() => this.alive), filter(({ item }) => item === this.menuItem), map(({ item }) => item.expanded))
            .subscribe(isExpanded => this.toggleState = isExpanded ? NbToggleStates.Expanded : NbToggleStates.Collapsed);
    }
    ngOnDestroy() {
        this.alive = false;
    }
    onToggleSubMenu(item) {
        this.toggleSubMenu.emit(item);
    }
    onHoverItem(item) {
        this.hoverItem.emit(item);
    }
    onSelectItem(item) {
        this.selectItem.emit(item);
    }
    onItemClick(item) {
        this.itemClick.emit(item);
    }
    getExpandStateIcon() {
        if (this.menuItem.expanded) {
            return 'chevron-down-outline';
        }
        return this.directionService.isLtr()
            ? 'chevron-left-outline'
            : 'chevron-right-outline';
    }
};
NbMenuItemComponent.ɵfac = function NbMenuItemComponent_Factory(t) { return new (t || NbMenuItemComponent)(ɵngcc0.ɵɵdirectiveInject(NbMenuService), ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService)); };
NbMenuItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbMenuItemComponent, selectors: [["", "nbMenuItem", ""]], inputs: { menuItem: "menuItem" }, outputs: { hoverItem: "hoverItem", toggleSubMenu: "toggleSubMenu", selectItem: "selectItem", itemClick: "itemClick" }, attrs: _c14, decls: 6, vars: 6, consts: [[4, "ngIf"], [3, "routerLink", "queryParams", "fragment", "skipLocationChange", "active", "mouseenter", "click", 4, "ngIf"], [3, "active", "mouseenter", "click", 4, "ngIf"], ["href", "#", 3, "active", "click", "mouseenter", 4, "ngIf"], ["class", "menu-items", 3, "collapsed", "expanded", 4, "ngIf"], ["class", "menu-icon", 3, "config", 4, "ngIf"], [1, "menu-icon", 3, "config"], [3, "routerLink", "queryParams", "fragment", "skipLocationChange", "mouseenter", "click"], [1, "menu-title"], [3, "mouseenter", "click"], ["href", "#", 3, "click", "mouseenter"], ["pack", "nebular-essentials", 1, "expand-state", 3, "icon"], [1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "menuItem", "hoverItem", "toggleSubMenu", "selectItem", "itemClick"]], template: function NbMenuItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbMenuItemComponent_span_0_Template, 3, 2, "span", 0);
        ɵngcc0.ɵɵtemplate(1, NbMenuItemComponent_a_1_Template, 4, 10, "a", 1);
        ɵngcc0.ɵɵtemplate(2, NbMenuItemComponent_a_2_Template, 4, 7, "a", 2);
        ɵngcc0.ɵɵtemplate(3, NbMenuItemComponent_a_3_Template, 4, 6, "a", 2);
        ɵngcc0.ɵɵtemplate(4, NbMenuItemComponent_a_4_Template, 5, 7, "a", 3);
        ɵngcc0.ɵɵtemplate(5, NbMenuItemComponent_ul_5_Template, 2, 6, "ul", 4);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItem.group);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.group);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItem.url && !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.group);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.menuItem.children && !ctx.menuItem.link && !ctx.menuItem.url && !ctx.menuItem.group);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItem.children);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.menuItem.children);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent, ɵngcc5.RouterLinkWithHref, ɵngcc2.NgForOf, NbMenuItemComponent], encapsulation: 2, data: { animation: [
            trigger('toggle', [
                state(NbToggleStates.Collapsed, style({ height: '0', margin: '0' })),
                state(NbToggleStates.Expanded, style({ height: '*' })),
                transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300)),
            ]),
        ] } });
__decorate$60([
    Input(),
    __metadata$41("design:type", Object)
], NbMenuItemComponent.prototype, "menuItem", void 0);
__decorate$60([
    Output(),
    __metadata$41("design:type", Object)
], NbMenuItemComponent.prototype, "hoverItem", void 0);
__decorate$60([
    Output(),
    __metadata$41("design:type", Object)
], NbMenuItemComponent.prototype, "toggleSubMenu", void 0);
__decorate$60([
    Output(),
    __metadata$41("design:type", Object)
], NbMenuItemComponent.prototype, "selectItem", void 0);
__decorate$60([
    Output(),
    __metadata$41("design:type", Object)
], NbMenuItemComponent.prototype, "itemClick", void 0);
NbMenuItemComponent = __decorate$60([ __metadata$41("design:paramtypes", [NbMenuService,
        NbLayoutDirectionService])
], NbMenuItemComponent);
/**
 * Vertical menu component.
 *
 * Accepts a list of menu items and renders them accordingly. Supports multi-level menus.
 *
 * Basic example
 * @stacked-example(Showcase, menu/menu-showcase.component)
 *
 * ```ts
 * // ...
 * items: NbMenuItem[] = [
 *  {
 *    title: home,
 *    link: '/'
 *  },
 *  {
 *    title: dashboard,
 *    link: 'dashboard'
 *  }
 * ];
 * // ...
 * <nb-menu [items]="items"></nb-menu>
 * ```
 * ### Installation
 *
 * Import `NbMenuModule.forRoot()` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbMenuModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * and `NbMenuModule` to your feature module where the component should be shown:
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbMenuModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Two-level menu example
 * @stacked-example(Two Levels, menu/menu-children.component)
 *
 *
 * Autocollapse menu example
 * @stacked-example(Autocollapse Menu, menu/menu-autocollapse.component)
 *
 *
 * @styles
 *
 * menu-background-color:
 * menu-text-color:
 * menu-text-font-family:
 * menu-text-font-size:
 * menu-text-font-weight:
 * menu-text-line-height:
 * menu-group-text-color:
 * menu-item-border-radius:
 * menu-item-padding:
 * menu-item-hover-background-color:
 * menu-item-hover-cursor:
 * menu-item-hover-text-color:
 * menu-item-icon-hover-color:
 * menu-item-active-background-color:
 * menu-item-active-text-color:
 * menu-item-icon-active-color:
 * menu-item-icon-color:
 * menu-item-icon-margin:
 * menu-item-icon-width:
 * menu-item-divider-color:
 * menu-item-divider-style:
 * menu-item-divider-width:
 * menu-submenu-background-color:
 * menu-submenu-text-color:
 * menu-submenu-margin:
 * menu-submenu-padding:
 * menu-submenu-item-border-color:
 * menu-submenu-item-border-style:
 * menu-submenu-item-border-width:
 * menu-submenu-item-border-radius:
 * menu-submenu-item-padding:
 * menu-submenu-item-hover-background-color:
 * menu-submenu-item-hover-border-color:
 * menu-submenu-item-hover-text-color:
 * menu-submenu-item-icon-hover-color:
 * menu-submenu-item-active-background-color:
 * menu-submenu-item-active-border-color:
 * menu-submenu-item-active-text-color:
 * menu-submenu-item-icon-active-color:
 * menu-submenu-item-active-hover-background-color:
 * menu-submenu-item-active-hover-border-color:
 * menu-submenu-item-active-hover-text-color:
 * menu-submenu-item-icon-active-hover-color:
 */
let NbMenuComponent = class NbMenuComponent {
    constructor(window, platformId, menuInternalService, router) {
        this.window = window;
        this.platformId = platformId;
        this.menuInternalService = menuInternalService;
        this.router = router;
        this._autoCollapse = false;
        this.alive = true;
    }
    /**
     * Collapse all opened submenus on the toggle event
     * Default value is "false"
     * @type boolean
     */
    get autoCollapse() {
        return this._autoCollapse;
    }
    set autoCollapse(value) {
        this._autoCollapse = convertToBoolProperty(value);
    }
    ngOnInit() {
        this.menuInternalService.prepareItems(this.items);
        this.menuInternalService
            .onAddItem()
            .pipe(takeWhile(() => this.alive), filter((data) => this.compareTag(data.tag)))
            .subscribe(data => this.onAddItem(data));
        this.menuInternalService
            .onNavigateHome()
            .pipe(takeWhile(() => this.alive), filter((data) => this.compareTag(data.tag)))
            .subscribe(() => this.navigateHome());
        this.menuInternalService
            .onGetSelectedItem()
            .pipe(takeWhile(() => this.alive), filter((data) => this.compareTag(data.tag)))
            .subscribe((data) => {
            data.listener.next({ tag: this.tag, item: this.getSelectedItem(this.items) });
        });
        this.menuInternalService
            .onCollapseAll()
            .pipe(takeWhile(() => this.alive), filter((data) => this.compareTag(data.tag)))
            .subscribe(() => this.collapseAll());
        this.router.events
            .pipe(takeWhile(() => this.alive), filter(event => event instanceof NavigationEnd))
            .subscribe(() => {
            this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
        });
    }
    ngAfterViewInit() {
        setTimeout(() => this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse));
    }
    onAddItem(data) {
        this.items.push(...data.items);
        this.menuInternalService.prepareItems(this.items);
        this.menuInternalService.selectFromUrl(this.items, this.tag, this.autoCollapse);
    }
    onHoverItem(item) {
        this.menuInternalService.itemHover(item, this.tag);
    }
    onToggleSubMenu(item) {
        if (this.autoCollapse) {
            this.menuInternalService.collapseAll(this.items, this.tag, item);
        }
        item.expanded = !item.expanded;
        this.menuInternalService.submenuToggle(item, this.tag);
    }
    // TODO: is not fired on page reload
    onSelectItem(item) {
        this.menuInternalService.selectItem(item, this.items, this.autoCollapse, this.tag);
    }
    onItemClick(item) {
        this.menuInternalService.itemClick(item, this.tag);
    }
    ngOnDestroy() {
        this.alive = false;
    }
    navigateHome() {
        const homeItem = this.getHomeItem(this.items);
        if (homeItem) {
            if (homeItem.link) {
                this.router.navigate([homeItem.link], { queryParams: homeItem.queryParams, fragment: homeItem.fragment });
            }
            if (homeItem.url && isPlatformBrowser(this.platformId)) {
                this.window.location.href = homeItem.url;
            }
        }
    }
    collapseAll() {
        this.menuInternalService.collapseAll(this.items, this.tag);
    }
    getHomeItem(items) {
        for (const item of items) {
            if (item.home) {
                return item;
            }
            const homeItem = item.children && this.getHomeItem(item.children);
            if (homeItem) {
                return homeItem;
            }
        }
    }
    compareTag(tag) {
        return !tag || tag === this.tag;
    }
    getSelectedItem(items) {
        let selected = null;
        items.forEach((item) => {
            if (item.selected) {
                selected = item;
            }
            if (item.selected && item.children && item.children.length > 0) {
                selected = this.getSelectedItem(item.children);
            }
        });
        return selected;
    }
};
NbMenuComponent.ɵfac = function NbMenuComponent_Factory(t) { return new (t || NbMenuComponent)(ɵngcc0.ɵɵdirectiveInject(NB_WINDOW), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(NbMenuInternalService), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Router)); };
NbMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbMenuComponent, selectors: [["nb-menu"]], inputs: { autoCollapse: "autoCollapse", tag: "tag", items: "items" }, decls: 2, vars: 1, consts: [[1, "menu-items"], [4, "ngFor", "ngForOf"], ["nbMenuItem", "", "class", "menu-item", 3, "menuItem", "menu-group", "hoverItem", "toggleSubMenu", "selectItem", "itemClick", 4, "ngIf"], ["nbMenuItem", "", 1, "menu-item", 3, "menuItem", "hoverItem", "toggleSubMenu", "selectItem", "itemClick"]], template: function NbMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, NbMenuComponent_ng_container_1_Template, 2, 1, "ng-container", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.items);
    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgIf, NbMenuItemComponent], styles: ["[_nghost-%COMP%]    {display:block}[_nghost-%COMP%]     .menu-items, [_nghost-%COMP%]     .menu-item>.menu-items{list-style-type:none;overflow:hidden}[_nghost-%COMP%]     .menu-item a{display:flex;color:inherit;text-decoration:none;align-items:center}[_nghost-%COMP%]     .menu-item a .menu-title{flex:1 0 auto}[dir=rtl]   [_nghost-%COMP%]     .menu-item a .menu-title{text-align:right}[_nghost-%COMP%]     .menu-group span{display:flex}"] });
__decorate$60([
    Input(),
    __metadata$41("design:type", String)
], NbMenuComponent.prototype, "tag", void 0);
__decorate$60([
    Input(),
    __metadata$41("design:type", Array)
], NbMenuComponent.prototype, "items", void 0);
__decorate$60([
    Input(),
    __metadata$41("design:type", Boolean),
    __metadata$41("design:paramtypes", [Boolean])
], NbMenuComponent.prototype, "autoCollapse", null);
NbMenuComponent = __decorate$60([ __param$11(0, Inject(NB_WINDOW)),
    __param$11(1, Inject(PLATFORM_ID)),
    __metadata$41("design:paramtypes", [Object, Object, NbMenuInternalService,
        Router])
], NbMenuComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$59 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbMenuModule_1;
const nbMenuComponents = [NbMenuComponent, NbMenuItemComponent];
const NB_MENU_PROVIDERS = [NbMenuService, NbMenuInternalService];
let NbMenuModule = NbMenuModule_1 = class NbMenuModule {
    static forRoot() {
        return {
            ngModule: NbMenuModule_1,
            providers: [
                ...NB_MENU_PROVIDERS,
            ],
        };
    }
};
NbMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbMenuModule });
NbMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbMenuModule_Factory(t) { return new (t || NbMenuModule)(); }, imports: [[NbSharedModule, NbIconModule]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$63 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$43 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Route tabset components.
 * Renders tabs inside of a router-outlet.
 *
 * ```ts
 *  tabs = [
 *  {
 *    title: 'Route tab #1',
 *    route: '/pages/description',
 *    icon: 'home',
 *    responsive: true, // hide title before `route-tabs-icon-only-max-width` value
 *  },
 *  {
 *    title: 'Route tab #2',
 *    route: '/pages/images',
 *    }
 *  ];
 *
 *  <nb-route-tabset [tabs]="tabs"></nb-route-tabset>
 * ```
 * ### Installation
 *
 * Import `NbRouteTabsetModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbRouteTabsetModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * @stacked-example(Route Tabset, tabset/route-tabset-showcase.component)
 *
 * @styles
 *
 * route-tabset-background-color:
 * route-tabset-border-radius:
 * route-tabset-shadow:
 * route-tabset-tab-background-color:
 * route-tabset-tab-padding:
 * route-tabset-tab-text-color:
 * route-tabset-tab-text-font-family:
 * route-tabset-tab-text-font-size:
 * route-tabset-tab-text-font-weight:
 * route-tabset-tab-text-line-height:
 * route-tabset-tab-text-transform:
 * route-tabset-tab-underline-width:
 * route-tabset-tab-underline-color:
 * route-tabset-tab-active-background-color:
 * route-tabset-tab-active-text-color:
 * route-tabset-tab-active-underline-color:
 * route-tabset-tab-focus-background-color:
 * route-tabset-tab-focus-text-color:
 * route-tabset-tab-focus-underline-color:
 * route-tabset-tab-hover-background-color:
 * route-tabset-tab-hover-text-color:
 * route-tabset-tab-hover-underline-color:
 * route-tabset-tab-disabled-background-color:
 * route-tabset-tab-disabled-text-color:
 * route-tabset-tab-disabled-underline-color:
 * route-tabset-divider-color:
 * route-tabset-divider-style:
 * route-tabset-divider-width:
 * route-tabset-scrollbar-color:
 * route-tabset-scrollbar-background-color:
 * route-tabset-scrollbar-width:
 * route-tabset-tab-text-hide-breakpoint:
 */
let NbRouteTabsetComponent = class NbRouteTabsetComponent {
    /**
     * Route tabset components.
     * Renders tabs inside of a router-outlet.
     *
     * ```ts
     *  tabs = [
     *  {
     *    title: 'Route tab #1',
     *    route: '/pages/description',
     *    icon: 'home',
     *    responsive: true, // hide title before `route-tabs-icon-only-max-width` value
     *  },
     *  {
     *    title: 'Route tab #2',
     *    route: '/pages/images',
     *    }
     *  ];
     *
     *  <nb-route-tabset [tabs]="tabs"></nb-route-tabset>
     * ```
     * ### Installation
     *
     * Import `NbRouteTabsetModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbRouteTabsetModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     *
     * @stacked-example(Route Tabset, tabset/route-tabset-showcase.component)
     *
     * @styles
     *
     * route-tabset-background-color:
     * route-tabset-border-radius:
     * route-tabset-shadow:
     * route-tabset-tab-background-color:
     * route-tabset-tab-padding:
     * route-tabset-tab-text-color:
     * route-tabset-tab-text-font-family:
     * route-tabset-tab-text-font-size:
     * route-tabset-tab-text-font-weight:
     * route-tabset-tab-text-line-height:
     * route-tabset-tab-text-transform:
     * route-tabset-tab-underline-width:
     * route-tabset-tab-underline-color:
     * route-tabset-tab-active-background-color:
     * route-tabset-tab-active-text-color:
     * route-tabset-tab-active-underline-color:
     * route-tabset-tab-focus-background-color:
     * route-tabset-tab-focus-text-color:
     * route-tabset-tab-focus-underline-color:
     * route-tabset-tab-hover-background-color:
     * route-tabset-tab-hover-text-color:
     * route-tabset-tab-hover-underline-color:
     * route-tabset-tab-disabled-background-color:
     * route-tabset-tab-disabled-text-color:
     * route-tabset-tab-disabled-underline-color:
     * route-tabset-divider-color:
     * route-tabset-divider-style:
     * route-tabset-divider-width:
     * route-tabset-scrollbar-color:
     * route-tabset-scrollbar-background-color:
     * route-tabset-scrollbar-width:
     * route-tabset-tab-text-hide-breakpoint:
     */
    constructor() {
        this.fullWidthValue = false;
        /**
         * Options passed to `routerLinkActiveOptions` directive which set on tab links.
         * `{ exact: true }` by default.
         */
        this.activeLinkOptions = { exact: true };
        /**
         * Emits when tab is selected
         * @type {EventEmitter<any>}
         */
        this.changeTab = new EventEmitter();
    }
    /**
     * Take full width of a parent
     * @param {boolean} val
     */
    set fullWidth(val) {
        this.fullWidthValue = convertToBoolProperty(val);
    }
    selectTab(tab) {
        this.changeTab.emit(tab);
    }
};
NbRouteTabsetComponent.ɵfac = function NbRouteTabsetComponent_Factory(t) { return new (t || NbRouteTabsetComponent)(); };
NbRouteTabsetComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRouteTabsetComponent, selectors: [["nb-route-tabset"]], hostVars: 2, hostBindings: function NbRouteTabsetComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("full-width", ctx.fullWidthValue);
    } }, inputs: { activeLinkOptions: "activeLinkOptions", fullWidth: "fullWidth", tabs: "tabs" }, outputs: { changeTab: "changeTab" }, decls: 3, vars: 1, consts: [[1, "route-tabset"], [4, "ngFor", "ngForOf"], ["class", "route-tab disabled", "tabindex", "-1", 3, "responsive", 4, "ngIf", "ngIfElse"], ["enabled", ""], ["tabindex", "-1", 1, "route-tab", "disabled"], ["tabindex", "-1", 1, "tab-link"], [3, "config", 4, "ngIf"], ["class", "tab-text", 4, "ngIf"], [3, "config"], [1, "tab-text"], ["routerLinkActive", "active", "tabindex", "0", 1, "route-tab", 3, "routerLink", "routerLinkActiveOptions", "click"], [3, "icon", 4, "ngIf"], [3, "icon"]], template: function NbRouteTabsetComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, NbRouteTabsetComponent_ng_container_1_Template, 4, 2, "ng-container", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(2, "router-outlet");
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
    } }, directives: [ɵngcc2.NgForOf, ɵngcc5.RouterOutlet, ɵngcc2.NgIf, NbIconComponent, ɵngcc5.RouterLinkActive, ɵngcc5.RouterLink], styles: [".route-tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;padding:0}.route-tabset[_ngcontent-%COMP%]   .route-tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]::before{display:block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{position:relative;text-decoration:none;display:inline-block}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]::before{position:absolute;content:'';width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr][_ngcontent-%COMP%]   .route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl][_ngcontent-%COMP%]   .route-tabset[_ngcontent-%COMP%]   .route-tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}.full-width[_nghost-%COMP%]   .route-tabset[_ngcontent-%COMP%]{justify-content:space-around}"] });
__decorate$63([
    HostBinding('class.full-width'),
    __metadata$43("design:type", Boolean)
], NbRouteTabsetComponent.prototype, "fullWidthValue", void 0);
__decorate$63([
    Input(),
    __metadata$43("design:type", Array)
], NbRouteTabsetComponent.prototype, "tabs", void 0);
__decorate$63([
    Input(),
    __metadata$43("design:type", Object)
], NbRouteTabsetComponent.prototype, "activeLinkOptions", void 0);
__decorate$63([
    Input(),
    __metadata$43("design:type", Boolean),
    __metadata$43("design:paramtypes", [Boolean])
], NbRouteTabsetComponent.prototype, "fullWidth", null);
__decorate$63([
    Output(),
    __metadata$43("design:type", Object)
], NbRouteTabsetComponent.prototype, "changeTab", void 0);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$62 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbRouteTabsetModule = class NbRouteTabsetModule {
};
NbRouteTabsetModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbRouteTabsetModule });
NbRouteTabsetModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbRouteTabsetModule_Factory(t) { return new (t || NbRouteTabsetModule)(); }, imports: [[
            NbSharedModule,
            NbIconModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$66 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Sidebar service.
 *
 * Root module service to control the sidebar from any part of the app.
 *
 * Allows you to change sidebar state dynamically from any part of the app:
 * @stacked-example(Sidebar State, sidebar/sidebar-toggle.component)
 */
let NbSidebarService = class NbSidebarService {
    /**
     * Sidebar service.
     *
     * Root module service to control the sidebar from any part of the app.
     *
     * Allows you to change sidebar state dynamically from any part of the app:
     * @stacked-example(Sidebar State, sidebar/sidebar-toggle.component)
     */
    constructor() {
        this.toggle$ = new Subject();
        this.expand$ = new Subject();
        this.collapse$ = new Subject();
        this.compact$ = new Subject();
    }
    /**
     * Subscribe to toggle events
     *
     * @returns Observable<{ compact: boolean, tag: string }>
     */
    onToggle() {
        return this.toggle$.pipe(share());
    }
    /**
     * Subscribe to expand events
     * @returns Observable<{ tag: string }>
     */
    onExpand() {
        return this.expand$.pipe(share());
    }
    /**
     * Subscribe to collapse evens
     * @returns Observable<{ tag: string }>
     */
    onCollapse() {
        return this.collapse$.pipe(share());
    }
    /**
     * Subscribe to compact evens
     * @returns Observable<{ tag: string }>
     */
    onCompact() {
        return this.compact$.pipe(share());
    }
    /**
     * Toggle a sidebar
     * @param {boolean} compact
     * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
     * to specify which sidebar you want to control
     */
    toggle(compact = false, tag) {
        this.toggle$.next({ compact, tag });
    }
    /**
     * Expands a sidebar
     * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
     * to specify which sidebar you want to control
     */
    expand(tag) {
        this.expand$.next({ tag });
    }
    /**
     * Collapses a sidebar
     * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
     * to specify which sidebar you want to control
     */
    collapse(tag) {
        this.collapse$.next({ tag });
    }
    /**
     * Makes sidebar compact
     * @param {string} tag If you have multiple sidebars on the page, mark them with `tag` input property and pass it here
     * to specify which sidebar you want to control
     */
    compact(tag) {
        this.compact$.next({ tag });
    }
};
NbSidebarService.ɵfac = function NbSidebarService_Factory(t) { return new (t || NbSidebarService)(); };
NbSidebarService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbSidebarService, factory: NbSidebarService.ɵfac });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$65 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$44 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NbSidebarComponent_1;
/**
 * Sidebar header container.
 *
 * Placeholder which contains a sidebar header content,
 * placed at the very top of the sidebar outside of the scroll area.
 */
let NbSidebarHeaderComponent = class NbSidebarHeaderComponent {
};
NbSidebarHeaderComponent.ɵfac = function NbSidebarHeaderComponent_Factory(t) { return new (t || NbSidebarHeaderComponent)(); };
NbSidebarHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSidebarHeaderComponent, selectors: [["nb-sidebar-header"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbSidebarHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/**
 * Sidebar footer container.
 *
 * Placeholder which contains a sidebar footer content,
 * placed at the very bottom of the sidebar outside of the scroll area.
 */
let NbSidebarFooterComponent = class NbSidebarFooterComponent {
};
NbSidebarFooterComponent.ɵfac = function NbSidebarFooterComponent_Factory(t) { return new (t || NbSidebarFooterComponent)(); };
NbSidebarFooterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSidebarFooterComponent, selectors: [["nb-sidebar-footer"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbSidebarFooterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/**
 * Layout sidebar component.
 *
 * @stacked-example(Showcase, sidebar/sidebar-showcase.component)
 *
 * ### Installation
 *
 * Import `NbSidebarModule.forRoot()` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSidebarModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * and `NbSidebarModule` to your feature module where the component should be shown:
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSidebarModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Sidebar can be placed on the left or the right side of the layout,
 * or on start/end position of layout (depends on document direction, left to right or right to left)
 * It can be fixed (shown above the content) or can push the layout when opened.
 *
 * There are three states - `expanded`, `collapsed`, `compacted`.
 * By default sidebar content is fixed and saves its position while the page is being scrolled.
 *
 * Compacted sidebar example:
 * @stacked-example(Compacted Sidebar, sidebar/sidebar-compacted.component)
 *
 * Sidebar also supports a `responsive` behavior, listening to window size change and changing its size respectably.
 *
 * In a pair with header it is possible to setup a configuration when header is placed on a side of the sidebar
 * and not on top of it. To achieve this simply put a `subheader` property to the header like this:
 * ```html
 * <nb-layout-header subheader></nb-layout-header>
 * ```
 * @stacked-example(Subheader, layout/layout-sidebar-subheader.component)
 * Note that in such configuration sidebar shadow is removed and header cannot be make `fixed`.
 *
 * @additional-example(Right Sidebar, sidebar/sidebar-right.component)
 * @additional-example(Fixed Sidebar, sidebar/sidebar-fixed.component)
 *
 * @styles
 *
 * sidebar-background-color:
 * sidebar-text-color:
 * sidebar-text-font-family:
 * sidebar-text-font-size:
 * sidebar-text-font-weight:
 * sidebar-text-line-height:
 * sidebar-height:
 * sidebar-width:
 * sidebar-width-compact:
 * sidebar-padding:
 * sidebar-header-height:
 * sidebar-footer-height:
 * sidebar-shadow:
 * sidebar-menu-item-highlight-color:
 * sidebar-scrollbar-background-color:
 * sidebar-scrollbar-color:
 * sidebar-scrollbar-width:
 */
let NbSidebarComponent = NbSidebarComponent_1 = class NbSidebarComponent {
    constructor(sidebarService, themeService, element) {
        this.sidebarService = sidebarService;
        this.themeService = themeService;
        this.element = element;
        this.responsiveValue = false;
        this.alive = true;
        this.containerFixedValue = true;
        this.fixedValue = false;
        this.rightValue = false;
        this.leftValue = true;
        this.startValue = false;
        this.endValue = false;
        // TODO: get width by the key and define only max width for the tablets and mobiles
        /**
         * Controls on which screen sizes sidebar should be switched to compacted state.
         * Works only when responsive mode is on.
         * Default values are `['xs', 'is', 'sm', 'md', 'lg']`.
         *
         * @type string[]
         */
        this.compactedBreakpoints = ['xs', 'is', 'sm', 'md', 'lg'];
        /**
         * Controls on which screen sizes sidebar should be switched to collapsed state.
         * Works only when responsive mode is on.
         * Default values are `['xs', 'is']`.
         *
         * @type string[]
         */
        this.collapsedBreakpoints = ['xs', 'is'];
        this.responsiveState = NbSidebarComponent_1.RESPONSIVE_STATE_PC;
    }
    // TODO: rename stateValue to state (take a look to the card component)
    get expanded() {
        return this.stateValue === NbSidebarComponent_1.STATE_EXPANDED;
    }
    get collapsed() {
        return this.stateValue === NbSidebarComponent_1.STATE_COLLAPSED;
    }
    get compacted() {
        return this.stateValue === NbSidebarComponent_1.STATE_COMPACTED;
    }
    /**
     * Places sidebar on the right side
     * @type {boolean}
     */
    set right(val) {
        this.rightValue = convertToBoolProperty(val);
        this.leftValue = !this.rightValue;
        this.startValue = false;
        this.endValue = false;
    }
    /**
     * Places sidebar on the left side
     * @type {boolean}
     */
    set left(val) {
        this.leftValue = convertToBoolProperty(val);
        this.rightValue = !this.leftValue;
        this.startValue = false;
        this.endValue = false;
    }
    /**
     * Places sidebar on the start edge of layout
     * @type {boolean}
     */
    set start(val) {
        this.startValue = convertToBoolProperty(val);
        this.endValue = !this.startValue;
        this.leftValue = false;
        this.rightValue = false;
    }
    /**
     * Places sidebar on the end edge of layout
     * @type {boolean}
     */
    set end(val) {
        this.endValue = convertToBoolProperty(val);
        this.startValue = !this.endValue;
        this.leftValue = false;
        this.rightValue = false;
    }
    /**
     * Makes sidebar fixed (shown above the layout content)
     * @type {boolean}
     */
    set fixed(val) {
        this.fixedValue = convertToBoolProperty(val);
    }
    /**
     * Makes sidebar container fixed
     * @type {boolean}
     */
    set containerFixed(val) {
        this.containerFixedValue = convertToBoolProperty(val);
    }
    /**
     * Initial sidebar state, `expanded`|`collapsed`|`compacted`
     * @type {string}
     */
    set state(val) {
        this.stateValue = val;
    }
    /**
     * Makes sidebar listen to media query events and change its behaviour
     * @type {boolean}
     */
    set responsive(val) {
        this.responsiveValue = convertToBoolProperty(val);
    }
    toggleResponsive(enabled) {
        if (enabled) {
            this.mediaQuerySubscription = this.onMediaQueryChanges();
        }
        else if (this.mediaQuerySubscription) {
            this.mediaQuerySubscription.unsubscribe();
        }
    }
    ngOnChanges(changes) {
        if (changes.responsive) {
            this.toggleResponsive(this.responsiveValue);
        }
    }
    ngOnInit() {
        this.sidebarService.onToggle()
            .pipe(takeWhile(() => this.alive))
            .subscribe((data) => {
            if (!this.tag || this.tag === data.tag) {
                this.toggle(data.compact);
            }
        });
        this.sidebarService.onExpand()
            .pipe(takeWhile(() => this.alive))
            .subscribe((data) => {
            if (!this.tag || this.tag === data.tag) {
                this.expand();
            }
        });
        this.sidebarService.onCollapse()
            .pipe(takeWhile(() => this.alive))
            .subscribe((data) => {
            if (!this.tag || this.tag === data.tag) {
                this.collapse();
            }
        });
        this.sidebarService.onCompact()
            .pipe(takeWhile(() => this.alive))
            .subscribe((data) => {
            if (!this.tag || this.tag === data.tag) {
                this.compact();
            }
        });
    }
    ngOnDestroy() {
        this.alive = false;
        if (this.mediaQuerySubscription) {
            this.mediaQuerySubscription.unsubscribe();
        }
    }
    // TODO: this is more of a workaround, should be a better way to make components communicate to each other
    onClick(event) {
        const menu = this.element.nativeElement.querySelector('nb-menu');
        if (menu && menu.contains(event.target)) {
            const link = this.getMenuLink(event.target);
            if (link && link.nextElementSibling && link.nextElementSibling.classList.contains('menu-items')) {
                this.sidebarService.expand(this.tag);
            }
        }
    }
    /**
     * Collapses the sidebar
     */
    collapse() {
        this.state = NbSidebarComponent_1.STATE_COLLAPSED;
    }
    /**
     * Expands the sidebar
     */
    expand() {
        this.state = NbSidebarComponent_1.STATE_EXPANDED;
    }
    /**
     * Compacts the sidebar (minimizes)
     */
    compact() {
        this.state = NbSidebarComponent_1.STATE_COMPACTED;
    }
    /**
     * Toggles sidebar state (expanded|collapsed|compacted)
     * @param {boolean} compact If true, then sidebar state will be changed between expanded & compacted,
     * otherwise - between expanded & collapsed. False by default.
     *
     * Toggle sidebar state
     *
     * ```ts
     * this.sidebar.toggle(true);
     * ```
     */
    toggle(compact = false) {
        if (this.responsiveEnabled()) {
            if (this.responsiveState === NbSidebarComponent_1.RESPONSIVE_STATE_MOBILE) {
                compact = false;
            }
        }
        const closedStates = [NbSidebarComponent_1.STATE_COMPACTED, NbSidebarComponent_1.STATE_COLLAPSED];
        if (compact) {
            this.state = closedStates.includes(this.stateValue) ?
                NbSidebarComponent_1.STATE_EXPANDED : NbSidebarComponent_1.STATE_COMPACTED;
        }
        else {
            this.state = closedStates.includes(this.stateValue) ?
                NbSidebarComponent_1.STATE_EXPANDED : NbSidebarComponent_1.STATE_COLLAPSED;
        }
    }
    onMediaQueryChanges() {
        return this.themeService.onMediaQueryChange()
            .subscribe(([prev, current]) => {
            const isCollapsed = this.collapsedBreakpoints.includes(current.name);
            const isCompacted = this.compactedBreakpoints.includes(current.name);
            if (isCompacted) {
                this.fixed = this.containerFixedValue;
                this.compact();
                this.responsiveState = NbSidebarComponent_1.RESPONSIVE_STATE_TABLET;
            }
            if (isCollapsed) {
                this.fixed = true;
                this.collapse();
                this.responsiveState = NbSidebarComponent_1.RESPONSIVE_STATE_MOBILE;
            }
            if (!isCollapsed && !isCompacted && prev.width < current.width) {
                this.expand();
                this.fixed = false;
                this.responsiveState = NbSidebarComponent_1.RESPONSIVE_STATE_PC;
            }
        });
    }
    responsiveEnabled() {
        return this.responsiveValue;
    }
    getMenuLink(element) {
        if (!element || element.tagName.toLowerCase() === 'nb-menu') {
            return;
        }
        if (element.tagName.toLowerCase() === 'a') {
            return element;
        }
        return this.getMenuLink(element.parentElement);
    }
};
NbSidebarComponent.ɵfac = function NbSidebarComponent_Factory(t) { return new (t || NbSidebarComponent)(ɵngcc0.ɵɵdirectiveInject(NbSidebarService), ɵngcc0.ɵɵdirectiveInject(NbThemeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbSidebarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSidebarComponent, selectors: [["nb-sidebar"]], hostVars: 16, hostBindings: function NbSidebarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("fixed", ctx.fixedValue)("right", ctx.rightValue)("left", ctx.leftValue)("start", ctx.startValue)("end", ctx.endValue)("expanded", ctx.expanded)("collapsed", ctx.collapsed)("compacted", ctx.compacted);
    } }, inputs: { compactedBreakpoints: "compactedBreakpoints", collapsedBreakpoints: "collapsedBreakpoints", right: "right", left: "left", start: "start", end: "end", fixed: "fixed", containerFixed: "containerFixed", state: "state", responsive: "responsive", tag: "tag" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], ngContentSelectors: _c16, decls: 5, vars: 2, consts: [[1, "main-container"], [1, "scrollable", 3, "click"]], template: function NbSidebarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c15);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementStart(2, "div", 1);
        ɵngcc0.ɵɵlistener("click", function NbSidebarComponent_Template_div_click_2_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵprojection(3, 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(4, 2);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("main-container-fixed", ctx.containerFixedValue);
    } }, styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}[_nghost-%COMP%]   .scrollable[_ngcontent-%COMP%]{overflow-y:auto;overflow-x:hidden;flex:1}[_nghost-%COMP%]   .main-container[_ngcontent-%COMP%]{transform:translate3d(0, 0, 0);display:flex;flex-direction:column}[_nghost-%COMP%]   .main-container-fixed[_ngcontent-%COMP%]{position:fixed}.right[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=ltr]   .right[_nghost-%COMP%]{order:4}[dir=rtl]   .right[_nghost-%COMP%]{order:0}.end[_nghost-%COMP%]{order:4}[dir=ltr]   .end[_nghost-%COMP%]{margin-right:0;margin-left:auto}[dir=rtl]   .end[_nghost-%COMP%]{margin-left:0;margin-right:auto}.fixed[_nghost-%COMP%]{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}.fixed.right[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.start[_nghost-%COMP%]{left:0}[dir=rtl]   .fixed.start[_nghost-%COMP%]{right:0}[dir=ltr]   .fixed.end[_nghost-%COMP%]{right:0}[dir=rtl]   .fixed.end[_nghost-%COMP%]{left:0}[_nghost-%COMP%]     nb-sidebar-footer{margin-top:auto;display:block}[_nghost-%COMP%]     nb-sidebar-header{display:block}"] });
NbSidebarComponent.STATE_EXPANDED = 'expanded';
NbSidebarComponent.STATE_COLLAPSED = 'collapsed';
NbSidebarComponent.STATE_COMPACTED = 'compacted';
NbSidebarComponent.RESPONSIVE_STATE_MOBILE = 'mobile';
NbSidebarComponent.RESPONSIVE_STATE_TABLET = 'tablet';
NbSidebarComponent.RESPONSIVE_STATE_PC = 'pc';
__decorate$65([
    HostBinding('class.fixed'),
    __metadata$44("design:type", Boolean)
], NbSidebarComponent.prototype, "fixedValue", void 0);
__decorate$65([
    HostBinding('class.right'),
    __metadata$44("design:type", Boolean)
], NbSidebarComponent.prototype, "rightValue", void 0);
__decorate$65([
    HostBinding('class.left'),
    __metadata$44("design:type", Boolean)
], NbSidebarComponent.prototype, "leftValue", void 0);
__decorate$65([
    HostBinding('class.start'),
    __metadata$44("design:type", Boolean)
], NbSidebarComponent.prototype, "startValue", void 0);
__decorate$65([
    HostBinding('class.end'),
    __metadata$44("design:type", Boolean)
], NbSidebarComponent.prototype, "endValue", void 0);
__decorate$65([
    HostBinding('class.expanded'),
    __metadata$44("design:type", Object),
    __metadata$44("design:paramtypes", [])
], NbSidebarComponent.prototype, "expanded", null);
__decorate$65([
    HostBinding('class.collapsed'),
    __metadata$44("design:type", Object),
    __metadata$44("design:paramtypes", [])
], NbSidebarComponent.prototype, "collapsed", null);
__decorate$65([
    HostBinding('class.compacted'),
    __metadata$44("design:type", Object),
    __metadata$44("design:paramtypes", [])
], NbSidebarComponent.prototype, "compacted", null);
__decorate$65([
    Input(),
    __metadata$44("design:type", Boolean),
    __metadata$44("design:paramtypes", [Boolean])
], NbSidebarComponent.prototype, "right", null);
__decorate$65([
    Input(),
    __metadata$44("design:type", Boolean),
    __metadata$44("design:paramtypes", [Boolean])
], NbSidebarComponent.prototype, "left", null);
__decorate$65([
    Input(),
    __metadata$44("design:type", Boolean),
    __metadata$44("design:paramtypes", [Boolean])
], NbSidebarComponent.prototype, "start", null);
__decorate$65([
    Input(),
    __metadata$44("design:type", Boolean),
    __metadata$44("design:paramtypes", [Boolean])
], NbSidebarComponent.prototype, "end", null);
__decorate$65([
    Input(),
    __metadata$44("design:type", Boolean),
    __metadata$44("design:paramtypes", [Boolean])
], NbSidebarComponent.prototype, "fixed", null);
__decorate$65([
    Input(),
    __metadata$44("design:type", Boolean),
    __metadata$44("design:paramtypes", [Boolean])
], NbSidebarComponent.prototype, "containerFixed", null);
__decorate$65([
    Input(),
    __metadata$44("design:type", String),
    __metadata$44("design:paramtypes", [String])
], NbSidebarComponent.prototype, "state", null);
__decorate$65([
    Input(),
    __metadata$44("design:type", Boolean),
    __metadata$44("design:paramtypes", [Boolean])
], NbSidebarComponent.prototype, "responsive", null);
__decorate$65([
    Input(),
    __metadata$44("design:type", String)
], NbSidebarComponent.prototype, "tag", void 0);
__decorate$65([
    Input(),
    __metadata$44("design:type", Array)
], NbSidebarComponent.prototype, "compactedBreakpoints", void 0);
__decorate$65([
    Input(),
    __metadata$44("design:type", Array)
], NbSidebarComponent.prototype, "collapsedBreakpoints", void 0);
NbSidebarComponent = NbSidebarComponent_1 = __decorate$65([ __metadata$44("design:paramtypes", [NbSidebarService,
        NbThemeService,
        ElementRef])
], NbSidebarComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$64 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbSidebarModule_1;
const NB_SIDEBAR_COMPONENTS = [
    NbSidebarComponent,
    NbSidebarFooterComponent,
    NbSidebarHeaderComponent,
];
const NB_SIDEBAR_PROVIDERS = [
    NbSidebarService,
];
let NbSidebarModule = NbSidebarModule_1 = class NbSidebarModule {
    static forRoot() {
        return {
            ngModule: NbSidebarModule_1,
            providers: [
                ...NB_SIDEBAR_PROVIDERS,
            ],
        };
    }
};
NbSidebarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSidebarModule });
NbSidebarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbSidebarModule_Factory(t) { return new (t || NbSidebarModule)(); }, imports: [[
            NbSharedModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$68 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$45 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Specific tab container.
 *
 * ```ts
 * <nb-tab tabTitle="Users"
 *   badgeText="99+"
 *   badgeStatus="danger">
 *   <p>List of <strong>users</strong>.</p>
 * </nb-tab>
 ```
 */
let NbTabComponent = class NbTabComponent {
    /**
     * Specific tab container.
     *
     * ```ts
     * <nb-tab tabTitle="Users"
     *   badgeText="99+"
     *   badgeStatus="danger">
     *   <p>List of <strong>users</strong>.</p>
     * </nb-tab>
     ```
     */
    constructor() {
        this.activeValue = false;
        this.responsiveValue = false;
        this.disabledValue = false;
        this.init = false;
    }
    /**
     * Item is disabled and cannot be opened.
     * @type {boolean}
     */
    get disabled() {
        return this.disabledValue;
    }
    set disabled(val) {
        this.disabledValue = convertToBoolProperty(val);
    }
    /**
     * Show only icons when width is smaller than `tabs-icon-only-max-width`
     * @type {boolean}
     */
    set responsive(val) {
        this.responsiveValue = convertToBoolProperty(val);
    }
    get responsive() {
        return this.responsiveValue;
    }
    /**
     * Specifies active tab
     * @returns {boolean}
     */
    get active() {
        return this.activeValue;
    }
    set active(val) {
        this.activeValue = convertToBoolProperty(val);
        if (this.activeValue) {
            this.init = true;
        }
    }
    /**
     * Lazy load content before tab selection
     * TODO: rename, as lazy is by default, and this is more `instant load`
     * @param {boolean} val
     */
    set lazyLoad(val) {
        this.init = convertToBoolProperty(val);
    }
};
NbTabComponent.ɵfac = function NbTabComponent_Factory(t) { return new (t || NbTabComponent)(); };
NbTabComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTabComponent, selectors: [["nb-tab"]], hostVars: 4, hostBindings: function NbTabComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("content-active", ctx.activeValue)("disabled", ctx.disabled);
    } }, inputs: { disabled: "disabled", responsive: "responsive", active: "active", lazyLoad: "lazyLoad", tabTitle: "tabTitle", tabId: "tabId", tabIcon: "tabIcon", route: "route", badgeText: "badgeText", badgeStatus: "badgeStatus", badgePosition: "badgePosition" }, ngContentSelectors: _c0, decls: 1, vars: 1, consts: [[4, "ngIf"]], template: function NbTabComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NbTabComponent_ng_container_0_Template, 2, 0, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.init);
    } }, directives: [ɵngcc2.NgIf], encapsulation: 2 });
__decorate$68([
    Input(),
    __metadata$45("design:type", String)
], NbTabComponent.prototype, "tabTitle", void 0);
__decorate$68([
    Input(),
    __metadata$45("design:type", String)
], NbTabComponent.prototype, "tabId", void 0);
__decorate$68([
    Input(),
    __metadata$45("design:type", Object)
], NbTabComponent.prototype, "tabIcon", void 0);
__decorate$68([
    Input('disabled'),
    HostBinding('class.disabled'),
    __metadata$45("design:type", Boolean),
    __metadata$45("design:paramtypes", [Boolean])
], NbTabComponent.prototype, "disabled", null);
__decorate$68([
    Input(),
    __metadata$45("design:type", Boolean),
    __metadata$45("design:paramtypes", [Boolean])
], NbTabComponent.prototype, "responsive", null);
__decorate$68([
    Input(),
    __metadata$45("design:type", String)
], NbTabComponent.prototype, "route", void 0);
__decorate$68([
    HostBinding('class.content-active'),
    __metadata$45("design:type", Boolean)
], NbTabComponent.prototype, "activeValue", void 0);
__decorate$68([
    Input(),
    __metadata$45("design:type", Boolean),
    __metadata$45("design:paramtypes", [Boolean])
], NbTabComponent.prototype, "active", null);
__decorate$68([
    Input(),
    __metadata$45("design:type", Boolean),
    __metadata$45("design:paramtypes", [Boolean])
], NbTabComponent.prototype, "lazyLoad", null);
__decorate$68([
    Input(),
    __metadata$45("design:type", String)
], NbTabComponent.prototype, "badgeText", void 0);
__decorate$68([
    Input(),
    __metadata$45("design:type", String)
], NbTabComponent.prototype, "badgeStatus", void 0);
__decorate$68([
    Input(),
    __metadata$45("design:type", String)
], NbTabComponent.prototype, "badgePosition", void 0);
// TODO: Combine tabset with route-tabset, so that we can:
// - have similar interface
// - easy to migrate from one to another
// - can mix them both (route/content tab)
/**
 *
 * Dynamic tabset component.
 * @stacked-example(Showcase, tabset/tabset-showcase.component)
 *
 * Basic tabset example
 *
 * ```html
 * <nb-tabset>
 *  <nb-tab tabTitle="Simple Tab #1">
 *    Tab content 1
 *  </nb-tab>
 *  <nb-tab tabTitle="Simple Tab #2">
 *    Tab content 2
 *  </nb-tab>
 * </nb-tabset>
 * ```
 *
 * ### Installation
 *
 * Import `NbTabsetModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTabsetModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * It is also possible to set a badge to a particular tab:
 * @stacked-example(Tab With Badge, tabset/tabset-badge.component)
 *
 * and we can set it to full a width of a parent component
 * @stacked-example(Full Width, tabset/tabset-width.component)
 *
 * `tabIcon` should be used to add an icon to the tab. Icon can also be combined with title.
 * `responsive` tab property if set allows you to hide the title on smaller screens
 * (`tabs-icon-only-max-width` property) for better responsive behaviour. You can open the following example and make
 * your screen smaller - titles will be hidden in the last tabset in the list:
 *
 * @stacked-example(Icon, tabset/tabset-icon.component)
 *
 * It is also possible to disable a tab using `disabled` property:
 * @stacked-example(Disabled Tab, tabset/tabset-disabled.component)
 *
 * @styles
 *
 * tabset-background-color:
 * tabset-border-radius:
 * tabset-shadow:
 * tabset-tab-background-color:
 * tabset-tab-padding:
 * tabset-tab-text-color:
 * tabset-tab-text-font-family:
 * tabset-tab-text-font-size:
 * tabset-tab-text-font-weight:
 * tabset-tab-text-line-height:
 * tabset-tab-text-transform:
 * tabset-tab-underline-width:
 * tabset-tab-underline-color:
 * tabset-tab-active-background-color:
 * tabset-tab-active-text-color:
 * tabset-tab-active-underline-color:
 * tabset-tab-focus-background-color:
 * tabset-tab-focus-text-color:
 * tabset-tab-focus-underline-color:
 * tabset-tab-hover-background-color:
 * tabset-tab-hover-text-color:
 * tabset-tab-hover-underline-color:
 * tabset-tab-disabled-background-color:
 * tabset-tab-disabled-text-color:
 * tabset-tab-disabled-underline-color:
 * tabset-divider-color:
 * tabset-divider-style:
 * tabset-divider-width:
 * tabset-content-background-color:
 * tabset-content-padding:
 * tabset-content-text-color:
 * tabset-content-text-font-family:
 * tabset-content-text-font-size:
 * tabset-content-text-font-weight:
 * tabset-content-text-line-height:
 * tabset-scrollbar-color:
 * tabset-scrollbar-background-color:
 * tabset-scrollbar-width:
 * tabset-tab-text-hide-breakpoint:
 */
let NbTabsetComponent = class NbTabsetComponent {
    constructor(route, changeDetectorRef) {
        this.route = route;
        this.changeDetectorRef = changeDetectorRef;
        this.fullWidthValue = false;
        /**
         * Emits when tab is selected
         * @type EventEmitter<any>
         */
        this.changeTab = new EventEmitter();
    }
    /**
     * Take full width of a parent
     * @param {boolean} val
     */
    set fullWidth(val) {
        this.fullWidthValue = convertToBoolProperty(val);
    }
    // TODO: refactoring this component, avoid change detection loop
    ngAfterContentInit() {
        this.route.params
            .pipe(map((params) => this.tabs.find((tab) => this.routeParam ? tab.route === params[this.routeParam] : tab.active)), delay(0), map((tab) => tab || this.tabs.first), filter((tab) => !!tab))
            .subscribe((tabToSelect) => {
            this.selectTab(tabToSelect);
            this.changeDetectorRef.markForCheck();
        });
    }
    // TODO: navigate to routeParam
    selectTab(selectedTab) {
        if (!selectedTab.disabled) {
            this.tabs.forEach(tab => tab.active = tab === selectedTab);
            this.changeTab.emit(selectedTab);
        }
    }
};
NbTabsetComponent.ɵfac = function NbTabsetComponent_Factory(t) { return new (t || NbTabsetComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc5.ActivatedRoute), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbTabsetComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTabsetComponent, selectors: [["nb-tabset"]], contentQueries: function NbTabsetComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbTabComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tabs = _t);
    } }, hostVars: 2, hostBindings: function NbTabsetComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("full-width", ctx.fullWidthValue);
    } }, inputs: { fullWidth: "fullWidth", routeParam: "routeParam" }, outputs: { changeTab: "changeTab" }, ngContentSelectors: _c18, decls: 3, vars: 1, consts: [[1, "tabset"], ["class", "tab", 3, "responsive", "active", "disabled", "click", "keyup.space", "keyup.enter", 4, "ngFor", "ngForOf"], [1, "tab", 3, "click", "keyup.space", "keyup.enter"], ["href", "", "tabindex", "-1", 1, "tab-link", 3, "click"], [3, "config", 4, "ngIf"], ["class", "tab-text", 4, "ngIf"], [3, "text", "status", "position", 4, "ngIf"], [3, "config"], [1, "tab-text"], [3, "text", "status", "position"]], template: function NbTabsetComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c17);
        ɵngcc0.ɵɵelementStart(0, "ul", 0);
        ɵngcc0.ɵɵtemplate(1, NbTabsetComponent_li_1_Template, 5, 10, "li", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tabs);
    } }, directives: function () { return [ɵngcc2.NgForOf, ɵngcc2.NgIf, NbIconComponent,
        NbBadgeComponent]; }, styles: ["[_nghost-%COMP%]{display:block}.full-width[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{justify-content:space-around}[_nghost-%COMP%]     nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}[_nghost-%COMP%]     nb-tab.content-active{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]{margin-bottom:-1px;text-align:center;position:relative}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab.active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]::before{display:block}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]{display:flex;position:relative;text-decoration:none}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]::before{position:absolute;content:'';width:100%;border-radius:3px;bottom:-2px;left:0}[_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{vertical-align:middle}[dir=ltr]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .tabset[_ngcontent-%COMP%]   .tab[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:.5rem}"] });
__decorate$68([
    ContentChildren(NbTabComponent),
    __metadata$45("design:type", QueryList)
], NbTabsetComponent.prototype, "tabs", void 0);
__decorate$68([
    HostBinding('class.full-width'),
    __metadata$45("design:type", Boolean)
], NbTabsetComponent.prototype, "fullWidthValue", void 0);
__decorate$68([
    Input(),
    __metadata$45("design:type", Boolean),
    __metadata$45("design:paramtypes", [Boolean])
], NbTabsetComponent.prototype, "fullWidth", null);
__decorate$68([
    Input(),
    __metadata$45("design:type", String)
], NbTabsetComponent.prototype, "routeParam", void 0);
__decorate$68([
    Output(),
    __metadata$45("design:type", Object)
], NbTabsetComponent.prototype, "changeTab", void 0);
NbTabsetComponent = __decorate$68([ __metadata$45("design:paramtypes", [ActivatedRoute,
        ChangeDetectorRef])
], NbTabsetComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$70 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$46 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Badge is a simple labeling component.
 * It can be used to add additional information to any content or highlight unread items.
 *
 * Element is absolute positioned, so parent should be
 * [positioned element](https://developer.mozilla.org/en-US/docs/Web/CSS/position).
 * It means parent `position` should be set to anything except `static`, e.g. `relative`,
 * `absolute`, `fixed`, or `sticky`.
 *
 * ### Installation
 *
 * Import `NbBadgeModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbBadgeModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Badge with default position and status(color):
 *
 * ```html
 * <nb-badge text="badgeText"></nb-badge>
 * ```
 *
 * For example, badge can be placed into nb-card header:
 * @stacked-example(Showcase, badge/badge-showcase.component)
 *
 * Badge located on the bottom right with warning status:
 *
 * ```html
 * <nb-badge text="badgeText" status="warning" position="bottom right">
 * </nb-badge>
 * ```
 *
 * @styles
 *
 * badge-border-radius:
 * badge-text-font-family:
 * badge-text-font-size:
 * badge-text-font-weight:
 * badge-text-line-height:
 * badge-padding:
 * badge-basic-background-color:
 * badge-basic-text-color:
 * badge-primary-background-color:
 * badge-primary-text-color:
 * badge-success-background-color:
 * badge-success-text-color:
 * badge-info-background-color:
 * badge-info-text-color:
 * badge-warning-background-color:
 * badge-warning-text-color:
 * badge-danger-background-color:
 * badge-danger-text-color:
 * badge-control-background-color:
 * badge-control-text-color:
 */
let NbBadgeComponent = class NbBadgeComponent {
    /**
     * Badge is a simple labeling component.
     * It can be used to add additional information to any content or highlight unread items.
     *
     * Element is absolute positioned, so parent should be
     * [positioned element](https://developer.mozilla.org/en-US/docs/Web/CSS/position).
     * It means parent `position` should be set to anything except `static`, e.g. `relative`,
     * `absolute`, `fixed`, or `sticky`.
     *
     * ### Installation
     *
     * Import `NbBadgeModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbBadgeModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * Badge with default position and status(color):
     *
     * ```html
     * <nb-badge text="badgeText"></nb-badge>
     * ```
     *
     * For example, badge can be placed into nb-card header:
     * @stacked-example(Showcase, badge/badge-showcase.component)
     *
     * Badge located on the bottom right with warning status:
     *
     * ```html
     * <nb-badge text="badgeText" status="warning" position="bottom right">
     * </nb-badge>
     * ```
     *
     * @styles
     *
     * badge-border-radius:
     * badge-text-font-family:
     * badge-text-font-size:
     * badge-text-font-weight:
     * badge-text-line-height:
     * badge-padding:
     * badge-basic-background-color:
     * badge-basic-text-color:
     * badge-primary-background-color:
     * badge-primary-text-color:
     * badge-success-background-color:
     * badge-success-text-color:
     * badge-info-background-color:
     * badge-info-text-color:
     * badge-warning-background-color:
     * badge-warning-text-color:
     * badge-danger-background-color:
     * badge-danger-text-color:
     * badge-control-background-color:
     * badge-control-text-color:
     */
    constructor() {
        /**
         * Text to display
         * @type string
         */
        this.text = '';
        this._defaultPosition = 'top right';
        this._position = this._defaultPosition;
        /**
         * Badge status (adds specific styles):
         * 'basic', 'primary', 'info', 'success', 'warning', 'danger', 'control'
         */
        this.status = 'primary';
    }
    /**
     * Badge position
     *
     * Can be set to any class or to one of predefined positions:
     * 'top left', 'top right', 'bottom left', 'bottom right',
     * 'top start', 'top end', 'bottom start', 'bottom end'
     * @type string
     */
    get position() {
        return this._position;
    }
    set position(value) {
        this._position = value || this._defaultPosition;
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get info() {
        return this.status === 'info';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get top() {
        return this.position.includes('top');
    }
    get right() {
        return this.position.includes('right');
    }
    get bottom() {
        return this.position.includes('bottom');
    }
    get left() {
        return this.position.includes('left');
    }
    get start() {
        return this.position.includes('start');
    }
    get end() {
        return this.position.includes('end');
    }
};
NbBadgeComponent.ɵfac = function NbBadgeComponent_Factory(t) { return new (t || NbBadgeComponent)(); };
NbBadgeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbBadgeComponent, selectors: [["nb-badge"]], hostVars: 26, hostBindings: function NbBadgeComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("position-top", ctx.top)("position-right", ctx.right)("position-bottom", ctx.bottom)("position-left", ctx.left)("position-start", ctx.start)("position-end", ctx.end);
    } }, inputs: { text: "text", status: "status", position: "position" }, decls: 1, vars: 1, template: function NbBadgeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtext(0);
    } if (rf & 2) {
        ɵngcc0.ɵɵtextInterpolate(ctx.text);
    } }, styles: ["[_nghost-%COMP%]{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}.position-top[_nghost-%COMP%]{top:0}.position-right[_nghost-%COMP%]{right:0}.position-bottom[_nghost-%COMP%]{bottom:0}.position-left[_nghost-%COMP%]{left:0}[dir=ltr]   .position-start[_nghost-%COMP%]{left:0}[dir=rtl]   .position-start[_nghost-%COMP%]{right:0}[dir=ltr]   .position-end[_nghost-%COMP%]{right:0}[dir=rtl]   .position-end[_nghost-%COMP%]{left:0}"] });
__decorate$70([
    Input(),
    __metadata$46("design:type", String)
], NbBadgeComponent.prototype, "text", void 0);
__decorate$70([
    Input(),
    __metadata$46("design:type", String),
    __metadata$46("design:paramtypes", [String])
], NbBadgeComponent.prototype, "position", null);
__decorate$70([
    Input(),
    __metadata$46("design:type", String)
], NbBadgeComponent.prototype, "status", void 0);
__decorate$70([
    HostBinding('class.status-primary'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "primary", null);
__decorate$70([
    HostBinding('class.status-success'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "success", null);
__decorate$70([
    HostBinding('class.status-info'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "info", null);
__decorate$70([
    HostBinding('class.status-warning'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "warning", null);
__decorate$70([
    HostBinding('class.status-danger'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "danger", null);
__decorate$70([
    HostBinding('class.status-basic'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "basic", null);
__decorate$70([
    HostBinding('class.status-control'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "control", null);
__decorate$70([
    HostBinding('class.position-top'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "top", null);
__decorate$70([
    HostBinding('class.position-right'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "right", null);
__decorate$70([
    HostBinding('class.position-bottom'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "bottom", null);
__decorate$70([
    HostBinding('class.position-left'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "left", null);
__decorate$70([
    HostBinding('class.position-start'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "start", null);
__decorate$70([
    HostBinding('class.position-end'),
    __metadata$46("design:type", Boolean),
    __metadata$46("design:paramtypes", [])
], NbBadgeComponent.prototype, "end", null);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$69 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbBadgeModule = class NbBadgeModule {
};
NbBadgeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbBadgeModule });
NbBadgeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbBadgeModule_Factory(t) { return new (t || NbBadgeModule)(); } });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$67 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const NB_TABSET_COMPONENTS = [
    NbTabsetComponent,
    NbTabComponent,
];
let NbTabsetModule = class NbTabsetModule {
};
NbTabsetModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbTabsetModule });
NbTabsetModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbTabsetModule_Factory(t) { return new (t || NbTabsetModule)(); }, imports: [[
            NbSharedModule,
            NbBadgeModule,
            NbIconModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$72 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$47 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Represents a component showing a user avatar (picture) with a user name on the right.
 * @stacked-example(Showcase, user/user-showcase.component)
 *
 * ```ts
 *   <nb-user name="John Doe" title="Engineer"></nb-user>
 * ```
 *
 * ### Installation
 *
 * Import `NbUserModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbUserModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Available in multiple sizes:
 * @stacked-example(Multiple Sizes, user/user-sizes.component)
 *
 *
 * You can hide unnecessary captions (name, title or both):
 * @stacked-example(Hide captions in user component, user/user-hide-captions.component)
 *
 *
 * You can set custom avatar background-color, user image (as link or BASE64 string) and disable user initials:
 * @stacked-example(Avatar image settings, user/user-avatar-settings.component)
 *
 * Component shape could be controlled with `shape` input.
 * @stacked-example(Shapes, user/user-shape.component)
 *
 * @styles
 *
 * user-picture-box-background-color:
 * user-picture-box-border-color:
 * user-picture-box-border-width:
 * user-initials-text-color:
 * user-initials-text-font-family:
 * user-initials-text-font-weight:
 * user-name-text-color:
 * user-name-text-font-family:
 * user-name-text-font-weight:
 * user-title-text-color:
 * user-title-text-font-family:
 * user-title-text-font-weight:
 * user-rectangle-border-radius:
 * user-semi-round-border-radius:
 * user-round-border-radius:
 * user-tiny-height:
 * user-tiny-width:
 * user-tiny-initials-text-font-size:
 * user-tiny-initials-text-line-height:
 * user-tiny-name-text-font-size:
 * user-tiny-name-text-line-height:
 * user-tiny-title-text-font-size:
 * user-tiny-title-text-line-height:
 * user-small-height:
 * user-small-width:
 * user-small-initials-text-font-size:
 * user-small-initials-text-line-height:
 * user-small-name-text-font-size:
 * user-small-name-text-line-height:
 * user-small-title-text-font-size:
 * user-small-title-text-line-height:
 * user-medium-height:
 * user-medium-width:
 * user-medium-initials-text-font-size:
 * user-medium-initials-text-line-height:
 * user-medium-name-text-font-size:
 * user-medium-name-text-line-height:
 * user-medium-title-text-font-size:
 * user-medium-title-text-line-height:
 * user-large-height:
 * user-large-width:
 * user-large-initials-text-font-size:
 * user-large-initials-text-line-height:
 * user-large-name-text-font-size:
 * user-large-name-text-line-height:
 * user-large-title-text-font-size:
 * user-large-title-text-line-height:
 * user-giant-height:
 * user-giant-width:
 * user-giant-initials-text-font-size:
 * user-giant-initials-text-line-height:
 * user-giant-name-text-font-size:
 * user-giant-name-text-line-height:
 * user-giant-title-text-font-size:
 * user-giant-title-text-line-height:
 */
let NbUserComponent = class NbUserComponent {
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
        /**
         * Specifies a name to be shown on the right of a user picture
         * @type string
         */
        this.name = 'Anonymous';
        /**
         * Size of the component.
         * Possible values: `tiny`, `small`, `medium` (default), `large`, 'giant'.
         */
        this.size = 'medium';
        /**
         * Shape of the picture box.
         * Possible values: `rectangle`, `semi-round`, `round`.
         */
        this.shape = 'round';
        this._showName = true;
        this._showTitle = true;
        this._showInitials = true;
    }
    /**
     * Absolute path to a user picture or base64 image.
     * User name initials will be shown if no picture specified (JD for John Doe).
     * @type string
     */
    set picture(value) {
        this.imageBackgroundStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
    }
    /**
     * Whether to show a user name or not
     */
    get showName() {
        return this._showName;
    }
    set showName(val) {
        this._showName = convertToBoolProperty(val);
    }
    /**
     * Whether to show a user title or not
     * @type boolean
     */
    get showTitle() {
        return this._showTitle;
    }
    set showTitle(val) {
        this._showTitle = convertToBoolProperty(val);
    }
    /**
     * Whether to show a user initials (if no picture specified) or not
     * @type boolean
     */
    get showInitials() {
        return this._showInitials;
    }
    set showInitials(val) {
        this._showInitials = convertToBoolProperty(val);
    }
    /**
     * Whether to show only a picture or also show the name and title
     * @type boolean
     */
    get onlyPicture() {
        return !this.showName && !this.showTitle;
    }
    set onlyPicture(val) {
        this.showName = this.showTitle = !convertToBoolProperty(val);
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get rectangle() {
        return this.shape === 'rectangle';
    }
    get semiRound() {
        return this.shape === 'semi-round';
    }
    get round() {
        return this.shape === 'round';
    }
    getInitials() {
        if (this.name) {
            const names = this.name.split(' ');
            return names.map(n => n.charAt(0)).splice(0, 2).join('').toUpperCase();
        }
        return '';
    }
};
NbUserComponent.ɵfac = function NbUserComponent_Factory(t) { return new (t || NbUserComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer)); };
NbUserComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbUserComponent, selectors: [["nb-user"]], hostVars: 16, hostBindings: function NbUserComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
    } }, inputs: { name: "name", size: "size", shape: "shape", picture: "picture", showName: "showName", showTitle: "showTitle", showInitials: "showInitials", onlyPicture: "onlyPicture", title: "title", color: "color", badgeText: "badgeText", badgeStatus: "badgeStatus", badgePosition: "badgePosition" }, decls: 6, vars: 4, consts: [[1, "user-container"], ["class", "user-picture image", 3, "background-image", 4, "ngIf"], ["class", "user-picture initials", 3, "background-color", 4, "ngIf"], [1, "info-container"], ["class", "user-name", 4, "ngIf"], ["class", "user-title", 4, "ngIf"], [1, "user-picture", "image"], [3, "text", "status", "position", 4, "ngIf"], [3, "text", "status", "position"], [1, "user-picture", "initials"], [4, "ngIf"], [1, "user-name"], [1, "user-title"]], template: function NbUserComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtemplate(1, NbUserComponent_div_1_Template, 2, 3, "div", 1);
        ɵngcc0.ɵɵtemplate(2, NbUserComponent_div_2_Template, 3, 4, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵtemplate(4, NbUserComponent_div_4_Template, 2, 1, "div", 4);
        ɵngcc0.ɵɵtemplate(5, NbUserComponent_div_5_Template, 2, 1, "div", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.imageBackgroundStyle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.imageBackgroundStyle);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showName && ctx.name);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showTitle && ctx.title);
    } }, directives: [ɵngcc2.NgIf, NbBadgeComponent], styles: ["[_nghost-%COMP%]{display:flex}[_nghost-%COMP%]   .user-container[_ngcontent-%COMP%]{position:relative;display:flex;align-items:center}[_nghost-%COMP%]   .user-picture[_ngcontent-%COMP%]{position:relative;flex-shrink:0}[_nghost-%COMP%]   .user-picture.image[_ngcontent-%COMP%]{background-size:cover;background-repeat:no-repeat}[_nghost-%COMP%]   .user-picture.initials[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center}[dir=rtl]   [_nghost-%COMP%]   .user-name[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .user-title[_ngcontent-%COMP%]{text-align:right}[dir=ltr]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .info-container[_ngcontent-%COMP%]{margin-right:.5rem}"] });
__decorate$72([
    Input(),
    __metadata$47("design:type", String)
], NbUserComponent.prototype, "name", void 0);
__decorate$72([
    Input(),
    __metadata$47("design:type", String)
], NbUserComponent.prototype, "title", void 0);
__decorate$72([
    Input(),
    __metadata$47("design:type", String),
    __metadata$47("design:paramtypes", [String])
], NbUserComponent.prototype, "picture", null);
__decorate$72([
    Input(),
    __metadata$47("design:type", String)
], NbUserComponent.prototype, "color", void 0);
__decorate$72([
    Input(),
    __metadata$47("design:type", String)
], NbUserComponent.prototype, "size", void 0);
__decorate$72([
    Input(),
    __metadata$47("design:type", String)
], NbUserComponent.prototype, "shape", void 0);
__decorate$72([
    Input(),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [Boolean])
], NbUserComponent.prototype, "showName", null);
__decorate$72([
    Input(),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [Boolean])
], NbUserComponent.prototype, "showTitle", null);
__decorate$72([
    Input(),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [Boolean])
], NbUserComponent.prototype, "showInitials", null);
__decorate$72([
    Input(),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [Boolean])
], NbUserComponent.prototype, "onlyPicture", null);
__decorate$72([
    Input(),
    __metadata$47("design:type", String)
], NbUserComponent.prototype, "badgeText", void 0);
__decorate$72([
    Input(),
    __metadata$47("design:type", String)
], NbUserComponent.prototype, "badgeStatus", void 0);
__decorate$72([
    Input(),
    __metadata$47("design:type", String)
], NbUserComponent.prototype, "badgePosition", void 0);
__decorate$72([
    HostBinding('class.size-tiny'),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [])
], NbUserComponent.prototype, "tiny", null);
__decorate$72([
    HostBinding('class.size-small'),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [])
], NbUserComponent.prototype, "small", null);
__decorate$72([
    HostBinding('class.size-medium'),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [])
], NbUserComponent.prototype, "medium", null);
__decorate$72([
    HostBinding('class.size-large'),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [])
], NbUserComponent.prototype, "large", null);
__decorate$72([
    HostBinding('class.size-giant'),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [])
], NbUserComponent.prototype, "giant", null);
__decorate$72([
    HostBinding('class.shape-rectangle'),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [])
], NbUserComponent.prototype, "rectangle", null);
__decorate$72([
    HostBinding('class.shape-semi-round'),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [])
], NbUserComponent.prototype, "semiRound", null);
__decorate$72([
    HostBinding('class.shape-round'),
    __metadata$47("design:type", Boolean),
    __metadata$47("design:paramtypes", [])
], NbUserComponent.prototype, "round", null);
NbUserComponent = __decorate$72([ __metadata$47("design:paramtypes", [DomSanitizer])
], NbUserComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$71 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const NB_USER_COMPONENTS = [
    NbUserComponent,
];
let NbUserModule = class NbUserModule {
};
NbUserModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbUserModule });
NbUserModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbUserModule_Factory(t) { return new (t || NbUserModule)(); }, imports: [[
            NbSharedModule,
            NbBadgeModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$74 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$48 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Action item, display a link with an icon, or any other content provided instead.
 */
let NbActionComponent = class NbActionComponent {
    /**
     * Action item, display a link with an icon, or any other content provided instead.
     */
    constructor() {
        /**
         * Optional title for mouseover
         * @type string
         */
        this.title = '';
        this._disabled = false;
    }
    /**
     * Visually disables the item
     * @type boolean
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
    }
};
NbActionComponent.ɵfac = function NbActionComponent_Factory(t) { return new (t || NbActionComponent)(); };
NbActionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbActionComponent, selectors: [["nb-action"]], hostVars: 2, hostBindings: function NbActionComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("disabled", ctx.disabled);
    } }, inputs: { title: "title", disabled: "disabled", link: "link", href: "href", icon: "icon", badgeText: "badgeText", badgeStatus: "badgeStatus", badgePosition: "badgePosition" }, ngContentSelectors: _c0, decls: 4, vars: 3, consts: [[4, "ngIf", "ngIfElse"], ["projectedContent", ""], [3, "text", "status", "position", 4, "ngIf"], ["class", "icon-container", 3, "routerLink", "title", 4, "ngIf"], ["class", "icon-container", 3, "href", "title", 4, "ngIf"], ["class", "icon-container", "href", "#", 3, "title", "click", 4, "ngIf"], [1, "icon-container", 3, "routerLink", "title"], [3, "config"], [1, "icon-container", 3, "href", "title"], ["href", "#", 1, "icon-container", 3, "title", "click"], [3, "text", "status", "position"]], template: function NbActionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NbActionComponent_ng_container_0_Template, 4, 3, "ng-container", 0);
        ɵngcc0.ɵɵtemplate(1, NbActionComponent_ng_template_1_Template, 1, 0, "ng-template", null, 1, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(3, NbActionComponent_nb_badge_3_Template, 1, 3, "nb-badge", 2);
    } if (rf & 2) {
        const _r129 = ɵngcc0.ɵɵreference(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.icon)("ngIfElse", _r129);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.badgeText);
    } }, directives: [ɵngcc2.NgIf, ɵngcc5.RouterLinkWithHref, NbIconComponent,
        NbBadgeComponent], styles: ["[_nghost-%COMP%]{background:transparent;display:flex;align-items:center;position:relative}.disabled[_nghost-%COMP%]{cursor:not-allowed}.disabled[_nghost-%COMP%]   a[_ngcontent-%COMP%], .disabled[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{cursor:not-allowed}nb-actions.full-width[_nghost-%COMP%], nb-actions.full-width   [_nghost-%COMP%]{justify-content:center;width:100%}a.icon-container[_ngcontent-%COMP%]:hover, a.icon-container[_ngcontent-%COMP%]:focus{text-decoration:none}nb-icon[_ngcontent-%COMP%]:hover{cursor:pointer}"] });
__decorate$74([
    Input(),
    __metadata$48("design:type", String)
], NbActionComponent.prototype, "link", void 0);
__decorate$74([
    Input(),
    __metadata$48("design:type", String)
], NbActionComponent.prototype, "href", void 0);
__decorate$74([
    Input(),
    __metadata$48("design:type", String)
], NbActionComponent.prototype, "title", void 0);
__decorate$74([
    Input(),
    __metadata$48("design:type", Object)
], NbActionComponent.prototype, "icon", void 0);
__decorate$74([
    Input(),
    HostBinding('class.disabled'),
    __metadata$48("design:type", Boolean),
    __metadata$48("design:paramtypes", [Boolean])
], NbActionComponent.prototype, "disabled", null);
__decorate$74([
    Input(),
    __metadata$48("design:type", String)
], NbActionComponent.prototype, "badgeText", void 0);
__decorate$74([
    Input(),
    __metadata$48("design:type", String)
], NbActionComponent.prototype, "badgeStatus", void 0);
__decorate$74([
    Input(),
    __metadata$48("design:type", String)
], NbActionComponent.prototype, "badgePosition", void 0);
/**
 * Shows a horizontal list of actions, available in multiple sizes.
 * Aligns items vertically.
 *
 * @stacked-example(Showcase, action/action-showcase.component)
 *
 * Basic actions setup:
 * ```html
 * <nb-actions size="small">
 *   <nb-action icon="nb-search"></nb-action>
 *   <nb-action icon="nb-power-circled"></nb-action>
 *   <nb-action icon="nb-person"></nb-action>
 * </nb-actions>
 * ```
 * ### Installation
 *
 * Import `NbActionsModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbActionsModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Multiple sizes example:
 * @stacked-example(Multiple Sizes, action/action-sizes.component)
 *
 * It is also possible to specify a `badge` value:
 *
 * @stacked-example(Action Badge, action/action-badge.component)
 *
 * and we can set it to full a width of a parent component
 * @stacked-example(Full Width, action/action-width.component)
 *
 * @styles
 *
 * actions-background-color:
 * actions-divider-color:
 * actions-divider-style:
 * actions-divider-width:
 * actions-icon-color:
 * actions-text-color:
 * actions-text-font-family:
 * actions-text-font-weight:
 * actions-text-line-height:
 * actions-disabled-icon-color:
 * actions-disabled-text-color:
 * actions-tiny-height:
 * actions-tiny-icon-height:
 * actions-tiny-padding:
 * actions-tiny-text-font-size:
 * actions-small-height:
 * actions-small-icon-height:
 * actions-small-padding:
 * actions-small-text-font-size:
 * actions-medium-height:
 * actions-medium-icon-height:
 * actions-medium-padding:
 * actions-medium-text-font-size:
 * actions-large-height:
 * actions-large-icon-height:
 * actions-large-padding:
 * actions-large-text-font-size:
 * actions-giant-height:
 * actions-giant-icon-height:
 * actions-giant-padding:
 * actions-giant-text-font-size:
 */
let NbActionsComponent = class NbActionsComponent {
    /**
     * Shows a horizontal list of actions, available in multiple sizes.
     * Aligns items vertically.
     *
     * @stacked-example(Showcase, action/action-showcase.component)
     *
     * Basic actions setup:
     * ```html
     * <nb-actions size="small">
     *   <nb-action icon="nb-search"></nb-action>
     *   <nb-action icon="nb-power-circled"></nb-action>
     *   <nb-action icon="nb-person"></nb-action>
     * </nb-actions>
     * ```
     * ### Installation
     *
     * Import `NbActionsModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbActionsModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * Multiple sizes example:
     * @stacked-example(Multiple Sizes, action/action-sizes.component)
     *
     * It is also possible to specify a `badge` value:
     *
     * @stacked-example(Action Badge, action/action-badge.component)
     *
     * and we can set it to full a width of a parent component
     * @stacked-example(Full Width, action/action-width.component)
     *
     * @styles
     *
     * actions-background-color:
     * actions-divider-color:
     * actions-divider-style:
     * actions-divider-width:
     * actions-icon-color:
     * actions-text-color:
     * actions-text-font-family:
     * actions-text-font-weight:
     * actions-text-line-height:
     * actions-disabled-icon-color:
     * actions-disabled-text-color:
     * actions-tiny-height:
     * actions-tiny-icon-height:
     * actions-tiny-padding:
     * actions-tiny-text-font-size:
     * actions-small-height:
     * actions-small-icon-height:
     * actions-small-padding:
     * actions-small-text-font-size:
     * actions-medium-height:
     * actions-medium-icon-height:
     * actions-medium-padding:
     * actions-medium-text-font-size:
     * actions-large-height:
     * actions-large-icon-height:
     * actions-large-padding:
     * actions-large-text-font-size:
     * actions-giant-height:
     * actions-giant-icon-height:
     * actions-giant-padding:
     * actions-giant-text-font-size:
     */
    constructor() {
        this._size = 'small';
        this._fullWidth = false;
    }
    /**
     * Size of the component: 'tiny', 'small' (default), 'medium', 'large', 'giant'
     */
    get size() {
        return this._size;
    }
    set size(value) {
        this._size = value;
    }
    /**
     * Component will fill full width of the container
     */
    get fullWidth() {
        return this._fullWidth;
    }
    set fullWidth(value) {
        this._fullWidth = convertToBoolProperty(value);
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
};
NbActionsComponent.ɵfac = function NbActionsComponent_Factory(t) { return new (t || NbActionsComponent)(); };
NbActionsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbActionsComponent, selectors: [["nb-actions"]], hostVars: 12, hostBindings: function NbActionsComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant);
    } }, inputs: { size: "size", fullWidth: "fullWidth" }, ngContentSelectors: _c20, decls: 1, vars: 0, template: function NbActionsComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c19);
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:flex;align-items:center}"] });
__decorate$74([
    Input(),
    __metadata$48("design:type", String),
    __metadata$48("design:paramtypes", [String])
], NbActionsComponent.prototype, "size", null);
__decorate$74([
    Input(),
    HostBinding('class.full-width'),
    __metadata$48("design:type", Boolean),
    __metadata$48("design:paramtypes", [Boolean])
], NbActionsComponent.prototype, "fullWidth", null);
__decorate$74([
    HostBinding('class.size-tiny'),
    __metadata$48("design:type", Boolean),
    __metadata$48("design:paramtypes", [])
], NbActionsComponent.prototype, "tiny", null);
__decorate$74([
    HostBinding('class.size-small'),
    __metadata$48("design:type", Boolean),
    __metadata$48("design:paramtypes", [])
], NbActionsComponent.prototype, "small", null);
__decorate$74([
    HostBinding('class.size-medium'),
    __metadata$48("design:type", Boolean),
    __metadata$48("design:paramtypes", [])
], NbActionsComponent.prototype, "medium", null);
__decorate$74([
    HostBinding('class.size-large'),
    __metadata$48("design:type", Boolean),
    __metadata$48("design:paramtypes", [])
], NbActionsComponent.prototype, "large", null);
__decorate$74([
    HostBinding('class.size-giant'),
    __metadata$48("design:type", Boolean),
    __metadata$48("design:paramtypes", [])
], NbActionsComponent.prototype, "giant", null);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$73 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const NB_ACTIONS_COMPONENTS = [
    NbActionComponent,
    NbActionsComponent,
];
let NbActionsModule = class NbActionsModule {
};
NbActionsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbActionsModule });
NbActionsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbActionsModule_Factory(t) { return new (t || NbActionsModule)(); }, imports: [[
            NbSharedModule,
            NbBadgeModule,
            NbIconModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$77 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Search component service, connects your code to a page-level search component.
 */
let NbSearchService = class NbSearchService {
    /**
     * Search component service, connects your code to a page-level search component.
     */
    constructor() {
        this.searchSubmittings$ = new Subject();
        this.searchActivations$ = new Subject();
        this.searchDeactivations$ = new Subject();
        this.searchInput$ = new Subject();
    }
    /***
     * Activate (open) search component
     * @param {string} searchType
     * @param {string} tag
     */
    activateSearch(searchType, tag) {
        this.searchActivations$.next({ searchType, tag });
    }
    /**
     * Deactibate (close) search component
     * @param {string} searchType
     * @param {string} tag
     */
    deactivateSearch(searchType, tag) {
        this.searchDeactivations$.next({ searchType, tag });
    }
    /**
     * Trigger search submit
     * @param {string} term
     * @param {string} tag
     */
    submitSearch(term, tag) {
        this.searchSubmittings$.next({ term, tag });
    }
    /**
     * Trigger search submit by input event
     * @param {string} term
     * @param {string} tag
     */
    searchInput(term, tag) {
        this.searchInput$.next({ term, tag });
    }
    /**
     * Subscribe to 'activate' event
     * @returns Observable<{searchType: string; tag?: string}>
     */
    onSearchActivate() {
        return this.searchActivations$.pipe(share());
    }
    /**
     * Subscribe to 'deactivate' event
     * @returns Observable<{searchType: string; tag?: string}>
     */
    onSearchDeactivate() {
        return this.searchDeactivations$.pipe(share());
    }
    /**
     * Subscribe to 'submit' event (when submit button clicked)
     * @returns Observable<{term: string; tag?: string}>
     */
    onSearchSubmit() {
        return this.searchSubmittings$.pipe(share());
    }
    /**
     * Subscribe to input event
     * @returns Observable<{term: string; tag?: string}>
     */
    onSearchInput() {
        return this.searchInput$.pipe(share());
    }
};
NbSearchService.ɵfac = function NbSearchService_Factory(t) { return new (t || NbSearchService)(); };
NbSearchService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbSearchService, factory: NbSearchService.ɵfac });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$76 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$49 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NbSearchFieldComponent_1;
/**
 * search-field-component is used under the hood by nb-search component
 * can't be used itself
 */
let NbSearchFieldComponent = NbSearchFieldComponent_1 = class NbSearchFieldComponent {
    /**
     * search-field-component is used under the hood by nb-search component
     * can't be used itself
     */
    constructor() {
        this.show = false;
        this.close = new EventEmitter();
        this.search = new EventEmitter();
        this.searchInput = new EventEmitter();
    }
    get showClass() {
        return this.show;
    }
    get modalZoomin() {
        return this.type === NbSearchFieldComponent_1.TYPE_MODAL_ZOOMIN;
    }
    get rotateLayout() {
        return this.type === NbSearchFieldComponent_1.TYPE_ROTATE_LAYOUT;
    }
    get modalMove() {
        return this.type === NbSearchFieldComponent_1.TYPE_MODAL_MOVE;
    }
    get curtain() {
        return this.type === NbSearchFieldComponent_1.TYPE_CURTAIN;
    }
    get columnCurtain() {
        return this.type === NbSearchFieldComponent_1.TYPE_COLUMN_CURTAIN;
    }
    get modalDrop() {
        return this.type === NbSearchFieldComponent_1.TYPE_MODAL_DROP;
    }
    get modalHalf() {
        return this.type === NbSearchFieldComponent_1.TYPE_MODAL_HALF;
    }
    ngOnChanges({ show }) {
        const becameHidden = !show.isFirstChange() && show.currentValue === false;
        if (becameHidden && this.inputElement) {
            this.inputElement.nativeElement.value = '';
        }
        this.focusInput();
    }
    ngAfterViewInit() {
        this.focusInput();
    }
    emitClose() {
        this.close.emit();
    }
    submitSearch(term) {
        if (term) {
            this.search.emit(term);
        }
    }
    emitSearchInput(term) {
        this.searchInput.emit(term);
    }
    focusInput() {
        if (this.show && this.inputElement) {
            this.inputElement.nativeElement.focus();
        }
    }
};
NbSearchFieldComponent.ɵfac = function NbSearchFieldComponent_Factory(t) { return new (t || NbSearchFieldComponent)(); };
NbSearchFieldComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSearchFieldComponent, selectors: [["nb-search-field"]], viewQuery: function NbSearchFieldComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c21, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    } }, hostVars: 16, hostBindings: function NbSearchFieldComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("show", ctx.showClass)("modal-zoomin", ctx.modalZoomin)("rotate-layout", ctx.rotateLayout)("modal-move", ctx.modalMove)("curtain", ctx.curtain)("column-curtain", ctx.columnCurtain)("modal-drop", ctx.modalDrop)("modal-half", ctx.modalHalf);
    } }, inputs: { show: "show", type: "type", placeholder: "placeholder", hint: "hint" }, outputs: { close: "close", search: "search", searchInput: "searchInput" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], decls: 10, vars: 2, consts: [[1, "search", 3, "keyup.esc"], ["nbButton", "", "ghost", "", 1, "close-button", 3, "click"], ["icon", "close-outline", "pack", "nebular-essentials"], [1, "form-wrapper"], [1, "form", 3, "keyup.enter"], [1, "form-content"], ["autocomplete", "off", "tabindex", "-1", 1, "search-input", 3, "input", "blur"], ["searchInput", ""], [1, "info"]], template: function NbSearchFieldComponent_Template(rf, ctx) { if (rf & 1) {
        const _r138 = ɵngcc0.ɵɵgetCurrentView();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵlistener("keyup.esc", function NbSearchFieldComponent_Template_div_keyup_esc_0_listener() { return ctx.emitClose(); });
        ɵngcc0.ɵɵelementStart(1, "button", 1);
        ɵngcc0.ɵɵlistener("click", function NbSearchFieldComponent_Template_button_click_1_listener() { return ctx.emitClose(); });
        ɵngcc0.ɵɵelement(2, "nb-icon", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 3);
        ɵngcc0.ɵɵelementStart(4, "form", 4);
        ɵngcc0.ɵɵlistener("keyup.enter", function NbSearchFieldComponent_Template_form_keyup_enter_4_listener() { ɵngcc0.ɵɵrestoreView(_r138); const _r137 = ɵngcc0.ɵɵreference(7); return ctx.submitSearch(_r137.value); });
        ɵngcc0.ɵɵelementStart(5, "div", 5);
        ɵngcc0.ɵɵelementStart(6, "input", 6, 7);
        ɵngcc0.ɵɵlistener("input", function NbSearchFieldComponent_Template_input_input_6_listener() { ɵngcc0.ɵɵrestoreView(_r138); const _r137 = ɵngcc0.ɵɵreference(7); return ctx.emitSearchInput(_r137.value); })("blur", function NbSearchFieldComponent_Template_input_blur_6_listener() { return ctx.focusInput(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(8, "span", 8);
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(6);
        ɵngcc0.ɵɵattribute("placeholder", ctx.placeholder);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.hint);
    } }, directives: [NbButtonComponent,
        NbIconComponent, ɵngcc6.ɵangular_packages_forms_forms_y, ɵngcc6.NgControlStatusGroup, ɵngcc6.NgForm], styles: ["[_nghost-%COMP%]   button[_ngcontent-%COMP%]{margin:0;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:0.05rem 0;-webkit-appearance:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]:focus{outline:none}[_nghost-%COMP%]   input[_ngcontent-%COMP%]::placeholder{opacity:0.3}[_nghost-%COMP%]   span[_ngcontent-%COMP%]{font-size:90%;font-weight:bold;display:block;width:75%;margin:0 auto;padding:0.85rem 0;text-align:right}.modal-zoomin[_nghost-%COMP%]{display:block}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity 0.5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before, .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::after{content:'';position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px, -15px, 0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px, 15px, 0)}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}.modal-zoomin[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before, .modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::after{transform:translate3d(0, 0, 0);transition:transform 0.5s}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}.modal-zoomin.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}@media screen and (max-width: 40rem){.modal-zoomin[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0 1rem}.modal-zoomin[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}", "nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}  nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform 0.5s cubic-bezier(0.2, 1, 0.3, 1)}  nb-layout.rotate-layout.with-search .scrollable-container{transition:transform 0.5s cubic-bezier(0.2, 1, 0.3, 1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0, 50vh, 0) rotate3d(1, 0, 0, 30deg);pointer-events:none}.rotate-layout[_nghost-%COMP%]{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:0.4s}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}[dir=ltr]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(0.7, 0.7, 1);transition:opacity 0.5s, transform 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}.rotate-layout[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:75%}.rotate-layout.show[_nghost-%COMP%]{opacity:1;transition-delay:0s}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}.rotate-layout.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}", "nb-layout.modal-move .layout{transition:transform 0.5s}  nb-layout.modal-move.with-search .layout{transform:scale3d(0.8, 0.8, 1);pointer-events:none}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity 0.5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity 0.5s}[dir=ltr]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{margin:5rem 0;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}.modal-move[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:10vw;width:75%;transform:scale3d(0, 1, 1);transform-origin:0 50%;transition:transform 0.3s}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto;opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}.modal-move.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{transform:scale3d(1, 1, 1);transition-duration:0.5s}@media screen and (max-width: 40rem){.modal-move[_nghost-%COMP%]   span[_ngcontent-%COMP%]{text-align:left}}", ".curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform 0.3s;transition-delay:0.4s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::after{content:'';position:absolute;top:0;left:0;width:100%;height:100%;transition:transform 0.3s;transition-timing-function:ease-out}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;transition:opacity 0.1s;transition-delay:0.3s}[dir=ltr]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:50%;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}.curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{width:100%;font-size:6vw}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{width:100%;pointer-events:auto;transform:translate3d(-100%, 0, 0);transition-delay:0s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::after{transform:translate3d(100%, 0, 0);transition-delay:0.4s}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}.curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}@media screen and (max-width: 40em){.curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2em;width:90%}}  nb-layout.curtain .scrollable-container{position:relative;z-index:0}", "nb-layout.column-curtain.with-search .layout{pointer-events:none}.column-curtain[_nghost-%COMP%]{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}.column-curtain[_nghost-%COMP%]::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0, 1, 1);transform-origin:0 50%;transition:transform 0.3s;transition-timing-function:cubic-bezier(0.86, 0, 0.07, 1)}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{position:relative;padding:2.5rem 1.5rem 0;background:transparent}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity 0.5s}[dir=ltr]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:2rem}[dir=rtl]   .column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:2rem}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:85%;transform:translate3d(-150%, 0, 0);transition:transform 0.3s}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:2.5rem;width:100%}.column-curtain[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:85%}.column-curtain.show[_nghost-%COMP%]{pointer-events:auto}.column-curtain.show[_nghost-%COMP%]::before{transform:scale3d(1, 1, 1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{transform:translate3d(0, 0, 0);transition-delay:0.15s;transition-timing-function:cubic-bezier(0.86, 0, 0.07, 1)}.column-curtain.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;z-index:100}@media screen and (max-width: 40rem){.column-curtain[_nghost-%COMP%]   span[_ngcontent-%COMP%]{width:90%}.column-curtain[_nghost-%COMP%]   input[_ngcontent-%COMP%]{font-size:2rem;width:90%}}", "nb-layout.modal-drop .layout{position:relative;transition:transform 0.4s, opacity 0.4s;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}  nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(0.9, 0.9, 1);pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before{content:'';position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity 0.4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity 0.4s}[dir=ltr]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{position:relative;margin:5rem 0 2rem}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:6vw;width:60%;padding:0.25rem;text-align:center;opacity:0;transition:opacity 0.4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{position:relative;z-index:9;display:block;width:60%;padding:0.85rem 0;opacity:0;transform:translate3d(0, -50px, 0);transition:opacity 0.4s, transform 0.4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{position:relative;z-index:10;overflow:hidden;transform:translate3d(0, -50px, 0);transition:transform 0.4s}.modal-drop[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]::after{content:'';position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]{transform:translate3d(0, 0, 0);transition:none}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-content[_ngcontent-%COMP%]::after{animation:scaleUpDown 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{opacity:1;transition:opacity 0s 0.4s}.modal-drop.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{opacity:1;transform:translate3d(0, 0, 0);transition-delay:0.4s;transition-timing-function:ease-out}@keyframes scaleUpDown{0%{opacity:1;transform:scale3d(1, 0, 1)}50%{transform:scale3d(1, 1, 1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}100%{opacity:1;transform:scale3d(1, 0, 1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){.modal-drop[_nghost-%COMP%]   form[_ngcontent-%COMP%]{margin:2rem 0}.modal-drop[_nghost-%COMP%]   input[_ngcontent-%COMP%]{width:100%;left:0}}", "nb-layout.modal-half .layout{transition:transform 0.6s, opacity 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}  nb-layout.modal-half.with-search .layout{transform:scale3d(0.8, 0.8, 1);pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.6s, transform 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}[dir=ltr]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{right:3rem}[dir=rtl]   .modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{left:3rem}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1);transform:translate3d(0, -100%, 0)}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   form[_ngcontent-%COMP%]{width:75%;margin:0 auto}.modal-half[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{font-size:7vw;width:100%}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]{pointer-events:auto}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]::before{opacity:1}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{opacity:1;transform:scale3d(1, 1, 1)}.modal-half.show[_nghost-%COMP%]   .search[_ngcontent-%COMP%]   .form-wrapper[_ngcontent-%COMP%]{transform:translate3d(0, 0, 0)}"], changeDetection: 0 });
NbSearchFieldComponent.TYPE_MODAL_ZOOMIN = 'modal-zoomin';
NbSearchFieldComponent.TYPE_ROTATE_LAYOUT = 'rotate-layout';
NbSearchFieldComponent.TYPE_MODAL_MOVE = 'modal-move';
NbSearchFieldComponent.TYPE_CURTAIN = 'curtain';
NbSearchFieldComponent.TYPE_COLUMN_CURTAIN = 'column-curtain';
NbSearchFieldComponent.TYPE_MODAL_DROP = 'modal-drop';
NbSearchFieldComponent.TYPE_MODAL_HALF = 'modal-half';
__decorate$76([
    Input(),
    __metadata$49("design:type", String)
], NbSearchFieldComponent.prototype, "type", void 0);
__decorate$76([
    Input(),
    __metadata$49("design:type", String)
], NbSearchFieldComponent.prototype, "placeholder", void 0);
__decorate$76([
    Input(),
    __metadata$49("design:type", String)
], NbSearchFieldComponent.prototype, "hint", void 0);
__decorate$76([
    Input(),
    __metadata$49("design:type", Object)
], NbSearchFieldComponent.prototype, "show", void 0);
__decorate$76([
    Output(),
    __metadata$49("design:type", Object)
], NbSearchFieldComponent.prototype, "close", void 0);
__decorate$76([
    Output(),
    __metadata$49("design:type", Object)
], NbSearchFieldComponent.prototype, "search", void 0);
__decorate$76([
    Output(),
    __metadata$49("design:type", Object)
], NbSearchFieldComponent.prototype, "searchInput", void 0);
__decorate$76([
    ViewChild('searchInput', { static: false }),
    __metadata$49("design:type", ElementRef)
], NbSearchFieldComponent.prototype, "inputElement", void 0);
__decorate$76([
    HostBinding('class.show'),
    __metadata$49("design:type", Object),
    __metadata$49("design:paramtypes", [])
], NbSearchFieldComponent.prototype, "showClass", null);
__decorate$76([
    HostBinding('class.modal-zoomin'),
    __metadata$49("design:type", Object),
    __metadata$49("design:paramtypes", [])
], NbSearchFieldComponent.prototype, "modalZoomin", null);
__decorate$76([
    HostBinding('class.rotate-layout'),
    __metadata$49("design:type", Object),
    __metadata$49("design:paramtypes", [])
], NbSearchFieldComponent.prototype, "rotateLayout", null);
__decorate$76([
    HostBinding('class.modal-move'),
    __metadata$49("design:type", Object),
    __metadata$49("design:paramtypes", [])
], NbSearchFieldComponent.prototype, "modalMove", null);
__decorate$76([
    HostBinding('class.curtain'),
    __metadata$49("design:type", Object),
    __metadata$49("design:paramtypes", [])
], NbSearchFieldComponent.prototype, "curtain", null);
__decorate$76([
    HostBinding('class.column-curtain'),
    __metadata$49("design:type", Object),
    __metadata$49("design:paramtypes", [])
], NbSearchFieldComponent.prototype, "columnCurtain", null);
__decorate$76([
    HostBinding('class.modal-drop'),
    __metadata$49("design:type", Object),
    __metadata$49("design:paramtypes", [])
], NbSearchFieldComponent.prototype, "modalDrop", null);
__decorate$76([
    HostBinding('class.modal-half'),
    __metadata$49("design:type", Object),
    __metadata$49("design:paramtypes", [])
], NbSearchFieldComponent.prototype, "modalHalf", null);
/**
 * Beautiful full-page search control.
 *
 * @stacked-example(Showcase, search/search-showcase.component)
 *
 * Basic setup:
 *
 * ```ts
 *  <nb-search type="rotate-layout"></nb-search>
 * ```
 * ### Installation
 *
 * Import `NbSearchModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSearchModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Several animation types are available:
 * modal-zoomin, rotate-layout, modal-move, curtain, column-curtain, modal-drop, modal-half
 *
 * It is also possible to handle search event using `NbSearchService`:
 *
 * @stacked-example(Search Event, search/search-event.component)
 *
 * @styles
 *
 * search-background-color:
 * search-divider-color:
 * search-divider-style:
 * search-divider-width:
 * search-extra-background-color:
 * search-text-color:
 * search-text-font-family:
 * search-text-font-size:
 * search-text-font-weight:
 * search-text-line-height:
 * search-placeholder-text-color:
 * search-info-text-color:
 * search-info-text-font-family:
 * search-info-text-font-size:
 * search-info-text-font-weight:
 * search-info-text-line-height:
 */
let NbSearchComponent = class NbSearchComponent {
    constructor(searchService, themeService, router, overlayService, changeDetector) {
        this.searchService = searchService;
        this.themeService = themeService;
        this.router = router;
        this.overlayService = overlayService;
        this.changeDetector = changeDetector;
        this.alive = true;
        this.showSearchField = false;
        /**
         * Search input placeholder
         * @type {string}
         */
        this.placeholder = 'Search...';
        /**
         * Hint showing under the input field to improve user experience
         *
         * @type {string}
         */
        this.hint = 'Hit enter to search';
    }
    ngOnInit() {
        this.router.events
            .pipe(takeWhile(() => this.alive), filter(event => event instanceof NavigationEnd))
            .subscribe(() => this.hideSearch());
        this.searchService.onSearchActivate()
            .pipe(takeWhile(() => this.alive), filter(data => !this.tag || data.tag === this.tag))
            .subscribe(() => this.openSearch());
        this.searchService.onSearchDeactivate()
            .pipe(takeWhile(() => this.alive), filter(data => !this.tag || data.tag === this.tag))
            .subscribe(() => this.hideSearch());
    }
    ngOnDestroy() {
        if (this.overlayRef && this.overlayRef.hasAttached()) {
            this.removeLayoutClasses();
            this.overlayRef.detach();
        }
        this.alive = false;
    }
    openSearch() {
        if (!this.overlayRef) {
            this.overlayRef = this.overlayService.create();
            this.overlayRef.attach(this.searchFieldPortal);
        }
        this.themeService.appendLayoutClass(this.type);
        of(null).pipe(delay(0)).subscribe(() => {
            this.themeService.appendLayoutClass('with-search');
            this.showSearchField = true;
            this.changeDetector.detectChanges();
        });
    }
    hideSearch() {
        this.removeLayoutClasses();
        this.showSearchField = false;
        this.changeDetector.detectChanges();
        this.searchButton.nativeElement.focus();
    }
    search(term) {
        this.searchService.submitSearch(term, this.tag);
        this.hideSearch();
    }
    emitInput(term) {
        this.searchService.searchInput(term, this.tag);
    }
    emitActivate() {
        this.searchService.activateSearch(this.type, this.tag);
    }
    emitDeactivate() {
        this.searchService.deactivateSearch(this.type, this.tag);
    }
    removeLayoutClasses() {
        this.themeService.removeLayoutClass('with-search');
        of(null).pipe(delay(500)).subscribe(() => {
            this.themeService.removeLayoutClass(this.type);
        });
    }
};
NbSearchComponent.ɵfac = function NbSearchComponent_Factory(t) { return new (t || NbSearchComponent)(ɵngcc0.ɵɵdirectiveInject(NbSearchService), ɵngcc0.ɵɵdirectiveInject(NbThemeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Router), ɵngcc0.ɵɵdirectiveInject(NbOverlayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbSearchComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSearchComponent, selectors: [["nb-search"]], viewQuery: function NbSearchComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbPortalDirective, true);
        ɵngcc0.ɵɵviewQuery(_c22, true, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchFieldPortal = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.searchButton = _t.first);
    } }, inputs: { placeholder: "placeholder", hint: "hint", tag: "tag", type: "type" }, decls: 4, vars: 0, consts: [["nbButton", "", "ghost", "", 1, "start-search", 3, "click"], ["searchButton", ""], ["icon", "search-outline", "pack", "nebular-essentials"], [3, "show", "type", "placeholder", "hint", "search", "searchInput", "close", 4, "nbPortal"], [3, "show", "type", "placeholder", "hint", "search", "searchInput", "close"]], template: function NbSearchComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0, 1);
        ɵngcc0.ɵɵlistener("click", function NbSearchComponent_Template_button_click_0_listener() { return ctx.emitActivate(); });
        ɵngcc0.ɵɵelement(2, "nb-icon", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, NbSearchComponent_nb_search_field_3_Template, 1, 4, "nb-search-field", 3);
    } }, directives: [NbButtonComponent,
        NbIconComponent,
        NbPortalDirective,
        NbSearchFieldComponent], styles: ["[_nghost-%COMP%]   button[_ngcontent-%COMP%]{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}[_nghost-%COMP%]   button[_ngcontent-%COMP%]:focus{box-shadow:none;outline:none}  nb-layout.with-search .scrollable-container{position:relative;z-index:0}"], changeDetection: 0 });
__decorate$76([
    Input(),
    __metadata$49("design:type", String)
], NbSearchComponent.prototype, "tag", void 0);
__decorate$76([
    Input(),
    __metadata$49("design:type", String)
], NbSearchComponent.prototype, "placeholder", void 0);
__decorate$76([
    Input(),
    __metadata$49("design:type", String)
], NbSearchComponent.prototype, "hint", void 0);
__decorate$76([
    Input(),
    __metadata$49("design:type", String)
], NbSearchComponent.prototype, "type", void 0);
__decorate$76([
    ViewChild(NbPortalDirective, { static: false }),
    __metadata$49("design:type", NbPortalDirective)
], NbSearchComponent.prototype, "searchFieldPortal", void 0);
__decorate$76([
    ViewChild('searchButton', { read: ElementRef, static: false }),
    __metadata$49("design:type", ElementRef)
], NbSearchComponent.prototype, "searchButton", void 0);
NbSearchComponent = __decorate$76([ __metadata$49("design:paramtypes", [NbSearchService,
        NbThemeService,
        Router,
        NbOverlayService,
        ChangeDetectorRef])
], NbSearchComponent);

var __decorate$75 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
let NbSearchModule = class NbSearchModule {
};
NbSearchModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSearchModule });
NbSearchModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbSearchModule_Factory(t) { return new (t || NbSearchModule)(); }, providers: [
        NbSearchService,
    ], imports: [[
            NbSharedModule,
            NbOverlayModule,
            NbIconModule,
            NbButtonModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$78 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$50 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NbCheckboxComponent_1;
/**
 * Styled checkbox component
 *
 * @stacked-example(Showcase, checkbox/checkbox-showcase.component)
 *
 * ### Installation
 *
 * Import `NbCheckboxComponent` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbCheckboxModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Checkbox is available in multiple colors using `status` property:
 * @stacked-example(Colored Checkboxes, checkbox/checkbox-status.component)
 *
 * Indeterminate state is also supported:
 * @stacked-example(Indeterminate Checkbox, checkbox/checkbox-indeterminate.component)
 *
 * Checkbox can be disabled via `disabled` attribute.
 * @stacked-example(Disabled Checkbox, checkbox/checkbox-disabled.component)
 *
 * @styles
 *
 * checkbox-height:
 * checkbox-width:
 * checkbox-border-style:
 * checkbox-border-width:
 * checkbox-border-radius:
 * checkbox-outline-width:
 * checkbox-outline-color:
 * checkbox-text-font-family:
 * checkbox-text-font-size:
 * checkbox-text-font-weight:
 * checkbox-text-line-height:
 * checkbox-text-space:
 * checkbox-padding:
 * checkbox-basic-text-color:
 * checkbox-basic-background-color:
 * checkbox-basic-border-color:
 * checkbox-basic-checked-background-color:
 * checkbox-basic-checked-border-color:
 * checkbox-basic-checked-checkmark-color:
 * checkbox-basic-indeterminate-background-color:
 * checkbox-basic-indeterminate-border-color:
 * checkbox-basic-indeterminate-checkmark-color:
 * checkbox-basic-focus-background-color:
 * checkbox-basic-focus-border-color:
 * checkbox-basic-focus-checked-background-color:
 * checkbox-basic-focus-checked-border-color:
 * checkbox-basic-hover-background-color:
 * checkbox-basic-hover-border-color:
 * checkbox-basic-hover-checked-background-color:
 * checkbox-basic-hover-checked-border-color:
 * checkbox-basic-active-background-color:
 * checkbox-basic-active-border-color:
 * checkbox-basic-active-checked-background-color:
 * checkbox-basic-active-checked-border-color:
 * checkbox-basic-disabled-background-color:
 * checkbox-basic-disabled-border-color:
 * checkbox-basic-disabled-checkmark-color:
 * checkbox-basic-disabled-text-color:
 * checkbox-basic-disabled-checked-background-color:
 * checkbox-primary-text-color:
 * checkbox-primary-background-color:
 * checkbox-primary-border-color:
 * checkbox-primary-checked-background-color:
 * checkbox-primary-checked-border-color:
 * checkbox-primary-checked-checkmark-color:
 * checkbox-primary-indeterminate-background-color:
 * checkbox-primary-indeterminate-border-color:
 * checkbox-primary-indeterminate-checkmark-color:
 * checkbox-primary-focus-background-color:
 * checkbox-primary-focus-border-color:
 * checkbox-primary-focus-checked-background-color:
 * checkbox-primary-focus-checked-border-color:
 * checkbox-primary-hover-background-color:
 * checkbox-primary-hover-border-color:
 * checkbox-primary-hover-checked-background-color:
 * checkbox-primary-hover-checked-border-color:
 * checkbox-primary-active-background-color:
 * checkbox-primary-active-border-color:
 * checkbox-primary-active-checked-background-color:
 * checkbox-primary-active-checked-border-color:
 * checkbox-primary-disabled-background-color:
 * checkbox-primary-disabled-border-color:
 * checkbox-primary-disabled-checkmark-color:
 * checkbox-primary-disabled-text-color:
 * checkbox-primary-disabled-checked-background-color:
 * checkbox-success-text-color:
 * checkbox-success-background-color:
 * checkbox-success-border-color:
 * checkbox-success-checked-background-color:
 * checkbox-success-checked-border-color:
 * checkbox-success-checked-checkmark-color:
 * checkbox-success-indeterminate-background-color:
 * checkbox-success-indeterminate-border-color:
 * checkbox-success-indeterminate-checkmark-color:
 * checkbox-success-focus-background-color:
 * checkbox-success-focus-border-color:
 * checkbox-success-focus-checked-background-color:
 * checkbox-success-focus-checked-border-color:
 * checkbox-success-hover-background-color:
 * checkbox-success-hover-border-color:
 * checkbox-success-hover-checked-background-color:
 * checkbox-success-hover-checked-border-color:
 * checkbox-success-active-background-color:
 * checkbox-success-active-border-color:
 * checkbox-success-active-checked-background-color:
 * checkbox-success-active-checked-border-color:
 * checkbox-success-disabled-background-color:
 * checkbox-success-disabled-border-color:
 * checkbox-success-disabled-checkmark-color:
 * checkbox-success-disabled-text-color:
 * checkbox-success-disabled-checked-background-color:
 * checkbox-info-text-color:
 * checkbox-info-background-color:
 * checkbox-info-border-color:
 * checkbox-info-checked-background-color:
 * checkbox-info-checked-border-color:
 * checkbox-info-checked-checkmark-color:
 * checkbox-info-indeterminate-background-color:
 * checkbox-info-indeterminate-border-color:
 * checkbox-info-indeterminate-checkmark-color:
 * checkbox-info-focus-background-color:
 * checkbox-info-focus-border-color:
 * checkbox-info-focus-checked-background-color:
 * checkbox-info-focus-checked-border-color:
 * checkbox-info-hover-background-color:
 * checkbox-info-hover-border-color:
 * checkbox-info-hover-checked-background-color:
 * checkbox-info-hover-checked-border-color:
 * checkbox-info-active-background-color:
 * checkbox-info-active-border-color:
 * checkbox-info-active-checked-background-color:
 * checkbox-info-active-checked-border-color:
 * checkbox-info-disabled-background-color:
 * checkbox-info-disabled-border-color:
 * checkbox-info-disabled-checkmark-color:
 * checkbox-info-disabled-text-color:
 * checkbox-info-disabled-checked-background-color:
 * checkbox-warning-text-color:
 * checkbox-warning-background-color:
 * checkbox-warning-border-color:
 * checkbox-warning-checked-background-color:
 * checkbox-warning-checked-border-color:
 * checkbox-warning-checked-checkmark-color:
 * checkbox-warning-indeterminate-background-color:
 * checkbox-warning-indeterminate-border-color:
 * checkbox-warning-indeterminate-checkmark-color:
 * checkbox-warning-focus-background-color:
 * checkbox-warning-focus-border-color:
 * checkbox-warning-focus-checked-background-color:
 * checkbox-warning-focus-checked-border-color:
 * checkbox-warning-hover-background-color:
 * checkbox-warning-hover-border-color:
 * checkbox-warning-hover-checked-background-color:
 * checkbox-warning-hover-checked-border-color:
 * checkbox-warning-active-background-color:
 * checkbox-warning-active-border-color:
 * checkbox-warning-active-checked-background-color:
 * checkbox-warning-active-checked-border-color:
 * checkbox-warning-disabled-background-color:
 * checkbox-warning-disabled-border-color:
 * checkbox-warning-disabled-checkmark-color:
 * checkbox-warning-disabled-text-color:
 * checkbox-warning-disabled-checked-background-color:
 * checkbox-danger-text-color:
 * checkbox-danger-background-color:
 * checkbox-danger-border-color:
 * checkbox-danger-checked-background-color:
 * checkbox-danger-checked-border-color:
 * checkbox-danger-checked-checkmark-color:
 * checkbox-danger-indeterminate-background-color:
 * checkbox-danger-indeterminate-border-color:
 * checkbox-danger-indeterminate-checkmark-color:
 * checkbox-danger-focus-background-color:
 * checkbox-danger-focus-border-color:
 * checkbox-danger-focus-checked-background-color:
 * checkbox-danger-focus-checked-border-color:
 * checkbox-danger-hover-background-color:
 * checkbox-danger-hover-border-color:
 * checkbox-danger-hover-checked-background-color:
 * checkbox-danger-hover-checked-border-color:
 * checkbox-danger-active-background-color:
 * checkbox-danger-active-border-color:
 * checkbox-danger-active-checked-background-color:
 * checkbox-danger-active-checked-border-color:
 * checkbox-danger-disabled-background-color:
 * checkbox-danger-disabled-border-color:
 * checkbox-danger-disabled-checkmark-color:
 * checkbox-danger-disabled-text-color:
 * checkbox-danger-disabled-checked-background-color:
 * checkbox-control-text-color:
 * checkbox-control-background-color:
 * checkbox-control-border-color:
 * checkbox-control-checked-background-color:
 * checkbox-control-checked-border-color:
 * checkbox-control-checked-checkmark-color:
 * checkbox-control-indeterminate-background-color:
 * checkbox-control-indeterminate-border-color:
 * checkbox-control-indeterminate-checkmark-color:
 * checkbox-control-focus-background-color:
 * checkbox-control-focus-border-color:
 * checkbox-control-focus-checked-background-color:
 * checkbox-control-focus-checked-border-color:
 * checkbox-control-hover-background-color:
 * checkbox-control-hover-border-color:
 * checkbox-control-hover-checked-background-color:
 * checkbox-control-hover-checked-border-color:
 * checkbox-control-active-background-color:
 * checkbox-control-active-border-color:
 * checkbox-control-active-checked-background-color:
 * checkbox-control-active-checked-border-color:
 * checkbox-control-disabled-background-color:
 * checkbox-control-disabled-border-color:
 * checkbox-control-disabled-checkmark-color:
 * checkbox-control-disabled-text-color:
 * checkbox-control-disabled-checked-background-color:
 */
let NbCheckboxComponent = NbCheckboxComponent_1 = class NbCheckboxComponent {
    constructor(changeDetector) {
        this.changeDetector = changeDetector;
        this.onChange = () => { };
        this.onTouched = () => { };
        this._checked = false;
        this._disabled = false;
        this._status = 'basic';
        this._indeterminate = false;
        /**
         * Output when checked state is changed by a user
         * @type EventEmitter<boolean>
         */
        this.checkedChange = new EventEmitter();
    }
    /**
     * Checkbox value
     * @deprecated
     * @breaking-change Remove @5.0.0
     */
    get value() {
        return this.checked;
    }
    /**
     * @deprecated
     * @breaking-change Remove @5.0.0
     */
    set value(value) {
        console.warn('NbCheckbox: `value` is deprecated and will be removed in 5.0.0. Use `checked` instead.');
        this.checked = value;
    }
    get checked() {
        return this._checked;
    }
    set checked(value) {
        this._checked = convertToBoolProperty(value);
    }
    /**
     * Controls input disabled state
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
    }
    /**
     * Checkbox status.
     * Possible values are: `basic`, `primary`, `success`, `warning`, `danger`, `info`, `control`.
     */
    get status() {
        return this._status;
    }
    set status(value) {
        if (value === '') {
            emptyStatusWarning('NbCheckbox');
            this._status = 'basic';
        }
        else {
            this._status = value;
        }
    }
    /**
     * Controls checkbox indeterminate state
     */
    get indeterminate() {
        return this._indeterminate;
    }
    set indeterminate(value) {
        this._indeterminate = convertToBoolProperty(value);
    }
    /**
     * Output when checked state is changed by a user
     * @deprecated
     * @breaking-change Remove @5.0.0
     * @type EventEmitter<boolean>
     */
    get valueChange() {
        console.warn('NbCheckbox: `valueChange` is deprecated and will be removed in 5.0.0. Use `checkedChange` instead.');
        return this.checkedChange;
    }
    set valueChange(valueChange) {
        this.checkedChange = valueChange;
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get info() {
        return this.status === 'info';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    writeValue(val) {
        this._checked = val;
        this.changeDetector.detectChanges();
    }
    setDisabledState(val) {
        this.disabled = convertToBoolProperty(val);
    }
    setTouched() {
        this.onTouched();
    }
    updateValueAndIndeterminate(event) {
        const input = event.target;
        this.checked = input.checked;
        this.checkedChange.emit(this.checked);
        this.onChange(this.checked);
        this.indeterminate = input.indeterminate;
    }
};
NbCheckboxComponent.ɵfac = function NbCheckboxComponent_Factory(t) { return new (t || NbCheckboxComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbCheckboxComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbCheckboxComponent, selectors: [["nb-checkbox"]], hostVars: 14, hostBindings: function NbCheckboxComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control);
    } }, inputs: { value: "value", checked: "checked", disabled: "disabled", status: "status", indeterminate: "indeterminate" }, outputs: { checkedChange: "checkedChange", valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbCheckboxComponent_1),
                multi: true
            }])], ngContentSelectors: _c0, decls: 7, vars: 9, consts: [[1, "label"], ["type", "checkbox", 1, "native-input", "visually-hidden", 3, "disabled", "checked", "indeterminate", "change", "blur", "click"], [1, "custom-checkbox"], ["icon", "minus-bold-outline", "pack", "nebular-essentials", 4, "ngIf"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "text"], ["icon", "minus-bold-outline", "pack", "nebular-essentials"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials"]], template: function NbCheckboxComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1);
        ɵngcc0.ɵɵlistener("change", function NbCheckboxComponent_Template_input_change_1_listener($event) { return ctx.updateValueAndIndeterminate($event); })("blur", function NbCheckboxComponent_Template_input_blur_1_listener() { return ctx.setTouched(); })("click", function NbCheckboxComponent_Template_input_click_1_listener($event) { return $event.stopPropagation(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtemplate(3, NbCheckboxComponent_nb_icon_3_Template, 1, 0, "nb-icon", 3);
        ɵngcc0.ɵɵtemplate(4, NbCheckboxComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "span", 5);
        ɵngcc0.ɵɵprojection(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("checked", ctx.checked)("indeterminate", ctx.indeterminate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("indeterminate", ctx.indeterminate)("checked", ctx.checked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.indeterminate);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.checked && !ctx.indeterminate);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]   .label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}[_nghost-%COMP%]   .custom-checkbox[_ngcontent-%COMP%]{flex-shrink:0;transition-duration:0.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}[_nghost-%COMP%]   .text[_ngcontent-%COMP%]{transition:color 0.15s ease-in}"] });
__decorate$78([
    Input(),
    __metadata$50("design:type", Boolean),
    __metadata$50("design:paramtypes", [Boolean])
], NbCheckboxComponent.prototype, "value", null);
__decorate$78([
    Input(),
    __metadata$50("design:type", Boolean),
    __metadata$50("design:paramtypes", [Boolean])
], NbCheckboxComponent.prototype, "checked", null);
__decorate$78([
    Input(),
    __metadata$50("design:type", Boolean),
    __metadata$50("design:paramtypes", [Boolean])
], NbCheckboxComponent.prototype, "disabled", null);
__decorate$78([
    Input(),
    __metadata$50("design:type", String),
    __metadata$50("design:paramtypes", [String])
], NbCheckboxComponent.prototype, "status", null);
__decorate$78([
    Input(),
    __metadata$50("design:type", Boolean),
    __metadata$50("design:paramtypes", [Boolean])
], NbCheckboxComponent.prototype, "indeterminate", null);
__decorate$78([
    Output(),
    __metadata$50("design:type", EventEmitter),
    __metadata$50("design:paramtypes", [EventEmitter])
], NbCheckboxComponent.prototype, "valueChange", null);
__decorate$78([
    Output(),
    __metadata$50("design:type", Object)
], NbCheckboxComponent.prototype, "checkedChange", void 0);
__decorate$78([
    HostBinding('class.status-primary'),
    __metadata$50("design:type", Object),
    __metadata$50("design:paramtypes", [])
], NbCheckboxComponent.prototype, "primary", null);
__decorate$78([
    HostBinding('class.status-success'),
    __metadata$50("design:type", Object),
    __metadata$50("design:paramtypes", [])
], NbCheckboxComponent.prototype, "success", null);
__decorate$78([
    HostBinding('class.status-warning'),
    __metadata$50("design:type", Object),
    __metadata$50("design:paramtypes", [])
], NbCheckboxComponent.prototype, "warning", null);
__decorate$78([
    HostBinding('class.status-danger'),
    __metadata$50("design:type", Object),
    __metadata$50("design:paramtypes", [])
], NbCheckboxComponent.prototype, "danger", null);
__decorate$78([
    HostBinding('class.status-info'),
    __metadata$50("design:type", Object),
    __metadata$50("design:paramtypes", [])
], NbCheckboxComponent.prototype, "info", null);
__decorate$78([
    HostBinding('class.status-basic'),
    __metadata$50("design:type", Object),
    __metadata$50("design:paramtypes", [])
], NbCheckboxComponent.prototype, "basic", null);
__decorate$78([
    HostBinding('class.status-control'),
    __metadata$50("design:type", Object),
    __metadata$50("design:paramtypes", [])
], NbCheckboxComponent.prototype, "control", null);
NbCheckboxComponent = NbCheckboxComponent_1 = __decorate$78([ __metadata$50("design:paramtypes", [ChangeDetectorRef])
], NbCheckboxComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$79 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbCheckboxModule = class NbCheckboxModule {
};
NbCheckboxModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbCheckboxModule });
NbCheckboxModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbCheckboxModule_Factory(t) { return new (t || NbCheckboxModule)(); }, imports: [[
            NbSharedModule,
            NbIconModule,
        ]] });

var __decorate$81 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$52 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbDynamicOverlay = class NbDynamicOverlay {
    constructor(overlay, componentFactoryResolver, zone, overlayContainer) {
        this.overlay = overlay;
        this.componentFactoryResolver = componentFactoryResolver;
        this.zone = zone;
        this.overlayContainer = overlayContainer;
        this.context = {};
        this.overlayConfig = {};
        this.positionStrategyChange$ = new Subject();
        this.isShown$ = new BehaviorSubject(false);
        this.alive = true;
    }
    get isAttached() {
        return this.ref && this.ref.hasAttached();
    }
    get isShown() {
        return this.isShown$.pipe(distinctUntilChanged());
    }
    create(componentType, content, context, positionStrategy, overlayConfig = {}) {
        this.setContentAndContext(content, context);
        this.setComponent(componentType);
        this.setPositionStrategy(positionStrategy);
        this.setOverlayConfig(overlayConfig);
        return this;
    }
    setContent(content) {
        this.content = content;
        if (this.container) {
            this.updateContext();
        }
    }
    setContext(context) {
        this.context = context;
        if (this.container) {
            this.updateContext();
        }
    }
    setContentAndContext(content, context) {
        this.content = content;
        this.context = context;
        if (this.container) {
            this.updateContext();
        }
    }
    setComponent(componentType) {
        this.componentType = componentType;
        // in case the component is shown we recreate it and show it back
        const wasAttached = this.isAttached;
        this.disposeOverlayRef();
        if (wasAttached) {
            this.show();
        }
    }
    setPositionStrategy(positionStrategy) {
        this.positionStrategyChange$.next();
        this.positionStrategy = positionStrategy;
        this.positionStrategy.positionChange
            .pipe(takeWhile(() => this.alive), takeUntil(this.positionStrategyChange$), filter(() => !!this.container))
            .subscribe((position) => {
            this.lastAppliedPosition = position;
            patch(this.container, { position });
        });
        if (this.ref) {
            this.ref.updatePositionStrategy(this.positionStrategy);
        }
    }
    setOverlayConfig(overlayConfig) {
        this.overlayConfig = overlayConfig;
        const wasAttached = this.isAttached;
        this.disposeOverlayRef();
        if (wasAttached) {
            this.show();
        }
    }
    show() {
        if (!this.ref) {
            this.createOverlay();
        }
        this.renderContainer();
        if (!this.hasOverlayInContainer()) {
            // Dispose overlay ref as it refers to the old overlay container and create new by calling `show`
            this.disposeOverlayRef();
            return this.show();
        }
        this.isShown$.next(true);
    }
    hide() {
        if (!this.ref) {
            return;
        }
        this.ref.detach();
        this.container = null;
        this.isShown$.next(false);
    }
    toggle() {
        if (this.isAttached) {
            this.hide();
        }
        else {
            this.show();
        }
    }
    dispose() {
        this.alive = false;
        this.hide();
        this.disposeOverlayRef();
        this.isShown$.complete();
        this.positionStrategyChange$.complete();
    }
    getContainer() {
        return this.container;
    }
    createOverlay() {
        this.ref = this.overlay.create(Object.assign({ positionStrategy: this.positionStrategy, scrollStrategy: this.overlay.scrollStrategies.reposition() }, this.overlayConfig));
        this.updatePositionWhenStable();
    }
    renderContainer() {
        const containerContext = this.createContainerContext();
        if (!this.container) {
            this.container = createContainer(this.ref, this.componentType, containerContext, this.componentFactoryResolver);
        }
        this.container.instance.renderContent();
    }
    updateContext() {
        const containerContext = this.createContainerContext();
        Object.assign(this.container.instance, containerContext);
        this.container.instance.renderContent();
        this.container.changeDetectorRef.detectChanges();
    }
    createContainerContext() {
        return {
            content: this.content,
            context: this.context,
            cfr: this.componentFactoryResolver,
            position: this.lastAppliedPosition,
        };
    }
    /**
     * Dimensions of the container may change after content update. So we listen to zone.stable event to
     * reposition the container.
     */
    updatePositionWhenStable() {
        this.zone.onStable
            .pipe(takeWhile(() => this.alive))
            .subscribe(() => {
            this.ref && this.ref.updatePosition();
        });
    }
    hasOverlayInContainer() {
        return this.overlayContainer.getContainerElement().contains(this.ref.hostElement);
    }
    disposeOverlayRef() {
        if (this.ref) {
            this.ref.dispose();
            this.ref = null;
            this.container = null;
        }
    }
};
NbDynamicOverlay.ɵfac = function NbDynamicOverlay_Factory(t) { return new (t || NbDynamicOverlay)(ɵngcc0.ɵɵinject(NbOverlayService), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(NbOverlayContainer)); };
NbDynamicOverlay.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbDynamicOverlay, factory: NbDynamicOverlay.ɵfac });
NbDynamicOverlay = __decorate$81([ __metadata$52("design:paramtypes", [NbOverlayService,
        ComponentFactoryResolver,
        NgZone,
        NbOverlayContainer])
], NbDynamicOverlay);

var __decorate$82 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$53 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
class NbDynamicOverlayChange extends SimpleChange {
    constructor(previousValue, currentValue, firstChange = false) {
        super(previousValue, currentValue, firstChange);
    }
    isChanged() {
        return this.currentValue !== this.previousValue;
    }
}
let NbDynamicOverlayHandler = class NbDynamicOverlayHandler {
    constructor(positionBuilder, triggerStrategyBuilder, dynamicOverlayService) {
        this.positionBuilder = positionBuilder;
        this.triggerStrategyBuilder = triggerStrategyBuilder;
        this.dynamicOverlayService = dynamicOverlayService;
        this._context = {};
        this._trigger = NbTrigger.NOOP;
        this._position = NbPosition.TOP;
        this._adjustment = NbAdjustment.NOOP;
        this._offset = 15;
        this._overlayConfig = {};
        this.changes = {};
    }
    host(host) {
        this.changes.host = new NbDynamicOverlayChange(this._host, host);
        this._host = host;
        return this;
    }
    trigger(trigger$$1) {
        this.changes.trigger = new NbDynamicOverlayChange(this._trigger, trigger$$1);
        this._trigger = trigger$$1;
        return this;
    }
    position(position) {
        this.changes.position = new NbDynamicOverlayChange(this._position, position);
        this._position = position;
        return this;
    }
    adjustment(adjustment) {
        this.changes.adjustment = new NbDynamicOverlayChange(this._adjustment, adjustment);
        this._adjustment = adjustment;
        return this;
    }
    componentType(componentType) {
        this.changes.componentType = new NbDynamicOverlayChange(this._componentType, componentType);
        this._componentType = componentType;
        return this;
    }
    content(content) {
        this.changes.content = new NbDynamicOverlayChange(this._content, content);
        this._content = content;
        return this;
    }
    context(context) {
        this.changes.context = new NbDynamicOverlayChange(this._context, context);
        this._context = context;
        return this;
    }
    offset(offset) {
        this.changes.offset = new NbDynamicOverlayChange(this._offset, offset);
        this._offset = offset;
        return this;
    }
    overlayConfig(overlayConfig) {
        this.changes.overlayConfig = new NbDynamicOverlayChange(this._overlayConfig, overlayConfig);
        this._overlayConfig = overlayConfig;
        return this;
    }
    build() {
        if (!this._componentType || !this._host) {
            throw Error(`NbDynamicOverlayHandler: at least 'componentType' and 'host' should be
      passed before building a dynamic overlay.`);
        }
        this.dynamicOverlay = this.dynamicOverlayService.create(this._componentType, this._content, this._context, this.createPositionStrategy(), this._overlayConfig);
        this.connect();
        this.clearChanges();
        return this.dynamicOverlay;
    }
    rebuild() {
        /**
         * we should not throw here
         * as we use rebuilt in lifecycle hooks
         * which it could be called before the build
         * so we just ignore this call
         */
        if (!this.dynamicOverlay) {
            return;
        }
        if (this.isPositionStrategyUpdateRequired()) {
            this.dynamicOverlay.setPositionStrategy(this.createPositionStrategy());
        }
        if (this.isTriggerStrategyUpdateRequired()) {
            this.connect();
        }
        if (this.isContainerRerenderRequired()) {
            this.dynamicOverlay.setContentAndContext(this._content, this._context);
        }
        if (this.isComponentTypeUpdateRequired()) {
            this.dynamicOverlay.setComponent(this._componentType);
        }
        if (this.isOverlayConfigUpdateRequired()) {
            this.dynamicOverlay.setOverlayConfig(this._overlayConfig);
        }
        this.clearChanges();
        return this.dynamicOverlay;
    }
    connect() {
        if (!this.dynamicOverlay) {
            throw new Error(`NbDynamicOverlayHandler: cannot connect to DynamicOverlay
      as it is not created yet. Call build() first`);
        }
        this.disconnect();
        this.subscribeOnTriggers(this.dynamicOverlay);
    }
    disconnect() {
        if (this.triggerStrategy) {
            this.triggerStrategy.destroy();
        }
    }
    destroy() {
        this.disconnect();
        this.clearChanges();
        if (this.dynamicOverlay) {
            this.dynamicOverlay.dispose();
        }
    }
    createPositionStrategy() {
        return this.positionBuilder
            .connectedTo(this._host)
            .position(this._position)
            .adjustment(this._adjustment)
            .offset(this._offset);
    }
    subscribeOnTriggers(dynamicOverlay) {
        this.triggerStrategy = this.triggerStrategyBuilder
            .trigger(this._trigger)
            .host(this._host.nativeElement)
            .container(() => dynamicOverlay.getContainer())
            .build();
        this.triggerStrategy.show$.subscribe(() => dynamicOverlay.show());
        this.triggerStrategy.hide$.subscribe(() => dynamicOverlay.hide());
    }
    isContainerRerenderRequired() {
        return this.isContentUpdated()
            || this.isContextUpdated()
            || this.isPositionStrategyUpdateRequired();
    }
    isPositionStrategyUpdateRequired() {
        return this.isAdjustmentUpdated() || this.isPositionUpdated() || this.isOffsetUpdated() || this.isHostUpdated();
    }
    isTriggerStrategyUpdateRequired() {
        return this.isTriggerUpdated() || this.isHostUpdated();
    }
    isComponentTypeUpdateRequired() {
        return this.isComponentTypeUpdated();
    }
    isOverlayConfigUpdateRequired() {
        return this.isOverlayConfigUpdated();
    }
    isComponentTypeUpdated() {
        return this.changes.componentType && this.changes.componentType.isChanged();
    }
    isContentUpdated() {
        return this.changes.content && this.changes.content.isChanged();
    }
    isContextUpdated() {
        return this.changes.context && this.changes.context.isChanged();
    }
    isAdjustmentUpdated() {
        return this.changes.adjustment && this.changes.adjustment.isChanged();
    }
    isPositionUpdated() {
        return this.changes.position && this.changes.position.isChanged();
    }
    isHostUpdated() {
        return this.changes.host && this.changes.host.isChanged();
    }
    isTriggerUpdated() {
        return this.changes.trigger && this.changes.trigger.isChanged();
    }
    isOffsetUpdated() {
        return this.changes.offset && this.changes.offset.isChanged();
    }
    isOverlayConfigUpdated() {
        return this.changes.overlayConfig && this.changes.overlayConfig.isChanged();
    }
    clearChanges() {
        this.changes = {};
    }
};
NbDynamicOverlayHandler.ɵfac = function NbDynamicOverlayHandler_Factory(t) { return new (t || NbDynamicOverlayHandler)(ɵngcc0.ɵɵinject(NbPositionBuilderService), ɵngcc0.ɵɵinject(NbTriggerStrategyBuilderService), ɵngcc0.ɵɵinject(NbDynamicOverlay)); };
NbDynamicOverlayHandler.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbDynamicOverlayHandler, factory: NbDynamicOverlayHandler.ɵfac });
NbDynamicOverlayHandler = __decorate$82([ __metadata$53("design:paramtypes", [NbPositionBuilderService,
        NbTriggerStrategyBuilderService,
        NbDynamicOverlay])
], NbDynamicOverlayHandler);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$83 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$54 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Overlay container.
 * Renders provided content inside.
 *
 * @styles
 *
 * popover-text-color:
 * popover-text-font-family:
 * popover-text-font-size:
 * popover-text-font-weight:
 * popover-text-line-height:
 * popover-background-color:
 * popover-border-width:
 * popover-border-color:
 * popover-border-radius:
 * popover-shadow:
 * popover-arrow-size:
 * popover-padding:
 * */
let NbPopoverComponent = class NbPopoverComponent extends NbPositionedContainer {
    renderContent() {
        this.detachContent();
        this.attachContent();
    }
    detachContent() {
        this.overlayContainer.detach();
    }
    attachContent() {
        if (this.content instanceof TemplateRef) {
            this.attachTemplate();
        }
        else if (this.content instanceof Type) {
            this.attachComponent();
        }
        else {
            this.attachString();
        }
    }
    attachTemplate() {
        this.overlayContainer
            .attachTemplatePortal(new NbTemplatePortal(this.content, null, { $implicit: this.context }));
    }
    attachComponent() {
        const portal = new NbComponentPortal(this.content, null, null, this.cfr);
        const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
        ref.changeDetectorRef.detectChanges();
    }
    attachString() {
        this.overlayContainer.attachStringContent(this.content);
    }
};
NbPopoverComponent.ɵfac = function NbPopoverComponent_Factory(t) { return ɵNbPopoverComponent_BaseFactory(t || NbPopoverComponent); };
NbPopoverComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbPopoverComponent, selectors: [["nb-popover"]], viewQuery: function NbPopoverComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbOverlayContainerComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    } }, inputs: { content: "content", context: "context", cfr: "cfr" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 0, consts: [[1, "arrow"]], template: function NbPopoverComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
        ɵngcc0.ɵɵelement(1, "nb-overlay-container");
    } }, directives: [NbOverlayContainerComponent], styles: ["[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}"] });
__decorate$83([
    ViewChild(NbOverlayContainerComponent, { static: false }),
    __metadata$54("design:type", NbOverlayContainerComponent)
], NbPopoverComponent.prototype, "overlayContainer", void 0);
__decorate$83([
    Input(),
    __metadata$54("design:type", Object)
], NbPopoverComponent.prototype, "content", void 0);
__decorate$83([
    Input(),
    __metadata$54("design:type", Object)
], NbPopoverComponent.prototype, "context", void 0);
__decorate$83([
    Input(),
    __metadata$54("design:type", ComponentFactoryResolver)
], NbPopoverComponent.prototype, "cfr", void 0);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$80 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$51 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Powerful popover directive, which provides the best UX for your users.
 *
 * @stacked-example(Showcase, popover/popover-showcase.component)
 *
 * Popover can accept different content such as:
 * TemplateRef
 *
 * ```html
 * <button [nbPopover]="templateRef"></button>
 * <ng-template #templateRef>
 *   <span>Hello, Popover!</span>
 * </ng-template>
 * ```
 * ### Installation
 *
 * Import `NbPopoverModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbPopoverModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Custom components
 *
 * ```html
 * <button [nbPopover]="MyPopoverComponent"></button>
 * ```
 *
 * Both custom components and templateRef popovers can receive *contentContext* property
 * that will be passed to the content props.
 *
 * Primitive types
 *
 * ```html
 * <button nbPopover="Hello, Popover!"></button>
 * ```
 *
 * Popover has different placements, such as: top, bottom, left, right, start and end
 * which can be used as following:
 *
 * @stacked-example(Placements, popover/popover-placements.component)
 *
 * By default popover will try to adjust itself to maximally fit viewport
 * and provide the best user experience. It will try to change position of the popover container.
 * If you want to disable this behaviour set it `noop`.
 *
 * ```html
 * <button nbPopover="Hello, Popover!" nbPopoverAdjustment="noop"></button>
 * ```
 *
 * Popover has a number of triggers which provides an ability to show and hide the component in different ways:
 *
 * - Click mode shows the component when a user clicks on the host element and hides when the user clicks
 * somewhere on the document outside the component.
 * - Hint provides capability to show the component when the user hovers over the host element
 * and hide when the user hovers out of the host.
 * - Hover works like hint mode with one exception - when the user moves mouse from host element to
 * the container element the component remains open, so that it is possible to interact with it content.
 * - Focus mode is applied when user focuses the element.
 * - Noop mode - the component won't react to the user interaction.
 *
 * @stacked-example(Available Triggers, popover/popover-modes.component.html)
 *
 * Noop mode is especially useful when you need to control Popover programmatically, for example show/hide
 * as a result of some third-party action, like HTTP request or validation check:
 *
 * @stacked-example(Manual Control, popover/popover-noop.component)
 *
 * Below are examples for manual popover settings control, both via template binding and code.
 * @stacked-example(Popover Settings, popover/popover-dynamic.component)
 *
 * Please note, while manipulating Popover setting via code, you need to call `rebuild()` method to apply the settings
 * changed.
 * @stacked-example(Popover Settings Code, popover/popover-dynamic-code.component)
 *
 * @additional-example(Template Ref, popover/popover-template-ref.component)
 * @additional-example(Custom Component, popover/popover-custom-component.component)
 * */
let NbPopoverDirective = class NbPopoverDirective {
    constructor(hostRef, dynamicOverlayHandler) {
        this.hostRef = hostRef;
        this.dynamicOverlayHandler = dynamicOverlayHandler;
        this.popoverComponent = NbPopoverComponent;
        this.destroy$ = new Subject();
        /**
         * Container content context. Will be applied to the rendered component.
         * */
        this.context = {};
        /**
         * Position will be calculated relatively host element based on the position.
         * Can be top, right, bottom, left, start or end.
         * */
        this.position = NbPosition.TOP;
        this._adjustment = NbAdjustment.CLOCKWISE;
        /**
         * Describes when the container will be shown.
         * Available options: `click`, `hover`, `hint`, `focus` and `noop`
         * */
        this.trigger = NbTrigger.CLICK;
        /**
         * Sets popover offset
         * */
        this.offset = 15;
        this.popoverClass = '';
        this.nbPopoverShowStateChange = new EventEmitter();
    }
    /**
     * Container position will be changes automatically based on this strategy if container can't fit view port.
     * Set this property to `noop` value if you want to disable automatically adjustment.
     * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
     * */
    get adjustment() {
        return this._adjustment;
    }
    set adjustment(value) {
        if (!value) {
            // @breaking-change Remove @5.0.0
            console.warn(`Falsy values for 'nbPopoverAdjustment' are deprecated and will be removed in Nebular 5.
 Use 'noop' instead.`);
            value = NbAdjustment.NOOP;
        }
        this._adjustment = value;
    }
    get isShown() {
        return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
    }
    ngOnInit() {
        this.dynamicOverlayHandler
            .host(this.hostRef)
            .componentType(this.popoverComponent);
    }
    ngOnChanges() {
        this.rebuild();
    }
    ngAfterViewInit() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .build();
        this.dynamicOverlay.isShown
            .pipe(skip(1), takeUntil(this.destroy$))
            .subscribe((isShown) => this.nbPopoverShowStateChange.emit({ isShown }));
    }
    rebuild() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .rebuild();
    }
    show() {
        this.dynamicOverlay.show();
    }
    hide() {
        this.dynamicOverlay.hide();
    }
    toggle() {
        this.dynamicOverlay.toggle();
    }
    ngOnDestroy() {
        this.dynamicOverlayHandler.destroy();
        this.destroy$.next();
        this.destroy$.complete();
    }
    configureDynamicOverlay() {
        return this.dynamicOverlayHandler
            .position(this.position)
            .trigger(this.trigger)
            .offset(this.offset)
            .adjustment(this.adjustment)
            .content(this.content)
            .context(this.context)
            .overlayConfig({ panelClass: this.popoverClass });
    }
};
NbPopoverDirective.ɵfac = function NbPopoverDirective_Factory(t) { return new (t || NbPopoverDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbDynamicOverlayHandler)); };
NbPopoverDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbPopoverDirective, selectors: [["", "nbPopover", ""]], inputs: { context: ["nbPopoverContext", "context"], position: ["nbPopoverPlacement", "position"], trigger: ["nbPopoverTrigger", "trigger"], offset: ["nbPopoverOffset", "offset"], popoverClass: ["nbPopoverClass", "popoverClass"], adjustment: ["nbPopoverAdjustment", "adjustment"], content: ["nbPopover", "content"] }, outputs: { nbPopoverShowStateChange: "nbPopoverShowStateChange" }, exportAs: ["nbPopover"], features: [ɵngcc0.ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵngcc0.ɵɵNgOnChangesFeature()] });
__decorate$80([
    Input('nbPopover'),
    __metadata$51("design:type", Object)
], NbPopoverDirective.prototype, "content", void 0);
__decorate$80([
    Input('nbPopoverContext'),
    __metadata$51("design:type", Object)
], NbPopoverDirective.prototype, "context", void 0);
__decorate$80([
    Input('nbPopoverPlacement'),
    __metadata$51("design:type", String)
], NbPopoverDirective.prototype, "position", void 0);
__decorate$80([
    Input('nbPopoverAdjustment'),
    __metadata$51("design:type", String),
    __metadata$51("design:paramtypes", [String])
], NbPopoverDirective.prototype, "adjustment", null);
__decorate$80([
    Input('nbPopoverTrigger'),
    __metadata$51("design:type", String)
], NbPopoverDirective.prototype, "trigger", void 0);
__decorate$80([
    Input('nbPopoverOffset'),
    __metadata$51("design:type", Object)
], NbPopoverDirective.prototype, "offset", void 0);
__decorate$80([
    Input('nbPopoverClass'),
    __metadata$51("design:type", String)
], NbPopoverDirective.prototype, "popoverClass", void 0);
__decorate$80([
    Output(),
    __metadata$51("design:type", Object)
], NbPopoverDirective.prototype, "nbPopoverShowStateChange", void 0);
NbPopoverDirective = __decorate$80([ __metadata$51("design:paramtypes", [ElementRef,
        NbDynamicOverlayHandler])
], NbPopoverDirective);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$84 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbPopoverModule = class NbPopoverModule {
};
NbPopoverModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbPopoverModule });
NbPopoverModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbPopoverModule_Factory(t) { return new (t || NbPopoverModule)(); }, imports: [[NbOverlayModule]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$86 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$56 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Context menu component used as content within NbContextMenuDirective.
 *
 * @styles
 *
 * context-menu-background-color:
 * context-menu-border-color:
 * context-menu-border-style:
 * context-menu-border-width:
 * context-menu-border-radius:
 * context-menu-min-width:
 * context-menu-max-width:
 * context-menu-shadow:
 * */
let NbContextMenuComponent = class NbContextMenuComponent extends NbPositionedContainer {
    /**
     * Context menu component used as content within NbContextMenuDirective.
     *
     * @styles
     *
     * context-menu-background-color:
     * context-menu-border-color:
     * context-menu-border-style:
     * context-menu-border-width:
     * context-menu-border-radius:
     * context-menu-min-width:
     * context-menu-max-width:
     * context-menu-shadow:
     * */
    constructor() {
        super(...arguments);
        this.items = [];
        this.context = { items: [] };
    }
    /**
     * The method is empty since we don't need to do anything additionally
     * render is handled by change detection
     */
    renderContent() { }
};
NbContextMenuComponent.ɵfac = function NbContextMenuComponent_Factory(t) { return ɵNbContextMenuComponent_BaseFactory(t || NbContextMenuComponent); };
NbContextMenuComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbContextMenuComponent, selectors: [["nb-context-menu"]], inputs: { items: "items", context: "context", tag: "tag" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 2, consts: [[1, "context-menu", 3, "items", "tag"]], template: function NbContextMenuComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "nb-menu", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("items", ctx.context.items)("tag", ctx.context.tag);
    } }, directives: [NbMenuComponent], encapsulation: 2 });
__decorate$86([
    Input(),
    __metadata$56("design:type", Array)
], NbContextMenuComponent.prototype, "items", void 0);
__decorate$86([
    Input(),
    __metadata$56("design:type", String)
], NbContextMenuComponent.prototype, "tag", void 0);
__decorate$86([
    Input(),
    __metadata$56("design:type", Object)
], NbContextMenuComponent.prototype, "context", void 0);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$85 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$55 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Full featured context menu directive.
 *
 * @stacked-example(Showcase, context-menu/context-menu-showcase.component)
 *
 * Just pass menu items array:
 *
 * ```html
 * <button [nbContextMenu]="items"></button>
 * ...
 * items = [{ title: 'Profile' }, { title: 'Log out' }];
 * ```
 * ### Installation
 *
 * Import `NbContextMenuModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbContextMenuModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * Also make sure `NbMenuModule` is imported to your `app.module`.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbMenuModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * ### Usage
 *
 * If you want to handle context menu clicks you have to pass `nbContextMenuTag`
 * param and register to events using NbMenuService.
 * `NbContextMenu` renders plain `NbMenu` inside, so
 * you have to work with it just like with `NbMenu` component:
 *
 * @stacked-example(Menu item click, context-menu/context-menu-click.component)
 *
 * Context menu has different placements, such as: top, bottom, left and right
 * which can be used as following:
 *
 * ```html
 * <button [nbContextMenu]="items" nbContextMenuPlacement="right"></button>
 * ```
 *
 * ```ts
 * items = [{ title: 'Profile' }, { title: 'Log out' }];
 * ```
 *
 * By default context menu will try to adjust itself to maximally fit viewport
 * and provide the best user experience. It will try to change position of the context menu.
 * If you wanna disable this behaviour just set it falsy value.
 *
 * ```html
 * <button [nbContextMenu]="items" nbContextMenuAdjustment="counterclockwise"></button>
 * ```
 *
 * ```ts
 * items = [{ title: 'Profile' }, { title: 'Log out' }];
 * ```
 * Context menu has a number of triggers which provides an ability to show and hide the component in different ways:
 *
 * - Click mode shows the component when a user clicks on the host element and hides when the user clicks
 * somewhere on the document outside the component.
 * - Hint provides capability to show the component when the user hovers over the host element
 * and hide when the user hovers out of the host.
 * - Hover works like hint mode with one exception - when the user moves mouse from host element to
 * the container element the component remains open, so that it is possible to interact with it content.
 * - Focus mode is applied when user focuses the element.
 * - Noop mode - the component won't react to the user interaction.
 *
 * @stacked-example(Available Triggers, context-menu/context-menu-modes.component.html)
 *
 * Noop mode is especially useful when you need to control Popover programmatically, for example show/hide
 * as a result of some third-party action, like HTTP request or validation check:
 *
 * @stacked-example(Manual Control, context-menu/context-menu-noop.component)
 *
 * @stacked-example(Manual Control, context-menu/context-menu-right-click.component)
 * */
let NbContextMenuDirective = class NbContextMenuDirective {
    constructor(hostRef, menuService, dynamicOverlayHandler) {
        this.hostRef = hostRef;
        this.menuService = menuService;
        this.dynamicOverlayHandler = dynamicOverlayHandler;
        this.contextMenuHost = true;
        /**
         * Position will be calculated relatively host element based on the position.
         * Can be top, right, bottom and left.
         * */
        this.position = NbPosition.BOTTOM;
        /**
         * Container position will be changes automatically based on this strategy if container can't fit view port.
         * Set this property to any falsy value if you want to disable automatically adjustment.
         * Available values: clockwise, counterclockwise.
         * */
        this.adjustment = NbAdjustment.CLOCKWISE;
        /**
         * Describes when the container will be shown.
         * Available options: `click`, `hover`, `hint`, `focus` and `noop`
         * */
        this.trigger = NbTrigger.CLICK;
        this.contextMenuClass = '';
        this.alive = true;
        this._items = [];
    }
    /**
     * Basic menu items, will be passed to the internal NbMenuComponent.
     * */
    set items(items) {
        this.validateItems(items);
        this._items = items;
    }
    ;
    ngOnInit() {
        this.dynamicOverlayHandler
            .host(this.hostRef)
            .componentType(NbContextMenuComponent);
    }
    ngOnChanges() {
        this.rebuild();
    }
    ngAfterViewInit() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .build();
        this.subscribeOnItemClick();
    }
    rebuild() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .rebuild();
    }
    show() {
        this.dynamicOverlay.show();
    }
    hide() {
        this.dynamicOverlay.hide();
    }
    toggle() {
        this.dynamicOverlay.toggle();
    }
    ngOnDestroy() {
        this.dynamicOverlayHandler.destroy();
    }
    configureDynamicOverlay() {
        return this.dynamicOverlayHandler
            .position(this.position)
            .trigger(this.trigger)
            .adjustment(this.adjustment)
            .context({
            position: this.position,
            items: this._items,
            tag: this.tag,
        })
            .overlayConfig({ panelClass: this.contextMenuClass });
    }
    /*
     * NbMenuComponent will crash if don't pass menu items to it.
     * So, we just validating them and throw custom obvious error.
     * */
    validateItems(items) {
        if (!items || !items.length) {
            throw Error(`List of menu items expected, but given: ${items}`);
        }
    }
    subscribeOnItemClick() {
        this.menuService.onItemClick()
            .pipe(takeWhile(() => this.alive), filter(({ tag }) => tag === this.tag))
            .subscribe(() => this.hide());
    }
};
NbContextMenuDirective.ɵfac = function NbContextMenuDirective_Factory(t) { return new (t || NbContextMenuDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbMenuService), ɵngcc0.ɵɵdirectiveInject(NbDynamicOverlayHandler)); };
NbContextMenuDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbContextMenuDirective, selectors: [["", "nbContextMenu", ""]], hostVars: 2, hostBindings: function NbContextMenuDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("context-menu-host", ctx.contextMenuHost);
    } }, inputs: { position: ["nbContextMenuPlacement", "position"], adjustment: ["nbContextMenuAdjustment", "adjustment"], trigger: ["nbContextMenuTrigger", "trigger"], contextMenuClass: ["nbContextMenuClass", "contextMenuClass"], items: ["nbContextMenu", "items"], tag: ["nbContextMenuTag", "tag"] }, features: [ɵngcc0.ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵngcc0.ɵɵNgOnChangesFeature()] });
__decorate$85([
    HostBinding('class.context-menu-host'),
    __metadata$55("design:type", Object)
], NbContextMenuDirective.prototype, "contextMenuHost", void 0);
__decorate$85([
    Input('nbContextMenuPlacement'),
    __metadata$55("design:type", String)
], NbContextMenuDirective.prototype, "position", void 0);
__decorate$85([
    Input('nbContextMenuAdjustment'),
    __metadata$55("design:type", String)
], NbContextMenuDirective.prototype, "adjustment", void 0);
__decorate$85([
    Input('nbContextMenuTag'),
    __metadata$55("design:type", String)
], NbContextMenuDirective.prototype, "tag", void 0);
__decorate$85([
    Input('nbContextMenu'),
    __metadata$55("design:type", Array),
    __metadata$55("design:paramtypes", [Array])
], NbContextMenuDirective.prototype, "items", null);
__decorate$85([
    Input('nbContextMenuTrigger'),
    __metadata$55("design:type", String)
], NbContextMenuDirective.prototype, "trigger", void 0);
__decorate$85([
    Input('nbContextMenuClass'),
    __metadata$55("design:type", String)
], NbContextMenuDirective.prototype, "contextMenuClass", void 0);
NbContextMenuDirective = __decorate$85([ __metadata$55("design:paramtypes", [ElementRef,
        NbMenuService,
        NbDynamicOverlayHandler])
], NbContextMenuDirective);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$87 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbContextMenuModule = class NbContextMenuModule {
};
NbContextMenuModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbContextMenuModule });
NbContextMenuModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbContextMenuModule_Factory(t) { return new (t || NbContextMenuModule)(); }, imports: [[CommonModule, NbOverlayModule, NbMenuModule]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$88 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$57 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Progress Bar is a component for indicating progress.
 *
 * Simple usage:
 *
 * ```html
 * <nb-progress-bar [value]="50"></nb-progress-bar>
 * ```
 * ### Installation
 *
 * Import `NbProgressBarModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbProgressBarModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Progress bar accepts property `value` in range 0-100
 * @stacked-example(Progress bar, progress-bar/progress-bar-showcase.component)
 *
 * Progress bar background could be configured by providing a `status` property:
 * @stacked-example(Progress bar status, progress-bar/progress-bar-status.component)
 *
 * Progress bar size (height and font-size) could be configured by providing a `size` property:
 * @stacked-example(Progress bar size, progress-bar/progress-bar-size.component)
 *
 * `displayValue` property shows current value inside progress bar. It's also possible to add custom text inside:
 * @stacked-example(Progress bar value, progress-bar/progress-bar-value.component)
 *
 * Progress bar supports `width` and `background-color` transition:
 * @stacked-example(Progress bar interactive, progress-bar/progress-bar-interactive.component)
 *
 * @styles
 *
 * progress-bar-animation-duration:
 * progress-bar-border-radius:
 * progress-bar-text-font-family:
 * progress-bar-tiny-height:
 * progress-bar-tiny-text-font-size:
 * progress-bar-tiny-text-font-weight:
 * progress-bar-tiny-text-line-height:
 * progress-bar-small-height:
 * progress-bar-small-text-font-size:
 * progress-bar-small-text-font-weight:
 * progress-bar-small-text-line-height:
 * progress-bar-medium-height:
 * progress-bar-medium-text-font-size:
 * progress-bar-medium-text-font-weight:
 * progress-bar-medium-text-line-height:
 * progress-bar-large-height:
 * progress-bar-large-text-font-size:
 * progress-bar-large-text-font-weight:
 * progress-bar-large-text-line-height:
 * progress-bar-giant-height:
 * progress-bar-giant-text-font-size:
 * progress-bar-giant-text-font-weight:
 * progress-bar-giant-text-line-height:
 * progress-bar-basic-background-color:
 * progress-bar-basic-filled-background-color:
 * progress-bar-basic-text-color:
 * progress-bar-primary-background-color:
 * progress-bar-primary-filled-background-color:
 * progress-bar-primary-text-color:
 * progress-bar-success-background-color:
 * progress-bar-success-filled-background-color:
 * progress-bar-success-text-color:
 * progress-bar-info-background-color:
 * progress-bar-info-filled-background-color:
 * progress-bar-info-text-color:
 * progress-bar-warning-background-color:
 * progress-bar-warning-filled-background-color:
 * progress-bar-warning-text-color:
 * progress-bar-danger-background-color:
 * progress-bar-danger-filled-background-color:
 * progress-bar-danger-text-color:
 * progress-bar-control-background-color:
 * progress-bar-control-filled-background-color:
 * progress-bar-control-text-color:
 */
let NbProgressBarComponent = class NbProgressBarComponent {
    /**
     * Progress Bar is a component for indicating progress.
     *
     * Simple usage:
     *
     * ```html
     * <nb-progress-bar [value]="50"></nb-progress-bar>
     * ```
     * ### Installation
     *
     * Import `NbProgressBarModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbProgressBarModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * Progress bar accepts property `value` in range 0-100
     * @stacked-example(Progress bar, progress-bar/progress-bar-showcase.component)
     *
     * Progress bar background could be configured by providing a `status` property:
     * @stacked-example(Progress bar status, progress-bar/progress-bar-status.component)
     *
     * Progress bar size (height and font-size) could be configured by providing a `size` property:
     * @stacked-example(Progress bar size, progress-bar/progress-bar-size.component)
     *
     * `displayValue` property shows current value inside progress bar. It's also possible to add custom text inside:
     * @stacked-example(Progress bar value, progress-bar/progress-bar-value.component)
     *
     * Progress bar supports `width` and `background-color` transition:
     * @stacked-example(Progress bar interactive, progress-bar/progress-bar-interactive.component)
     *
     * @styles
     *
     * progress-bar-animation-duration:
     * progress-bar-border-radius:
     * progress-bar-text-font-family:
     * progress-bar-tiny-height:
     * progress-bar-tiny-text-font-size:
     * progress-bar-tiny-text-font-weight:
     * progress-bar-tiny-text-line-height:
     * progress-bar-small-height:
     * progress-bar-small-text-font-size:
     * progress-bar-small-text-font-weight:
     * progress-bar-small-text-line-height:
     * progress-bar-medium-height:
     * progress-bar-medium-text-font-size:
     * progress-bar-medium-text-font-weight:
     * progress-bar-medium-text-line-height:
     * progress-bar-large-height:
     * progress-bar-large-text-font-size:
     * progress-bar-large-text-font-weight:
     * progress-bar-large-text-line-height:
     * progress-bar-giant-height:
     * progress-bar-giant-text-font-size:
     * progress-bar-giant-text-font-weight:
     * progress-bar-giant-text-line-height:
     * progress-bar-basic-background-color:
     * progress-bar-basic-filled-background-color:
     * progress-bar-basic-text-color:
     * progress-bar-primary-background-color:
     * progress-bar-primary-filled-background-color:
     * progress-bar-primary-text-color:
     * progress-bar-success-background-color:
     * progress-bar-success-filled-background-color:
     * progress-bar-success-text-color:
     * progress-bar-info-background-color:
     * progress-bar-info-filled-background-color:
     * progress-bar-info-text-color:
     * progress-bar-warning-background-color:
     * progress-bar-warning-filled-background-color:
     * progress-bar-warning-text-color:
     * progress-bar-danger-background-color:
     * progress-bar-danger-filled-background-color:
     * progress-bar-danger-text-color:
     * progress-bar-control-background-color:
     * progress-bar-control-filled-background-color:
     * progress-bar-control-text-color:
     */
    constructor() {
        /**
         * Progress bar value in percent (0 - 100)
         */
        this.value = 0;
        /**
         * Progress bar background (`basic`, `primary` (default), `info`, `success`, `warning`, `danger`, `control`)
         */
        this.status = 'primary';
        /**
         * Progress bar size (`tiny`, `small`, `medium` (default), `large`, `giant`)
         */
        this.size = 'medium';
        /**
         * Displays value inside progress bar
         */
        this.displayValue = false;
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get info() {
        return this.status === 'info';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
};
NbProgressBarComponent.ɵfac = function NbProgressBarComponent_Factory(t) { return new (t || NbProgressBarComponent)(); };
NbProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbProgressBarComponent, selectors: [["nb-progress-bar"]], hostVars: 24, hostBindings: function NbProgressBarComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    } }, inputs: { value: "value", status: "status", size: "size", displayValue: "displayValue" }, ngContentSelectors: _c0, decls: 4, vars: 3, consts: [[1, "progress-container"], [1, "progress-value"], [4, "ngIf"]], template: function NbProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, NbProgressBarComponent_span_2_Template, 2, 1, "span", 2);
        ɵngcc0.ɵɵprojection(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("width", ctx.value, "%");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.displayValue);
    } }, directives: [ɵngcc2.NgIf], styles: ["[_nghost-%COMP%]{display:block}.progress-container[_ngcontent-%COMP%]{overflow:hidden}.progress-value[_ngcontent-%COMP%]{height:100%;text-align:center;overflow:hidden}"] });
__decorate$88([
    Input(),
    __metadata$57("design:type", Number)
], NbProgressBarComponent.prototype, "value", void 0);
__decorate$88([
    Input(),
    __metadata$57("design:type", String)
], NbProgressBarComponent.prototype, "status", void 0);
__decorate$88([
    Input(),
    __metadata$57("design:type", String)
], NbProgressBarComponent.prototype, "size", void 0);
__decorate$88([
    Input(),
    __metadata$57("design:type", Boolean)
], NbProgressBarComponent.prototype, "displayValue", void 0);
__decorate$88([
    HostBinding('class.size-tiny'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "tiny", null);
__decorate$88([
    HostBinding('class.size-small'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "small", null);
__decorate$88([
    HostBinding('class.size-medium'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "medium", null);
__decorate$88([
    HostBinding('class.size-large'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "large", null);
__decorate$88([
    HostBinding('class.size-giant'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "giant", null);
__decorate$88([
    HostBinding('class.status-primary'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "primary", null);
__decorate$88([
    HostBinding('class.status-success'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "success", null);
__decorate$88([
    HostBinding('class.status-info'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "info", null);
__decorate$88([
    HostBinding('class.status-warning'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "warning", null);
__decorate$88([
    HostBinding('class.status-danger'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "danger", null);
__decorate$88([
    HostBinding('class.status-basic'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "basic", null);
__decorate$88([
    HostBinding('class.status-control'),
    __metadata$57("design:type", Boolean),
    __metadata$57("design:paramtypes", [])
], NbProgressBarComponent.prototype, "control", null);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$89 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbProgressBarModule = class NbProgressBarModule {
};
NbProgressBarModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbProgressBarModule });
NbProgressBarModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbProgressBarModule_Factory(t) { return new (t || NbProgressBarModule)(); }, imports: [[
            NbSharedModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$90 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$58 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Alert component.
 *
 * Basic alert example:
 * @stacked-example(Showcase, alert/alert-showcase.component)
 *
 * Alert configuration:
 *
 * ```html
 * <nb-alert status="success">
 *   You have been successfully authenticated!
 * </nb-alert>
 * ```
 * ### Installation
 *
 * Import `NbAlertModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbAlertModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Alert could additionally have a `close` button when `closable` property is set:
 * ```html
 * <nb-alert status="success" closable (close)="onClose()">
 *   You have been successfully authenticated!
 * </nb-alert>
 * ```
 *
 * Colored alerts could be simply configured by providing a `status` property:
 * @stacked-example(Alert status, alert/alert-colors.component)
 *
 * It is also possible to assign an `accent` property for a slight alert highlight
 * as well as combine it with `status`:
 * @stacked-example(Alert accent, alert/alert-accents.component)
 *
 * And `outline` property:
 * @stacked-example(Outline Alert, alert/alert-outline.component)
 *
 * @additional-example(Multiple Sizes, alert/alert-sizes.component)
 *
 * @styles
 *
 * alert-border-radius:
 * alert-bottom-margin:
 * alert-padding:
 * alert-scrollbar-color:
 * alert-scrollbar-background-color:
 * alert-scrollbar-width:
 * alert-shadow:
 * alert-text-font-family:
 * alert-text-font-size:
 * alert-text-font-weight:
 * alert-text-line-height:
 * alert-closable-start-padding:
 * alert-tiny-height:
 * alert-small-height:
 * alert-medium-height:
 * alert-medium-padding:
 * alert-large-height:
 * alert-giant-height:
 * alert-basic-background-color:
 * alert-basic-text-color:
 * alert-primary-background-color:
 * alert-primary-text-color:
 * alert-success-background-color:
 * alert-success-text-color:
 * alert-info-background-color:
 * alert-info-text-color:
 * alert-warning-background-color:
 * alert-warning-text-color:
 * alert-danger-background-color:
 * alert-danger-text-color:
 * alert-control-background-color:
 * alert-control-text-color:
 * alert-accent-basic-color:
 * alert-accent-primary-color:
 * alert-accent-info-color:
 * alert-accent-success-color:
 * alert-accent-warning-color:
 * alert-accent-danger-color:
 * alert-accent-control-color:
 * alert-outline-width:
 * alert-outline-basic-color:
 * alert-outline-primary-color:
 * alert-outline-info-color:
 * alert-outline-success-color:
 * alert-outline-warning-color:
 * alert-outline-danger-color:
 * alert-outline-control-color:
 */
let NbAlertComponent = class NbAlertComponent {
    /**
     * Alert component.
     *
     * Basic alert example:
     * @stacked-example(Showcase, alert/alert-showcase.component)
     *
     * Alert configuration:
     *
     * ```html
     * <nb-alert status="success">
     *   You have been successfully authenticated!
     * </nb-alert>
     * ```
     * ### Installation
     *
     * Import `NbAlertModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbAlertModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * Alert could additionally have a `close` button when `closable` property is set:
     * ```html
     * <nb-alert status="success" closable (close)="onClose()">
     *   You have been successfully authenticated!
     * </nb-alert>
     * ```
     *
     * Colored alerts could be simply configured by providing a `status` property:
     * @stacked-example(Alert status, alert/alert-colors.component)
     *
     * It is also possible to assign an `accent` property for a slight alert highlight
     * as well as combine it with `status`:
     * @stacked-example(Alert accent, alert/alert-accents.component)
     *
     * And `outline` property:
     * @stacked-example(Outline Alert, alert/alert-outline.component)
     *
     * @additional-example(Multiple Sizes, alert/alert-sizes.component)
     *
     * @styles
     *
     * alert-border-radius:
     * alert-bottom-margin:
     * alert-padding:
     * alert-scrollbar-color:
     * alert-scrollbar-background-color:
     * alert-scrollbar-width:
     * alert-shadow:
     * alert-text-font-family:
     * alert-text-font-size:
     * alert-text-font-weight:
     * alert-text-line-height:
     * alert-closable-start-padding:
     * alert-tiny-height:
     * alert-small-height:
     * alert-medium-height:
     * alert-medium-padding:
     * alert-large-height:
     * alert-giant-height:
     * alert-basic-background-color:
     * alert-basic-text-color:
     * alert-primary-background-color:
     * alert-primary-text-color:
     * alert-success-background-color:
     * alert-success-text-color:
     * alert-info-background-color:
     * alert-info-text-color:
     * alert-warning-background-color:
     * alert-warning-text-color:
     * alert-danger-background-color:
     * alert-danger-text-color:
     * alert-control-background-color:
     * alert-control-text-color:
     * alert-accent-basic-color:
     * alert-accent-primary-color:
     * alert-accent-info-color:
     * alert-accent-success-color:
     * alert-accent-warning-color:
     * alert-accent-danger-color:
     * alert-accent-control-color:
     * alert-outline-width:
     * alert-outline-basic-color:
     * alert-outline-primary-color:
     * alert-outline-info-color:
     * alert-outline-success-color:
     * alert-outline-warning-color:
     * alert-outline-danger-color:
     * alert-outline-control-color:
     */
    constructor() {
        /**
         * Alert size, available sizes:
         * `tiny`, `small`, `medium`, `large`, `giant`
         * Unset by default.
         */
        this.size = '';
        this._status = 'basic';
        /**
         * Alert accent (color of the top border):
         * `basic`, `primary`, `success`, `info`, `warning`, `danger`, `control`.
         * Unset by default.
         */
        this.accent = '';
        /**
         * Alert outline (color of the border):
         * `basic`, `primary`, `success`, `info`, `warning`, `danger`, `control`.
         * Unset by default.
         */
        this.outline = '';
        this._closable = false;
        /**
         * Emits when chip is removed
         * @type EventEmitter<any>
         */
        this.close = new EventEmitter();
    }
    /**
     * Alert status (adds specific styles):
     * `basic` (default), `primary`, `success`, `info`, `warning`, `danger`, `control`.
     */
    get status() {
        return this._status;
    }
    set status(value) {
        if (value === '') {
            emptyStatusWarning('NbAlert');
            value = 'basic';
        }
        this._status = value;
    }
    /**
     * Shows `close` icon
     */
    get closable() {
        return this._closable;
    }
    set closable(value) {
        this._closable = convertToBoolProperty(value);
    }
    /**
     * Emits the removed chip event
     */
    onClose() {
        this.close.emit();
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get info() {
        return this.status === 'info';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get primaryAccent() {
        return this.accent === 'primary';
    }
    get successAccent() {
        return this.accent === 'success';
    }
    get infoAccent() {
        return this.accent === 'info';
    }
    get warningAccent() {
        return this.accent === 'warning';
    }
    get dangerAccent() {
        return this.accent === 'danger';
    }
    get basicAccent() {
        return this.accent === 'basic';
    }
    get controlAccent() {
        return this.accent === 'control';
    }
    get primaryOutline() {
        return this.outline === 'primary';
    }
    get successOutline() {
        return this.outline === 'success';
    }
    get infoOutline() {
        return this.outline === 'info';
    }
    get warningOutline() {
        return this.outline === 'warning';
    }
    get dangerOutline() {
        return this.outline === 'danger';
    }
    get basicOutline() {
        return this.outline === 'basic';
    }
    get controlOutline() {
        return this.outline === 'control';
    }
};
NbAlertComponent.ɵfac = function NbAlertComponent_Factory(t) { return new (t || NbAlertComponent)(); };
NbAlertComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbAlertComponent, selectors: [["nb-alert"]], hostVars: 54, hostBindings: function NbAlertComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("closable", ctx.closable)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("accent-primary", ctx.primaryAccent)("accent-success", ctx.successAccent)("accent-info", ctx.infoAccent)("accent-warning", ctx.warningAccent)("accent-danger", ctx.dangerAccent)("accent-basic", ctx.basicAccent)("accent-control", ctx.controlAccent)("outline-primary", ctx.primaryOutline)("outline-success", ctx.successOutline)("outline-info", ctx.infoOutline)("outline-warning", ctx.warningOutline)("outline-danger", ctx.dangerOutline)("outline-basic", ctx.basicOutline)("outline-control", ctx.controlOutline);
    } }, inputs: { size: "size", accent: "accent", outline: "outline", status: "status", closable: "closable" }, outputs: { close: "close" }, ngContentSelectors: _c0, decls: 2, vars: 1, consts: [["type", "button", "class", "close", "aria-label", "Close", 3, "click", 4, "ngIf"], ["type", "button", "aria-label", "Close", 1, "close", 3, "click"], ["aria-hidden", "true"]], template: function NbAlertComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NbAlertComponent_button_0_Template, 3, 0, "button", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.closable);
    } }, directives: [ɵngcc2.NgIf], styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative}[dir=ltr]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{right:0}[dir=rtl]   [_nghost-%COMP%]   .close[_ngcontent-%COMP%]{left:0}.close[_ngcontent-%COMP%]{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}"] });
__decorate$90([
    Input(),
    __metadata$58("design:type", String)
], NbAlertComponent.prototype, "size", void 0);
__decorate$90([
    Input(),
    __metadata$58("design:type", String),
    __metadata$58("design:paramtypes", [String])
], NbAlertComponent.prototype, "status", null);
__decorate$90([
    Input(),
    __metadata$58("design:type", String)
], NbAlertComponent.prototype, "accent", void 0);
__decorate$90([
    Input(),
    __metadata$58("design:type", String)
], NbAlertComponent.prototype, "outline", void 0);
__decorate$90([
    Input(),
    HostBinding('class.closable'),
    __metadata$58("design:type", Boolean),
    __metadata$58("design:paramtypes", [Boolean])
], NbAlertComponent.prototype, "closable", null);
__decorate$90([
    Output(),
    __metadata$58("design:type", Object)
], NbAlertComponent.prototype, "close", void 0);
__decorate$90([
    HostBinding('class.size-tiny'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "tiny", null);
__decorate$90([
    HostBinding('class.size-small'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "small", null);
__decorate$90([
    HostBinding('class.size-medium'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "medium", null);
__decorate$90([
    HostBinding('class.size-large'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "large", null);
__decorate$90([
    HostBinding('class.size-giant'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "giant", null);
__decorate$90([
    HostBinding('class.status-primary'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "primary", null);
__decorate$90([
    HostBinding('class.status-success'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "success", null);
__decorate$90([
    HostBinding('class.status-info'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "info", null);
__decorate$90([
    HostBinding('class.status-warning'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "warning", null);
__decorate$90([
    HostBinding('class.status-danger'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "danger", null);
__decorate$90([
    HostBinding('class.status-basic'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "basic", null);
__decorate$90([
    HostBinding('class.status-control'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "control", null);
__decorate$90([
    HostBinding('class.accent-primary'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "primaryAccent", null);
__decorate$90([
    HostBinding('class.accent-success'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "successAccent", null);
__decorate$90([
    HostBinding('class.accent-info'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "infoAccent", null);
__decorate$90([
    HostBinding('class.accent-warning'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "warningAccent", null);
__decorate$90([
    HostBinding('class.accent-danger'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "dangerAccent", null);
__decorate$90([
    HostBinding('class.accent-basic'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "basicAccent", null);
__decorate$90([
    HostBinding('class.accent-control'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "controlAccent", null);
__decorate$90([
    HostBinding('class.outline-primary'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "primaryOutline", null);
__decorate$90([
    HostBinding('class.outline-success'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "successOutline", null);
__decorate$90([
    HostBinding('class.outline-info'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "infoOutline", null);
__decorate$90([
    HostBinding('class.outline-warning'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "warningOutline", null);
__decorate$90([
    HostBinding('class.outline-danger'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "dangerOutline", null);
__decorate$90([
    HostBinding('class.outline-basic'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "basicOutline", null);
__decorate$90([
    HostBinding('class.outline-control'),
    __metadata$58("design:type", Object),
    __metadata$58("design:paramtypes", [])
], NbAlertComponent.prototype, "controlOutline", null);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$91 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbAlertModule = class NbAlertModule {
};
NbAlertModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbAlertModule });
NbAlertModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbAlertModule_Factory(t) { return new (t || NbAlertModule)(); }, imports: [[
            NbSharedModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$93 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$60 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Chat form component.
 *
 * Show a message form with a send message button.
 *
 * ```ts
 * <nb-chat-form showButton="true" buttonIcon="nb-send">
 * </nb-chat-form>
 * ```
 *
 * When `[dropFiles]="true"` handles files drag&drop with a file preview.
 *
 * Drag & drop available for files and images:
 * @stacked-example(Drag & Drop Chat, chat/chat-drop.component)
 *
 * New message could be tracked outside by using `(send)` output.
 *
 * ```ts
 * <nb-chat-form (send)="onNewMessage($event)">
 * </nb-chat-form>
 *
 * // ...
 *
 * onNewMessage({ message: string, files: any[] }) {
 *   this.service.sendToServer(message, files);
 * }
 * ```
 */
let NbChatFormComponent = class NbChatFormComponent {
    constructor(cd, domSanitizer) {
        this.cd = cd;
        this.domSanitizer = domSanitizer;
        this.status = 'basic';
        this.inputFocus = false;
        this.inputHover = false;
        this.droppedFiles = [];
        this.imgDropTypes = ['image/png', 'image/jpeg', 'image/gif'];
        /**
         * Predefined message text
         * @type {string}
         */
        this.message = '';
        /**
         * Send button title
         * @type {string}
         */
        this.buttonTitle = '';
        /**
         * Send button icon, shown if `buttonTitle` is empty
         * @type {string}
         */
        this.buttonIcon = 'paper-plane-outline';
        /**
         * Show send button
         * @type {boolean}
         */
        this.showButton = true;
        /**
         * Show send button
         * @type {boolean}
         */
        this.dropFiles = false;
        /**
         *
         * @type {EventEmitter<{ message: string, files: File[] }>}
         */
        this.send = new EventEmitter();
        this.fileOver = false;
    }
    onDrop(event) {
        if (this.dropFiles) {
            event.preventDefault();
            event.stopPropagation();
            this.fileOver = false;
            if (event.dataTransfer && event.dataTransfer.files) {
                for (const file of event.dataTransfer.files) {
                    const res = file;
                    if (this.imgDropTypes.includes(file.type)) {
                        const fr = new FileReader();
                        fr.onload = (e) => {
                            res.src = e.target.result;
                            res.urlStyle = this.domSanitizer.bypassSecurityTrustStyle(`url(${res.src})`);
                            this.cd.detectChanges();
                        };
                        fr.readAsDataURL(file);
                    }
                    this.droppedFiles.push(res);
                }
            }
        }
    }
    removeFile(file) {
        const index = this.droppedFiles.indexOf(file);
        if (index >= 0) {
            this.droppedFiles.splice(index, 1);
        }
    }
    onDragOver() {
        if (this.dropFiles) {
            this.fileOver = true;
        }
    }
    onDragLeave() {
        if (this.dropFiles) {
            this.fileOver = false;
        }
    }
    sendMessage() {
        if (this.droppedFiles.length || String(this.message).trim().length) {
            this.send.emit({ message: this.message, files: this.droppedFiles });
            this.message = '';
            this.droppedFiles = [];
        }
    }
    setStatus(status) {
        if (this.status !== status) {
            this.status = status;
            this.cd.detectChanges();
        }
    }
    getInputStatus() {
        if (this.fileOver) {
            return this.getHighlightStatus();
        }
        if (this.inputFocus || this.inputHover) {
            return this.status;
        }
        return 'basic';
    }
    getButtonStatus() {
        return this.getHighlightStatus();
    }
    getHighlightStatus() {
        if (this.status === 'basic' || this.status === 'control') {
            return 'primary';
        }
        return this.status;
    }
};
NbChatFormComponent.ɵfac = function NbChatFormComponent_Factory(t) { return new (t || NbChatFormComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer)); };
NbChatFormComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatFormComponent, selectors: [["nb-chat-form"]], hostVars: 2, hostBindings: function NbChatFormComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("drop", function NbChatFormComponent_drop_HostBindingHandler($event) { return ctx.onDrop($event); })("dragover", function NbChatFormComponent_dragover_HostBindingHandler() { return ctx.onDragOver(); })("dragleave", function NbChatFormComponent_dragleave_HostBindingHandler() { return ctx.onDragLeave(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("file-over", ctx.fileOver);
    } }, inputs: { message: "message", buttonTitle: "buttonTitle", buttonIcon: "buttonIcon", showButton: "showButton", dropFiles: "dropFiles" }, outputs: { send: "send" }, decls: 4, vars: 7, consts: [["class", "dropped-files", 4, "ngIf"], [1, "message-row"], ["nbInput", "", "fullWidth", "", "type", "text", 3, "status", "ngModel", "placeholder", "focus", "blur", "mouseenter", "mouseleave", "ngModelChange", "keyup.enter"], ["nbButton", "", "class", "send-button", 3, "status", "with-icon", "click", 4, "ngIf"], [1, "dropped-files"], [4, "ngFor", "ngForOf"], [3, "background-image", 4, "ngIf"], ["icon", "file-text-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "remove", 3, "click"], ["icon", "file-text-outline", "pack", "nebular-essentials"], ["nbButton", "", 1, "send-button", 3, "status", "click"], ["pack", "nebular-essentials", 3, "icon", 4, "ngIf", "ngIfElse"], ["title", ""], ["pack", "nebular-essentials", 3, "icon"]], template: function NbChatFormComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbChatFormComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "input", 2);
        ɵngcc0.ɵɵlistener("focus", function NbChatFormComponent_Template_input_focus_2_listener() { return ctx.inputFocus = true; })("blur", function NbChatFormComponent_Template_input_blur_2_listener() { return ctx.inputFocus = false; })("mouseenter", function NbChatFormComponent_Template_input_mouseenter_2_listener() { return ctx.inputHover = true; })("mouseleave", function NbChatFormComponent_Template_input_mouseleave_2_listener() { return ctx.inputHover = false; })("ngModelChange", function NbChatFormComponent_Template_input_ngModelChange_2_listener($event) { return ctx.message = $event; })("keyup.enter", function NbChatFormComponent_Template_input_keyup_enter_2_listener() { return ctx.sendMessage(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(3, NbChatFormComponent_button_3_Template, 4, 5, "button", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.droppedFiles == null ? null : ctx.droppedFiles.length);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵclassProp("with-button", ctx.showButton);
        ɵngcc0.ɵɵpropertyInterpolate("placeholder", ctx.fileOver ? "Drop file to send" : "Type a message");
        ɵngcc0.ɵɵproperty("status", ctx.getInputStatus())("ngModel", ctx.message);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showButton);
    } }, directives: function () { return [ɵngcc2.NgIf, NbInputDirective, ɵngcc6.DefaultValueAccessor, ɵngcc6.NgControlStatus, ɵngcc6.NgModel, ɵngcc2.NgForOf, NbIconComponent,
        NbButtonComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate$93([
    Input(),
    __metadata$60("design:type", String)
], NbChatFormComponent.prototype, "message", void 0);
__decorate$93([
    Input(),
    __metadata$60("design:type", String)
], NbChatFormComponent.prototype, "buttonTitle", void 0);
__decorate$93([
    Input(),
    __metadata$60("design:type", String)
], NbChatFormComponent.prototype, "buttonIcon", void 0);
__decorate$93([
    Input(),
    __metadata$60("design:type", Boolean)
], NbChatFormComponent.prototype, "showButton", void 0);
__decorate$93([
    Input(),
    __metadata$60("design:type", Boolean)
], NbChatFormComponent.prototype, "dropFiles", void 0);
__decorate$93([
    Output(),
    __metadata$60("design:type", Object)
], NbChatFormComponent.prototype, "send", void 0);
__decorate$93([
    HostBinding('class.file-over'),
    __metadata$60("design:type", Object)
], NbChatFormComponent.prototype, "fileOver", void 0);
__decorate$93([
    HostListener('drop', ['$event']),
    __metadata$60("design:type", Function),
    __metadata$60("design:paramtypes", [Object]),
    __metadata$60("design:returntype", void 0)
], NbChatFormComponent.prototype, "onDrop", null);
__decorate$93([
    HostListener('dragover'),
    __metadata$60("design:type", Function),
    __metadata$60("design:paramtypes", []),
    __metadata$60("design:returntype", void 0)
], NbChatFormComponent.prototype, "onDragOver", null);
__decorate$93([
    HostListener('dragleave'),
    __metadata$60("design:type", Function),
    __metadata$60("design:paramtypes", []),
    __metadata$60("design:returntype", void 0)
], NbChatFormComponent.prototype, "onDragLeave", null);
NbChatFormComponent = __decorate$93([ __metadata$60("design:paramtypes", [ChangeDetectorRef, DomSanitizer])
], NbChatFormComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$94 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$61 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Chat message component.
 *
 * Multiple message types are available through a `type` property, such as
 * - text - simple text message
 * - file - could be a file preview or a file icon
 * if multiple files are provided grouped files are shown
 * - quote - quotes a message with specific quote styles
 * - map - shows a google map picture by provided [latitude] and [longitude] properties
 *
 * @stacked-example(Available Types, chat/chat-message-types-showcase.component)
 *
 * Message with attached files:
 * ```html
 * <nb-chat-message
 *   type="file"
 *   [files]="[ { url: '...' } ]"
 *   message="Hello world!">
 * </nb-chat-message>
 * ```
 *
 * Map message:
 * ```html
 * <nb-chat-message
 *   type="map"
 *   [latitude]="53.914"
 *   [longitude]="27.59"
 *   message="Here I am">
 * </nb-chat-message>
 * ```
 *
 * @styles
 *
 * chat-message-background:
 * chat-message-text-color:
 * chat-message-reply-background-color:
 * chat-message-reply-text-color:
 * chat-message-avatar-background-color:
 * chat-message-sender-text-color:
 * chat-message-quote-background-color:
 * chat-message-quote-text-color:
 * chat-message-file-text-color:
 * chat-message-file-background-color:
 */
let NbChatMessageComponent = class NbChatMessageComponent {
    constructor(domSanitizer) {
        this.domSanitizer = domSanitizer;
        this._reply = false;
    }
    get flyInOut() {
        return true;
    }
    get notReply() {
        return !this.reply;
    }
    /**
     * Determines if a message is a reply
     */
    get reply() {
        return this._reply;
    }
    set reply(value) {
        this._reply = convertToBoolProperty(value);
    }
    /**
     * Message send avatar
     * @type {string}
     */
    set avatar(value) {
        this.avatarStyle = value ? this.domSanitizer.bypassSecurityTrustStyle(`url(${value})`) : null;
    }
    getInitials() {
        if (this.sender) {
            const names = this.sender.split(' ');
            return names.map(n => n.charAt(0)).splice(0, 2).join('').toUpperCase();
        }
        return '';
    }
};
NbChatMessageComponent.ɵfac = function NbChatMessageComponent_Factory(t) { return new (t || NbChatMessageComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer)); };
NbChatMessageComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatMessageComponent, selectors: [["nb-chat-message"]], hostVars: 5, hostBindings: function NbChatMessageComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵupdateSyntheticHostBinding("@flyInOut", ctx.flyInOut);
        ɵngcc0.ɵɵclassProp("not-reply", ctx.notReply)("reply", ctx.reply);
    } }, inputs: { reply: "reply", avatar: "avatar", message: "message", sender: "sender", date: "date", files: "files", quote: "quote", latitude: "latitude", longitude: "longitude", type: "type" }, decls: 7, vars: 5, consts: [["class", "avatar", 3, "background-image", 4, "ngIf"], [1, "message"], [3, "ngSwitch"], [3, "sender", "date", "message", "files", 4, "ngSwitchCase"], [3, "sender", "date", "message", "quote", 4, "ngSwitchCase"], [3, "sender", "date", "message", "latitude", "longitude", 4, "ngSwitchCase"], [3, "sender", "date", "message", 4, "ngSwitchDefault"], [1, "avatar"], [4, "ngIf"], [3, "sender", "date", "message", "files"], [3, "sender", "date", "message", "quote"], [3, "sender", "date", "message", "latitude", "longitude"], [3, "sender", "date", "message"]], template: function NbChatMessageComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbChatMessageComponent_div_0_Template, 2, 3, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementContainerStart(2, 2);
        ɵngcc0.ɵɵtemplate(3, NbChatMessageComponent_nb_chat_message_file_3_Template, 1, 4, "nb-chat-message-file", 3);
        ɵngcc0.ɵɵtemplate(4, NbChatMessageComponent_nb_chat_message_quote_4_Template, 1, 4, "nb-chat-message-quote", 4);
        ɵngcc0.ɵɵtemplate(5, NbChatMessageComponent_nb_chat_message_map_5_Template, 1, 5, "nb-chat-message-map", 5);
        ɵngcc0.ɵɵtemplate(6, NbChatMessageComponent_nb_chat_message_text_6_Template, 1, 3, "nb-chat-message-text", 6);
        ɵngcc0.ɵɵelementContainerEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.reply);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngSwitch", ctx.type);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "file");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "quote");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngSwitchCase", "map");
    } }, directives: function () { return [ɵngcc2.NgIf, ɵngcc2.NgSwitch, ɵngcc2.NgSwitchCase, ɵngcc2.NgSwitchDefault, NbChatMessageFileComponent,
        NbChatMessageQuoteComponent,
        NbChatMessageMapComponent,
        NbChatMessageTextComponent]; }, encapsulation: 2, data: { animation: [
            trigger('flyInOut', [
                state('in', style({ transform: 'translateX(0)' })),
                transition('void => *', [
                    style({ transform: 'translateX(-100%)' }),
                    animate(80),
                ]),
                transition('* => void', [
                    animate(80, style({ transform: 'translateX(100%)' })),
                ]),
            ]),
        ] }, changeDetection: 0 });
__decorate$94([
    HostBinding('@flyInOut'),
    __metadata$61("design:type", Object),
    __metadata$61("design:paramtypes", [])
], NbChatMessageComponent.prototype, "flyInOut", null);
__decorate$94([
    HostBinding('class.not-reply'),
    __metadata$61("design:type", Object),
    __metadata$61("design:paramtypes", [])
], NbChatMessageComponent.prototype, "notReply", null);
__decorate$94([
    Input(),
    HostBinding('class.reply'),
    __metadata$61("design:type", Boolean),
    __metadata$61("design:paramtypes", [Boolean])
], NbChatMessageComponent.prototype, "reply", null);
__decorate$94([
    Input(),
    __metadata$61("design:type", String)
], NbChatMessageComponent.prototype, "message", void 0);
__decorate$94([
    Input(),
    __metadata$61("design:type", String)
], NbChatMessageComponent.prototype, "sender", void 0);
__decorate$94([
    Input(),
    __metadata$61("design:type", Date)
], NbChatMessageComponent.prototype, "date", void 0);
__decorate$94([
    Input(),
    __metadata$61("design:type", Array)
], NbChatMessageComponent.prototype, "files", void 0);
__decorate$94([
    Input(),
    __metadata$61("design:type", String)
], NbChatMessageComponent.prototype, "quote", void 0);
__decorate$94([
    Input(),
    __metadata$61("design:type", Number)
], NbChatMessageComponent.prototype, "latitude", void 0);
__decorate$94([
    Input(),
    __metadata$61("design:type", Number)
], NbChatMessageComponent.prototype, "longitude", void 0);
__decorate$94([
    Input(),
    __metadata$61("design:type", String),
    __metadata$61("design:paramtypes", [String])
], NbChatMessageComponent.prototype, "avatar", null);
__decorate$94([
    Input(),
    __metadata$61("design:type", String)
], NbChatMessageComponent.prototype, "type", void 0);
NbChatMessageComponent = __decorate$94([ __metadata$61("design:paramtypes", [DomSanitizer])
], NbChatMessageComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$92 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$59 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Conversational UI collection - a set of components for chat-like UI construction.
 *
 * Main features:
 * - different message types support (text, image, file, file group, map, etc)
 * - drag & drop for images and files with preview
 * - different UI styles
 * - custom action buttons (coming soon)
 *
 * Here's a complete example build in a bot-like app. Type `help` to be able to receive different message types.
 * Enjoy the conversation and the beautiful UI.
 * @stacked-example(Showcase, chat/chat-showcase.component)
 *
 * Basic chat configuration and usage:
 * ```ts
 * <nb-chat title="Nebular Conversational UI">
 *       <nb-chat-message *ngFor="let msg of messages"
 *                        [type]="msg.type"
 *                        [message]="msg.text"
 *                        [reply]="msg.reply"
 *                        [sender]="msg.user.name"
 *                        [date]="msg.date"
 *                        [files]="msg.files"
 *                        [quote]="msg.quote"
 *                        [latitude]="msg.latitude"
 *                        [longitude]="msg.longitude"
 *                        [avatar]="msg.user.avatar">
 *   </nb-chat-message>
 *
 *   <nb-chat-form (send)="sendMessage($event)" [dropFiles]="true">
 *   </nb-chat-form>
 * </nb-chat>
 * ```
 * ### Installation
 *
 * Import `NbChatModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbChatModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * If you need to provide an API key for a `map` message type (which is required by Google Maps)
 * you may use `NbChatModule.forRoot({ ... })` call if this is a global app configuration
 * or `NbChatModule.forChild({ ... })` for a feature module configuration:
 *
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbChatModule.forRoot({ messageGoogleMapKey: 'MAP_KEY' }),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * ### Usage
 *
 * There are three main components:
 * ```ts
 * <nb-chat>
 * </nb-chat> // chat container
 *
 * <nb-chat-form>
 * </nb-chat-form> // chat form with drag&drop files feature
 *
 * <nb-chat-message>
 * </nb-chat-message> // chat message, available multiple types
 * ```
 *
 * Two users conversation showcase:
 * @stacked-example(Conversation, chat/chat-conversation-showcase.component)
 *
 * Chat UI is also available in different colors by specifying a `[status]` input:
 *
 * @stacked-example(Colored Chat, chat/chat-colors.component)
 *
 * Also it is possible to configure sizes through `[size]` input:
 *
 * @stacked-example(Chat Sizes, chat/chat-sizes.component)
 *
 * @styles
 *
 * chat-background-color:
 * chat-border:
 * chat-border-radius:
 * chat-shadow:
 * chat-padding:
 * chat-scrollbar-color:
 * chat-scrollbar-background-color:
 * chat-scrollbar-width:
 * chat-text-color:
 * chat-text-font-family:
 * chat-text-font-size:
 * chat-text-font-weight:
 * chat-text-line-height:
 * chat-header-text-font-family:
 * chat-header-text-font-size:
 * chat-header-text-font-weight:
 * chat-header-text-line-height:
 * chat-tiny-height:
 * chat-small-height:
 * chat-medium-height:
 * chat-large-height:
 * chat-giant-height:
 * chat-basic-background-color:
 * chat-basic-text-color:
 * chat-primary-background-color:
 * chat-primary-text-color:
 * chat-success-background-color:
 * chat-success-text-color:
 * chat-info-background-color:
 * chat-info-text-color:
 * chat-warning-background-color:
 * chat-warning-text-color:
 * chat-danger-background-color:
 * chat-danger-text-color:
 * chat-control-background-color:
 * chat-control-text-color:
 * chat-divider-color:
 * chat-divider-style:
 * chat-divider-width:
 * chat-message-background:
 * chat-message-text-color:
 * chat-message-reply-background-color:
 * chat-message-reply-text-color:
 * chat-message-avatar-background-color:
 * chat-message-sender-text-color:
 * chat-message-quote-background-color:
 * chat-message-quote-text-color:
 * chat-message-file-text-color:
 * chat-message-file-background-color:
 */
let NbChatComponent = class NbChatComponent {
    /**
     * Conversational UI collection - a set of components for chat-like UI construction.
     *
     * Main features:
     * - different message types support (text, image, file, file group, map, etc)
     * - drag & drop for images and files with preview
     * - different UI styles
     * - custom action buttons (coming soon)
     *
     * Here's a complete example build in a bot-like app. Type `help` to be able to receive different message types.
     * Enjoy the conversation and the beautiful UI.
     * @stacked-example(Showcase, chat/chat-showcase.component)
     *
     * Basic chat configuration and usage:
     * ```ts
     * <nb-chat title="Nebular Conversational UI">
     *       <nb-chat-message *ngFor="let msg of messages"
     *                        [type]="msg.type"
     *                        [message]="msg.text"
     *                        [reply]="msg.reply"
     *                        [sender]="msg.user.name"
     *                        [date]="msg.date"
     *                        [files]="msg.files"
     *                        [quote]="msg.quote"
     *                        [latitude]="msg.latitude"
     *                        [longitude]="msg.longitude"
     *                        [avatar]="msg.user.avatar">
     *   </nb-chat-message>
     *
     *   <nb-chat-form (send)="sendMessage($event)" [dropFiles]="true">
     *   </nb-chat-form>
     * </nb-chat>
     * ```
     * ### Installation
     *
     * Import `NbChatModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbChatModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     *
     * If you need to provide an API key for a `map` message type (which is required by Google Maps)
     * you may use `NbChatModule.forRoot({ ... })` call if this is a global app configuration
     * or `NbChatModule.forChild({ ... })` for a feature module configuration:
     *
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbChatModule.forRoot({ messageGoogleMapKey: 'MAP_KEY' }),
     *   ],
     * })
     * export class AppModule { }
     * ```
     *
     * ### Usage
     *
     * There are three main components:
     * ```ts
     * <nb-chat>
     * </nb-chat> // chat container
     *
     * <nb-chat-form>
     * </nb-chat-form> // chat form with drag&drop files feature
     *
     * <nb-chat-message>
     * </nb-chat-message> // chat message, available multiple types
     * ```
     *
     * Two users conversation showcase:
     * @stacked-example(Conversation, chat/chat-conversation-showcase.component)
     *
     * Chat UI is also available in different colors by specifying a `[status]` input:
     *
     * @stacked-example(Colored Chat, chat/chat-colors.component)
     *
     * Also it is possible to configure sizes through `[size]` input:
     *
     * @stacked-example(Chat Sizes, chat/chat-sizes.component)
     *
     * @styles
     *
     * chat-background-color:
     * chat-border:
     * chat-border-radius:
     * chat-shadow:
     * chat-padding:
     * chat-scrollbar-color:
     * chat-scrollbar-background-color:
     * chat-scrollbar-width:
     * chat-text-color:
     * chat-text-font-family:
     * chat-text-font-size:
     * chat-text-font-weight:
     * chat-text-line-height:
     * chat-header-text-font-family:
     * chat-header-text-font-size:
     * chat-header-text-font-weight:
     * chat-header-text-line-height:
     * chat-tiny-height:
     * chat-small-height:
     * chat-medium-height:
     * chat-large-height:
     * chat-giant-height:
     * chat-basic-background-color:
     * chat-basic-text-color:
     * chat-primary-background-color:
     * chat-primary-text-color:
     * chat-success-background-color:
     * chat-success-text-color:
     * chat-info-background-color:
     * chat-info-text-color:
     * chat-warning-background-color:
     * chat-warning-text-color:
     * chat-danger-background-color:
     * chat-danger-text-color:
     * chat-control-background-color:
     * chat-control-text-color:
     * chat-divider-color:
     * chat-divider-style:
     * chat-divider-width:
     * chat-message-background:
     * chat-message-text-color:
     * chat-message-reply-background-color:
     * chat-message-reply-text-color:
     * chat-message-avatar-background-color:
     * chat-message-sender-text-color:
     * chat-message-quote-background-color:
     * chat-message-quote-text-color:
     * chat-message-file-text-color:
     * chat-message-file-background-color:
     */
    constructor() {
        this._status = 'basic';
        this._scrollBottom = true;
    }
    /**
     * Chat status color (adds specific styles):
     * `basic` (default), `primary`, `success`, `info`, `warning`, `danger`, `control`.
     */
    get status() {
        return this._status;
    }
    set status(value) {
        if (!value) {
            emptyStatusWarning('NbChat');
            value = 'basic';
        }
        this._status = value;
    }
    /**
     * Scroll chat to the bottom of the list when a new message arrives
     */
    get scrollBottom() {
        return this._scrollBottom;
    }
    set scrollBottom(value) {
        this._scrollBottom = convertToBoolProperty(value);
    }
    ngOnChanges(changes) {
        if ('status' in changes) {
            this.updateFormStatus();
        }
    }
    ngAfterContentInit() {
        this.updateFormStatus();
    }
    ngAfterViewInit() {
        this.messages.changes
            .subscribe((messages) => {
            this.messages = messages;
            this.updateView();
        });
        this.updateView();
    }
    updateView() {
        if (this.scrollBottom) {
            this.scrollListBottom();
        }
    }
    scrollListBottom() {
        this.scrollable.nativeElement.scrollTop = this.scrollable.nativeElement.scrollHeight;
    }
    updateFormStatus() {
        if (this.chatForm) {
            this.chatForm.setStatus(this.status);
        }
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get info() {
        return this.status === 'info';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
};
NbChatComponent.ɵfac = function NbChatComponent_Factory(t) { return new (t || NbChatComponent)(); };
NbChatComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatComponent, selectors: [["nb-chat"]], contentQueries: function NbChatComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbChatFormComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbChatMessageComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chatForm = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.messages = _t);
    } }, viewQuery: function NbChatComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c23, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.scrollable = _t.first);
    } }, hostVars: 24, hostBindings: function NbChatComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    } }, inputs: { status: "status", scrollBottom: "scrollBottom", title: "title", size: "size" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], ngContentSelectors: _c25, decls: 9, vars: 2, consts: [[1, "header"], [1, "scrollable"], ["scrollable", ""], [1, "messages"], ["class", "no-messages", 4, "ngIf"], [1, "form"], [1, "no-messages"]], template: function NbChatComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c24);
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 1, 2);
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵtemplate(6, NbChatComponent_p_6_Template, 2, 0, "p", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "div", 5);
        ɵngcc0.ɵɵprojection(8, 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.title);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", !(ctx.messages == null ? null : ctx.messages.length));
    } }, directives: [ɵngcc2.NgIf], styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;position:relative;height:100%}"] });
__decorate$92([
    Input(),
    __metadata$59("design:type", String)
], NbChatComponent.prototype, "title", void 0);
__decorate$92([
    Input(),
    __metadata$59("design:type", String)
], NbChatComponent.prototype, "size", void 0);
__decorate$92([
    Input(),
    __metadata$59("design:type", String),
    __metadata$59("design:paramtypes", [String])
], NbChatComponent.prototype, "status", null);
__decorate$92([
    Input(),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [Boolean])
], NbChatComponent.prototype, "scrollBottom", null);
__decorate$92([
    ViewChild('scrollable', { static: false }),
    __metadata$59("design:type", ElementRef)
], NbChatComponent.prototype, "scrollable", void 0);
__decorate$92([
    ContentChildren(NbChatMessageComponent),
    __metadata$59("design:type", QueryList)
], NbChatComponent.prototype, "messages", void 0);
__decorate$92([
    ContentChild(NbChatFormComponent, { static: false }),
    __metadata$59("design:type", NbChatFormComponent)
], NbChatComponent.prototype, "chatForm", void 0);
__decorate$92([
    HostBinding('class.size-tiny'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "tiny", null);
__decorate$92([
    HostBinding('class.size-small'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "small", null);
__decorate$92([
    HostBinding('class.size-medium'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "medium", null);
__decorate$92([
    HostBinding('class.size-large'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "large", null);
__decorate$92([
    HostBinding('class.size-giant'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "giant", null);
__decorate$92([
    HostBinding('class.status-primary'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "primary", null);
__decorate$92([
    HostBinding('class.status-success'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "success", null);
__decorate$92([
    HostBinding('class.status-info'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "info", null);
__decorate$92([
    HostBinding('class.status-warning'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "warning", null);
__decorate$92([
    HostBinding('class.status-danger'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "danger", null);
__decorate$92([
    HostBinding('class.status-basic'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "basic", null);
__decorate$92([
    HostBinding('class.status-control'),
    __metadata$59("design:type", Boolean),
    __metadata$59("design:paramtypes", [])
], NbChatComponent.prototype, "control", null);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbChatOptions {
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$95 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$62 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Chat message component.
 */
let NbChatMessageMapComponent = class NbChatMessageMapComponent {
    constructor(options) {
        this.mapKey = options.messageGoogleMapKey;
    }
    get file() {
        return {
            // tslint:disable-next-line:max-line-length
            url: `https://maps.googleapis.com/maps/api/staticmap?center=${this.latitude},${this.longitude}&zoom=12&size=400x400&key=${this.mapKey}`,
            type: 'image/png',
            icon: 'location',
        };
    }
};
NbChatMessageMapComponent.ɵfac = function NbChatMessageMapComponent_Factory(t) { return new (t || NbChatMessageMapComponent)(ɵngcc0.ɵɵdirectiveInject(NbChatOptions)); };
NbChatMessageMapComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatMessageMapComponent, selectors: [["nb-chat-message-map"]], inputs: { message: "message", sender: "sender", date: "date", latitude: "latitude", longitude: "longitude" }, decls: 1, vars: 6, consts: [[3, "files", "message", "sender", "date"]], template: function NbChatMessageMapComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "nb-chat-message-file", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("files", ɵngcc0.ɵɵpureFunction1(4, _c26, ctx.file))("message", ctx.message)("sender", ctx.sender)("date", ctx.date);
    } }, directives: function () { return [NbChatMessageFileComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate$95([
    Input(),
    __metadata$62("design:type", String)
], NbChatMessageMapComponent.prototype, "message", void 0);
__decorate$95([
    Input(),
    __metadata$62("design:type", String)
], NbChatMessageMapComponent.prototype, "sender", void 0);
__decorate$95([
    Input(),
    __metadata$62("design:type", Date)
], NbChatMessageMapComponent.prototype, "date", void 0);
__decorate$95([
    Input(),
    __metadata$62("design:type", Number)
], NbChatMessageMapComponent.prototype, "latitude", void 0);
__decorate$95([
    Input(),
    __metadata$62("design:type", Number)
], NbChatMessageMapComponent.prototype, "longitude", void 0);
NbChatMessageMapComponent = __decorate$95([ __metadata$62("design:paramtypes", [NbChatOptions])
], NbChatMessageMapComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$96 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$63 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Chat message component.
 */
let NbChatMessageFileComponent = class NbChatMessageFileComponent {
    constructor(cd, domSanitizer) {
        this.cd = cd;
        this.domSanitizer = domSanitizer;
    }
    /**
     * Message file path
     * @type {Date}
     */
    set files(files) {
        this.readyFiles = (files || []).map((file) => {
            const isImage = this.isImage(file);
            return Object.assign({}, file, { urlStyle: isImage && this.domSanitizer.bypassSecurityTrustStyle(`url(${file.url})`), isImage: isImage });
        });
        this.cd.detectChanges();
    }
    isImage(file) {
        return ['image/png', 'image/jpeg', 'image/gif'].includes(file.type);
    }
};
NbChatMessageFileComponent.ɵfac = function NbChatMessageFileComponent_Factory(t) { return new (t || NbChatMessageFileComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer)); };
NbChatMessageFileComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatMessageFileComponent, selectors: [["nb-chat-message-file"]], inputs: { files: "files", message: "message", sender: "sender", date: "date" }, decls: 4, vars: 6, consts: [[3, "sender", "date", "message"], [4, "ngIf"], [1, "message-content-group"], ["target", "_blank", 3, "href", 4, "ngFor", "ngForOf"], ["target", "_blank", 3, "href"], [3, "icon", 4, "ngIf"], [3, "background-image", 4, "ngIf"], [3, "icon"]], template: function NbChatMessageFileComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-chat-message-text", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NbChatMessageFileComponent_ng_container_2_Template, 3, 1, "ng-container", 1);
        ɵngcc0.ɵɵtemplate(3, NbChatMessageFileComponent_ng_container_3_Template, 4, 3, "ng-container", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("sender", ctx.sender)("date", ctx.date)("message", ctx.message);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.message, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) > 1);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", (ctx.readyFiles == null ? null : ctx.readyFiles.length) === 1);
    } }, directives: function () { return [NbChatMessageTextComponent, ɵngcc2.NgIf, ɵngcc2.NgForOf, NbIconComponent]; }, encapsulation: 2, changeDetection: 0 });
__decorate$96([
    Input(),
    __metadata$63("design:type", String)
], NbChatMessageFileComponent.prototype, "message", void 0);
__decorate$96([
    Input(),
    __metadata$63("design:type", String)
], NbChatMessageFileComponent.prototype, "sender", void 0);
__decorate$96([
    Input(),
    __metadata$63("design:type", Date)
], NbChatMessageFileComponent.prototype, "date", void 0);
__decorate$96([
    Input(),
    __metadata$63("design:type", Array),
    __metadata$63("design:paramtypes", [Array])
], NbChatMessageFileComponent.prototype, "files", null);
NbChatMessageFileComponent = __decorate$96([ __metadata$63("design:paramtypes", [ChangeDetectorRef, DomSanitizer])
], NbChatMessageFileComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$97 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$64 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Chat message component.
 */
let NbChatMessageQuoteComponent = class NbChatMessageQuoteComponent {
};
NbChatMessageQuoteComponent.ɵfac = function NbChatMessageQuoteComponent_Factory(t) { return new (t || NbChatMessageQuoteComponent)(); };
NbChatMessageQuoteComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatMessageQuoteComponent, selectors: [["nb-chat-message-quote"]], inputs: { message: "message", sender: "sender", date: "date", quote: "quote" }, decls: 5, vars: 4, consts: [["class", "sender", 4, "ngIf"], [1, "quote"], [3, "message"], [1, "sender"]], template: function NbChatMessageQuoteComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbChatMessageQuoteComponent_p_0_Template, 5, 5, "p", 0);
        ɵngcc0.ɵɵelementStart(1, "p", 1);
        ɵngcc0.ɵɵtext(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "nb-chat-message-text", 2);
        ɵngcc0.ɵɵtext(4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.sender || ctx.date);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.quote, " ");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("message", ctx.message);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.message, " ");
    } }, directives: function () { return [ɵngcc2.NgIf, NbChatMessageTextComponent]; }, pipes: function () { return [ɵngcc2.DatePipe]; }, encapsulation: 2, changeDetection: 0 });
__decorate$97([
    Input(),
    __metadata$64("design:type", String)
], NbChatMessageQuoteComponent.prototype, "message", void 0);
__decorate$97([
    Input(),
    __metadata$64("design:type", String)
], NbChatMessageQuoteComponent.prototype, "sender", void 0);
__decorate$97([
    Input(),
    __metadata$64("design:type", Date)
], NbChatMessageQuoteComponent.prototype, "date", void 0);
__decorate$97([
    Input(),
    __metadata$64("design:type", String)
], NbChatMessageQuoteComponent.prototype, "quote", void 0);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$98 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$65 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Chat message component.
 */
let NbChatMessageTextComponent = class NbChatMessageTextComponent {
};
NbChatMessageTextComponent.ɵfac = function NbChatMessageTextComponent_Factory(t) { return new (t || NbChatMessageTextComponent)(); };
NbChatMessageTextComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbChatMessageTextComponent, selectors: [["nb-chat-message-text"]], inputs: { sender: "sender", message: "message", date: "date" }, decls: 2, vars: 2, consts: [["class", "sender", 4, "ngIf"], ["class", "text", 4, "ngIf"], [1, "sender"], [1, "text"]], template: function NbChatMessageTextComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbChatMessageTextComponent_p_0_Template, 5, 5, "p", 0);
        ɵngcc0.ɵɵtemplate(1, NbChatMessageTextComponent_p_1_Template, 2, 1, "p", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.sender || ctx.date);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.message);
    } }, directives: [ɵngcc2.NgIf], pipes: [ɵngcc2.DatePipe], encapsulation: 2, changeDetection: 0 });
__decorate$98([
    Input(),
    __metadata$65("design:type", String)
], NbChatMessageTextComponent.prototype, "sender", void 0);
__decorate$98([
    Input(),
    __metadata$65("design:type", String)
], NbChatMessageTextComponent.prototype, "message", void 0);
__decorate$98([
    Input(),
    __metadata$65("design:type", Date)
], NbChatMessageTextComponent.prototype, "date", void 0);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$101 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$66 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Basic input directive.
 *
 * ```html
 * <input nbInput></input>
 * ```
 *
 * ### Installation
 *
 * Import `NbInputModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbInputModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Default input size is `medium`:
 * @stacked-example(Showcase, input/input-showcase.component)
 *
 * Inputs are available in multiple colors using `status` property:
 * @stacked-example(Input Colors, input/input-colors.component)
 *
 * There are three input sizes:
 *
 * @stacked-example(Input Sizes, input/input-sizes.component)
 *
 * Inputs available in different shapes, which could be combined with the other properties:
 * @stacked-example(Input Shapes, input/input-shapes.component)
 *
 * `nbInput` could be applied to the following selectors - `input`, `textarea`:
 * @stacked-example(Input Elements, input/input-types.component)
 *
 * You can add `fullWidth` attribute to make element fill container:
 * @stacked-example(Full width inputs, input/input-full-width.component)
 *
 * Or you can bind control with form controls or ngModel:
 * @stacked-example(Input form binding, input/input-form.component)
 *
 * @styles
 *
 * input-border-style:
 * input-border-width:
 * input-outline-color:
 * input-outline-width:
 * input-placeholder-text-font-family:
 * input-text-font-family:
 * input-basic-text-color:
 * input-basic-placeholder-text-color:
 * input-basic-background-color:
 * input-basic-border-color:
 * input-basic-focus-background-color:
 * input-basic-focus-border-color:
 * input-basic-hover-background-color:
 * input-basic-hover-border-color:
 * input-basic-disabled-background-color:
 * input-basic-disabled-border-color:
 * input-basic-disabled-text-color:
 * input-basic-disabled-placeholder-text-color:
 * input-primary-text-color:
 * input-primary-placeholder-text-color:
 * input-primary-background-color:
 * input-primary-border-color:
 * input-primary-focus-background-color:
 * input-primary-focus-border-color:
 * input-primary-hover-background-color:
 * input-primary-hover-border-color:
 * input-primary-disabled-background-color:
 * input-primary-disabled-border-color:
 * input-primary-disabled-text-color:
 * input-primary-disabled-placeholder-text-color:
 * input-success-text-color:
 * input-success-placeholder-text-color:
 * input-success-background-color:
 * input-success-border-color:
 * input-success-focus-background-color:
 * input-success-focus-border-color:
 * input-success-hover-background-color:
 * input-success-hover-border-color:
 * input-success-disabled-background-color:
 * input-success-disabled-border-color:
 * input-success-disabled-text-color:
 * input-success-disabled-placeholder-text-color:
 * input-info-text-color:
 * input-info-placeholder-text-color:
 * input-info-background-color:
 * input-info-border-color:
 * input-info-focus-background-color:
 * input-info-focus-border-color:
 * input-info-hover-background-color:
 * input-info-hover-border-color:
 * input-info-disabled-background-color:
 * input-info-disabled-border-color:
 * input-info-disabled-text-color:
 * input-info-disabled-placeholder-text-color:
 * input-warning-text-color:
 * input-warning-placeholder-text-color:
 * input-warning-background-color:
 * input-warning-border-color:
 * input-warning-focus-background-color:
 * input-warning-focus-border-color:
 * input-warning-hover-background-color:
 * input-warning-hover-border-color:
 * input-warning-disabled-background-color:
 * input-warning-disabled-border-color:
 * input-warning-disabled-text-color:
 * input-warning-disabled-placeholder-text-color:
 * input-danger-text-color:
 * input-danger-placeholder-text-color:
 * input-danger-background-color:
 * input-danger-border-color:
 * input-danger-focus-background-color:
 * input-danger-focus-border-color:
 * input-danger-hover-background-color:
 * input-danger-hover-border-color:
 * input-danger-disabled-background-color:
 * input-danger-disabled-border-color:
 * input-danger-disabled-text-color:
 * input-danger-disabled-placeholder-text-color:
 * input-control-text-color:
 * input-control-placeholder-text-color:
 * input-control-background-color:
 * input-control-border-color:
 * input-control-focus-background-color:
 * input-control-focus-border-color:
 * input-control-hover-background-color:
 * input-control-hover-border-color:
 * input-control-disabled-background-color:
 * input-control-disabled-border-color:
 * input-control-disabled-text-color:
 * input-control-disabled-placeholder-text-color:
 * input-rectangle-border-radius:
 * input-semi-round-border-radius:
 * input-round-border-radius:
 * input-tiny-text-font-size:
 * input-tiny-text-font-weight:
 * input-tiny-text-line-height:
 * input-tiny-placeholder-text-font-size:
 * input-tiny-placeholder-text-font-weight:
 * input-tiny-placeholder-text-line-height:
 * input-tiny-padding:
 * input-tiny-max-width:
 * input-small-text-font-size:
 * input-small-text-font-weight:
 * input-small-text-line-height:
 * input-small-placeholder-text-font-size:
 * input-small-placeholder-text-font-weight:
 * input-small-placeholder-text-line-height:
 * input-small-padding:
 * input-small-max-width:
 * input-medium-text-font-size:
 * input-medium-text-font-weight:
 * input-medium-text-line-height:
 * input-medium-placeholder-text-font-size:
 * input-medium-placeholder-text-font-weight:
 * input-medium-placeholder-text-line-height:
 * input-medium-padding:
 * input-medium-max-width:
 * input-large-text-font-size:
 * input-large-text-font-weight:
 * input-large-text-line-height:
 * input-large-placeholder-text-font-size:
 * input-large-placeholder-text-font-weight:
 * input-large-placeholder-text-line-height:
 * input-large-padding:
 * input-large-max-width:
 * input-giant-text-font-size:
 * input-giant-text-font-weight:
 * input-giant-text-line-height:
 * input-giant-placeholder-text-font-size:
 * input-giant-placeholder-text-font-weight:
 * input-giant-placeholder-text-line-height:
 * input-giant-padding:
 * input-giant-max-width:
 */
let NbInputDirective = class NbInputDirective {
    /**
     * Basic input directive.
     *
     * ```html
     * <input nbInput></input>
     * ```
     *
     * ### Installation
     *
     * Import `NbInputModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbInputModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * Default input size is `medium`:
     * @stacked-example(Showcase, input/input-showcase.component)
     *
     * Inputs are available in multiple colors using `status` property:
     * @stacked-example(Input Colors, input/input-colors.component)
     *
     * There are three input sizes:
     *
     * @stacked-example(Input Sizes, input/input-sizes.component)
     *
     * Inputs available in different shapes, which could be combined with the other properties:
     * @stacked-example(Input Shapes, input/input-shapes.component)
     *
     * `nbInput` could be applied to the following selectors - `input`, `textarea`:
     * @stacked-example(Input Elements, input/input-types.component)
     *
     * You can add `fullWidth` attribute to make element fill container:
     * @stacked-example(Full width inputs, input/input-full-width.component)
     *
     * Or you can bind control with form controls or ngModel:
     * @stacked-example(Input form binding, input/input-form.component)
     *
     * @styles
     *
     * input-border-style:
     * input-border-width:
     * input-outline-color:
     * input-outline-width:
     * input-placeholder-text-font-family:
     * input-text-font-family:
     * input-basic-text-color:
     * input-basic-placeholder-text-color:
     * input-basic-background-color:
     * input-basic-border-color:
     * input-basic-focus-background-color:
     * input-basic-focus-border-color:
     * input-basic-hover-background-color:
     * input-basic-hover-border-color:
     * input-basic-disabled-background-color:
     * input-basic-disabled-border-color:
     * input-basic-disabled-text-color:
     * input-basic-disabled-placeholder-text-color:
     * input-primary-text-color:
     * input-primary-placeholder-text-color:
     * input-primary-background-color:
     * input-primary-border-color:
     * input-primary-focus-background-color:
     * input-primary-focus-border-color:
     * input-primary-hover-background-color:
     * input-primary-hover-border-color:
     * input-primary-disabled-background-color:
     * input-primary-disabled-border-color:
     * input-primary-disabled-text-color:
     * input-primary-disabled-placeholder-text-color:
     * input-success-text-color:
     * input-success-placeholder-text-color:
     * input-success-background-color:
     * input-success-border-color:
     * input-success-focus-background-color:
     * input-success-focus-border-color:
     * input-success-hover-background-color:
     * input-success-hover-border-color:
     * input-success-disabled-background-color:
     * input-success-disabled-border-color:
     * input-success-disabled-text-color:
     * input-success-disabled-placeholder-text-color:
     * input-info-text-color:
     * input-info-placeholder-text-color:
     * input-info-background-color:
     * input-info-border-color:
     * input-info-focus-background-color:
     * input-info-focus-border-color:
     * input-info-hover-background-color:
     * input-info-hover-border-color:
     * input-info-disabled-background-color:
     * input-info-disabled-border-color:
     * input-info-disabled-text-color:
     * input-info-disabled-placeholder-text-color:
     * input-warning-text-color:
     * input-warning-placeholder-text-color:
     * input-warning-background-color:
     * input-warning-border-color:
     * input-warning-focus-background-color:
     * input-warning-focus-border-color:
     * input-warning-hover-background-color:
     * input-warning-hover-border-color:
     * input-warning-disabled-background-color:
     * input-warning-disabled-border-color:
     * input-warning-disabled-text-color:
     * input-warning-disabled-placeholder-text-color:
     * input-danger-text-color:
     * input-danger-placeholder-text-color:
     * input-danger-background-color:
     * input-danger-border-color:
     * input-danger-focus-background-color:
     * input-danger-focus-border-color:
     * input-danger-hover-background-color:
     * input-danger-hover-border-color:
     * input-danger-disabled-background-color:
     * input-danger-disabled-border-color:
     * input-danger-disabled-text-color:
     * input-danger-disabled-placeholder-text-color:
     * input-control-text-color:
     * input-control-placeholder-text-color:
     * input-control-background-color:
     * input-control-border-color:
     * input-control-focus-background-color:
     * input-control-focus-border-color:
     * input-control-hover-background-color:
     * input-control-hover-border-color:
     * input-control-disabled-background-color:
     * input-control-disabled-border-color:
     * input-control-disabled-text-color:
     * input-control-disabled-placeholder-text-color:
     * input-rectangle-border-radius:
     * input-semi-round-border-radius:
     * input-round-border-radius:
     * input-tiny-text-font-size:
     * input-tiny-text-font-weight:
     * input-tiny-text-line-height:
     * input-tiny-placeholder-text-font-size:
     * input-tiny-placeholder-text-font-weight:
     * input-tiny-placeholder-text-line-height:
     * input-tiny-padding:
     * input-tiny-max-width:
     * input-small-text-font-size:
     * input-small-text-font-weight:
     * input-small-text-line-height:
     * input-small-placeholder-text-font-size:
     * input-small-placeholder-text-font-weight:
     * input-small-placeholder-text-line-height:
     * input-small-padding:
     * input-small-max-width:
     * input-medium-text-font-size:
     * input-medium-text-font-weight:
     * input-medium-text-line-height:
     * input-medium-placeholder-text-font-size:
     * input-medium-placeholder-text-font-weight:
     * input-medium-placeholder-text-line-height:
     * input-medium-padding:
     * input-medium-max-width:
     * input-large-text-font-size:
     * input-large-text-font-weight:
     * input-large-text-line-height:
     * input-large-placeholder-text-font-size:
     * input-large-placeholder-text-font-weight:
     * input-large-placeholder-text-line-height:
     * input-large-padding:
     * input-large-max-width:
     * input-giant-text-font-size:
     * input-giant-text-font-weight:
     * input-giant-text-line-height:
     * input-giant-placeholder-text-font-size:
     * input-giant-placeholder-text-font-weight:
     * input-giant-placeholder-text-line-height:
     * input-giant-padding:
     * input-giant-max-width:
     */
    constructor() {
        /**
         * Field size modifications. Possible values: `small`, `medium` (default), `large`.
         */
        this.fieldSize = 'medium';
        this._status = 'basic';
        /**
         * Field shapes modifications. Possible values: `rectangle` (default), `round`, `semi-round`.
         */
        this.shape = 'rectangle';
        this._fullWidth = false;
    }
    /**
     * Field status (adds specific styles):
     * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`
     */
    get status() {
        return this._status;
    }
    set status(value) {
        if (value === '') {
            emptyStatusWarning('NbInput');
            this._status = 'basic';
        }
        else {
            this._status = value;
        }
    }
    /**
     * If set element will fill container. `false` by default.
     */
    get fullWidth() {
        return this._fullWidth;
    }
    set fullWidth(value) {
        this._fullWidth = convertToBoolProperty(value);
    }
    get tiny() {
        return this.fieldSize === 'tiny';
    }
    get small() {
        return this.fieldSize === 'small';
    }
    get medium() {
        return this.fieldSize === 'medium';
    }
    get large() {
        return this.fieldSize === 'large';
    }
    get giant() {
        return this.fieldSize === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get rectangle() {
        return this.shape === 'rectangle';
    }
    get semiRound() {
        return this.shape === 'semi-round';
    }
    get round() {
        return this.shape === 'round';
    }
};
NbInputDirective.ɵfac = function NbInputDirective_Factory(t) { return new (t || NbInputDirective)(); };
NbInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbInputDirective, selectors: [["input", "nbInput", ""], ["textarea", "nbInput", ""]], hostVars: 32, hostBindings: function NbInputDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("input-full-width", ctx.fullWidth)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-semi-round", ctx.semiRound)("shape-round", ctx.round);
    } }, inputs: { fieldSize: "fieldSize", shape: "shape", status: "status", fullWidth: "fullWidth" } });
__decorate$101([
    Input(),
    __metadata$66("design:type", String)
], NbInputDirective.prototype, "fieldSize", void 0);
__decorate$101([
    Input(),
    __metadata$66("design:type", String),
    __metadata$66("design:paramtypes", [String])
], NbInputDirective.prototype, "status", null);
__decorate$101([
    Input(),
    __metadata$66("design:type", String)
], NbInputDirective.prototype, "shape", void 0);
__decorate$101([
    Input(),
    HostBinding('class.input-full-width'),
    __metadata$66("design:type", Boolean),
    __metadata$66("design:paramtypes", [Boolean])
], NbInputDirective.prototype, "fullWidth", null);
__decorate$101([
    HostBinding('class.size-tiny'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "tiny", null);
__decorate$101([
    HostBinding('class.size-small'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "small", null);
__decorate$101([
    HostBinding('class.size-medium'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "medium", null);
__decorate$101([
    HostBinding('class.size-large'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "large", null);
__decorate$101([
    HostBinding('class.size-giant'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "giant", null);
__decorate$101([
    HostBinding('class.status-primary'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "primary", null);
__decorate$101([
    HostBinding('class.status-info'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "info", null);
__decorate$101([
    HostBinding('class.status-success'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "success", null);
__decorate$101([
    HostBinding('class.status-warning'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "warning", null);
__decorate$101([
    HostBinding('class.status-danger'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "danger", null);
__decorate$101([
    HostBinding('class.status-basic'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "basic", null);
__decorate$101([
    HostBinding('class.status-control'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "control", null);
__decorate$101([
    HostBinding('class.shape-rectangle'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "rectangle", null);
__decorate$101([
    HostBinding('class.shape-semi-round'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "semiRound", null);
__decorate$101([
    HostBinding('class.shape-round'),
    __metadata$66("design:type", Object),
    __metadata$66("design:paramtypes", [])
], NbInputDirective.prototype, "round", null);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$100 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const NB_INPUT_COMPONENTS = [
    NbInputDirective,
];
let NbInputModule = class NbInputModule {
};
NbInputModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbInputModule });
NbInputModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbInputModule_Factory(t) { return new (t || NbInputModule)(); }, imports: [[NbSharedModule]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$99 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbChatModule_1;
const NB_CHAT_COMPONENTS = [
    NbChatComponent,
    NbChatMessageComponent,
    NbChatFormComponent,
    NbChatMessageTextComponent,
    NbChatMessageFileComponent,
    NbChatMessageQuoteComponent,
    NbChatMessageMapComponent,
];
let NbChatModule = NbChatModule_1 = class NbChatModule {
    static forRoot(options) {
        return {
            ngModule: NbChatModule_1,
            providers: [
                { provide: NbChatOptions, useValue: options || {} },
            ],
        };
    }
    static forChild(options) {
        return {
            ngModule: NbChatModule_1,
            providers: [
                { provide: NbChatOptions, useValue: options || {} },
            ],
        };
    }
};
NbChatModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbChatModule });
NbChatModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbChatModule_Factory(t) { return new (t || NbChatModule)(); }, imports: [[
            NbSharedModule,
            NbIconModule,
            NbInputModule,
            NbButtonModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$102 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$67 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Styled spinner component
 *
 * @styles
 *
 * spinner-text-color:
 * spinner-text-font-family:
 * spinner-text-font-size:
 * spinner-text-font-weight:
 * spinner-text-line-height:
 * spinner-basic-background-color:
 * spinner-basic-circle-filled-color:
 * spinner-basic-circle-empty-color:
 * spinner-primary-background-color:
 * spinner-primary-circle-filled-color:
 * spinner-primary-circle-empty-color:
 * spinner-info-background-color:
 * spinner-info-circle-filled-color:
 * spinner-info-circle-empty-color:
 * spinner-success-background-color:
 * spinner-success-circle-filled-color:
 * spinner-success-circle-empty-color:
 * spinner-warning-background-color:
 * spinner-warning-circle-filled-color:
 * spinner-warning-circle-empty-color:
 * spinner-danger-background-color:
 * spinner-danger-circle-filled-color:
 * spinner-danger-circle-empty-color:
 * spinner-control-background-color:
 * spinner-control-circle-filled-color:
 * spinner-control-circle-empty-color:
 * spinner-height-tiny:
 * spinner-height-small:
 * spinner-height-medium:
 * spinner-height-large:
 * spinner-height-giant:
 */
let NbSpinnerComponent = class NbSpinnerComponent {
    /**
     * Styled spinner component
     *
     * @styles
     *
     * spinner-text-color:
     * spinner-text-font-family:
     * spinner-text-font-size:
     * spinner-text-font-weight:
     * spinner-text-line-height:
     * spinner-basic-background-color:
     * spinner-basic-circle-filled-color:
     * spinner-basic-circle-empty-color:
     * spinner-primary-background-color:
     * spinner-primary-circle-filled-color:
     * spinner-primary-circle-empty-color:
     * spinner-info-background-color:
     * spinner-info-circle-filled-color:
     * spinner-info-circle-empty-color:
     * spinner-success-background-color:
     * spinner-success-circle-filled-color:
     * spinner-success-circle-empty-color:
     * spinner-warning-background-color:
     * spinner-warning-circle-filled-color:
     * spinner-warning-circle-empty-color:
     * spinner-danger-background-color:
     * spinner-danger-circle-filled-color:
     * spinner-danger-circle-empty-color:
     * spinner-control-background-color:
     * spinner-control-circle-filled-color:
     * spinner-control-circle-empty-color:
     * spinner-height-tiny:
     * spinner-height-small:
     * spinner-height-medium:
     * spinner-height-large:
     * spinner-height-giant:
     */
    constructor() {
        /**
         * Loading text that is shown near the icon
         * @type string
         */
        this.message = 'Loading...';
        /**
         * Spinner size, available sizes:
         * tiny, small, medium, large, giant
         * @param {string} value
         */
        this.size = 'medium';
        this._status = 'basic';
    }
    /**
     * Spinner status (adds specific styles):
     * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`.
     */
    get status() {
        return this._status;
    }
    set status(value) {
        if (value === '') {
            emptyStatusWarning('NbSpinner');
            value = 'basic';
        }
        this._status = value;
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
};
NbSpinnerComponent.ɵfac = function NbSpinnerComponent_Factory(t) { return new (t || NbSpinnerComponent)(); };
NbSpinnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSpinnerComponent, selectors: [["nb-spinner"]], hostVars: 24, hostBindings: function NbSpinnerComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control);
    } }, inputs: { message: "message", size: "size", status: "status" }, decls: 2, vars: 1, consts: [[1, "spin-circle"], ["class", "message", 4, "ngIf"], [1, "message"]], template: function NbSpinnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
        ɵngcc0.ɵɵtemplate(1, NbSpinnerComponent_span_1_Template, 2, 1, "span", 1);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.message);
    } }, directives: [ɵngcc2.NgIf], styles: ["[_nghost-%COMP%]{opacity:1;position:absolute;border-radius:inherit;top:0;right:0;left:0;bottom:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}[_nghost-%COMP%]   .spin-circle[_ngcontent-%COMP%]{animation:spin 0.8s infinite linear;border-radius:50%;border-style:solid;border-width:0.125em;width:1em;height:1em}[_nghost-%COMP%]   .message[_ngcontent-%COMP%]{margin-left:0.5rem}"] });
__decorate$102([
    Input(),
    __metadata$67("design:type", String)
], NbSpinnerComponent.prototype, "message", void 0);
__decorate$102([
    Input(),
    __metadata$67("design:type", String)
], NbSpinnerComponent.prototype, "size", void 0);
__decorate$102([
    Input(),
    __metadata$67("design:type", String),
    __metadata$67("design:paramtypes", [String])
], NbSpinnerComponent.prototype, "status", null);
__decorate$102([
    HostBinding('class.size-tiny'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "tiny", null);
__decorate$102([
    HostBinding('class.size-small'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "small", null);
__decorate$102([
    HostBinding('class.size-medium'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "medium", null);
__decorate$102([
    HostBinding('class.size-large'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "large", null);
__decorate$102([
    HostBinding('class.size-giant'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "giant", null);
__decorate$102([
    HostBinding('class.status-primary'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "primary", null);
__decorate$102([
    HostBinding('class.status-info'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "info", null);
__decorate$102([
    HostBinding('class.status-success'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "success", null);
__decorate$102([
    HostBinding('class.status-warning'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "warning", null);
__decorate$102([
    HostBinding('class.status-danger'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "danger", null);
__decorate$102([
    HostBinding('class.status-basic'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "basic", null);
__decorate$102([
    HostBinding('class.status-control'),
    __metadata$67("design:type", Object),
    __metadata$67("design:paramtypes", [])
], NbSpinnerComponent.prototype, "control", null);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$103 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$68 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Styled spinner directive
 *
 * @stacked-example(Spinner Showcase, spinner/spinner-card.component)
 *
 *
 * ```ts
 * <nb-card [nbSpinner]="loading" nbSpinnerStatus="danger">
 *   <nb-card-body>Card Content</nb-card-body>
 * </nb-card>
 * ```
 *
 * ### Installation
 *
 * Import `NbSpinnerModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSpinnerModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Could be colored using `status` property
 *
 * @stacked-example(Spinner Colors, spinner/spinner-colors.component)
 *
 * Available in different sizes with `size` property:
 *
 * @stacked-example(Spinner Sizes, spinner/spinner-sizes.component)
 *
 * It is also possible to place it into the button:
 * @stacked-example(Buttons with spinner, spinner/spinner-button.component)
 *
 * Or tabs:
 * @stacked-example(Spinner in tabs, spinner/spinner-tabs.component)
 */
let NbSpinnerDirective = class NbSpinnerDirective {
    constructor(directiveView, componentFactoryResolver, renderer, directiveElement) {
        this.directiveView = directiveView;
        this.componentFactoryResolver = componentFactoryResolver;
        this.renderer = renderer;
        this.directiveElement = directiveElement;
        this.shouldShow = false;
        /**
         * Spinner status color
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`.
         */
        this.spinnerStatus = 'basic';
        /**
         * Spinner size. Possible values: `tiny`, `small`, `medium` (default), `large`, `giant`
         */
        this.spinnerSize = 'medium';
        this.isSpinnerExist = false;
    }
    /**
     * Directive value - show or hide spinner
     * @param {boolean} val
     */
    set nbSpinner(val) {
        if (this.componentFactory) {
            if (val) {
                this.show();
            }
            else {
                this.hide();
            }
        }
        else {
            this.shouldShow = val;
        }
    }
    ngOnInit() {
        this.componentFactory = this.componentFactoryResolver.resolveComponentFactory(NbSpinnerComponent);
        if (this.shouldShow) {
            this.show();
        }
    }
    hide() {
        if (this.isSpinnerExist) {
            this.directiveView.remove();
            this.isSpinnerExist = false;
        }
    }
    show() {
        if (!this.isSpinnerExist) {
            this.spinner = this.directiveView.createComponent(this.componentFactory);
            this.setInstanceInputs(this.spinner.instance);
            this.spinner.changeDetectorRef.detectChanges();
            this.renderer.appendChild(this.directiveElement.nativeElement, this.spinner.location.nativeElement);
            this.isSpinnerExist = true;
        }
    }
    setInstanceInputs(instance) {
        instance.message = this.spinnerMessage;
        typeof this.spinnerStatus !== 'undefined' && (instance.status = this.spinnerStatus);
        typeof this.spinnerSize !== 'undefined' && (instance.size = this.spinnerSize);
    }
};
NbSpinnerDirective.ɵfac = function NbSpinnerDirective_Factory(t) { return new (t || NbSpinnerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbSpinnerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbSpinnerDirective, selectors: [["", "nbSpinner", ""]], hostVars: 2, hostBindings: function NbSpinnerDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nb-spinner-container", ctx.isSpinnerExist);
    } }, inputs: { spinnerStatus: ["nbSpinnerStatus", "spinnerStatus"], spinnerSize: ["nbSpinnerSize", "spinnerSize"], nbSpinner: "nbSpinner", spinnerMessage: ["nbSpinnerMessage", "spinnerMessage"] } });
__decorate$103([
    Input('nbSpinnerMessage'),
    __metadata$68("design:type", String)
], NbSpinnerDirective.prototype, "spinnerMessage", void 0);
__decorate$103([
    Input('nbSpinnerStatus'),
    __metadata$68("design:type", String)
], NbSpinnerDirective.prototype, "spinnerStatus", void 0);
__decorate$103([
    Input('nbSpinnerSize'),
    __metadata$68("design:type", String)
], NbSpinnerDirective.prototype, "spinnerSize", void 0);
__decorate$103([
    Input('nbSpinner'),
    __metadata$68("design:type", Boolean),
    __metadata$68("design:paramtypes", [Boolean])
], NbSpinnerDirective.prototype, "nbSpinner", null);
__decorate$103([
    HostBinding('class.nb-spinner-container'),
    __metadata$68("design:type", Object)
], NbSpinnerDirective.prototype, "isSpinnerExist", void 0);
NbSpinnerDirective = __decorate$103([ __metadata$68("design:paramtypes", [ViewContainerRef,
        ComponentFactoryResolver,
        Renderer2,
        ElementRef])
], NbSpinnerDirective);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$104 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbSpinnerModule = class NbSpinnerModule {
};
NbSpinnerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSpinnerModule });
NbSpinnerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbSpinnerModule_Factory(t) { return new (t || NbSpinnerModule)(); }, imports: [[
            NbSharedModule,
        ]] });

const NB_STEPPER = new InjectionToken('Nebular Stepper Component');

var __decorate$106 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$70 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$12 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Component intended to be used within  the `<nb-stepper>` component.
 * Container for a step
 */
let NbStepComponent = class NbStepComponent {
    constructor(stepper) {
        this._completed = false;
        this.interacted = false;
        this.stepper = stepper;
    }
    /**
     * Check that label is a TemplateRef.
     *
     * @return boolean
     * */
    get isLabelTemplate() {
        return this.label instanceof TemplateRef;
    }
    /**
     * Whether step is marked as completed.
     *
     * @type {boolean}
     */
    get completed() {
        return this._completed || this.isCompleted;
    }
    set completed(value) {
        this._completed = convertToBoolProperty(value);
    }
    get isCompleted() {
        return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
    }
    /**
     * Mark step as selected
     * */
    select() {
        this.stepper.selected = this;
    }
    /**
     * Reset step and stepControl state
     * */
    reset() {
        this.interacted = false;
        if (this.stepControl) {
            this.stepControl.reset();
        }
    }
};
NbStepComponent.ɵfac = function NbStepComponent_Factory(t) { return new (t || NbStepComponent)(ɵngcc0.ɵɵdirectiveInject(NB_STEPPER)); };
NbStepComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbStepComponent, selectors: [["nb-step"]], viewQuery: function NbStepComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(TemplateRef, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.content = _t.first);
    } }, inputs: { completed: "completed", stepControl: "stepControl", label: "label", hidden: "hidden" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbStepComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NbStepComponent_ng_template_0_Template, 1, 0, "ng-template");
    } }, encapsulation: 2 });
__decorate$106([
    ViewChild(TemplateRef, { static: true }),
    __metadata$70("design:type", TemplateRef)
], NbStepComponent.prototype, "content", void 0);
__decorate$106([
    Input(),
    __metadata$70("design:type", AbstractControl)
], NbStepComponent.prototype, "stepControl", void 0);
__decorate$106([
    Input(),
    __metadata$70("design:type", Object)
], NbStepComponent.prototype, "label", void 0);
__decorate$106([
    Input(),
    __metadata$70("design:type", Boolean)
], NbStepComponent.prototype, "hidden", void 0);
__decorate$106([
    Input(),
    __metadata$70("design:type", Boolean),
    __metadata$70("design:paramtypes", [Boolean])
], NbStepComponent.prototype, "completed", null);
NbStepComponent = __decorate$106([ __param$12(0, Inject(NB_STEPPER)),
    __metadata$70("design:paramtypes", [Object])
], NbStepComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$105 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$69 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NbStepperComponent_1;
/**
 * Stepper component
 *
 * @stacked-example(Showcase, stepper/stepper-showcase.component)
 *
 * ### Installation
 *
 * Import `NbStepperModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbStepperModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * If step label is string you can pass it as `label` attribute. Otherwise ng-template should be used:
 * ```html
 * // ...
 * <nb-stepper orientation="horizontal">
 *   <nb-step label="step number one">
 *       // ... step content here
 *   </nb-step>
 *   <nb-step label="stepLabel">
 *       <ng-template #stepLabel>
 *           <div>
 *               step number two
 *           </div>
 *       </ng-template>
 *       // ... step content here
 *   </nb-step>
 * </nb-stepper>
 * ```
 *
 * When linear mode enabled user can't move forward unless current step is complete.
 * @stacked-example(Linear, stepper/stepper-linear.component)
 *
 * Specify `[stepControl]="form"` and stepper allow go to the next step only if form is valid.
 * You can disable it via `linear` mode setting.
 * ```html
 * // ...
 * <nb-stepper  orientation="horizontal">
 *   <nb-step label="step number one" [stepControl]="form">
 *     <form [formGroup]="form">
 *       // ...
 *     </form>
 *   </nb-step>
 *    // ...
 * </nb-stepper>
 * ```
 *
 * @stacked-example(Validation, stepper/stepper-validation.component)
 *
 * Stepper component has two layout options - `vertical` & `horizontal`
 * @stacked-example(Vertical, stepper/stepper-vertical.component)
 *
 * `disableStepNavigation` disables navigation by clicking on steps, so user can navigate only using
 * 'nbStepperPrevious' and 'nbStepperNext' buttons.
 * @stacked-example(Disabled steps navigation, stepper/stepper-disabled-step-nav.component)
 *
 * @styles
 *
 * stepper-step-text-color:
 * stepper-step-text-font-family:
 * stepper-step-text-font-size:
 * stepper-step-text-font-weight:
 * stepper-step-text-line-height:
 * stepper-step-active-text-color:
 * stepper-step-completed-text-color:
 * stepper-step-index-border-color:
 * stepper-step-index-border-style:
 * stepper-step-index-border-width:
 * stepper-step-index-border-radius:
 * stepper-step-index-width:
 * stepper-step-index-active-border-color:
 * stepper-step-index-completed-background-color:
 * stepper-step-index-completed-border-color:
 * stepper-step-index-completed-text-color:
 * stepper-connector-background-color:
 * stepper-connector-completed-background-color:
 * stepper-horizontal-connector-margin:
 * stepper-vertical-connector-margin:
 * stepper-step-content-padding:
 */
let NbStepperComponent = NbStepperComponent_1 = class NbStepperComponent {
    /**
     * Stepper component
     *
     * @stacked-example(Showcase, stepper/stepper-showcase.component)
     *
     * ### Installation
     *
     * Import `NbStepperModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbStepperModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * If step label is string you can pass it as `label` attribute. Otherwise ng-template should be used:
     * ```html
     * // ...
     * <nb-stepper orientation="horizontal">
     *   <nb-step label="step number one">
     *       // ... step content here
     *   </nb-step>
     *   <nb-step label="stepLabel">
     *       <ng-template #stepLabel>
     *           <div>
     *               step number two
     *           </div>
     *       </ng-template>
     *       // ... step content here
     *   </nb-step>
     * </nb-stepper>
     * ```
     *
     * When linear mode enabled user can't move forward unless current step is complete.
     * @stacked-example(Linear, stepper/stepper-linear.component)
     *
     * Specify `[stepControl]="form"` and stepper allow go to the next step only if form is valid.
     * You can disable it via `linear` mode setting.
     * ```html
     * // ...
     * <nb-stepper  orientation="horizontal">
     *   <nb-step label="step number one" [stepControl]="form">
     *     <form [formGroup]="form">
     *       // ...
     *     </form>
     *   </nb-step>
     *    // ...
     * </nb-stepper>
     * ```
     *
     * @stacked-example(Validation, stepper/stepper-validation.component)
     *
     * Stepper component has two layout options - `vertical` & `horizontal`
     * @stacked-example(Vertical, stepper/stepper-vertical.component)
     *
     * `disableStepNavigation` disables navigation by clicking on steps, so user can navigate only using
     * 'nbStepperPrevious' and 'nbStepperNext' buttons.
     * @stacked-example(Disabled steps navigation, stepper/stepper-disabled-step-nav.component)
     *
     * @styles
     *
     * stepper-step-text-color:
     * stepper-step-text-font-family:
     * stepper-step-text-font-size:
     * stepper-step-text-font-weight:
     * stepper-step-text-line-height:
     * stepper-step-active-text-color:
     * stepper-step-completed-text-color:
     * stepper-step-index-border-color:
     * stepper-step-index-border-style:
     * stepper-step-index-border-width:
     * stepper-step-index-border-radius:
     * stepper-step-index-width:
     * stepper-step-index-active-border-color:
     * stepper-step-index-completed-background-color:
     * stepper-step-index-completed-border-color:
     * stepper-step-index-completed-text-color:
     * stepper-connector-background-color:
     * stepper-connector-completed-background-color:
     * stepper-horizontal-connector-margin:
     * stepper-vertical-connector-margin:
     * stepper-step-content-padding:
     */
    constructor() {
        this._selectedIndex = 0;
        this._disableStepNavigation = false;
        /**
         * Stepper orientation - `horizontal`|`vertical`
         */
        this.orientation = 'horizontal';
        this._linear = true;
    }
    /**
     * Selected step index
     */
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(index) {
        if (!this.steps) {
            this._selectedIndex = index;
            return;
        }
        this.markCurrentStepInteracted();
        if (this.canBeSelected(index)) {
            this._selectedIndex = index;
        }
    }
    /**
     * Disables navigation by clicking on steps. False by default
     * @param {boolean} value
     */
    set disableStepNavigation(value) {
        this._disableStepNavigation = convertToBoolProperty(value);
    }
    get disableStepNavigation() {
        return this._disableStepNavigation;
    }
    /**
     * Selected step component
     */
    get selected() {
        return this.steps ? this.steps.toArray()[this.selectedIndex] : undefined;
    }
    set selected(step) {
        if (!this.steps) {
            return;
        }
        this.selectedIndex = this.steps.toArray().indexOf(step);
    }
    /**
     * Allow moving forward only if the current step is complete
     * @default true
     */
    set linear(value) {
        this._linear = convertToBoolProperty(value);
    }
    get linear() {
        return this._linear;
    }
    get vertical() {
        return this.orientation === 'vertical';
    }
    get horizontal() {
        return this.orientation === 'horizontal';
    }
    /**
     * Navigate to next step
     * */
    next() {
        this.selectedIndex = Math.min(this.selectedIndex + 1, this.steps.length - 1);
    }
    /**
     * Navigate to previous step
     * */
    previous() {
        this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
    }
    /**
     * Reset stepper and stepControls to initial state
     * */
    reset() {
        this._selectedIndex = 0;
        this.steps.forEach(step => step.reset());
    }
    isStepSelected(step) {
        return this.selected === step;
    }
    isStepValid(index) {
        return this.steps.toArray()[index].completed;
    }
    canBeSelected(indexToCheck) {
        const noSteps = !this.steps || this.steps.length === 0;
        if (noSteps || indexToCheck < 0 || indexToCheck >= this.steps.length) {
            return false;
        }
        if (indexToCheck <= this.selectedIndex || !this.linear) {
            return true;
        }
        let isAllStepsValid = true;
        for (let i = this.selectedIndex; i < indexToCheck; i++) {
            if (!this.isStepValid(i)) {
                isAllStepsValid = false;
                break;
            }
        }
        return isAllStepsValid;
    }
    markCurrentStepInteracted() {
        if (this.selected) {
            this.selected.interacted = true;
        }
    }
};
NbStepperComponent.ɵfac = function NbStepperComponent_Factory(t) { return new (t || NbStepperComponent)(); };
NbStepperComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbStepperComponent, selectors: [["nb-stepper"]], contentQueries: function NbStepperComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbStepComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.steps = _t);
    } }, hostVars: 4, hostBindings: function NbStepperComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("vertical", ctx.vertical)("horizontal", ctx.horizontal);
    } }, inputs: { orientation: "orientation", selectedIndex: "selectedIndex", disableStepNavigation: "disableStepNavigation", selected: "selected", linear: "linear" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NB_STEPPER, useExisting: NbStepperComponent_1 }])], ngContentSelectors: _c28, decls: 5, vars: 2, consts: [[1, "header"], [4, "ngFor", "ngForOf"], [1, "step-content"], [3, "ngTemplateOutlet"], ["class", "connector", 3, "connector-past", 4, "ngIf"], ["class", "step", 3, "selected", "completed", "noninteractive", "click", 4, "ngIf"], [1, "connector"], [1, "step", 3, "click"], [1, "label-index"], [4, "ngIf"], ["icon", "checkmark-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "label"], ["icon", "checkmark-outline", "pack", "nebular-essentials"], [4, "ngTemplateOutlet"]], template: function NbStepperComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c27);
        ɵngcc0.ɵɵtemplate(0, NbStepperComponent_ng_template_0_Template, 1, 0, "ng-template");
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵtemplate(2, NbStepperComponent_ng_container_2_Template, 3, 2, "ng-container", 1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "div", 2);
        ɵngcc0.ɵɵelementContainer(4, 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.steps);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.selected == null ? null : ctx.selected.content);
    } }, directives: [ɵngcc2.NgForOf, ɵngcc2.NgTemplateOutlet, ɵngcc2.NgIf, NbIconComponent], styles: [".horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{flex-direction:column}.horizontal[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{height:2px}.horizontal[_nghost-%COMP%]   .label-index[_ngcontent-%COMP%]{margin-bottom:10px}.vertical[_nghost-%COMP%]{display:flex;height:100%}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]{flex-direction:column}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{margin:0 10px}.vertical[_nghost-%COMP%]   .header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{width:2px}.header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header[_ngcontent-%COMP%]   .connector[_ngcontent-%COMP%]{flex:auto}.header[_ngcontent-%COMP%]   .step[_ngcontent-%COMP%]{display:flex;align-items:center;cursor:pointer}.header[_ngcontent-%COMP%]   .step.noninteractive[_ngcontent-%COMP%]{cursor:default}.header[_ngcontent-%COMP%]   .label-index[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center}.header[_ngcontent-%COMP%]   .label[_ngcontent-%COMP%]{width:max-content}"] });
__decorate$105([
    Input(),
    __metadata$69("design:type", Number),
    __metadata$69("design:paramtypes", [Number])
], NbStepperComponent.prototype, "selectedIndex", null);
__decorate$105([
    Input(),
    __metadata$69("design:type", Boolean),
    __metadata$69("design:paramtypes", [Boolean])
], NbStepperComponent.prototype, "disableStepNavigation", null);
__decorate$105([
    Input(),
    __metadata$69("design:type", NbStepComponent),
    __metadata$69("design:paramtypes", [NbStepComponent])
], NbStepperComponent.prototype, "selected", null);
__decorate$105([
    Input(),
    __metadata$69("design:type", String)
], NbStepperComponent.prototype, "orientation", void 0);
__decorate$105([
    Input(),
    __metadata$69("design:type", Boolean),
    __metadata$69("design:paramtypes", [Boolean])
], NbStepperComponent.prototype, "linear", null);
__decorate$105([
    HostBinding('class.vertical'),
    __metadata$69("design:type", Object),
    __metadata$69("design:paramtypes", [])
], NbStepperComponent.prototype, "vertical", null);
__decorate$105([
    HostBinding('class.horizontal'),
    __metadata$69("design:type", Object),
    __metadata$69("design:paramtypes", [])
], NbStepperComponent.prototype, "horizontal", null);
__decorate$105([
    ContentChildren(NbStepComponent),
    __metadata$69("design:type", QueryList)
], NbStepperComponent.prototype, "steps", void 0);

var __decorate$107 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$71 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbStepperNextDirective = class NbStepperNextDirective {
    constructor(stepper) {
        this.stepper = stepper;
        this.type = 'submit';
    }
    onClick() {
        this.stepper.next();
    }
};
NbStepperNextDirective.ɵfac = function NbStepperNextDirective_Factory(t) { return new (t || NbStepperNextDirective)(ɵngcc0.ɵɵdirectiveInject(NbStepperComponent)); };
NbStepperNextDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbStepperNextDirective, selectors: [["button", "nbStepperNext", ""]], hostVars: 1, hostBindings: function NbStepperNextDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbStepperNextDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("type", ctx.type);
    } }, inputs: { type: "type" } });
__decorate$107([
    Input(), HostBinding('attr.type'),
    __metadata$71("design:type", String)
], NbStepperNextDirective.prototype, "type", void 0);
__decorate$107([
    HostListener('click'),
    __metadata$71("design:type", Function),
    __metadata$71("design:paramtypes", []),
    __metadata$71("design:returntype", void 0)
], NbStepperNextDirective.prototype, "onClick", null);
NbStepperNextDirective = __decorate$107([ __metadata$71("design:paramtypes", [NbStepperComponent])
], NbStepperNextDirective);
let NbStepperPreviousDirective = class NbStepperPreviousDirective {
    constructor(stepper) {
        this.stepper = stepper;
        this.type = 'button';
    }
    onClick() {
        this.stepper.previous();
    }
};
NbStepperPreviousDirective.ɵfac = function NbStepperPreviousDirective_Factory(t) { return new (t || NbStepperPreviousDirective)(ɵngcc0.ɵɵdirectiveInject(NbStepperComponent)); };
NbStepperPreviousDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbStepperPreviousDirective, selectors: [["button", "nbStepperPrevious", ""]], hostVars: 1, hostBindings: function NbStepperPreviousDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbStepperPreviousDirective_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("type", ctx.type);
    } }, inputs: { type: "type" } });
__decorate$107([
    Input(), HostBinding('attr.type'),
    __metadata$71("design:type", String)
], NbStepperPreviousDirective.prototype, "type", void 0);
__decorate$107([
    HostListener('click'),
    __metadata$71("design:type", Function),
    __metadata$71("design:paramtypes", []),
    __metadata$71("design:returntype", void 0)
], NbStepperPreviousDirective.prototype, "onClick", null);
NbStepperPreviousDirective = __decorate$107([ __metadata$71("design:paramtypes", [NbStepperComponent])
], NbStepperPreviousDirective);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$108 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbStepperModule = class NbStepperModule {
};
NbStepperModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbStepperModule });
NbStepperModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbStepperModule_Factory(t) { return new (t || NbStepperModule)(); }, imports: [[
            NbSharedModule,
            NbIconModule,
        ]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$109 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$72 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * An accordion allows to toggle the display of sections of content
 *
 * Basic example
 * @stacked-example(Showcase, accordion/accordion-showcase.component)
 *
 * ```ts
 * <nb-accordion>
 *  <nb-accordion-item>
 *   <nb-accordion-item-header>Product Details</nb-accordion-item-header>
 *   <nb-accordion-item-body>
 *     Item Content
 *   </nb-accordion-item-body>
 *  </nb-accordion-item>
 * </nb-accordion>
 * ```
 * ### Installation
 *
 * Import `NbAccordionModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbAccordionModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * With `multi` mode accordion can have multiple items expanded:
 * @stacked-example(Multiple expanded items, accordion/accordion-multi.component)
 *
 * `NbAccordionItemComponent` has several methods, for example it is possible to trigger item click/toggle:
 * @stacked-example(Expand API, accordion/accordion-toggle.component)
 *
 * @styles
 *
 * accordion-border-radius:
 * accordion-padding:
 * accordion-shadow:
 * accordion-header-text-color:
 * accordion-header-text-font-family:
 * accordion-header-text-font-size:
 * accordion-header-text-font-weight:
 * accordion-header-text-line-height:
 * accordion-header-disabled-text-color:
 * accordion-header-border-color:
 * accordion-header-border-style:
 * accordion-header-border-width:
 * accordion-item-background-color:
 * accordion-item-text-color:
 * accordion-item-text-font-family:
 * accordion-item-text-font-size:
 * accordion-item-text-font-weight:
 * accordion-item-text-line-height:
 */
let NbAccordionComponent = class NbAccordionComponent {
    /**
     * An accordion allows to toggle the display of sections of content
     *
     * Basic example
     * @stacked-example(Showcase, accordion/accordion-showcase.component)
     *
     * ```ts
     * <nb-accordion>
     *  <nb-accordion-item>
     *   <nb-accordion-item-header>Product Details</nb-accordion-item-header>
     *   <nb-accordion-item-body>
     *     Item Content
     *   </nb-accordion-item-body>
     *  </nb-accordion-item>
     * </nb-accordion>
     * ```
     * ### Installation
     *
     * Import `NbAccordionModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbAccordionModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * With `multi` mode accordion can have multiple items expanded:
     * @stacked-example(Multiple expanded items, accordion/accordion-multi.component)
     *
     * `NbAccordionItemComponent` has several methods, for example it is possible to trigger item click/toggle:
     * @stacked-example(Expand API, accordion/accordion-toggle.component)
     *
     * @styles
     *
     * accordion-border-radius:
     * accordion-padding:
     * accordion-shadow:
     * accordion-header-text-color:
     * accordion-header-text-font-family:
     * accordion-header-text-font-size:
     * accordion-header-text-font-weight:
     * accordion-header-text-line-height:
     * accordion-header-disabled-text-color:
     * accordion-header-border-color:
     * accordion-header-border-style:
     * accordion-header-border-width:
     * accordion-item-background-color:
     * accordion-item-text-color:
     * accordion-item-text-font-family:
     * accordion-item-text-font-size:
     * accordion-item-text-font-weight:
     * accordion-item-text-line-height:
     */
    constructor() {
        this.openCloseItems = new Subject();
        this.multiValue = false;
    }
    /**
     *  Allow multiple items to be expanded at the same time.
     * @type {boolean}
     */
    get multi() {
        return this.multiValue;
    }
    set multi(val) {
        this.multiValue = convertToBoolProperty(val);
    }
    /**
     * Opens all enabled accordion items.
     */
    openAll() {
        if (this.multi) {
            this.openCloseItems.next(false);
        }
    }
    /**
     * Closes all enabled accordion items.
     */
    closeAll() {
        this.openCloseItems.next(true);
    }
};
NbAccordionComponent.ɵfac = function NbAccordionComponent_Factory(t) { return new (t || NbAccordionComponent)(); };
NbAccordionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbAccordionComponent, selectors: [["nb-accordion"]], inputs: { multi: "multi" }, ngContentSelectors: _c30, decls: 1, vars: 0, template: function NbAccordionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c29);
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
__decorate$109([
    Input('multi'),
    __metadata$72("design:type", Boolean),
    __metadata$72("design:paramtypes", [Boolean])
], NbAccordionComponent.prototype, "multi", null);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$110 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$73 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$13 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Component intended to be used within `<nb-accordion>` component
 */
let NbAccordionItemComponent = class NbAccordionItemComponent {
    constructor(accordion, cd) {
        this.accordion = accordion;
        this.cd = cd;
        /**
         * Emits whenever the expanded state of the accordion changes.
         * Primarily used to facilitate two-way binding.
         */
        this.collapsedChange = new EventEmitter();
        this.accordionItemInvalidate = new Subject();
        this.collapsedValue = true;
        this.disabledValue = false;
        this.alive = true;
    }
    /**
     * Item is collapse (`true` by default)
     * @type {boolean}
     */
    get collapsed() {
        return this.collapsedValue;
    }
    set collapsed(val) {
        this.collapsedValue = convertToBoolProperty(val);
        this.collapsedChange.emit(this.collapsedValue);
        this.invalidate();
    }
    /**
     * Item is expanded (`false` by default)
     * @type {boolean}
     */
    get expanded() {
        return !this.collapsed;
    }
    set expanded(val) {
        this.collapsedValue = !convertToBoolProperty(val);
    }
    /**
     * Item is disabled and cannot be opened.
     * @type {boolean}
     */
    get disabled() {
        return this.disabledValue;
    }
    set disabled(val) {
        this.disabledValue = convertToBoolProperty(val);
        this.invalidate();
    }
    /**
     * Open/close the item
     */
    toggle() {
        if (!this.disabled) {
            // we need this temporary variable as `openCloseItems.next` will change current value we need to save
            const willSet = !this.collapsed;
            if (!this.accordion.multi) {
                this.accordion.openCloseItems.next(true);
            }
            this.collapsed = willSet;
        }
    }
    /**
     * Open the item.
     */
    open() {
        !this.disabled && (this.collapsed = false);
    }
    /**
     * Collapse the item.
     */
    close() {
        !this.disabled && (this.collapsed = true);
    }
    ngOnInit() {
        this.accordion.openCloseItems
            .pipe(takeWhile(() => this.alive))
            .subscribe(collapsed => {
            !this.disabled && (this.collapsed = collapsed);
        });
    }
    ngOnChanges(changes) {
        this.accordionItemInvalidate.next(true);
    }
    ngOnDestroy() {
        this.alive = false;
        this.accordionItemInvalidate.complete();
    }
    invalidate() {
        this.accordionItemInvalidate.next(true);
        this.cd.markForCheck();
    }
};
NbAccordionItemComponent.ɵfac = function NbAccordionItemComponent_Factory(t) { return new (t || NbAccordionItemComponent)(ɵngcc0.ɵɵdirectiveInject(NbAccordionComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbAccordionItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbAccordionItemComponent, selectors: [["nb-accordion-item"]], hostVars: 6, hostBindings: function NbAccordionItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("collapsed", ctx.collapsed)("expanded", ctx.expanded)("disabled", ctx.disabled);
    } }, inputs: { collapsed: "collapsed", expanded: "expanded", disabled: "disabled" }, outputs: { collapsedChange: "collapsedChange" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()], ngContentSelectors: _c32, decls: 2, vars: 0, template: function NbAccordionItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c31);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
    } }, styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column}"], changeDetection: 0 });
__decorate$110([
    Input('collapsed'),
    HostBinding('class.collapsed'),
    __metadata$73("design:type", Boolean),
    __metadata$73("design:paramtypes", [Boolean])
], NbAccordionItemComponent.prototype, "collapsed", null);
__decorate$110([
    Input('expanded'),
    HostBinding('class.expanded'),
    __metadata$73("design:type", Boolean),
    __metadata$73("design:paramtypes", [Boolean])
], NbAccordionItemComponent.prototype, "expanded", null);
__decorate$110([
    Input('disabled'),
    HostBinding('class.disabled'),
    __metadata$73("design:type", Boolean),
    __metadata$73("design:paramtypes", [Boolean])
], NbAccordionItemComponent.prototype, "disabled", null);
__decorate$110([
    Output(),
    __metadata$73("design:type", Object)
], NbAccordionItemComponent.prototype, "collapsedChange", void 0);
NbAccordionItemComponent = __decorate$110([ __param$13(0, Host()),
    __metadata$73("design:paramtypes", [NbAccordionComponent, ChangeDetectorRef])
], NbAccordionItemComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$111 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$74 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$14 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
const accordionItemBodyTrigger = trigger('accordionItemBody', [
    state('collapsed', style({
        overflow: 'hidden',
        visibility: 'hidden',
        height: 0,
    })),
    state('expanded', style({
        overflow: 'hidden',
        visibility: 'visible',
    })),
    transition('collapsed => expanded', animate('100ms ease-in')),
    transition('expanded => collapsed', animate('100ms ease-out')),
]);
/**
 * Component intended to be used within `<nb-accordion-item>` component
 */
let NbAccordionItemBodyComponent = class NbAccordionItemBodyComponent {
    constructor(accordionItem, cd) {
        this.accordionItem = accordionItem;
        this.cd = cd;
        this.alive = true;
    }
    get state() {
        return this.accordionItem.collapsed ? 'collapsed' : 'expanded';
    }
    ngOnInit() {
        this.accordionItem.accordionItemInvalidate
            .pipe(takeWhile(() => this.alive))
            .subscribe(() => this.cd.markForCheck());
    }
    ngOnDestroy() {
        this.alive = false;
    }
};
NbAccordionItemBodyComponent.ɵfac = function NbAccordionItemBodyComponent_Factory(t) { return new (t || NbAccordionItemBodyComponent)(ɵngcc0.ɵɵdirectiveInject(NbAccordionItemComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbAccordionItemBodyComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbAccordionItemBodyComponent, selectors: [["nb-accordion-item-body"]], ngContentSelectors: _c0, decls: 3, vars: 3, consts: [[1, "item-body"]], template: function NbAccordionItemBodyComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "div", 0);
        ɵngcc0.ɵɵprojection(2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("@accordionItemBody", ɵngcc0.ɵɵpureFunction1(1, _c33, ctx.state));
    } }, encapsulation: 2, data: { animation: [accordionItemBodyTrigger] }, changeDetection: 0 });
NbAccordionItemBodyComponent = __decorate$111([ __param$14(0, Host()),
    __metadata$74("design:paramtypes", [NbAccordionItemComponent, ChangeDetectorRef])
], NbAccordionItemBodyComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$112 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$75 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$15 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * Component intended to be used within `<nb-accordion-item>` component
 */
let NbAccordionItemHeaderComponent = class NbAccordionItemHeaderComponent {
    constructor(accordionItem, cd) {
        this.accordionItem = accordionItem;
        this.cd = cd;
        this.alive = true;
    }
    get isCollapsed() {
        return this.accordionItem.collapsed;
    }
    get expanded() {
        return !this.accordionItem.collapsed;
    }
    // issue #794
    get tabbable() {
        return this.accordionItem.disabled ? '-1' : '0';
    }
    get disabled() {
        return this.accordionItem.disabled;
    }
    toggle() {
        this.accordionItem.toggle();
    }
    get state() {
        if (this.isCollapsed) {
            return 'collapsed';
        }
        if (this.expanded) {
            return 'expanded';
        }
    }
    ngOnInit() {
        this.accordionItem.accordionItemInvalidate
            .pipe(takeWhile(() => this.alive))
            .subscribe(() => this.cd.markForCheck());
    }
    ngOnDestroy() {
        this.alive = false;
    }
};
NbAccordionItemHeaderComponent.ɵfac = function NbAccordionItemHeaderComponent_Factory(t) { return new (t || NbAccordionItemHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(NbAccordionItemComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbAccordionItemHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbAccordionItemHeaderComponent, selectors: [["nb-accordion-item-header"]], hostVars: 7, hostBindings: function NbAccordionItemHeaderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbAccordionItemHeaderComponent_click_HostBindingHandler() { return ctx.toggle(); })("keydown.space", function NbAccordionItemHeaderComponent_keydown_space_HostBindingHandler() { return ctx.toggle(); })("keydown.enter", function NbAccordionItemHeaderComponent_keydown_enter_HostBindingHandler() { return ctx.toggle(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-expanded", ctx.expanded)("tabindex", ctx.tabbable)("aria-disabled", ctx.disabled);
        ɵngcc0.ɵɵclassProp("accordion-item-header-collapsed", ctx.isCollapsed)("accordion-item-header-expanded", ctx.expanded);
    } }, ngContentSelectors: _c35, decls: 4, vars: 1, consts: [["icon", "chevron-down-outline", "pack", "nebular-essentials", "class", "expansion-indicator", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", 1, "expansion-indicator"]], template: function NbAccordionItemHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c34);
        ɵngcc0.ɵɵprojection(0);
        ɵngcc0.ɵɵprojection(1, 1);
        ɵngcc0.ɵɵprojection(2, 2);
        ɵngcc0.ɵɵtemplate(3, NbAccordionItemHeaderComponent_nb_icon_3_Template, 1, 1, "nb-icon", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.disabled);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{display:flex;align-items:center;cursor:pointer}[_nghost-%COMP%]:focus{outline:0}"], data: { animation: [
            trigger('expansionIndicator', [
                state('expanded', style({
                    transform: 'rotate(180deg)'
                })),
                transition('collapsed => expanded', animate('100ms ease-in')),
                transition('expanded => collapsed', animate('100ms ease-out')),
            ]),
        ] }, changeDetection: 0 });
__decorate$112([
    HostBinding('class.accordion-item-header-collapsed'),
    __metadata$75("design:type", Boolean),
    __metadata$75("design:paramtypes", [])
], NbAccordionItemHeaderComponent.prototype, "isCollapsed", null);
__decorate$112([
    HostBinding('class.accordion-item-header-expanded'),
    HostBinding('attr.aria-expanded'),
    __metadata$75("design:type", Boolean),
    __metadata$75("design:paramtypes", [])
], NbAccordionItemHeaderComponent.prototype, "expanded", null);
__decorate$112([
    HostBinding('attr.tabindex'),
    __metadata$75("design:type", String),
    __metadata$75("design:paramtypes", [])
], NbAccordionItemHeaderComponent.prototype, "tabbable", null);
__decorate$112([
    HostBinding('attr.aria-disabled'),
    __metadata$75("design:type", Boolean),
    __metadata$75("design:paramtypes", [])
], NbAccordionItemHeaderComponent.prototype, "disabled", null);
__decorate$112([
    HostListener('click'),
    HostListener('keydown.space'),
    HostListener('keydown.enter'),
    __metadata$75("design:type", Function),
    __metadata$75("design:paramtypes", []),
    __metadata$75("design:returntype", void 0)
], NbAccordionItemHeaderComponent.prototype, "toggle", null);
NbAccordionItemHeaderComponent = __decorate$112([ __param$15(0, Host()),
    __metadata$75("design:paramtypes", [NbAccordionItemComponent, ChangeDetectorRef])
], NbAccordionItemHeaderComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$113 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const NB_ACCORDION_COMPONENTS = [
    NbAccordionComponent,
    NbAccordionItemComponent,
    NbAccordionItemHeaderComponent,
    NbAccordionItemBodyComponent,
];
let NbAccordionModule = class NbAccordionModule {
};
NbAccordionModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbAccordionModule });
NbAccordionModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbAccordionModule_Factory(t) { return new (t || NbAccordionModule)(); }, providers: [], imports: [[CommonModule, NbIconModule]] });

var __decorate$114 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$76 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * List is a container component that wraps `nb-list-item` component.
 *
 * Basic example:
 * @stacked-example(Simple list, list/simple-list-showcase.component)
 *
 * `nb-list-item` accepts arbitrary content, so you can create a list of any components.
 *
 * ### Installation
 *
 * Import `NbListModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbListModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * List of users:
 * @stacked-example(Users list, list/users-list-showcase.component)
 *
 * @styles
 *
 * list-item-divider-color:
 * list-item-divider-style:
 * list-item-divider-width:
 * list-item-padding:
 * list-item-text-color:
 * list-item-font-family:
 * list-item-font-size:
 * list-item-font-weight:
 * list-item-line-height:
 */
let NbListComponent = class NbListComponent {
    /**
     * List is a container component that wraps `nb-list-item` component.
     *
     * Basic example:
     * @stacked-example(Simple list, list/simple-list-showcase.component)
     *
     * `nb-list-item` accepts arbitrary content, so you can create a list of any components.
     *
     * ### Installation
     *
     * Import `NbListModule` to your feature module.
     * ```ts
     * @NgModule({
     *   imports: [
     *     // ...
     *     NbListModule,
     *   ],
     * })
     * export class PageModule { }
     * ```
     * ### Usage
     *
     * List of users:
     * @stacked-example(Users list, list/users-list-showcase.component)
     *
     * @styles
     *
     * list-item-divider-color:
     * list-item-divider-style:
     * list-item-divider-width:
     * list-item-padding:
     * list-item-text-color:
     * list-item-font-family:
     * list-item-font-size:
     * list-item-font-weight:
     * list-item-line-height:
     */
    constructor() {
        /**
         * Role attribute value
         *
         * @type {string}
         */
        this.role = 'list';
    }
};
NbListComponent.ɵfac = function NbListComponent_Factory(t) { return new (t || NbListComponent)(); };
NbListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbListComponent, selectors: [["nb-list"]], hostVars: 1, hostBindings: function NbListComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
    } }, inputs: { role: "role" }, ngContentSelectors: _c37, decls: 1, vars: 0, template: function NbListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c36);
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}"] });
__decorate$114([
    Input(),
    HostBinding('attr.role'),
    __metadata$76("design:type", Object)
], NbListComponent.prototype, "role", void 0);
/**
 * List item component is a grouping component that accepts arbitrary content.
 * It should be direct child of `nb-list` componet.
 */
let NbListItemComponent = class NbListItemComponent {
    /**
     * List item component is a grouping component that accepts arbitrary content.
     * It should be direct child of `nb-list` componet.
     */
    constructor() {
        /**
         * Role attribute value
         *
         * @type {string}
         */
        this.role = 'listitem';
    }
};
NbListItemComponent.ɵfac = function NbListItemComponent_Factory(t) { return new (t || NbListItemComponent)(); };
NbListItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbListItemComponent, selectors: [["nb-list-item"]], hostVars: 1, hostBindings: function NbListItemComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("role", ctx.role);
    } }, inputs: { role: "role" }, ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbListItemComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, styles: ["[_nghost-%COMP%]{display:flex;align-items:center;flex-shrink:0}"] });
__decorate$114([
    Input(),
    HostBinding('attr.role'),
    __metadata$76("design:type", Object)
], NbListItemComponent.prototype, "role", void 0);

var __decorate$116 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$77 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * List pager directive
 *
 * Directive allows you to determine page of currently viewing items.
 *
 */
let NbListPageTrackerDirective = class NbListPageTrackerDirective {
    constructor() {
        this.alive = true;
        /**
         * Page to start counting with.
         */
        this.startPage = 1;
        /**
         * Emits when another page become visible.
         */
        this.pageChange = new EventEmitter();
        this.observer = new IntersectionObserver(entries => this.checkForPageChange(entries), { threshold: 0.5 });
    }
    ngAfterViewInit() {
        if (this.listItems && this.listItems.length) {
            this.observeItems();
        }
        this.listItems.changes
            .pipe(takeWhile(() => this.alive))
            .subscribe(() => this.observeItems());
    }
    ngOnDestroy() {
        this.observer.disconnect && this.observer.disconnect();
    }
    observeItems() {
        this.listItems.forEach(i => this.observer.observe(i.nativeElement));
    }
    checkForPageChange(entries) {
        const mostVisiblePage = this.findMostVisiblePage(entries);
        if (mostVisiblePage && this.currentPage !== mostVisiblePage) {
            this.currentPage = mostVisiblePage;
            this.pageChange.emit(this.currentPage);
        }
    }
    findMostVisiblePage(entries) {
        const intersectionRatioByPage = new Map();
        for (const entry of entries) {
            if (entry.intersectionRatio < 0.5) {
                continue;
            }
            const elementIndex = this.elementIndex(entry.target);
            if (elementIndex === -1) {
                continue;
            }
            const page = this.startPage + Math.floor(elementIndex / this.pageSize);
            let ratio = entry.intersectionRatio;
            if (intersectionRatioByPage.has(page)) {
                ratio += intersectionRatioByPage.get(page);
            }
            intersectionRatioByPage.set(page, ratio);
        }
        let maxRatio = 0;
        let mostVisiblePage;
        intersectionRatioByPage.forEach((ratio, page) => {
            if (ratio > maxRatio) {
                maxRatio = ratio;
                mostVisiblePage = page;
            }
        });
        return mostVisiblePage;
    }
    elementIndex(element) {
        return element.parentElement && element.parentElement.children
            ? Array.from(element.parentElement.children).indexOf(element)
            : -1;
    }
};
NbListPageTrackerDirective.ɵfac = function NbListPageTrackerDirective_Factory(t) { return new (t || NbListPageTrackerDirective)(); };
NbListPageTrackerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbListPageTrackerDirective, selectors: [["", "nbListPageTracker", ""]], contentQueries: function NbListPageTrackerDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbListItemComponent, false, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listItems = _t);
    } }, inputs: { startPage: "startPage", pageSize: "pageSize" }, outputs: { pageChange: "pageChange" } });
__decorate$116([
    Input(),
    __metadata$77("design:type", Number)
], NbListPageTrackerDirective.prototype, "pageSize", void 0);
__decorate$116([
    Input(),
    __metadata$77("design:type", Number)
], NbListPageTrackerDirective.prototype, "startPage", void 0);
__decorate$116([
    Output(),
    __metadata$77("design:type", Object)
], NbListPageTrackerDirective.prototype, "pageChange", void 0);
__decorate$116([
    ContentChildren(NbListItemComponent, { read: ElementRef }),
    __metadata$77("design:type", QueryList)
], NbListPageTrackerDirective.prototype, "listItems", void 0);
NbListPageTrackerDirective = __decorate$116([ __metadata$77("design:paramtypes", [])
], NbListPageTrackerDirective);

var __decorate$117 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$78 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
class NbScrollableContainerDimentions {
}
/**
 * Infinite List Directive
 *
 * ```html
 *  <nb-list nbInfiniteList [threshold]="500" (bottomThreshold)="loadNext()">
 *    <nb-list-item *ngFor="let item of items"></nb-list-item>
 *  </nb-list>
 * ```
 *
 * @stacked-example(Simple infinite list, infinite-list/infinite-list-showcase.component)
 *
 * Directive will notify when list scrolled up or down to a given threshold.
 * By default it listen to scroll of list on which applied, but also can be set to listen to window scroll.
 *
 * @stacked-example(Scroll modes, infinite-list/infinite-list-scroll-modes.component)
 *
 * To improve UX of infinite lists, it's better to keep current page in url,
 * so user able to return to the last viewed page or to share a link to this page.
 * `nbListPageTracker` directive will help you to know, what page user currently viewing.
 * Just put it on a list, set page size and it will calculate page that currently in viewport.
 * You can [open the example](example/infinite-list/infinite-news-list.component)
 * in a new tab to check out this feature.
 *
 * @stacked-example(Infinite list with pager, infinite-list/infinite-news-list.component)
 *
 * @stacked-example(Infinite list with placeholders at the top, infinite-list/infinite-list-placeholders.component)
 *
 */
let NbInfiniteListDirective = class NbInfiniteListDirective {
    constructor(elementRef, scrollService, dimensionsService) {
        this.elementRef = elementRef;
        this.scrollService = scrollService;
        this.dimensionsService = dimensionsService;
        this.alive = true;
        this.windowScroll = false;
        /**
         * Emits when distance between list bottom and current scroll position is less than threshold.
         */
        this.bottomThreshold = new EventEmitter(true);
        /**
         * Emits when distance between list top and current scroll position is less than threshold.
         */
        this.topThreshold = new EventEmitter(true);
    }
    get elementScroll() {
        return !this.windowScroll;
    }
    /**
     * By default component observes list scroll position.
     * If set to `true`, component will observe position of page scroll instead.
     */
    set listenWindowScroll(value) {
        this.windowScroll = convertToBoolProperty(value);
    }
    onElementScroll() {
        if (this.elementScroll) {
            this.checkPosition(this.elementRef.nativeElement);
        }
    }
    ngAfterViewInit() {
        this.scrollService.onScroll()
            .pipe(takeWhile(() => this.alive), filter(() => this.windowScroll), switchMap(() => this.getContainerDimensions()))
            .subscribe(dimentions => this.checkPosition(dimentions));
        this.listItems.changes
            .pipe(takeWhile(() => this.alive), 
        // For some reason, changes are emitted before list item removed from dom,
        // so dimensions will be incorrect.
        // Check every 50ms for a second if dom and query are in sync.
        // Once they synchronized, we can get proper dimensions.
        switchMap(() => interval(50).pipe(takeUntil(timer(1000)), filter(() => this.inSyncWithDom()), take(1))), switchMap(() => this.getContainerDimensions()))
            .subscribe(dimentions => this.checkPosition(dimentions));
        this.getContainerDimensions().subscribe(dimentions => this.checkPosition(dimentions));
    }
    ngOnDestroy() {
        this.alive = false;
    }
    checkPosition({ scrollHeight, scrollTop, clientHeight }) {
        const initialCheck = this.lastScrollPosition == null;
        const manualCheck = this.lastScrollPosition === scrollTop;
        const scrollUp = scrollTop < this.lastScrollPosition;
        const scrollDown = scrollTop > this.lastScrollPosition;
        const distanceToBottom = scrollHeight - scrollTop - clientHeight;
        if ((initialCheck || manualCheck || scrollDown) && distanceToBottom <= this.threshold) {
            this.bottomThreshold.emit();
        }
        if ((initialCheck || scrollUp) && scrollTop <= this.threshold) {
            this.topThreshold.emit();
        }
        this.lastScrollPosition = scrollTop;
    }
    getContainerDimensions() {
        if (this.elementScroll) {
            const { scrollTop, scrollHeight, clientHeight } = this.elementRef.nativeElement;
            return of({ scrollTop, scrollHeight, clientHeight });
        }
        return forkJoin(this.scrollService.getPosition(), this.dimensionsService.getDimensions())
            .pipe(map(([scrollPosition, dimensions]) => ({
            scrollTop: scrollPosition.y,
            scrollHeight: dimensions.scrollHeight,
            clientHeight: dimensions.clientHeight,
        })));
    }
    inSyncWithDom() {
        return this.elementRef.nativeElement.children.length === this.listItems.length;
    }
};
NbInfiniteListDirective.ɵfac = function NbInfiniteListDirective_Factory(t) { return new (t || NbInfiniteListDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbLayoutScrollService), ɵngcc0.ɵɵdirectiveInject(NbLayoutRulerService)); };
NbInfiniteListDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbInfiniteListDirective, selectors: [["", "nbInfiniteList", ""]], contentQueries: function NbInfiniteListDirective_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbListItemComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.listItems = _t);
    } }, hostBindings: function NbInfiniteListDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("scroll", function NbInfiniteListDirective_scroll_HostBindingHandler() { return ctx.onElementScroll(); });
    } }, inputs: { listenWindowScroll: "listenWindowScroll", threshold: "threshold" }, outputs: { bottomThreshold: "bottomThreshold", topThreshold: "topThreshold" } });
__decorate$117([
    Input(),
    __metadata$78("design:type", Number)
], NbInfiniteListDirective.prototype, "threshold", void 0);
__decorate$117([
    Input(),
    __metadata$78("design:type", Object),
    __metadata$78("design:paramtypes", [Object])
], NbInfiniteListDirective.prototype, "listenWindowScroll", null);
__decorate$117([
    Output(),
    __metadata$78("design:type", Object)
], NbInfiniteListDirective.prototype, "bottomThreshold", void 0);
__decorate$117([
    Output(),
    __metadata$78("design:type", Object)
], NbInfiniteListDirective.prototype, "topThreshold", void 0);
__decorate$117([
    HostListener('scroll'),
    __metadata$78("design:type", Function),
    __metadata$78("design:paramtypes", []),
    __metadata$78("design:returntype", void 0)
], NbInfiniteListDirective.prototype, "onElementScroll", null);
__decorate$117([
    ContentChildren(NbListItemComponent),
    __metadata$78("design:type", QueryList)
], NbInfiniteListDirective.prototype, "listItems", void 0);
NbInfiniteListDirective = __decorate$117([ __metadata$78("design:paramtypes", [ElementRef,
        NbLayoutScrollService,
        NbLayoutRulerService])
], NbInfiniteListDirective);

var __decorate$115 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const components = [
    NbListComponent,
    NbListItemComponent,
    NbListPageTrackerDirective,
    NbInfiniteListDirective,
];
let NbListModule = class NbListModule {
};
NbListModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbListModule });
NbListModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbListModule_Factory(t) { return new (t || NbListModule)(); } });

var __decorate$118 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbDirectionality = class NbDirectionality extends Directionality {
};
NbDirectionality.ɵfac = function NbDirectionality_Factory(t) { return ɵNbDirectionality_BaseFactory(t || NbDirectionality); };
NbDirectionality.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbDirectionality, factory: NbDirectionality.ɵfac });

var __decorate$119 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbBidiModule = class NbBidiModule extends BidiModule {
};
NbBidiModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbBidiModule });
NbBidiModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbBidiModule_Factory(t) { return ɵNbBidiModule_BaseFactory(t || NbBidiModule); }, providers: [
        { provide: NbDirectionality, useExisting: Directionality },
    ] });

class NbPlatform$1 extends Platform {
}

var __decorate$120 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbPlatformModule = class NbPlatformModule extends PlatformModule {
};
NbPlatformModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbPlatformModule });
NbPlatformModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbPlatformModule_Factory(t) { return ɵNbPlatformModule_BaseFactory(t || NbPlatformModule); }, providers: [
        { provide: NbPlatform$1, useExisting: Platform },
    ] });

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license infornbion.
 */
var __decorate$121 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$79 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NbCellDefDirective_1;
var NbHeaderCellDefDirective_1;
var NbFooterCellDefDirective_1;
var NbColumnDefDirective_1;
/**
 * Cell definition for the nb-table.
 * Captures the template of a column's data row cell as well as cell-specific properties.
 */
let NbCellDefDirective = NbCellDefDirective_1 = class NbCellDefDirective extends CdkCellDef {
};
NbCellDefDirective.ɵfac = function NbCellDefDirective_Factory(t) { return ɵNbCellDefDirective_BaseFactory(t || NbCellDefDirective); };
NbCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbCellDefDirective, selectors: [["", "nbCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkCellDef, useExisting: NbCellDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * Header cell definition for the nb-table.
 * Captures the template of a column's header cell and as well as cell-specific properties.
 */
let NbHeaderCellDefDirective = NbHeaderCellDefDirective_1 = class NbHeaderCellDefDirective extends CdkHeaderCellDef {
};
NbHeaderCellDefDirective.ɵfac = function NbHeaderCellDefDirective_Factory(t) { return ɵNbHeaderCellDefDirective_BaseFactory(t || NbHeaderCellDefDirective); };
NbHeaderCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbHeaderCellDefDirective, selectors: [["", "nbHeaderCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkHeaderCellDef, useExisting: NbHeaderCellDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * Footer cell definition for the nb-table.
 * Captures the template of a column's footer cell and as well as cell-specific properties.
 */
let NbFooterCellDefDirective = NbFooterCellDefDirective_1 = class NbFooterCellDefDirective extends CdkFooterCellDef {
};
NbFooterCellDefDirective.ɵfac = function NbFooterCellDefDirective_Factory(t) { return ɵNbFooterCellDefDirective_BaseFactory(t || NbFooterCellDefDirective); };
NbFooterCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFooterCellDefDirective, selectors: [["", "nbFooterCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkFooterCellDef, useExisting: NbFooterCellDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
const NB_SORT_HEADER_COLUMN_DEF = new InjectionToken('NB_SORT_HEADER_COLUMN_DEF');
/**
 * Column definition for the nb-table.
 * Defines a set of cells available for a table column.
 */
let NbColumnDefDirective = NbColumnDefDirective_1 = class NbColumnDefDirective extends CdkColumnDef {
};
NbColumnDefDirective.ɵfac = function NbColumnDefDirective_Factory(t) { return ɵNbColumnDefDirective_BaseFactory(t || NbColumnDefDirective); };
NbColumnDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbColumnDefDirective, selectors: [["", "nbColumnDef", ""]], inputs: { name: ["nbColumnDef", "name"], sticky: "sticky", stickyEnd: "stickyEnd" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: CdkColumnDef, useExisting: NbColumnDefDirective_1 },
            { provide: NB_SORT_HEADER_COLUMN_DEF, useExisting: NbColumnDefDirective_1 },
        ]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate$121([
    Input('nbColumnDef'),
    __metadata$79("design:type", String)
], NbColumnDefDirective.prototype, "name", void 0);
__decorate$121([
    Input(),
    __metadata$79("design:type", Boolean)
], NbColumnDefDirective.prototype, "sticky", void 0);
__decorate$121([
    Input(),
    __metadata$79("design:type", Boolean)
], NbColumnDefDirective.prototype, "stickyEnd", void 0);
/** Header cell template container that adds the right classes and role. */
let NbHeaderCellDirective = class NbHeaderCellDirective extends CdkHeaderCell {
    constructor(columnDef, elementRef) {
        super(columnDef, elementRef);
        elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
    }
};
NbHeaderCellDirective.ɵfac = function NbHeaderCellDirective_Factory(t) { return new (t || NbHeaderCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbHeaderCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbHeaderCellDirective, selectors: [["nb-header-cell"], ["th", "nbHeaderCell", ""]], hostAttrs: ["role", "columnheader", 1, "nb-header-cell"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NbHeaderCellDirective = __decorate$121([ __metadata$79("design:paramtypes", [NbColumnDefDirective,
        ElementRef])
], NbHeaderCellDirective);
/** Footer cell template container that adds the right classes and role. */
let NbFooterCellDirective = class NbFooterCellDirective extends CdkFooterCell {
    constructor(columnDef, elementRef) {
        super(columnDef, elementRef);
        elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
    }
};
NbFooterCellDirective.ɵfac = function NbFooterCellDirective_Factory(t) { return new (t || NbFooterCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbFooterCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFooterCellDirective, selectors: [["nb-footer-cell"], ["td", "nbFooterCell", ""]], hostAttrs: ["role", "gridcell", 1, "nb-footer-cell"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NbFooterCellDirective = __decorate$121([ __metadata$79("design:paramtypes", [NbColumnDefDirective,
        ElementRef])
], NbFooterCellDirective);
/** Cell template container that adds the right classes and role. */
let NbCellDirective = class NbCellDirective extends CdkCell {
    constructor(columnDef, elementRef) {
        super(columnDef, elementRef);
        elementRef.nativeElement.classList.add(`nb-column-${columnDef.cssClassFriendlyName}`);
    }
};
NbCellDirective.ɵfac = function NbCellDirective_Factory(t) { return new (t || NbCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbCellDirective, selectors: [["nb-cell"], ["td", "nbCell", ""]], hostAttrs: ["role", "gridcell", 1, "nb-cell"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
NbCellDirective = __decorate$121([ __metadata$79("design:paramtypes", [NbColumnDefDirective,
        ElementRef])
], NbCellDirective);

class NbDataSource extends DataSource {
}

var __decorate$122 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$80 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NbDataRowOutletDirective_1;
var NbHeaderRowOutletDirective_1;
var NbFooterRowOutletDirective_1;
var NbCellOutletDirective_1;
var NbHeaderRowDefDirective_1;
var NbFooterRowDefDirective_1;
var NbRowDefDirective_1;
var NbHeaderRowComponent_1;
var NbFooterRowComponent_1;
var NbRowComponent_1;
let NbDataRowOutletDirective = NbDataRowOutletDirective_1 = class NbDataRowOutletDirective extends DataRowOutlet {
};
NbDataRowOutletDirective.ɵfac = function NbDataRowOutletDirective_Factory(t) { return ɵNbDataRowOutletDirective_BaseFactory(t || NbDataRowOutletDirective); };
NbDataRowOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbDataRowOutletDirective, selectors: [["", "nbRowOutlet", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: DataRowOutlet, useExisting: NbDataRowOutletDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
let NbHeaderRowOutletDirective = NbHeaderRowOutletDirective_1 = class NbHeaderRowOutletDirective extends HeaderRowOutlet {
};
NbHeaderRowOutletDirective.ɵfac = function NbHeaderRowOutletDirective_Factory(t) { return ɵNbHeaderRowOutletDirective_BaseFactory(t || NbHeaderRowOutletDirective); };
NbHeaderRowOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbHeaderRowOutletDirective, selectors: [["", "nbHeaderRowOutlet", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: HeaderRowOutlet, useExisting: NbHeaderRowOutletDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
let NbFooterRowOutletDirective = NbFooterRowOutletDirective_1 = class NbFooterRowOutletDirective extends FooterRowOutlet {
};
NbFooterRowOutletDirective.ɵfac = function NbFooterRowOutletDirective_Factory(t) { return ɵNbFooterRowOutletDirective_BaseFactory(t || NbFooterRowOutletDirective); };
NbFooterRowOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFooterRowOutletDirective, selectors: [["", "nbFooterRowOutlet", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: FooterRowOutlet, useExisting: NbFooterRowOutletDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
let NbCellOutletDirective = NbCellOutletDirective_1 = class NbCellOutletDirective extends CdkCellOutlet {
};
NbCellOutletDirective.ɵfac = function NbCellOutletDirective_Factory(t) { return ɵNbCellOutletDirective_BaseFactory(t || NbCellOutletDirective); };
NbCellOutletDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbCellOutletDirective, selectors: [["", "nbCellOutlet", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkCellOutlet, useExisting: NbCellOutletDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * Header row definition for the nb-table.
 * Captures the header row's template and other header properties such as the columns to display.
 */
let NbHeaderRowDefDirective = NbHeaderRowDefDirective_1 = class NbHeaderRowDefDirective extends CdkHeaderRowDef {
};
NbHeaderRowDefDirective.ɵfac = function NbHeaderRowDefDirective_Factory(t) { return ɵNbHeaderRowDefDirective_BaseFactory(t || NbHeaderRowDefDirective); };
NbHeaderRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbHeaderRowDefDirective, selectors: [["", "nbHeaderRowDef", ""]], inputs: { columns: ["nbHeaderRowDef", "columns"], sticky: ["nbHeaderRowDefSticky", "sticky"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkHeaderRowDef, useExisting: NbHeaderRowDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate$122([
    Input('nbHeaderRowDef'),
    __metadata$80("design:type", Object)
], NbHeaderRowDefDirective.prototype, "columns", void 0);
__decorate$122([
    Input('nbHeaderRowDefSticky'),
    __metadata$80("design:type", Boolean)
], NbHeaderRowDefDirective.prototype, "sticky", void 0);
/**
 * Footer row definition for the nb-table.
 * Captures the footer row's template and other footer properties such as the columns to display.
 */
let NbFooterRowDefDirective = NbFooterRowDefDirective_1 = class NbFooterRowDefDirective extends CdkFooterRowDef {
};
NbFooterRowDefDirective.ɵfac = function NbFooterRowDefDirective_Factory(t) { return ɵNbFooterRowDefDirective_BaseFactory(t || NbFooterRowDefDirective); };
NbFooterRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFooterRowDefDirective, selectors: [["", "nbFooterRowDef", ""]], inputs: { columns: ["nbFooterRowDef", "columns"], sticky: ["nbFooterRowDefSticky", "sticky"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkFooterRowDef, useExisting: NbFooterRowDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate$122([
    Input('nbFooterRowDef'),
    __metadata$80("design:type", Object)
], NbFooterRowDefDirective.prototype, "columns", void 0);
__decorate$122([
    Input('nbFooterRowDefSticky'),
    __metadata$80("design:type", Boolean)
], NbFooterRowDefDirective.prototype, "sticky", void 0);
/**
 * Data row definition for the nb-table.
 * Captures the data row's template and other properties such as the columns to display and
 * a when predicate that describes when this row should be used.
 */
let NbRowDefDirective = NbRowDefDirective_1 = class NbRowDefDirective extends CdkRowDef {
};
NbRowDefDirective.ɵfac = function NbRowDefDirective_Factory(t) { return ɵNbRowDefDirective_BaseFactory(t || NbRowDefDirective); };
NbRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbRowDefDirective, selectors: [["", "nbRowDef", ""]], inputs: { columns: ["nbRowDefColumns", "columns"], when: ["nbRowDefWhen", "when"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkRowDef, useExisting: NbRowDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate$122([
    Input('nbRowDefColumns'),
    __metadata$80("design:type", Object)
], NbRowDefDirective.prototype, "columns", void 0);
__decorate$122([
    Input('nbRowDefWhen'),
    __metadata$80("design:type", Function)
], NbRowDefDirective.prototype, "when", void 0);
/** Footer template container that contains the cell outlet. Adds the right class and role. */
let NbHeaderRowComponent = NbHeaderRowComponent_1 = class NbHeaderRowComponent extends CdkHeaderRow {
};
NbHeaderRowComponent.ɵfac = function NbHeaderRowComponent_Factory(t) { return ɵNbHeaderRowComponent_BaseFactory(t || NbHeaderRowComponent); };
NbHeaderRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbHeaderRowComponent, selectors: [["nb-header-row"], ["tr", "nbHeaderRow", ""]], hostAttrs: ["role", "row", 1, "nb-header-row"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkHeaderRow, useExisting: NbHeaderRowComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbHeaderRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2, changeDetection: 0 });
/** Footer template container that contains the cell outlet. Adds the right class and role. */
let NbFooterRowComponent = NbFooterRowComponent_1 = class NbFooterRowComponent extends CdkFooterRow {
};
NbFooterRowComponent.ɵfac = function NbFooterRowComponent_Factory(t) { return ɵNbFooterRowComponent_BaseFactory(t || NbFooterRowComponent); };
NbFooterRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbFooterRowComponent, selectors: [["nb-footer-row"], ["tr", "nbFooterRow", ""]], hostAttrs: ["role", "row", 1, "nb-footer-row"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkFooterRow, useExisting: NbFooterRowComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbFooterRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2, changeDetection: 0 });
/** Data row template container that contains the cell outlet. Adds the right class and role. */
let NbRowComponent = NbRowComponent_1 = class NbRowComponent extends CdkRow {
};
NbRowComponent.ɵfac = function NbRowComponent_Factory(t) { return ɵNbRowComponent_BaseFactory(t || NbRowComponent); };
NbRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRowComponent, selectors: [["nb-row"], ["tr", "nbRow", ""]], hostAttrs: ["role", "row", 1, "nb-row"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: CdkRow, useExisting: NbRowComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2, changeDetection: 0 });

var __decorate$123 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$81 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$16 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
const NB_TABLE_TEMPLATE = `
  <ng-container nbHeaderRowOutlet></ng-container>
  <ng-container nbRowOutlet></ng-container>
  <ng-container nbFooterRowOutlet></ng-container>`;
let NbTable = class NbTable extends CdkTable {
    constructor(differs, changeDetectorRef, elementRef, role, dir, document, platform) {
        super(differs, changeDetectorRef, elementRef, role, dir, document, platform);
    }
};
NbTable.ɵfac = function NbTable_Factory(t) { return new (t || NbTable)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(NbDirectionality), ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NbPlatform$1)); };
NbTable.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTable, selectors: [["cdk-table"], ["table", "cdk-table", ""]], exportAs: ["cdkTable"], features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵCopyDefinitionFeature], decls: 0, vars: 0, template: function NbTable_Template(rf, ctx) { }, encapsulation: 2 });
NbTable = __decorate$123([
    __param$16(3, Attribute('role')),
    __param$16(5, Inject(NB_DOCUMENT)),
    __metadata$81("design:paramtypes", [IterableDiffers,
        ChangeDetectorRef,
        ElementRef, String, NbDirectionality, Object, NbPlatform$1])
], NbTable);
const COMPONENTS$1 = [
    NbTable,
    // Template defs
    NbHeaderCellDefDirective,
    NbHeaderRowDefDirective,
    NbColumnDefDirective,
    NbCellDefDirective,
    NbRowDefDirective,
    NbFooterCellDefDirective,
    NbFooterRowDefDirective,
    // Outlets
    NbDataRowOutletDirective,
    NbHeaderRowOutletDirective,
    NbFooterRowOutletDirective,
    NbCellOutletDirective,
    // Cell directives
    NbHeaderCellDirective,
    NbCellDirective,
    NbFooterCellDirective,
    // Row directives
    NbHeaderRowComponent,
    NbRowComponent,
    NbFooterRowComponent,
];
let NbTableModule = class NbTableModule extends CdkTableModule {
};
NbTableModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbTableModule });
NbTableModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbTableModule_Factory(t) { return ɵNbTableModule_BaseFactory(t || NbTableModule); }, imports: [[NbBidiModule, NbPlatformModule]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_DIALOG_CONFIG = new InjectionToken('Default dialog options');
/**
 * Describes all available options that may be passed to the NbDialogService.
 * */
class NbDialogConfig {
    constructor(config) {
        /**
         * If true than overlay will render backdrop under a dialog.
         * */
        this.hasBackdrop = true;
        /**
         * Class that'll be assigned to the backdrop element.
         * */
        this.backdropClass = 'overlay-backdrop';
        /**
         * Class that'll be assigned to the dialog overlay.
         * */
        this.dialogClass = '';
        /**
         * If true then mouse clicks by backdrop will close a dialog.
         * */
        this.closeOnBackdropClick = true;
        /**
         * If true then escape press will close a dialog.
         * */
        this.closeOnEsc = true;
        /**
         * Disables scroll on content under dialog if true and does nothing otherwise.
         * */
        this.hasScroll = false;
        /**
         * Focuses dialog automatically after open if true.
         * */
        this.autoFocus = true;
        Object.assign(this, config);
    }
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
/**
 * The `NbDialogRef` helps to manipulate dialog after it was created.
 * The dialog can be dismissed by using `close` method of the dialogRef.
 * You can access rendered component as `content` property of the dialogRef.
 * `onBackdropClick` streams click events on the backdrop of the dialog.
 * */
class NbDialogRef {
    constructor(overlayRef) {
        this.overlayRef = overlayRef;
        this.onClose$ = new Subject();
        this.onClose = this.onClose$.asObservable();
        this.onBackdropClick = this.overlayRef.backdropClick();
    }
    /**
     * Hides dialog.
     * */
    close(res) {
        this.overlayRef.detach();
        this.overlayRef.dispose();
        this.onClose$.next(res);
        this.onClose$.complete();
    }
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$125 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$83 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Container component for each dialog.
 * All the dialogs will be attached to it.
 * // TODO add animations
 * */
let NbDialogContainerComponent = class NbDialogContainerComponent {
    constructor(config, elementRef, focusTrapFactory) {
        this.config = config;
        this.elementRef = elementRef;
        this.focusTrapFactory = focusTrapFactory;
    }
    ngOnInit() {
        if (this.config.autoFocus) {
            this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
            this.focusTrap.blurPreviouslyFocusedElement();
            this.focusTrap.focusInitialElement();
        }
    }
    ngOnDestroy() {
        if (this.config.autoFocus && this.focusTrap) {
            this.focusTrap.restoreFocus();
        }
    }
    attachComponentPortal(portal) {
        return this.portalOutlet.attachComponentPortal(portal);
    }
    attachTemplatePortal(portal) {
        return this.portalOutlet.attachTemplatePortal(portal);
    }
};
NbDialogContainerComponent.ɵfac = function NbDialogContainerComponent_Factory(t) { return new (t || NbDialogContainerComponent)(ɵngcc0.ɵɵdirectiveInject(NbDialogConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbFocusTrapFactoryService)); };
NbDialogContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbDialogContainerComponent, selectors: [["nb-dialog-container"]], viewQuery: function NbDialogContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(NbPortalOutletDirective, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portalOutlet = _t.first);
    } }, decls: 1, vars: 0, consts: [["nbPortalOutlet", ""]], template: function NbDialogContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbDialogContainerComponent_ng_template_0_Template, 0, 0, "ng-template", 0);
    } }, directives: [NbPortalOutletDirective], encapsulation: 2 });
__decorate$125([
    ViewChild(NbPortalOutletDirective, { static: true }),
    __metadata$83("design:type", NbPortalOutletDirective)
], NbDialogContainerComponent.prototype, "portalOutlet", void 0);
NbDialogContainerComponent = __decorate$125([ __metadata$83("design:paramtypes", [NbDialogConfig,
        ElementRef,
        NbFocusTrapFactoryService])
], NbDialogContainerComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$124 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$82 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$17 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * The `NbDialogService` helps to open dialogs.
 *
 * @stacked-example(Showcase, dialog/dialog-showcase.component)
 *
 * A new dialog is opened by calling the `open` method with a component to be loaded and an optional configuration.
 * `open` method will return `NbDialogRef` that can be used for the further manipulations.
 *
 * ### Installation
 *
 * Import `NbDialogModule.forRoot()` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDialogModule.forRoot(config),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * If you are using it in a lazy loaded module than you have to install it with `NbDialogModule.forChild()`:
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDialogModule.forChild(config),
 *   ],
 * })
 * export class LazyLoadedModule { }
 * ```
 *
 * ### Usage
 *
 * ```ts
 * const dialogRef = this.dialogService.open(MyDialogComponent, { ... });
 * ```
 *
 * `NbDialogRef` gives capability access reference to the rendered dialog component,
 * destroy dialog and some other options described below.
 *
 * Also, you can inject `NbDialogRef` in dialog component.
 *
 * ```ts
 * this.dialogService.open(MyDialogComponent, { ... });
 *
 * // my-dialog.component.ts
 * constructor(protected dialogRef: NbDialogRef) {
 * }
 *
 * close() {
 *   this.dialogRef.close();
 * }
 * ```
 *
 * Instead of component you can create dialog from TemplateRef:
 *
 * @stacked-example(Template ref, dialog/dialog-template.component)
 *
 * The dialog may return result through `NbDialogRef`. Calling component can receive this result with `onClose`
 * stream of `NbDialogRef`.
 *
 * @stacked-example(Result, dialog/dialog-result.component)
 *
 * ### Configuration
 *
 * As we mentioned above, `open` method of the `NbDialogService` may receive optional configuration options.
 * Also, you can provide global dialogs configuration through `NbDialogModule.forRoot({ ... })`.
 *
 * This config may contain the following:
 *
 * `context` - both, template and component may receive data through `config.context` property.
 * For components, this data will be assigned through inputs.
 * For templates, you can access it inside template as $implicit.
 *
 * ```ts
 * this.dialogService.open(template, { context: 'pass data in template' });
 * ```
 *
 * ```html
 * <ng-template let-some-additional-data>
 *   {{ some-additional-data }}
 * <ng-template/>
 * ```
 *
 * `hasBackdrop` - determines is service have to render backdrop under the dialog.
 * Default is true.
 * @stacked-example(Backdrop, dialog/dialog-has-backdrop.component)
 *
 * `closeOnBackdropClick` - close dialog on backdrop click if true.
 * Default is true.
 * @stacked-example(Backdrop click, dialog/dialog-backdrop-click.component)
 *
 * `closeOnEsc` - close dialog on escape button on the keyboard.
 * Default is true.
 * @stacked-example(Escape hit, dialog/dialog-esc.component)
 *
 * `hasScroll` - Disables scroll on content under dialog if true and does nothing otherwise.
 * Default is false.
 * Please, open dialogs in the separate window and try to scroll.
 * @stacked-example(Scroll, dialog/dialog-scroll.component)
 *
 * `autoFocus` - Focuses dialog automatically after open if true. It's useful to prevent misclicks on
 * trigger elements and opening multiple dialogs.
 * Default is true.
 *
 * As you can see, if you open dialog with auto focus dialog will focus first focusable element
 * or just blur previously focused automatically.
 * Otherwise, without auto focus, the focus will stay on the previously focused element.
 * Please, open dialogs in the separate window and try to click on the button without focus
 * and then hit space any times. Multiple same dialogs will be opened.
 * @stacked-example(Auto focus, dialog/dialog-auto-focus.component)
 * */
let NbDialogService = class NbDialogService {
    constructor(document, globalConfig, positionBuilder, overlay, injector, cfr) {
        this.document = document;
        this.globalConfig = globalConfig;
        this.positionBuilder = positionBuilder;
        this.overlay = overlay;
        this.injector = injector;
        this.cfr = cfr;
    }
    /**
     * Opens new instance of the dialog, may receive optional config.
     * */
    open(content, userConfig = {}) {
        const config = new NbDialogConfig(Object.assign({}, this.globalConfig, userConfig));
        const overlayRef = this.createOverlay(config);
        const dialogRef = new NbDialogRef(overlayRef);
        const container = this.createContainer(config, overlayRef);
        this.createContent(config, content, container, dialogRef);
        this.registerCloseListeners(config, overlayRef, dialogRef);
        return dialogRef;
    }
    createOverlay(config) {
        const positionStrategy = this.createPositionStrategy();
        const scrollStrategy = this.createScrollStrategy(config.hasScroll);
        return this.overlay.create({
            positionStrategy,
            scrollStrategy,
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass,
            panelClass: config.dialogClass,
        });
    }
    createPositionStrategy() {
        return this.positionBuilder
            .global()
            .centerVertically()
            .centerHorizontally();
    }
    createScrollStrategy(hasScroll) {
        if (hasScroll) {
            return this.overlay.scrollStrategies.noop();
        }
        else {
            return this.overlay.scrollStrategies.block();
        }
    }
    createContainer(config, overlayRef) {
        const injector = new NbPortalInjector(this.createInjector(config), new WeakMap([[NbDialogConfig, config]]));
        const containerPortal = new NbComponentPortal(NbDialogContainerComponent, null, injector, this.cfr);
        const containerRef = overlayRef.attach(containerPortal);
        return containerRef.instance;
    }
    createContent(config, content, container, dialogRef) {
        if (content instanceof TemplateRef) {
            const portal = this.createTemplatePortal(config, content, dialogRef);
            container.attachTemplatePortal(portal);
        }
        else {
            const portal = this.createComponentPortal(config, content, dialogRef);
            dialogRef.componentRef = container.attachComponentPortal(portal);
            if (config.context) {
                Object.assign(dialogRef.componentRef.instance, Object.assign({}, config.context));
            }
        }
    }
    createTemplatePortal(config, content, dialogRef) {
        return new NbTemplatePortal(content, null, { $implicit: config.context, dialogRef });
    }
    /**
     * We're creating portal with custom injector provided through config or using global injector.
     * This approach provides us capability inject `NbDialogRef` in dialog component.
     * */
    createComponentPortal(config, content, dialogRef) {
        const injector = this.createInjector(config);
        const portalInjector = new NbPortalInjector(injector, new WeakMap([[NbDialogRef, dialogRef]]));
        return new NbComponentPortal(content, config.viewContainerRef, portalInjector);
    }
    createInjector(config) {
        return config.viewContainerRef && config.viewContainerRef.injector || this.injector;
    }
    registerCloseListeners(config, overlayRef, dialogRef) {
        if (config.closeOnBackdropClick) {
            overlayRef.backdropClick().subscribe(() => dialogRef.close());
        }
        if (config.closeOnEsc) {
            fromEvent(this.document, 'keyup')
                .pipe(filter((event) => event.keyCode === 27), takeUntil(dialogRef.onClose))
                .subscribe(() => dialogRef.close());
        }
    }
};
NbDialogService.ɵfac = function NbDialogService_Factory(t) { return new (t || NbDialogService)(ɵngcc0.ɵɵinject(NB_DOCUMENT), ɵngcc0.ɵɵinject(NB_DIALOG_CONFIG), ɵngcc0.ɵɵinject(NbPositionBuilderService), ɵngcc0.ɵɵinject(NbOverlayService), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver)); };
NbDialogService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbDialogService, factory: NbDialogService.ɵfac });
NbDialogService = __decorate$124([ __param$17(0, Inject(NB_DOCUMENT)),
    __param$17(1, Inject(NB_DIALOG_CONFIG)),
    __metadata$82("design:paramtypes", [Object, Object, NbPositionBuilderService,
        NbOverlayService,
        Injector,
        ComponentFactoryResolver])
], NbDialogService);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$126 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbDialogModule_1;
let NbDialogModule = NbDialogModule_1 = class NbDialogModule {
    static forRoot(dialogConfig = {}) {
        return {
            ngModule: NbDialogModule_1,
            providers: [
                NbDialogService,
                { provide: NB_DIALOG_CONFIG, useValue: dialogConfig },
            ],
        };
    }
    static forChild(dialogConfig = {}) {
        return {
            ngModule: NbDialogModule_1,
            providers: [
                NbDialogService,
                { provide: NB_DIALOG_CONFIG, useValue: dialogConfig },
            ],
        };
    }
};
NbDialogModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbDialogModule });
NbDialogModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbDialogModule_Factory(t) { return new (t || NbDialogModule)(); }, imports: [[NbSharedModule, NbOverlayModule]] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
class NbToast {
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$130 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$86 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * The `NbToastComponent` is responsible for rendering each toast with appropriate styles.
 *
 * @styles
 *
 * toastr-border-style:
 * toastr-border-width:
 * toastr-border-radius:
 * toastr-padding:
 * toastr-shadow:
 * toastr-text-font-family:
 * toastr-text-font-size:
 * toastr-text-font-weight:
 * toastr-text-line-height:
 * toastr-title-text-font-family:
 * toastr-title-text-font-size:
 * toastr-title-text-font-weight:
 * toastr-title-text-line-height:
 * toastr-basic-background-color:
 * toastr-basic-border-color:
 * toastr-basic-text-color:
 * toastr-icon-basic-background-color:
 * toastr-icon-basic-color:
 * toastr-destroyable-hover-basic-background-color:
 * toastr-destroyable-hover-basic-border-color:
 * toastr-primary-background-color:
 * toastr-primary-border-color:
 * toastr-primary-text-color:
 * toastr-icon-primary-background-color:
 * toastr-icon-primary-color:
 * toastr-destroyable-hover-primary-background-color:
 * toastr-destroyable-hover-primary-border-color:
 * toastr-success-background-color:
 * toastr-success-border-color:
 * toastr-success-text-color:
 * toastr-icon-success-background-color:
 * toastr-icon-success-color:
 * toastr-destroyable-hover-success-background-color:
 * toastr-destroyable-hover-success-border-color:
 * toastr-info-background-color:
 * toastr-info-border-color:
 * toastr-info-text-color:
 * toastr-icon-info-background-color:
 * toastr-icon-info-color:
 * toastr-destroyable-hover-info-background-color:
 * toastr-destroyable-hover-info-border-color:
 * toastr-warning-background-color:
 * toastr-warning-border-color:
 * toastr-warning-text-color:
 * toastr-icon-warning-background-color:
 * toastr-icon-warning-color:
 * toastr-destroyable-hover-warning-background-color:
 * toastr-destroyable-hover-warning-border-color:
 * toastr-danger-background-color:
 * toastr-danger-border-color:
 * toastr-danger-text-color:
 * toastr-icon-danger-background-color:
 * toastr-icon-danger-color:
 * toastr-destroyable-hover-danger-background-color:
 * toastr-destroyable-hover-danger-border-color:
 * toastr-control-background-color:
 * toastr-control-border-color:
 * toastr-control-text-color:
 * toastr-icon-control-background-color:
 * toastr-icon-control-color:
 * toastr-destroyable-hover-control-background-color:
 * toastr-destroyable-hover-control-border-color:
 * */
let NbToastComponent = class NbToastComponent {
    constructor(renderer, elementRef) {
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.destroy = new EventEmitter();
    }
    get success() {
        return this.toast.config.status === 'success';
    }
    get info() {
        return this.toast.config.status === 'info';
    }
    get warning() {
        return this.toast.config.status === 'warning';
    }
    get primary() {
        return this.toast.config.status === 'primary';
    }
    get danger() {
        return this.toast.config.status === 'danger';
    }
    get basic() {
        return this.toast.config.status === 'basic';
    }
    get control() {
        return this.toast.config.status === 'control';
    }
    get destroyByClick() {
        return this.toast.config.destroyByClick;
    }
    get hasIcon() {
        const { icon } = this.toast.config;
        if (typeof icon === 'string') {
            return true;
        }
        return !!(icon && icon.icon);
    }
    get customIcon() {
        return !!this.icon;
    }
    get icon() {
        return this.toast.config.icon;
    }
    /* @deprecated Use pack property of icon config */
    get iconPack() {
        return this.toast.config.iconPack;
    }
    /*
      @breaking-change 5 remove
      @deprecated
    */
    get iconConfig() {
        const toastConfig = this.toast.config;
        const isIconName = typeof this.icon === 'string';
        if (!isIconName) {
            return toastConfig.icon;
        }
        const iconConfig = { icon: toastConfig.icon };
        if (toastConfig.iconPack) {
            iconConfig.pack = toastConfig.iconPack;
        }
        return iconConfig;
    }
    onClick() {
        this.destroy.emit();
    }
    ngOnInit() {
        if (this.toast.config.toastClass) {
            this.renderer.addClass(this.elementRef.nativeElement, this.toast.config.toastClass);
        }
    }
};
NbToastComponent.ɵfac = function NbToastComponent_Factory(t) { return new (t || NbToastComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbToastComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbToastComponent, selectors: [["nb-toast"]], hostVars: 20, hostBindings: function NbToastComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbToastComponent_click_HostBindingHandler() { return ctx.onClick(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("status-success", ctx.success)("status-info", ctx.info)("status-warning", ctx.warning)("status-primary", ctx.primary)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("destroy-by-click", ctx.destroyByClick)("has-icon", ctx.hasIcon)("custom-icon", ctx.customIcon);
    } }, inputs: { toast: "toast" }, outputs: { destroy: "destroy" }, decls: 6, vars: 3, consts: [["class", "icon-container", 4, "ngIf"], [1, "content-container"], [1, "title", "subtitle"], [1, "message"], [1, "icon-container"], [3, "config"]], template: function NbToastComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbToastComponent_div_0_Template, 2, 1, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "span", 2);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 3);
        ɵngcc0.ɵɵtext(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.hasIcon && ctx.icon);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.toast.title);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.toast.message);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{display:flex;align-items:center;width:25rem;margin:0.5rem}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{margin-right:0.25rem}.default[_nghost-%COMP%]   .content-container[_ngcontent-%COMP%], [_nghost-%COMP%]:not(.has-icon)   .content-container[_ngcontent-%COMP%]{display:flex;flex-direction:row}.destroy-by-click[_nghost-%COMP%]{cursor:pointer}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{font-size:2.5rem}[_nghost-%COMP%]   svg[_ngcontent-%COMP%]{width:2.5rem;height:2.5rem}"] });
__decorate$130([
    Input(),
    __metadata$86("design:type", NbToast)
], NbToastComponent.prototype, "toast", void 0);
__decorate$130([
    Output(),
    __metadata$86("design:type", EventEmitter)
], NbToastComponent.prototype, "destroy", void 0);
__decorate$130([
    HostBinding('class.status-success'),
    __metadata$86("design:type", Boolean),
    __metadata$86("design:paramtypes", [])
], NbToastComponent.prototype, "success", null);
__decorate$130([
    HostBinding('class.status-info'),
    __metadata$86("design:type", Boolean),
    __metadata$86("design:paramtypes", [])
], NbToastComponent.prototype, "info", null);
__decorate$130([
    HostBinding('class.status-warning'),
    __metadata$86("design:type", Boolean),
    __metadata$86("design:paramtypes", [])
], NbToastComponent.prototype, "warning", null);
__decorate$130([
    HostBinding('class.status-primary'),
    __metadata$86("design:type", Boolean),
    __metadata$86("design:paramtypes", [])
], NbToastComponent.prototype, "primary", null);
__decorate$130([
    HostBinding('class.status-danger'),
    __metadata$86("design:type", Boolean),
    __metadata$86("design:paramtypes", [])
], NbToastComponent.prototype, "danger", null);
__decorate$130([
    HostBinding('class.status-basic'),
    __metadata$86("design:type", Boolean),
    __metadata$86("design:paramtypes", [])
], NbToastComponent.prototype, "basic", null);
__decorate$130([
    HostBinding('class.status-control'),
    __metadata$86("design:type", Boolean),
    __metadata$86("design:paramtypes", [])
], NbToastComponent.prototype, "control", null);
__decorate$130([
    HostBinding('class.destroy-by-click'),
    __metadata$86("design:type", Boolean),
    __metadata$86("design:paramtypes", [])
], NbToastComponent.prototype, "destroyByClick", null);
__decorate$130([
    HostBinding('class.has-icon'),
    __metadata$86("design:type", Boolean),
    __metadata$86("design:paramtypes", [])
], NbToastComponent.prototype, "hasIcon", null);
__decorate$130([
    HostBinding('class.custom-icon'),
    __metadata$86("design:type", Boolean),
    __metadata$86("design:paramtypes", [])
], NbToastComponent.prototype, "customIcon", null);
__decorate$130([
    HostListener('click'),
    __metadata$86("design:type", Function),
    __metadata$86("design:paramtypes", []),
    __metadata$86("design:returntype", void 0)
], NbToastComponent.prototype, "onClick", null);
NbToastComponent = __decorate$130([ __metadata$86("design:paramtypes", [Renderer2, ElementRef])
], NbToastComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$129 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$85 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
const voidState = style({
    transform: 'translateX({{ direction }}110%)',
    height: 0,
    marginLeft: '0',
    marginRight: '0',
    marginTop: '0',
    marginBottom: '0',
});
const defaultOptions = { params: { direction: '' } };
let NbToastrContainerComponent = class NbToastrContainerComponent {
    constructor(layoutDirection, positionHelper) {
        this.layoutDirection = layoutDirection;
        this.positionHelper = positionHelper;
        this.destroy$ = new Subject();
        this.content = [];
    }
    ngOnInit() {
        this.layoutDirection.onDirectionChange()
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.onDirectionChange());
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    onDirectionChange() {
        const direction = this.positionHelper.isRightPosition(this.position) ? '' : '-';
        this.fadeIn = { value: '', params: { direction } };
    }
};
NbToastrContainerComponent.ɵfac = function NbToastrContainerComponent_Factory(t) { return new (t || NbToastrContainerComponent)(ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService), ɵngcc0.ɵɵdirectiveInject(NbPositionHelper)); };
NbToastrContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbToastrContainerComponent, selectors: [["nb-toastr-container"]], viewQuery: function NbToastrContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbToastComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.toasts = _t);
    } }, inputs: { content: "content", context: "context", position: "position" }, decls: 1, vars: 1, consts: [[3, "toast", 4, "ngFor", "ngForOf"], [3, "toast"]], template: function NbToastrContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbToastrContainerComponent_nb_toast_0_Template, 1, 2, "nb-toast", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.content);
    } }, directives: [ɵngcc2.NgForOf, NbToastComponent], encapsulation: 2, data: { animation: [
            trigger('fadeIn', [
                transition(':enter', [voidState, animate(100)], defaultOptions),
                transition(':leave', [animate(100, voidState)], defaultOptions),
            ]),
        ] } });
__decorate$129([
    Input(),
    __metadata$85("design:type", Array)
], NbToastrContainerComponent.prototype, "content", void 0);
__decorate$129([
    Input(),
    __metadata$85("design:type", Object)
], NbToastrContainerComponent.prototype, "context", void 0);
__decorate$129([
    Input(),
    __metadata$85("design:type", String)
], NbToastrContainerComponent.prototype, "position", void 0);
__decorate$129([
    ViewChildren(NbToastComponent),
    __metadata$85("design:type", QueryList)
], NbToastrContainerComponent.prototype, "toasts", void 0);
NbToastrContainerComponent = __decorate$129([ __metadata$85("design:paramtypes", [NbLayoutDirectionService,
        NbPositionHelper])
], NbToastrContainerComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_TOASTR_CONFIG = new InjectionToken('Default toastr options');
/**
 * The `NbToastrConfig` class describes configuration of the `NbToastrService.show` and global toastr configuration.
 * */
class NbToastrConfig {
    constructor(config) {
        /**
         * Determines where on the screen toast have to be rendered.
         * */
        this.position = NbGlobalLogicalPosition.TOP_END;
        /**
         * Status chooses color scheme for the toast.
         * */
        this.status = 'primary';
        /**
         * Duration is timeout between toast appears and disappears.
         * */
        this.duration = 3000;
        /**
         * Destroy by click means you can hide the toast by clicking it.
         * */
        this.destroyByClick = true;
        /**
         * If preventDuplicates is true then the toast with the same title, message and status will not be rendered.
         * Find duplicates behaviour determined by `preventDuplicates`.
         * The default `previous` duplicate behaviour is used.
         * */
        this.preventDuplicates = false;
        /**
         * Determines the how to threat duplicates.
         * */
        this.duplicatesBehaviour = 'previous';
        /*
        * The number of visible toasts. If the limit exceeded the oldest toast will be removed.
        * */
        this.limit = null;
        /**
         * Class to be applied to the toast.
         */
        this.toastClass = '';
        /**
         * Determines render icon or not.
         * */
        this.hasIcon = true;
        /**
         * Icon name or icon config object that can be provided to render custom icon.
         * */
        this.icon = 'email';
        /**
         * Toast status icon-class mapping.
         * */
        this.icons = {
            danger: 'flash-outline',
            success: 'checkmark-outline',
            info: 'question-mark-outline',
            warning: 'alert-triangle-outline',
            primary: 'email-outline',
            control: 'email-outline',
            basic: 'email-outline',
        };
        if (config.status === '') {
            emptyStatusWarning('NbToastr');
            config.status = 'primary';
        }
        this.patchIcon(config);
        Object.assign(this, config);
    }
    patchIcon(config) {
        if (!('icon' in config)) {
            config.icon = {
                icon: this.icons[config.status || 'primary'],
                pack: 'nebular-essentials',
            };
        }
    }
}

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$128 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$84 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$18 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
class NbToastRef {
    constructor(toastContainer, toast) {
        this.toastContainer = toastContainer;
        this.toast = toast;
    }
    close() {
        this.toastContainer.destroy(this.toast);
    }
}
class NbToastContainer {
    constructor(position, containerRef, positionHelper) {
        this.position = position;
        this.containerRef = containerRef;
        this.positionHelper = positionHelper;
        this.toasts = [];
        this.toastDuplicateCompareFunc = (t1, t2) => {
            return t1.message === t2.message
                && t1.title === t2.title
                && t1.config.status === t2.config.status;
        };
    }
    get nativeElement() {
        return this.containerRef.location.nativeElement;
    }
    attach(toast) {
        if (toast.config.preventDuplicates && this.isDuplicate(toast)) {
            return;
        }
        this.removeToastIfLimitReached(toast);
        const toastComponent = this.attachToast(toast);
        if (toast.config.destroyByClick) {
            this.subscribeOnClick(toastComponent, toast);
        }
        if (toast.config.duration) {
            this.setDestroyTimeout(toast);
        }
        this.prevToast = toast;
        return new NbToastRef(this, toast);
    }
    destroy(toast) {
        if (this.prevToast === toast) {
            this.prevToast = null;
        }
        this.toasts = this.toasts.filter(t => t !== toast);
        this.updateContainer();
    }
    isDuplicate(toast) {
        return toast.config.duplicatesBehaviour === 'previous'
            ? this.isDuplicatePrevious(toast)
            : this.isDuplicateAmongAll(toast);
    }
    isDuplicatePrevious(toast) {
        return this.prevToast && this.toastDuplicateCompareFunc(this.prevToast, toast);
    }
    isDuplicateAmongAll(toast) {
        return this.toasts.some(t => this.toastDuplicateCompareFunc(t, toast));
    }
    removeToastIfLimitReached(toast) {
        if (!toast.config.limit || this.toasts.length < toast.config.limit) {
            return;
        }
        if (this.positionHelper.isTopPosition(toast.config.position)) {
            this.toasts.pop();
        }
        else {
            this.toasts.shift();
        }
    }
    attachToast(toast) {
        if (this.positionHelper.isTopPosition(toast.config.position)) {
            return this.attachToTop(toast);
        }
        else {
            return this.attachToBottom(toast);
        }
    }
    attachToTop(toast) {
        this.toasts.unshift(toast);
        this.updateContainer();
        return this.containerRef.instance.toasts.first;
    }
    attachToBottom(toast) {
        this.toasts.push(toast);
        this.updateContainer();
        return this.containerRef.instance.toasts.last;
    }
    setDestroyTimeout(toast) {
        setTimeout(() => this.destroy(toast), toast.config.duration);
    }
    subscribeOnClick(toastComponent, toast) {
        toastComponent.destroy.subscribe(() => this.destroy(toast));
    }
    updateContainer() {
        patch(this.containerRef, { content: this.toasts, position: this.position });
    }
}
let NbToastrContainerRegistry = class NbToastrContainerRegistry {
    constructor(overlay, positionBuilder, positionHelper, cfr, document) {
        this.overlay = overlay;
        this.positionBuilder = positionBuilder;
        this.positionHelper = positionHelper;
        this.cfr = cfr;
        this.document = document;
        this.overlays = new Map();
    }
    get(position) {
        const logicalPosition = this.positionHelper.toLogicalPosition(position);
        const overlayWithContainer = this.overlays.get(logicalPosition);
        if (!overlayWithContainer || !this.existsInDom(overlayWithContainer.toastrContainer)) {
            if (overlayWithContainer) {
                overlayWithContainer.overlayRef.dispose();
            }
            this.instantiateContainer(logicalPosition);
        }
        return this.overlays.get(logicalPosition).toastrContainer;
    }
    instantiateContainer(position) {
        const toastrOverlayWithContainer = this.createContainer(position);
        this.overlays.set(position, toastrOverlayWithContainer);
    }
    createContainer(position) {
        const positionStrategy = this.positionBuilder.global().position(position);
        const ref = this.overlay.create({ positionStrategy });
        this.addClassToOverlayHost(ref);
        const containerRef = ref.attach(new NbComponentPortal(NbToastrContainerComponent, null, null, this.cfr));
        return {
            overlayRef: ref,
            toastrContainer: new NbToastContainer(position, containerRef, this.positionHelper),
        };
    }
    addClassToOverlayHost(overlayRef) {
        overlayRef.hostElement.classList.add('toastr-overlay-container');
    }
    existsInDom(toastContainer) {
        return this.document.body.contains(toastContainer.nativeElement);
    }
};
NbToastrContainerRegistry.ɵfac = function NbToastrContainerRegistry_Factory(t) { return new (t || NbToastrContainerRegistry)(ɵngcc0.ɵɵinject(NbOverlayService), ɵngcc0.ɵɵinject(NbPositionBuilderService), ɵngcc0.ɵɵinject(NbPositionHelper), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbToastrContainerRegistry.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbToastrContainerRegistry, factory: NbToastrContainerRegistry.ɵfac });
NbToastrContainerRegistry = __decorate$128([ __param$18(4, Inject(NB_DOCUMENT)),
    __metadata$84("design:paramtypes", [NbOverlayService,
        NbPositionBuilderService,
        NbPositionHelper,
        ComponentFactoryResolver, Object])
], NbToastrContainerRegistry);
/**
 * The `NbToastrService` provides a capability to build toast notifications.
 *
 * @stacked-example(Showcase, toastr/toastr-showcase.component)
 *
 * `NbToastrService.show(message, title, config)` accepts three params, title and config are optional.
 *
 * ### Installation
 *
 * Import `NbToastrModule.forRoot()` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbToastrModule.forRoot(config),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * ### Usage
 *
 * Calling `NbToastrService.show(...)` will render new toast and return `NbToastrRef` with
 * help of which you may close newly created toast by calling `close` method.
 *
 * ```ts
 * const toastRef: NbToastRef = this.toastrService.show(...);
 * toastRef.close();
 * ```
 *
 * Config accepts following options:
 *
 * `position` - determines where on the screen toast will be rendered.
 * Default is `top-end`.
 *
 * @stacked-example(Position, toastr/toastr-positions.component)
 *
 * `status` - coloring and icon of the toast.
 * Default is `primary`.
 *
 * @stacked-example(Status, toastr/toastr-statuses.component)
 *
 * `duration` - the time after which the toast will be destroyed.
 * `0` means endless toast, that may be destroyed by click only.
 * Default is 3000 ms.
 *
 * @stacked-example(Duration, toastr/toastr-duration.component)
 *
 * `destroyByClick` - provides a capability to destroy toast by click.
 * Default is true.
 *
 * @stacked-example(Destroy by click, toastr/toastr-destroy-by-click.component)
 *
 * `preventDuplicates` - don't create new toast if it has the same title, message and status.
 * Default is false.
 *
 * @stacked-example(Prevent duplicates, toastr/toastr-prevent-duplicates.component)
 *
 * `duplicatesBehaviour` - determines how to threat the toasts duplication.
 * Compare with the previous message `previous`
 * or with all visible messages `all`.
 *
 * @stacked-example(Prevent duplicates behaviour , toastr/toastr-prevent-duplicates-behaviour.component)
 *
 * `limit` - the number of visible toasts in the toast container. The number of toasts is unlimited by default.
 *
 * @stacked-example(Prevent duplicates behaviour , toastr/toastr-limit.component)
 *
 * `hasIcon` - if true then render toast icon.
 * `icon` - you can pass icon class that will be applied into the toast.
 *
 * @stacked-example(Has icon, toastr/toastr-icon.component)
 * */
let NbToastrService = class NbToastrService {
    constructor(globalConfig, containerRegistry) {
        this.globalConfig = globalConfig;
        this.containerRegistry = containerRegistry;
    }
    /**
     * Shows toast with message, title and user config.
     * */
    show(message, title, userConfig) {
        const config = new NbToastrConfig(Object.assign({}, this.globalConfig, userConfig));
        const container = this.containerRegistry.get(config.position);
        const toast = { message, title, config };
        return container.attach(toast);
    }
    /**
     * Shows success toast with message, title and user config.
     * */
    success(message, title, config) {
        return this.show(message, title, Object.assign({}, config, { status: 'success' }));
    }
    /**
     * Shows info toast with message, title and user config.
     * */
    info(message, title, config) {
        return this.show(message, title, Object.assign({}, config, { status: 'info' }));
    }
    /**
     * Shows warning toast with message, title and user config.
     * */
    warning(message, title, config) {
        return this.show(message, title, Object.assign({}, config, { status: 'warning' }));
    }
    /**
     * Shows primary toast with message, title and user config.
     * */
    primary(message, title, config) {
        return this.show(message, title, Object.assign({}, config, { status: 'primary' }));
    }
    /**
     * Shows danger toast with message, title and user config.
     * */
    danger(message, title, config) {
        return this.show(message, title, Object.assign({}, config, { status: 'danger' }));
    }
    /**
     * Shows basic toast with message, title and user config.
     * */
    default(message, title, config) {
        return this.show(message, title, Object.assign({}, config, { status: 'basic' }));
    }
    /**
     * Shows control toast with message, title and user config.
     * */
    control(message, title, config) {
        return this.default(message, title, Object.assign({}, config, { status: 'control' }));
    }
};
NbToastrService.ɵfac = function NbToastrService_Factory(t) { return new (t || NbToastrService)(ɵngcc0.ɵɵinject(NB_TOASTR_CONFIG), ɵngcc0.ɵɵinject(NbToastrContainerRegistry)); };
NbToastrService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbToastrService, factory: NbToastrService.ɵfac });
NbToastrService = __decorate$128([ __param$18(0, Inject(NB_TOASTR_CONFIG)),
    __metadata$84("design:paramtypes", [NbToastrConfig,
        NbToastrContainerRegistry])
], NbToastrService);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$127 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbToastrModule_1;
let NbToastrModule = NbToastrModule_1 = class NbToastrModule {
    static forRoot(toastrConfig = {}) {
        return {
            ngModule: NbToastrModule_1,
            providers: [
                NbToastrService,
                NbToastrContainerRegistry,
                { provide: NB_TOASTR_CONFIG, useValue: toastrConfig },
            ],
        };
    }
};
NbToastrModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbToastrModule });
NbToastrModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbToastrModule_Factory(t) { return new (t || NbToastrModule)(); }, imports: [[NbSharedModule, NbOverlayModule, NbIconModule]] });

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$132 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$87 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * Tooltip container.
 * Renders provided tooltip inside.
 *
 * @styles
 *
 * tooltip-background-color:
 * tooltip-border-color:
 * tooltip-border-style:
 * tooltip-border-width:
 * tooltip-border-radius:
 * tooltip-padding:
 * tooltip-text-color:
 * tooltip-text-font-family:
 * tooltip-text-font-size:
 * tooltip-text-font-weight:
 * tooltip-text-line-height:
 * tooltip-icon-height:
 * tooltip-icon-width:
 * tooltip-max-width:
 * tooltip-basic-background-color:
 * tooltip-basic-border-color:
 * tooltip-basic-text-color:
 * tooltip-primary-background-color:
 * tooltip-primary-border-color:
 * tooltip-primary-text-color:
 * tooltip-info-background-color:
 * tooltip-info-border-color:
 * tooltip-info-text-color:
 * tooltip-success-background-color:
 * tooltip-success-border-color:
 * tooltip-success-text-color:
 * tooltip-warning-background-color:
 * tooltip-warning-border-color:
 * tooltip-warning-text-color:
 * tooltip-danger-background-color:
 * tooltip-danger-border-color:
 * tooltip-danger-text-color:
 * tooltip-control-background-color:
 * tooltip-control-border-color:
 * tooltip-control-text-color:
 * tooltip-shadow:
 */
let NbTooltipComponent = class NbTooltipComponent {
    /**
     * Tooltip container.
     * Renders provided tooltip inside.
     *
     * @styles
     *
     * tooltip-background-color:
     * tooltip-border-color:
     * tooltip-border-style:
     * tooltip-border-width:
     * tooltip-border-radius:
     * tooltip-padding:
     * tooltip-text-color:
     * tooltip-text-font-family:
     * tooltip-text-font-size:
     * tooltip-text-font-weight:
     * tooltip-text-line-height:
     * tooltip-icon-height:
     * tooltip-icon-width:
     * tooltip-max-width:
     * tooltip-basic-background-color:
     * tooltip-basic-border-color:
     * tooltip-basic-text-color:
     * tooltip-primary-background-color:
     * tooltip-primary-border-color:
     * tooltip-primary-text-color:
     * tooltip-info-background-color:
     * tooltip-info-border-color:
     * tooltip-info-text-color:
     * tooltip-success-background-color:
     * tooltip-success-border-color:
     * tooltip-success-text-color:
     * tooltip-warning-background-color:
     * tooltip-warning-border-color:
     * tooltip-warning-text-color:
     * tooltip-danger-background-color:
     * tooltip-danger-border-color:
     * tooltip-danger-text-color:
     * tooltip-control-background-color:
     * tooltip-control-border-color:
     * tooltip-control-text-color:
     * tooltip-shadow:
     */
    constructor() {
        /**
         * Popover position relatively host element.
         * */
        this.position = NbPosition.TOP;
        this.context = {};
    }
    get binding() {
        return `${this.position} ${this.statusClass}`;
    }
    get show() {
        return true;
    }
    get statusClass() {
        if (this.context.status) {
            return `status-${this.context.status}`;
        }
        return '';
    }
    /**
     * The method is empty since we don't need to do anything additionally
     * render is handled by change detection
     */
    renderContent() { }
};
NbTooltipComponent.ɵfac = function NbTooltipComponent_Factory(t) { return new (t || NbTooltipComponent)(); };
NbTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTooltipComponent, selectors: [["nb-tooltip"]], hostVars: 3, hostBindings: function NbTooltipComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵupdateSyntheticHostBinding("@showTooltip", ctx.show);
        ɵngcc0.ɵɵclassMap(ctx.binding);
    } }, inputs: { position: "position", context: "context", content: "content" }, decls: 4, vars: 2, consts: [[1, "arrow"], [1, "content"], [3, "config", 4, "ngIf"], [4, "ngIf"], [3, "config"]], template: function NbTooltipComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵtemplate(2, NbTooltipComponent_nb_icon_2_Template, 1, 1, "nb-icon", 2);
        ɵngcc0.ɵɵtemplate(3, NbTooltipComponent_span_3_Template, 2, 1, "span", 3);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.context == null ? null : ctx.context.icon);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.content);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{z-index:10000}[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{display:flex;align-items:center}.right[_nghost-%COMP%]   .content[_ngcontent-%COMP%]{flex-direction:row-reverse}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-left:0.5rem}.right[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%] + span[_ngcontent-%COMP%]{margin-right:0.5rem}[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{border-left:6px solid transparent;border-right:6px solid transparent}.bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px;left:calc(50% - 6px)}.bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .bottom-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:-6px}[dir=ltr]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .bottom-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}[dir=rtl]   .left[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}.start-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;bottom:6px;transform:rotate(90deg)}.start-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;top:6px;transform:rotate(90deg)}.top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}.top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:calc(-1 * 6px + 1px);transform:rotate(180deg)}[dir=ltr]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}[dir=rtl]   .top-start[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}.top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{bottom:calc(-6px + 1px);transform:rotate(180deg)}[dir=ltr]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:6px}[dir=rtl]   .top-end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:6px}.right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{top:calc(50% - 2.4px)}[dir=ltr]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=ltr]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:-8px;transform:rotate(270deg)}[dir=rtl]   .right[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%], [dir=rtl]   .end[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{right:-8px;transform:rotate(90deg)}.end-top[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:calc(-6px - 6px / 2.5);bottom:6px;transform:rotate(270deg)}.end-bottom[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{left:calc(-6px - 6px / 2.5);top:6px;transform:rotate(270deg)}"], data: { animation: [
            trigger('showTooltip', [
                state('in', style({ opacity: 1 })),
                transition('void => *', [
                    style({ opacity: 0 }),
                    animate(100),
                ]),
                transition('* => void', [
                    animate(100, style({ opacity: 0 })),
                ]),
            ]),
        ] } });
__decorate$132([
    Input(),
    __metadata$87("design:type", String)
], NbTooltipComponent.prototype, "content", void 0);
__decorate$132([
    Input(),
    __metadata$87("design:type", String)
], NbTooltipComponent.prototype, "position", void 0);
__decorate$132([
    HostBinding('class'),
    __metadata$87("design:type", Object),
    __metadata$87("design:paramtypes", [])
], NbTooltipComponent.prototype, "binding", null);
__decorate$132([
    HostBinding('@showTooltip'),
    __metadata$87("design:type", Object),
    __metadata$87("design:paramtypes", [])
], NbTooltipComponent.prototype, "show", null);
__decorate$132([
    Input(),
    __metadata$87("design:type", Object)
], NbTooltipComponent.prototype, "context", void 0);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$133 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$88 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 *
 * Tooltip directive for small text/icon hints.
 *
 * ### Installation
 *
 * Import `NbTooltipModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTooltipModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * @stacked-example(Showcase, tooltip/tooltip-showcase.component)
 *
 * Tooltip can accept a hint text and/or an icon:
 * @stacked-example(With Icon, tooltip/tooltip-with-icon.component)
 *
 * Same way as Popover, tooltip can accept placement position with `nbTooltipPlacement` property:
 * @stacked-example(Placements, tooltip/tooltip-placements.component)
 *
 * It is also possible to specify tooltip color using `nbTooltipStatus` property:
 * @stacked-example(Colored Tooltips, tooltip/tooltip-colors.component)
 *
 * Tooltip has a number of triggers which provides an ability to show and hide the component in different ways:
 *
 * - Click mode shows the component when a user clicks on the host element and hides when the user clicks
 * somewhere on the document outside the component.
 * - Hint provides capability to show the component when the user hovers over the host element
 * and hide when the user hovers out of the host.
 * - Hover works like hint mode with one exception - when the user moves mouse from host element to
 * the container element the component remains open, so that it is possible to interact with it content.
 * - Focus mode is applied when user focuses the element.
 * - Noop mode - the component won't react to the user interaction.
 */
let NbTooltipDirective = class NbTooltipDirective {
    constructor(hostRef, dynamicOverlayHandler) {
        this.hostRef = hostRef;
        this.dynamicOverlayHandler = dynamicOverlayHandler;
        this.destroy$ = new Subject();
        this.tooltipComponent = NbTooltipComponent;
        this.offset = 8;
        this.context = {};
        /**
         * Position will be calculated relatively host element based on the position.
         * Can be top, right, bottom, left, start or end.
         */
        this.position = NbPosition.TOP;
        this._adjustment = NbAdjustment.CLOCKWISE;
        this.tooltipClass = '';
        /**
         * Describes when the container will be shown.
         * Available options: `click`, `hover`, `hint`, `focus` and `noop`
         * */
        this.trigger = NbTrigger.HINT;
        this.nbTooltipShowStateChange = new EventEmitter();
    }
    /**
     * Container position will change automatically based on this strategy if container can't fit view port.
     * Set this property to `noop` value if you want to disable automatic adjustment.
     * Available values: `clockwise` (default), `counterclockwise`, `vertical`, `horizontal`, `noop`.
     */
    get adjustment() {
        return this._adjustment;
    }
    set adjustment(value) {
        if (!value) {
            // @breaking-change Remove @5.0.0
            console.warn(`Falsy values for 'nbPopoverAdjustment' are deprecated and will be removed in Nebular 5.
 Use 'noop' instead.`);
            value = NbAdjustment.NOOP;
        }
        this._adjustment = value;
    }
    /**
     * Accepts icon name or icon config object
     * @param {string | NbIconConfig} icon name or config object
     */
    set icon(icon) {
        this.context = Object.assign(this.context, { icon });
    }
    /**
     *
     * @param {string} status
     */
    set status(status) {
        this.context = Object.assign(this.context, { status });
    }
    get isShown() {
        return !!(this.dynamicOverlay && this.dynamicOverlay.isAttached);
    }
    ngOnInit() {
        this.dynamicOverlayHandler
            .host(this.hostRef)
            .componentType(this.tooltipComponent)
            .offset(this.offset);
    }
    ngOnChanges() {
        this.rebuild();
    }
    ngAfterViewInit() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .build();
        this.dynamicOverlay.isShown
            .pipe(skip(1), takeUntil(this.destroy$))
            .subscribe((isShown) => this.nbTooltipShowStateChange.emit({ isShown }));
    }
    rebuild() {
        this.dynamicOverlay = this.configureDynamicOverlay()
            .rebuild();
    }
    show() {
        this.dynamicOverlay.show();
    }
    hide() {
        this.dynamicOverlay.hide();
    }
    toggle() {
        this.dynamicOverlay.toggle();
    }
    ngOnDestroy() {
        this.dynamicOverlayHandler.destroy();
        this.destroy$.next();
        this.destroy$.complete();
    }
    configureDynamicOverlay() {
        return this.dynamicOverlayHandler
            .position(this.position)
            .trigger(this.trigger)
            .adjustment(this.adjustment)
            .content(this.content)
            .context(this.context)
            .overlayConfig({ panelClass: this.tooltipClass });
    }
};
NbTooltipDirective.ɵfac = function NbTooltipDirective_Factory(t) { return new (t || NbTooltipDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbDynamicOverlayHandler)); };
NbTooltipDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTooltipDirective, selectors: [["", "nbTooltip", ""]], inputs: { position: ["nbTooltipPlacement", "position"], tooltipClass: ["nbTooltipClass", "tooltipClass"], trigger: ["nbTooltipTrigger", "trigger"], adjustment: ["nbTooltipAdjustment", "adjustment"], icon: ["nbTooltipIcon", "icon"], status: ["nbTooltipStatus", "status"], content: ["nbTooltip", "content"] }, outputs: { nbTooltipShowStateChange: "nbTooltipShowStateChange" }, exportAs: ["nbTooltip"], features: [ɵngcc0.ɵɵProvidersFeature([NbDynamicOverlayHandler, NbDynamicOverlay]), ɵngcc0.ɵɵNgOnChangesFeature()] });
__decorate$133([
    Input('nbTooltip'),
    __metadata$88("design:type", String)
], NbTooltipDirective.prototype, "content", void 0);
__decorate$133([
    Input('nbTooltipPlacement'),
    __metadata$88("design:type", String)
], NbTooltipDirective.prototype, "position", void 0);
__decorate$133([
    Input('nbTooltipAdjustment'),
    __metadata$88("design:type", String),
    __metadata$88("design:paramtypes", [String])
], NbTooltipDirective.prototype, "adjustment", null);
__decorate$133([
    Input('nbTooltipClass'),
    __metadata$88("design:type", String)
], NbTooltipDirective.prototype, "tooltipClass", void 0);
__decorate$133([
    Input('nbTooltipIcon'),
    __metadata$88("design:type", Object),
    __metadata$88("design:paramtypes", [Object])
], NbTooltipDirective.prototype, "icon", null);
__decorate$133([
    Input('nbTooltipStatus'),
    __metadata$88("design:type", String),
    __metadata$88("design:paramtypes", [String])
], NbTooltipDirective.prototype, "status", null);
__decorate$133([
    Input('nbTooltipTrigger'),
    __metadata$88("design:type", String)
], NbTooltipDirective.prototype, "trigger", void 0);
__decorate$133([
    Output(),
    __metadata$88("design:type", Object)
], NbTooltipDirective.prototype, "nbTooltipShowStateChange", void 0);
NbTooltipDirective = __decorate$133([ __metadata$88("design:paramtypes", [ElementRef,
        NbDynamicOverlayHandler])
], NbTooltipDirective);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$131 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbTooltipModule = class NbTooltipModule {
};
NbTooltipModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbTooltipModule });
NbTooltipModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbTooltipModule_Factory(t) { return new (t || NbTooltipModule)(); }, imports: [[NbSharedModule, NbOverlayModule, NbIconModule]] });

const NB_SELECT_INJECTION_TOKEN = new InjectionToken('NB_SELECT_INJECTION_TOKEN');

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$136 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$90 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$20 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
let NbOptionComponent = class NbOptionComponent {
    constructor(parent, elementRef, cd) {
        this.elementRef = elementRef;
        this.cd = cd;
        this.disabledByGroup = false;
        this._disabled = false;
        /**
         * Fires value when option selection change.
         * */
        this.selectionChange = new EventEmitter();
        /**
         * Fires when option clicked
         */
        this.click$ = new Subject();
        this.selected = false;
        this.alive = true;
        this.parent = parent;
    }
    get disabled() {
        return this._disabled || this.disabledByGroup;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
    }
    get click() {
        return this.click$.asObservable();
    }
    ngOnDestroy() {
        this.alive = false;
    }
    /**
     * Determines should we render checkbox.
     * */
    get withCheckbox() {
        return this.multiple && this.value != null;
    }
    get content() {
        return this.elementRef.nativeElement.textContent;
    }
    get multiple() {
        return this.parent.multiple;
    }
    get selectedClass() {
        return this.selected;
    }
    get disabledAttribute() {
        return this.disabled ? '' : null;
    }
    get tabindex() {
        return '-1';
    }
    onClick(event) {
        this.click$.next(this);
        // Prevent scroll on space click, etc.
        event.preventDefault();
    }
    select() {
        this.setSelection(true);
    }
    deselect() {
        this.setSelection(false);
    }
    /**
     * Sets disabled by group state and marks component for check.
     */
    setDisabledByGroupState(disabled) {
        if (this.disabledByGroup !== disabled) {
            this.disabledByGroup = disabled;
            this.cd.markForCheck();
        }
    }
    setSelection(selected) {
        /**
         * In case of changing options in runtime the reference to the selected option will be kept in select component.
         * This may lead to exceptions with detecting changes in destroyed component.
         *
         * Also Angular can call writeValue on destroyed view (select implements ControlValueAccessor).
         * angular/angular#27803
         * */
        if (this.alive && this.selected !== selected) {
            this.selected = selected;
            this.selectionChange.emit(this);
            this.cd.markForCheck();
        }
    }
    focus() {
        this.elementRef.nativeElement.focus();
    }
    getLabel() {
        return this.content;
    }
};
NbOptionComponent.ɵfac = function NbOptionComponent_Factory(t) { return new (t || NbOptionComponent)(ɵngcc0.ɵɵdirectiveInject(NB_SELECT_INJECTION_TOKEN), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbOptionComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbOptionComponent, selectors: [["nb-option"]], hostVars: 4, hostBindings: function NbOptionComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbOptionComponent_click_HostBindingHandler($event) { return ctx.onClick($event); })("keydown.space", function NbOptionComponent_keydown_space_HostBindingHandler($event) { return ctx.onClick($event); })("keydown.enter", function NbOptionComponent_keydown_enter_HostBindingHandler($event) { return ctx.onClick($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("tabIndex", ctx.tabindex);
        ɵngcc0.ɵɵattribute("disabled", ctx.disabledAttribute);
        ɵngcc0.ɵɵclassProp("selected", ctx.selectedClass);
    } }, inputs: { disabled: "disabled", value: "value" }, outputs: { selectionChange: "selectionChange" }, ngContentSelectors: _c0, decls: 2, vars: 1, consts: [["aria-hidden", "true", 3, "checked", "disabled", 4, "ngIf"], ["aria-hidden", "true", 3, "checked", "disabled"]], template: function NbOptionComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵtemplate(0, NbOptionComponent_nb_checkbox_0_Template, 1, 2, "nb-checkbox", 0);
        ɵngcc0.ɵɵprojection(1);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.withCheckbox);
    } }, directives: [ɵngcc2.NgIf, NbCheckboxComponent], styles: ["[_nghost-%COMP%]{display:flex;transition-duration:0.15s;transition-property:background-color,color;transition-timing-function:ease-in}[_nghost-%COMP%]:hover{cursor:pointer}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{display:flex;pointer-events:none}[dir=ltr]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-right:.5rem}[dir=rtl]   [_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]{margin-left:.5rem}[_nghost-%COMP%]   nb-checkbox[_ngcontent-%COMP%]     .label{padding:0}[disabled][_nghost-%COMP%]{pointer-events:none}"], changeDetection: 0 });
__decorate$136([
    Input(),
    __metadata$90("design:type", Object)
], NbOptionComponent.prototype, "value", void 0);
__decorate$136([
    Input(),
    __metadata$90("design:type", Boolean),
    __metadata$90("design:paramtypes", [Boolean])
], NbOptionComponent.prototype, "disabled", null);
__decorate$136([
    Output(),
    __metadata$90("design:type", EventEmitter)
], NbOptionComponent.prototype, "selectionChange", void 0);
__decorate$136([
    HostBinding('class.selected'),
    __metadata$90("design:type", Boolean),
    __metadata$90("design:paramtypes", [])
], NbOptionComponent.prototype, "selectedClass", null);
__decorate$136([
    HostBinding('attr.disabled'),
    __metadata$90("design:type", String),
    __metadata$90("design:paramtypes", [])
], NbOptionComponent.prototype, "disabledAttribute", null);
__decorate$136([
    HostBinding('tabIndex'),
    __metadata$90("design:type", Object),
    __metadata$90("design:paramtypes", [])
], NbOptionComponent.prototype, "tabindex", null);
__decorate$136([
    HostListener('click', ['$event']),
    HostListener('keydown.space', ['$event']),
    HostListener('keydown.enter', ['$event']),
    __metadata$90("design:type", Function),
    __metadata$90("design:paramtypes", [Object]),
    __metadata$90("design:returntype", void 0)
], NbOptionComponent.prototype, "onClick", null);
NbOptionComponent = __decorate$136([ __param$20(0, Inject(NB_SELECT_INJECTION_TOKEN)),
    __metadata$90("design:paramtypes", [Object, ElementRef,
        ChangeDetectorRef])
], NbOptionComponent);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$135 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$89 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$19 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NbSelectComponent_1;
let NbSelectLabelComponent = class NbSelectLabelComponent {
};
NbSelectLabelComponent.ɵfac = function NbSelectLabelComponent_Factory(t) { return new (t || NbSelectLabelComponent)(); };
NbSelectLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSelectLabelComponent, selectors: [["nb-select-label"]], ngContentSelectors: _c0, decls: 1, vars: 0, template: function NbSelectLabelComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2 });
/**
 * The `NbSelectComponent` provides a capability to select one of the passed items.
 *
 * @stacked-example(Showcase, select/select-showcase.component)
 *
 * ### Installation
 *
 * Import `NbSelectModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbSelectModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * If you want to use it as the multi-select control you have to mark it as `multiple`.
 * In this case, `nb-select` will work only with arrays - accept arrays and propagate arrays.
 *
 * @stacked-example(Multiple, select/select-multiple.component)
 *
 * Items without values will clean the selection. Both `null` and `undefined` values will also clean the selection.
 *
 * @stacked-example(Clean selection, select/select-clean.component)
 *
 * Select may be bounded using `selected` input:
 *
 * ```html
 * <nb-select [(selected)]="selected"></nb-selected>
 * ```
 *
 * Or you can bind control with form controls or ngModel:
 *
 * @stacked-example(Select form binding, select/select-form.component)
 *
 * Options in the select may be grouped using `nb-option-group` component.
 *
 * @stacked-example(Grouping, select/select-groups.component)
 *
 * Select may have a placeholder that will be shown when nothing selected:
 *
 * @stacked-example(Placeholder, select/select-placeholder.component)
 *
 * You can disable select, options and whole groups.
 *
 * @stacked-example(Disabled select, select/select-disabled.component)
 *
 * Also, the custom label may be provided in select.
 * This custom label will be used for instead placeholder when something selected.
 *
 * @stacked-example(Custom label, select/select-label.component)
 *
 * Default `nb-select` size is `medium` and status is `basic`.
 * Select is available in multiple colors using `status` property:
 *
 * @stacked-example(Select statuses, select/select-status.component)
 *
 * There are five select sizes:
 *
 * @stacked-example(Select sizes, select/select-sizes.component)
 *
 * And two additional style types - `filled`:
 *
 * @stacked-example(Filled select, select/select-filled.component)
 *
 * and `hero`:
 *
 * @stacked-example(Select colors, select/select-hero.component)
 *
 * Select is available in different shapes, that could be combined with the other properties:
 *
 * @stacked-example(Select shapes, select/select-shapes.component)
 *
 * @additional-example(Interactive, select/select-interactive.component)
 *
 * @styles
 *
 * select-cursor:
 * select-disabled-cursor:
 * select-min-width:
 * select-options-list-max-height:
 * select-options-list-shadow:
 * select-options-list-border-style:
 * select-options-list-border-width:
 * select-outline-width:
 * select-outline-color:
 * select-text-font-family:
 * select-placeholder-text-font-family:
 * select-option-background-color:
 * select-option-text-color:
 * select-option-selected-background-color:
 * select-option-selected-text-color:
 * select-option-focus-background-color:
 * select-option-focus-text-color:
 * select-option-hover-background-color:
 * select-option-hover-text-color:
 * select-option-disabled-background-color:
 * select-option-disabled-text-color:
 * select-tiny-text-font-size:
 * select-tiny-text-font-weight:
 * select-tiny-text-line-height:
 * select-tiny-placeholder-text-font-size:
 * select-tiny-placeholder-text-font-weight:
 * select-tiny-max-width:
 * select-small-text-font-size:
 * select-small-text-font-weight:
 * select-small-text-line-height:
 * select-small-placeholder-text-font-size:
 * select-small-placeholder-text-font-weight:
 * select-small-max-width:
 * select-medium-text-font-size:
 * select-medium-text-font-weight:
 * select-medium-text-line-height:
 * select-medium-placeholder-text-font-size:
 * select-medium-placeholder-text-font-weight:
 * select-medium-max-width:
 * select-large-text-font-size:
 * select-large-text-font-weight:
 * select-large-text-line-height:
 * select-large-placeholder-text-font-size:
 * select-large-placeholder-text-font-weight:
 * select-large-max-width:
 * select-giant-text-font-size:
 * select-giant-text-font-weight:
 * select-giant-text-line-height:
 * select-giant-placeholder-text-font-size:
 * select-giant-placeholder-text-font-weight:
 * select-giant-max-width:
 * select-rectangle-border-radius:
 * select-semi-round-border-radius:
 * select-round-border-radius:
 * select-outline-border-style:
 * select-outline-border-width:
 * select-outline-tiny-padding:
 * select-outline-small-padding:
 * select-outline-medium-padding:
 * select-outline-large-padding:
 * select-outline-giant-padding:
 * select-outline-basic-icon-color:
 * select-outline-basic-text-color:
 * select-outline-basic-placeholder-text-color:
 * select-outline-basic-background-color:
 * select-outline-basic-border-color:
 * select-outline-basic-focus-background-color:
 * select-outline-basic-focus-border-color:
 * select-outline-basic-hover-background-color:
 * select-outline-basic-hover-border-color:
 * select-outline-basic-disabled-background-color:
 * select-outline-basic-disabled-border-color:
 * select-outline-basic-disabled-icon-color:
 * select-outline-basic-disabled-text-color:
 * select-outline-primary-icon-color:
 * select-outline-primary-text-color:
 * select-outline-primary-placeholder-text-color:
 * select-outline-primary-background-color:
 * select-outline-primary-border-color:
 * select-outline-primary-focus-background-color:
 * select-outline-primary-focus-border-color:
 * select-outline-primary-hover-background-color:
 * select-outline-primary-hover-border-color:
 * select-outline-primary-disabled-background-color:
 * select-outline-primary-disabled-border-color:
 * select-outline-primary-disabled-icon-color:
 * select-outline-primary-disabled-text-color:
 * select-outline-success-icon-color:
 * select-outline-success-text-color:
 * select-outline-success-placeholder-text-color:
 * select-outline-success-background-color:
 * select-outline-success-border-color:
 * select-outline-success-focus-background-color:
 * select-outline-success-focus-border-color:
 * select-outline-success-hover-background-color:
 * select-outline-success-hover-border-color:
 * select-outline-success-disabled-background-color:
 * select-outline-success-disabled-border-color:
 * select-outline-success-disabled-icon-color:
 * select-outline-success-disabled-text-color:
 * select-outline-info-icon-color:
 * select-outline-info-text-color:
 * select-outline-info-placeholder-text-color:
 * select-outline-info-background-color:
 * select-outline-info-border-color:
 * select-outline-info-focus-background-color:
 * select-outline-info-focus-border-color:
 * select-outline-info-hover-background-color:
 * select-outline-info-hover-border-color:
 * select-outline-info-disabled-background-color:
 * select-outline-info-disabled-border-color:
 * select-outline-info-disabled-icon-color:
 * select-outline-info-disabled-text-color:
 * select-outline-warning-icon-color:
 * select-outline-warning-text-color:
 * select-outline-warning-placeholder-text-color:
 * select-outline-warning-background-color:
 * select-outline-warning-border-color:
 * select-outline-warning-focus-background-color:
 * select-outline-warning-focus-border-color:
 * select-outline-warning-hover-background-color:
 * select-outline-warning-hover-border-color:
 * select-outline-warning-disabled-background-color:
 * select-outline-warning-disabled-border-color:
 * select-outline-warning-disabled-icon-color:
 * select-outline-warning-disabled-text-color:
 * select-outline-danger-icon-color:
 * select-outline-danger-text-color:
 * select-outline-danger-placeholder-text-color:
 * select-outline-danger-background-color:
 * select-outline-danger-border-color:
 * select-outline-danger-focus-background-color:
 * select-outline-danger-focus-border-color:
 * select-outline-danger-hover-background-color:
 * select-outline-danger-hover-border-color:
 * select-outline-danger-disabled-background-color:
 * select-outline-danger-disabled-border-color:
 * select-outline-danger-disabled-icon-color:
 * select-outline-danger-disabled-text-color:
 * select-outline-control-icon-color:
 * select-outline-control-text-color:
 * select-outline-control-placeholder-text-color:
 * select-outline-control-background-color:
 * select-outline-control-border-color:
 * select-outline-control-focus-background-color:
 * select-outline-control-focus-border-color:
 * select-outline-control-hover-background-color:
 * select-outline-control-hover-border-color:
 * select-outline-control-disabled-background-color:
 * select-outline-control-disabled-border-color:
 * select-outline-control-disabled-icon-color:
 * select-outline-control-disabled-text-color:
 * select-option-outline-tiny-padding:
 * select-option-outline-small-padding:
 * select-option-outline-medium-padding:
 * select-option-outline-large-padding:
 * select-option-outline-giant-padding:
 * select-outline-adjacent-border-style:
 * select-outline-adjacent-border-width:
 * select-outline-basic-open-border-color:
 * select-outline-basic-adjacent-border-color:
 * select-outline-primary-open-border-color:
 * select-outline-primary-adjacent-border-color:
 * select-outline-success-open-border-color:
 * select-outline-success-adjacent-border-color:
 * select-outline-info-open-border-color:
 * select-outline-info-adjacent-border-color:
 * select-outline-warning-open-border-color:
 * select-outline-warning-adjacent-border-color:
 * select-outline-danger-open-border-color:
 * select-outline-danger-adjacent-border-color:
 * select-outline-control-open-border-color:
 * select-outline-control-adjacent-border-color:
 * select-group-option-outline-tiny-start-padding:
 * select-group-option-outline-small-start-padding:
 * select-group-option-outline-medium-start-padding:
 * select-group-option-outline-large-start-padding:
 * select-group-option-outline-giant-start-padding:
 * select-options-list-outline-basic-border-color:
 * select-options-list-outline-primary-border-color:
 * select-options-list-outline-success-border-color:
 * select-options-list-outline-info-border-color:
 * select-options-list-outline-warning-border-color:
 * select-options-list-outline-danger-border-color:
 * select-options-list-outline-control-border-color:
 * select-filled-border-style:
 * select-filled-border-width:
 * select-filled-tiny-padding:
 * select-filled-small-padding:
 * select-filled-medium-padding:
 * select-filled-large-padding:
 * select-filled-giant-padding:
 * select-filled-basic-background-color:
 * select-filled-basic-border-color:
 * select-filled-basic-icon-color:
 * select-filled-basic-text-color:
 * select-filled-basic-placeholder-text-color:
 * select-filled-basic-focus-background-color:
 * select-filled-basic-focus-border-color:
 * select-filled-basic-hover-background-color:
 * select-filled-basic-hover-border-color:
 * select-filled-basic-disabled-background-color:
 * select-filled-basic-disabled-border-color:
 * select-filled-basic-disabled-icon-color:
 * select-filled-basic-disabled-text-color:
 * select-filled-primary-background-color:
 * select-filled-primary-border-color:
 * select-filled-primary-icon-color:
 * select-filled-primary-text-color:
 * select-filled-primary-placeholder-text-color:
 * select-filled-primary-focus-background-color:
 * select-filled-primary-focus-border-color:
 * select-filled-primary-hover-background-color:
 * select-filled-primary-hover-border-color:
 * select-filled-primary-disabled-background-color:
 * select-filled-primary-disabled-border-color:
 * select-filled-primary-disabled-icon-color:
 * select-filled-primary-disabled-text-color:
 * select-filled-success-background-color:
 * select-filled-success-border-color:
 * select-filled-success-icon-color:
 * select-filled-success-text-color:
 * select-filled-success-placeholder-text-color:
 * select-filled-success-focus-background-color:
 * select-filled-success-focus-border-color:
 * select-filled-success-hover-background-color:
 * select-filled-success-hover-border-color:
 * select-filled-success-disabled-background-color:
 * select-filled-success-disabled-border-color:
 * select-filled-success-disabled-icon-color:
 * select-filled-success-disabled-text-color:
 * select-filled-info-background-color:
 * select-filled-info-border-color:
 * select-filled-info-icon-color:
 * select-filled-info-text-color:
 * select-filled-info-placeholder-text-color:
 * select-filled-info-focus-background-color:
 * select-filled-info-focus-border-color:
 * select-filled-info-hover-background-color:
 * select-filled-info-hover-border-color:
 * select-filled-info-disabled-background-color:
 * select-filled-info-disabled-border-color:
 * select-filled-info-disabled-icon-color:
 * select-filled-info-disabled-text-color:
 * select-filled-warning-background-color:
 * select-filled-warning-border-color:
 * select-filled-warning-icon-color:
 * select-filled-warning-text-color:
 * select-filled-warning-placeholder-text-color:
 * select-filled-warning-focus-background-color:
 * select-filled-warning-focus-border-color:
 * select-filled-warning-hover-background-color:
 * select-filled-warning-hover-border-color:
 * select-filled-warning-disabled-background-color:
 * select-filled-warning-disabled-border-color:
 * select-filled-warning-disabled-icon-color:
 * select-filled-warning-disabled-text-color:
 * select-filled-danger-background-color:
 * select-filled-danger-border-color:
 * select-filled-danger-icon-color:
 * select-filled-danger-text-color:
 * select-filled-danger-placeholder-text-color:
 * select-filled-danger-focus-background-color:
 * select-filled-danger-focus-border-color:
 * select-filled-danger-hover-background-color:
 * select-filled-danger-hover-border-color:
 * select-filled-danger-disabled-background-color:
 * select-filled-danger-disabled-border-color:
 * select-filled-danger-disabled-icon-color:
 * select-filled-danger-disabled-text-color:
 * select-filled-control-background-color:
 * select-filled-control-border-color:
 * select-filled-control-icon-color:
 * select-filled-control-text-color:
 * select-filled-control-placeholder-text-color:
 * select-filled-control-focus-background-color:
 * select-filled-control-focus-border-color:
 * select-filled-control-hover-background-color:
 * select-filled-control-hover-border-color:
 * select-filled-control-disabled-background-color:
 * select-filled-control-disabled-border-color:
 * select-filled-control-disabled-icon-color:
 * select-filled-control-disabled-text-color:
 * select-option-filled-tiny-padding:
 * select-group-option-filled-tiny-padding-start:
 * select-option-filled-small-padding:
 * select-group-option-filled-small-padding-start:
 * select-option-filled-medium-padding:
 * select-group-option-filled-medium-padding-start:
 * select-option-filled-large-padding:
 * select-group-option-filled-large-padding-start:
 * select-option-filled-giant-padding:
 * select-group-option-filled-giant-padding-start:
 * select-options-list-filled-basic-border-color:
 * select-options-list-filled-primary-border-color:
 * select-options-list-filled-success-border-color:
 * select-options-list-filled-info-border-color:
 * select-options-list-filled-warning-border-color:
 * select-options-list-filled-danger-border-color:
 * select-options-list-filled-control-border-color:
 * select-hero-tiny-padding:
 * select-hero-small-padding:
 * select-hero-medium-padding:
 * select-hero-large-padding:
 * select-hero-giant-padding:
 * select-hero-basic-left-background-color:
 * select-hero-basic-right-background-color:
 * select-hero-basic-icon-color:
 * select-hero-basic-text-color:
 * select-hero-basic-placeholder-text-color:
 * select-hero-basic-focus-left-background-color:
 * select-hero-basic-focus-right-background-color:
 * select-hero-basic-hover-left-background-color:
 * select-hero-basic-hover-right-background-color:
 * select-hero-basic-disabled-background-color:
 * select-hero-basic-disabled-icon-color:
 * select-hero-basic-disabled-text-color:
 * select-hero-primary-left-background-color:
 * select-hero-primary-right-background-color:
 * select-hero-primary-icon-color:
 * select-hero-primary-text-color:
 * select-hero-primary-placeholder-text-color:
 * select-hero-primary-focus-left-background-color:
 * select-hero-primary-focus-right-background-color:
 * select-hero-primary-hover-left-background-color:
 * select-hero-primary-hover-right-background-color:
 * select-hero-primary-disabled-background-color:
 * select-hero-primary-disabled-icon-color:
 * select-hero-primary-disabled-text-color:
 * select-hero-success-left-background-color:
 * select-hero-success-right-background-color:
 * select-hero-success-icon-color:
 * select-hero-success-text-color:
 * select-hero-success-placeholder-text-color:
 * select-hero-success-focus-left-background-color:
 * select-hero-success-focus-right-background-color:
 * select-hero-success-hover-left-background-color:
 * select-hero-success-hover-right-background-color:
 * select-hero-success-disabled-background-color:
 * select-hero-success-disabled-icon-color:
 * select-hero-success-disabled-text-color:
 * select-hero-info-left-background-color:
 * select-hero-info-right-background-color:
 * select-hero-info-icon-color:
 * select-hero-info-text-color:
 * select-hero-info-placeholder-text-color:
 * select-hero-info-focus-left-background-color:
 * select-hero-info-focus-right-background-color:
 * select-hero-info-hover-left-background-color:
 * select-hero-info-hover-right-background-color:
 * select-hero-info-disabled-background-color:
 * select-hero-info-disabled-icon-color:
 * select-hero-info-disabled-text-color:
 * select-hero-warning-left-background-color:
 * select-hero-warning-right-background-color:
 * select-hero-warning-icon-color:
 * select-hero-warning-text-color:
 * select-hero-warning-placeholder-text-color:
 * select-hero-warning-focus-left-background-color:
 * select-hero-warning-focus-right-background-color:
 * select-hero-warning-hover-left-background-color:
 * select-hero-warning-hover-right-background-color:
 * select-hero-warning-disabled-background-color:
 * select-hero-warning-disabled-icon-color:
 * select-hero-warning-disabled-text-color:
 * select-hero-danger-left-background-color:
 * select-hero-danger-right-background-color:
 * select-hero-danger-icon-color:
 * select-hero-danger-text-color:
 * select-hero-danger-placeholder-text-color:
 * select-hero-danger-focus-left-background-color:
 * select-hero-danger-focus-right-background-color:
 * select-hero-danger-hover-left-background-color:
 * select-hero-danger-hover-right-background-color:
 * select-hero-danger-disabled-background-color:
 * select-hero-danger-disabled-icon-color:
 * select-hero-danger-disabled-text-color:
 * select-hero-control-left-background-color:
 * select-hero-control-right-background-color:
 * select-hero-control-icon-color:
 * select-hero-control-text-color:
 * select-hero-control-placeholder-text-color:
 * select-hero-control-focus-left-background-color:
 * select-hero-control-focus-right-background-color:
 * select-hero-control-hover-left-background-color:
 * select-hero-control-hover-right-background-color:
 * select-hero-control-disabled-background-color:
 * select-hero-control-disabled-icon-color:
 * select-hero-control-disabled-text-color:
 * select-option-hero-tiny-padding:
 * select-group-option-hero-tiny-padding-start:
 * select-option-hero-small-padding:
 * select-group-option-hero-small-padding-start:
 * select-option-hero-medium-padding:
 * select-group-option-hero-medium-padding-start:
 * select-option-hero-large-padding:
 * select-group-option-hero-large-padding-start:
 * select-option-hero-giant-padding:
 * select-group-option-hero-giant-padding-start:
 * select-options-list-hero-basic-border-color:
 * select-options-list-hero-primary-border-color:
 * select-options-list-hero-success-border-color:
 * select-options-list-hero-info-border-color:
 * select-options-list-hero-warning-border-color:
 * select-options-list-hero-danger-border-color:
 * select-options-list-hero-control-border-color:
 * */
let NbSelectComponent = NbSelectComponent_1 = class NbSelectComponent {
    constructor(document, overlay, hostRef, positionBuilder, triggerStrategyBuilder, cd, focusKeyManagerFactoryService) {
        this.document = document;
        this.overlay = overlay;
        this.hostRef = hostRef;
        this.positionBuilder = positionBuilder;
        this.triggerStrategyBuilder = triggerStrategyBuilder;
        this.cd = cd;
        this.focusKeyManagerFactoryService = focusKeyManagerFactoryService;
        /**
         * Select size, available sizes:
         * `tiny`, `small`, `medium` (default), `large`, `giant`
         */
        this.size = 'medium';
        /**
         * Select status (adds specific styles):
         * `basic`, `primary`, `info`, `success`, `warning`, `danger`, `control`
         */
        this.status = 'basic';
        /**
         * Select shapes: `rectangle` (default), `round`, `semi-round`
         */
        this.shape = 'rectangle';
        /**
         * Select appearances: `outline` (default), `filled`, `hero`
         */
        this.appearance = 'outline';
        this._fullWidth = false;
        /**
         * Renders select placeholder if nothing selected.
         * */
        this.placeholder = '';
        this._multiple = false;
        /**
         * Will be emitted when selected value changes.
         * */
        this.selectedChange = new EventEmitter();
        /**
         * List of selected options.
         * */
        this.selectionModel = [];
        /**
         * Current overlay position because of we have to toggle overlayPosition
         * in [ngClass] direction and this directive can use only string.
         */
        this.overlayPosition = '';
        this.alive = true;
        /**
         * Function passed through control value accessor to propagate changes.
         * */
        this.onChange = () => { };
        this.onTouched = () => { };
    }
    /**
     * Adds `outline` styles
     */
    get outline() {
        return this.appearance === 'outline';
    }
    set outline(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'outline';
        }
    }
    /**
     * Adds `filled` styles
     */
    get filled() {
        return this.appearance === 'filled';
    }
    set filled(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'filled';
        }
    }
    /**
     * Adds `hero` styles
     */
    get hero() {
        return this.appearance === 'hero';
    }
    set hero(value) {
        if (convertToBoolProperty(value)) {
            this.appearance = 'hero';
        }
    }
    /**
     * Disables the select
     */
    get disabled() {
        return !!this._disabled;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
    }
    /**
     * If set element will fill its container
     */
    get fullWidth() {
        return this._fullWidth;
    }
    set fullWidth(value) {
        this._fullWidth = convertToBoolProperty(value);
    }
    /**
     * Accepts selected item or array of selected items.
     * */
    set selected(value) {
        this.writeValue(value);
    }
    get selected() {
        return this.multiple
            ? this.selectionModel.map(o => o.value)
            : this.selectionModel[0].value;
    }
    /**
     * Gives capability just write `multiple` over the element.
     * */
    get multiple() {
        return this._multiple;
    }
    set multiple(value) {
        this._multiple = convertToBoolProperty(value);
    }
    /**
     * Determines is select opened.
     * */
    get isOpen() {
        return this.ref && this.ref.hasAttached();
    }
    /**
     * Determines is select hidden.
     * */
    get isHidden() {
        return !this.isOpen;
    }
    /**
     * Returns width of the select button.
     * */
    get hostWidth() {
        return this.button.nativeElement.getBoundingClientRect().width;
    }
    get selectButtonClasses() {
        const classes = [];
        if (!this.selectionModel.length) {
            classes.push('placeholder');
        }
        if (!this.selectionModel.length && !this.placeholder) {
            classes.push('empty');
        }
        if (this.isOpen) {
            classes.push(this.overlayPosition);
        }
        return classes;
    }
    get optionsListClasses() {
        const classes = [
            `appearance-${this.appearance}`,
            `size-${this.size}`,
            `shape-${this.shape}`,
            `status-${this.status}`,
            this.overlayPosition,
        ];
        if (this.fullWidth) {
            classes.push('full-width');
        }
        return classes;
    }
    /**
     * Content rendered in the label.
     * */
    get selectionView() {
        if (this.selectionModel.length > 1) {
            return this.selectionModel.map((option) => option.content).join(', ');
        }
        return this.selectionModel[0].content;
    }
    ngAfterContentInit() {
        this.options.changes
            .pipe(takeWhile(() => this.alive), startWith(this.options), filter(() => this.queue != null && this.canSelectValue()))
            .subscribe(() => {
            // Call 'writeValue' when current change detection run is finished.
            // When writing is finished, change detection starts again, since
            // microtasks queue is empty.
            // Prevents ExpressionChangedAfterItHasBeenCheckedError.
            Promise.resolve().then(() => {
                this.writeValue(this.queue);
            });
        });
    }
    ngAfterViewInit() {
        this.triggerStrategy = this.createTriggerStrategy();
        this.subscribeOnTriggers();
        this.subscribeOnOptionClick();
    }
    ngOnDestroy() {
        this.alive = false;
        if (this.ref) {
            this.ref.dispose();
        }
        if (this.triggerStrategy) {
            this.triggerStrategy.destroy();
        }
    }
    show() {
        if (this.isHidden) {
            this.attachToOverlay();
            this.setActiveOption();
            this.cd.markForCheck();
        }
    }
    hide() {
        if (this.isOpen) {
            this.ref.detach();
            this.cd.markForCheck();
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.cd.markForCheck();
    }
    writeValue(value) {
        if (!this.alive) {
            return;
        }
        if (this.canSelectValue()) {
            this.setSelection(value);
            if (this.selectionModel.length) {
                this.queue = null;
            }
        }
        else {
            this.queue = value;
        }
    }
    /**
     * Selects option or clear all selected options if value is null.
     * */
    handleOptionClick(option) {
        this.queue = null;
        if (option.value == null) {
            this.reset();
        }
        else {
            this.selectOption(option);
        }
        this.cd.markForCheck();
    }
    /**
     * Deselect all selected options.
     * */
    reset() {
        this.selectionModel.forEach((option) => option.deselect());
        this.selectionModel = [];
        this.hide();
        this.button.nativeElement.focus();
        this.emitSelected(this.multiple ? [] : null);
    }
    /**
     * Determines how to select option as multiple or single.
     * */
    selectOption(option) {
        if (this.multiple) {
            this.handleMultipleSelect(option);
        }
        else {
            this.handleSingleSelect(option);
        }
    }
    /**
     * Select single option.
     * */
    handleSingleSelect(option) {
        const selected = this.selectionModel.pop();
        if (selected && selected !== option) {
            selected.deselect();
        }
        this.selectionModel = [option];
        option.select();
        this.hide();
        this.button.nativeElement.focus();
        this.emitSelected(option.value);
    }
    /**
     * Select for multiple options.
     * */
    handleMultipleSelect(option) {
        if (option.selected) {
            this.selectionModel = this.selectionModel.filter(s => s.value !== option.value);
            option.deselect();
        }
        else {
            this.selectionModel.push(option);
            option.select();
        }
        this.emitSelected(this.selectionModel.map((opt) => opt.value));
    }
    attachToOverlay() {
        if (!this.ref) {
            this.createOverlay();
            this.subscribeOnPositionChange();
            this.createKeyManager();
            this.subscribeOnOverlayKeys();
        }
        this.ref.attach(this.portal);
    }
    setActiveOption() {
        if (this.selectionModel.length) {
            this.keyManager.setActiveItem(this.selectionModel[0]);
        }
        else {
            this.keyManager.setFirstItemActive();
        }
    }
    createOverlay() {
        const scrollStrategy = this.createScrollStrategy();
        this.positionStrategy = this.createPositionStrategy();
        this.ref = this.overlay.create({ positionStrategy: this.positionStrategy, scrollStrategy });
    }
    createKeyManager() {
        this.keyManager = this.focusKeyManagerFactoryService.create(this.options).withTypeAhead(200);
    }
    createPositionStrategy() {
        return this.positionBuilder
            .connectedTo(this.button)
            .position(NbPosition.BOTTOM)
            .offset(0)
            .adjustment(NbAdjustment.VERTICAL);
    }
    createScrollStrategy() {
        return this.overlay.scrollStrategies.block();
    }
    createTriggerStrategy() {
        return this.triggerStrategyBuilder
            .trigger(NbTrigger.CLICK)
            .host(this.hostRef.nativeElement)
            .container(() => this.getContainer())
            .build();
    }
    subscribeOnTriggers() {
        this.triggerStrategy.show$.subscribe(() => this.show());
        this.triggerStrategy.hide$
            .pipe(filter(() => this.isOpen))
            .subscribe(($event) => {
            this.hide();
            if (!this.isClickedWithinComponent($event)) {
                this.onTouched();
            }
        });
    }
    subscribeOnPositionChange() {
        this.positionStrategy.positionChange
            .pipe(takeWhile(() => this.alive))
            .subscribe((position) => {
            this.overlayPosition = position;
            this.cd.detectChanges();
        });
    }
    subscribeOnOptionClick() {
        /**
         * If the user changes provided options list in the runtime we have to handle this
         * and resubscribe on options selection changes event.
         * Otherwise, the user will not be able to select new options.
         * */
        this.options.changes
            .pipe(startWith(this.options), switchMap((options) => {
            return merge(...options.map(option => option.click));
        }), takeWhile(() => this.alive))
            .subscribe((clickedOption) => this.handleOptionClick(clickedOption));
    }
    subscribeOnOverlayKeys() {
        this.ref.keydownEvents()
            .pipe(takeWhile(() => this.alive), filter(() => this.isOpen))
            .subscribe((event) => {
            if (event.keyCode === ESCAPE) {
                this.button.nativeElement.focus();
                this.hide();
            }
            else {
                this.keyManager.onKeydown(event);
            }
        });
        this.keyManager.tabOut
            .pipe(takeWhile(() => this.alive))
            .subscribe(() => {
            this.hide();
            this.onTouched();
        });
    }
    getContainer() {
        return this.ref && this.ref.hasAttached() && {
            location: {
                nativeElement: this.ref.overlayElement,
            },
        };
    }
    /**
     * Propagate selected value.
     * */
    emitSelected(selected) {
        this.onChange(selected);
        this.selectedChange.emit(selected);
    }
    /**
     * Set selected value in model.
     * */
    setSelection(value) {
        const isArray = Array.isArray(value);
        if (this.multiple && !isArray) {
            throw new Error('Can\'t assign single value if select is marked as multiple');
        }
        if (!this.multiple && isArray) {
            throw new Error('Can\'t assign array if select is not marked as multiple');
        }
        const previouslySelectedOptions = this.selectionModel;
        this.selectionModel = [];
        if (isArray) {
            value.forEach((option) => this.selectValue(option));
        }
        else {
            this.selectValue(value);
        }
        // find options which were selected before and trigger deselect
        previouslySelectedOptions
            .filter((option) => !this.selectionModel.includes(option))
            .forEach((option) => option.deselect());
        this.cd.markForCheck();
    }
    /**
     * Selects value.
     * */
    selectValue(value) {
        const corresponding = this.options.find((option) => option.value === value);
        if (corresponding) {
            corresponding.select();
            this.selectionModel.push(corresponding);
        }
    }
    /**
     * Sets touched if focus moved outside of button and overlay,
     * ignoring the case when focus moved to options overlay.
     */
    trySetTouched() {
        if (this.isHidden) {
            this.onTouched();
        }
    }
    isClickedWithinComponent($event) {
        return this.hostRef.nativeElement === $event.target || this.hostRef.nativeElement.contains($event.target);
    }
    canSelectValue() {
        return !!(this.options && this.options.length);
    }
    get tiny() {
        return this.size === 'tiny';
    }
    get small() {
        return this.size === 'small';
    }
    get medium() {
        return this.size === 'medium';
    }
    get large() {
        return this.size === 'large';
    }
    get giant() {
        return this.size === 'giant';
    }
    get primary() {
        return this.status === 'primary';
    }
    get info() {
        return this.status === 'info';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get rectangle() {
        return this.shape === 'rectangle';
    }
    get round() {
        return this.shape === 'round';
    }
    get semiRound() {
        return this.shape === 'semi-round';
    }
};
NbSelectComponent.ɵfac = function NbSelectComponent_Factory(t) { return new (t || NbSelectComponent)(ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NbOverlayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbPositionBuilderService), ɵngcc0.ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NbFocusKeyManagerFactoryService)); };
NbSelectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSelectComponent, selectors: [["nb-select"]], contentQueries: function NbSelectComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbSelectLabelComponent, true);
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbOptionComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customLabel = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);
    } }, viewQuery: function NbSelectComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbPortalDirective, true);
        ɵngcc0.ɵɵviewQuery(_c38, true, ElementRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.portal = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.button = _t.first);
    } }, hostVars: 40, hostBindings: function NbSelectComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("appearance-outline", ctx.outline)("appearance-filled", ctx.filled)("appearance-hero", ctx.hero)("full-width", ctx.fullWidth)("open", ctx.isOpen)("size-tiny", ctx.tiny)("size-small", ctx.small)("size-medium", ctx.medium)("size-large", ctx.large)("size-giant", ctx.giant)("status-primary", ctx.primary)("status-info", ctx.info)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-basic", ctx.basic)("status-control", ctx.control)("shape-rectangle", ctx.rectangle)("shape-round", ctx.round)("shape-semi-round", ctx.semiRound);
    } }, inputs: { size: "size", status: "status", shape: "shape", appearance: "appearance", placeholder: "placeholder", outline: "outline", filled: "filled", hero: "hero", disabled: "disabled", fullWidth: "fullWidth", selected: "selected", multiple: "multiple" }, outputs: { selectedChange: "selectedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbSelectComponent_1),
                multi: true
            },
            { provide: NB_SELECT_INJECTION_TOKEN, useExisting: NbSelectComponent_1 },
        ])], ngContentSelectors: _c40, decls: 7, vars: 4, consts: [["type", "button", 1, "select-button", 3, "disabled", "ngClass", "blur", "keydown.arrowDown", "keydown.arrowUp"], ["selectButton", ""], [4, "ngIf", "ngIfElse"], ["placeholderTemplate", ""], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 3, "click"], ["class", "options-list-container", 3, "ngClass", "width", 4, "nbPortal"], ["defaultSelectionTemplate", ""], [1, "options-list-container", 3, "ngClass"], [1, "options-list"]], template: function NbSelectComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c39);
        ɵngcc0.ɵɵelementStart(0, "button", 0, 1);
        ɵngcc0.ɵɵlistener("blur", function NbSelectComponent_Template_button_blur_0_listener() { return ctx.trySetTouched(); })("keydown.arrowDown", function NbSelectComponent_Template_button_keydown_arrowDown_0_listener() { return ctx.show(); })("keydown.arrowUp", function NbSelectComponent_Template_button_keydown_arrowUp_0_listener() { return ctx.show(); });
        ɵngcc0.ɵɵtemplate(2, NbSelectComponent_ng_container_2_Template, 4, 2, "ng-container", 2);
        ɵngcc0.ɵɵtemplate(3, NbSelectComponent_ng_template_3_Template, 1, 1, "ng-template", null, 3, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵelementStart(5, "nb-icon", 4);
        ɵngcc0.ɵɵlistener("click", function NbSelectComponent_Template_nb_icon_click_5_listener($event) { return ctx.disabled && $event.stopPropagation(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(6, NbSelectComponent_div_6_Template, 3, 5, "div", 5);
    } if (rf & 2) {
        const _r221 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("ngClass", ctx.selectButtonClasses);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.selectionModel.length)("ngIfElse", _r221);
    } }, directives: [ɵngcc2.NgClass, ɵngcc2.NgIf, NbIconComponent,
        NbPortalDirective], styles: ["[_nghost-%COMP%]{display:inline-block;max-width:100%}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:left}[dir=ltr]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:0.2em}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]{text-align:right}[dir=rtl]   [_nghost-%COMP%]   .select-button[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:0.2em}[_nghost-%COMP%]   .select-button.bottom[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0}[_nghost-%COMP%]   .select-button.top[_ngcontent-%COMP%]{border-top-left-radius:0;border-top-right-radius:0}.full-width[_nghost-%COMP%]{width:100%}.select-button[_ngcontent-%COMP%]{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap;transition-duration:0.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}nb-icon[_ngcontent-%COMP%]{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:0.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{right:.5rem}[dir=rtl][_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{left:.5rem}.open[_nghost-%COMP%]   nb-icon[_ngcontent-%COMP%]{transform:translateY(-50%) rotate(180deg)}"], changeDetection: 0 });
__decorate$135([
    Input(),
    __metadata$89("design:type", String)
], NbSelectComponent.prototype, "size", void 0);
__decorate$135([
    Input(),
    __metadata$89("design:type", String)
], NbSelectComponent.prototype, "status", void 0);
__decorate$135([
    Input(),
    __metadata$89("design:type", String)
], NbSelectComponent.prototype, "shape", void 0);
__decorate$135([
    Input(),
    __metadata$89("design:type", String)
], NbSelectComponent.prototype, "appearance", void 0);
__decorate$135([
    Input(),
    HostBinding('class.appearance-outline'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [Boolean])
], NbSelectComponent.prototype, "outline", null);
__decorate$135([
    Input(),
    HostBinding('class.appearance-filled'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [Boolean])
], NbSelectComponent.prototype, "filled", null);
__decorate$135([
    Input(),
    HostBinding('class.appearance-hero'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [Boolean])
], NbSelectComponent.prototype, "hero", null);
__decorate$135([
    Input(),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [Boolean])
], NbSelectComponent.prototype, "disabled", null);
__decorate$135([
    Input(),
    HostBinding('class.full-width'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [Boolean])
], NbSelectComponent.prototype, "fullWidth", null);
__decorate$135([
    Input(),
    __metadata$89("design:type", String)
], NbSelectComponent.prototype, "placeholder", void 0);
__decorate$135([
    Input(),
    __metadata$89("design:type", Object),
    __metadata$89("design:paramtypes", [Object])
], NbSelectComponent.prototype, "selected", null);
__decorate$135([
    Input(),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [Boolean])
], NbSelectComponent.prototype, "multiple", null);
__decorate$135([
    Output(),
    __metadata$89("design:type", EventEmitter)
], NbSelectComponent.prototype, "selectedChange", void 0);
__decorate$135([
    ContentChildren(NbOptionComponent, { descendants: true }),
    __metadata$89("design:type", QueryList)
], NbSelectComponent.prototype, "options", void 0);
__decorate$135([
    ContentChild(NbSelectLabelComponent, { static: false }),
    __metadata$89("design:type", Object)
], NbSelectComponent.prototype, "customLabel", void 0);
__decorate$135([
    ViewChild(NbPortalDirective, { static: false }),
    __metadata$89("design:type", NbPortalDirective)
], NbSelectComponent.prototype, "portal", void 0);
__decorate$135([
    ViewChild('selectButton', { read: ElementRef, static: false }),
    __metadata$89("design:type", ElementRef)
], NbSelectComponent.prototype, "button", void 0);
__decorate$135([
    HostBinding('class.open'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "isOpen", null);
__decorate$135([
    HostBinding('class.size-tiny'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "tiny", null);
__decorate$135([
    HostBinding('class.size-small'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "small", null);
__decorate$135([
    HostBinding('class.size-medium'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "medium", null);
__decorate$135([
    HostBinding('class.size-large'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "large", null);
__decorate$135([
    HostBinding('class.size-giant'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "giant", null);
__decorate$135([
    HostBinding('class.status-primary'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "primary", null);
__decorate$135([
    HostBinding('class.status-info'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "info", null);
__decorate$135([
    HostBinding('class.status-success'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "success", null);
__decorate$135([
    HostBinding('class.status-warning'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "warning", null);
__decorate$135([
    HostBinding('class.status-danger'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "danger", null);
__decorate$135([
    HostBinding('class.status-basic'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "basic", null);
__decorate$135([
    HostBinding('class.status-control'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "control", null);
__decorate$135([
    HostBinding('class.shape-rectangle'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "rectangle", null);
__decorate$135([
    HostBinding('class.shape-round'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "round", null);
__decorate$135([
    HostBinding('class.shape-semi-round'),
    __metadata$89("design:type", Boolean),
    __metadata$89("design:paramtypes", [])
], NbSelectComponent.prototype, "semiRound", null);
NbSelectComponent = NbSelectComponent_1 = __decorate$135([ __param$19(0, Inject(NB_DOCUMENT)),
    __metadata$89("design:paramtypes", [Object, NbOverlayService,
        ElementRef,
        NbPositionBuilderService,
        NbTriggerStrategyBuilderService,
        ChangeDetectorRef,
        NbFocusKeyManagerFactoryService])
], NbSelectComponent);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$137 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$91 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbOptionGroupComponent = class NbOptionGroupComponent {
    constructor() {
        this.alive = true;
        this._disabled = false;
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
        if (this.options) {
            this.updateOptionsDisabledState();
        }
    }
    get disabledAttribute() {
        return this.disabled ? '' : null;
    }
    ngAfterContentInit() {
        if (this.options.length) {
            this.asyncUpdateOptionsDisabledState();
        }
        this.options.changes
            .pipe(takeWhile(() => this.alive))
            .subscribe(() => this.asyncUpdateOptionsDisabledState());
    }
    ngOnDestroy() {
        this.alive = false;
    }
    /**
     * Sets disabled state for each option to current group disabled state.
     */
    updateOptionsDisabledState() {
        this.options.forEach((option) => option.setDisabledByGroupState(this.disabled));
    }
    /**
     * Updates options disabled state after promise resolution.
     * This way change detection will be triggered after options state updated.
     * Use this method when updating options during change detection run (e.g. QueryList.changes, lifecycle hooks).
     */
    asyncUpdateOptionsDisabledState() {
        Promise.resolve().then(() => this.updateOptionsDisabledState());
    }
};
NbOptionGroupComponent.ɵfac = function NbOptionGroupComponent_Factory(t) { return new (t || NbOptionGroupComponent)(); };
NbOptionGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbOptionGroupComponent, selectors: [["nb-option-group"]], contentQueries: function NbOptionGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbOptionComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);
    } }, hostVars: 1, hostBindings: function NbOptionGroupComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵattribute("disabled", ctx.disabledAttribute);
    } }, inputs: { disabled: "disabled", title: "title" }, ngContentSelectors: _c42, decls: 3, vars: 1, consts: [[1, "option-group-title"]], template: function NbOptionGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c41);
        ɵngcc0.ɵɵelementStart(0, "span", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵprojection(2);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ctx.title);
    } }, styles: ["[_nghost-%COMP%]{display:block}.option-group-title[_ngcontent-%COMP%]{display:block}"], changeDetection: 0 });
__decorate$137([
    Input(),
    __metadata$91("design:type", String)
], NbOptionGroupComponent.prototype, "title", void 0);
__decorate$137([
    Input(),
    __metadata$91("design:type", Boolean),
    __metadata$91("design:paramtypes", [Boolean])
], NbOptionGroupComponent.prototype, "disabled", null);
__decorate$137([
    HostBinding('attr.disabled'),
    __metadata$91("design:type", String),
    __metadata$91("design:paramtypes", [])
], NbOptionGroupComponent.prototype, "disabledAttribute", null);
__decorate$137([
    ContentChildren(NbOptionComponent, { descendants: true }),
    __metadata$91("design:type", QueryList)
], NbOptionGroupComponent.prototype, "options", void 0);

var __decorate$134 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const NB_SELECT_COMPONENTS = [
    NbSelectComponent,
    NbOptionComponent,
    NbOptionGroupComponent,
    NbSelectLabelComponent,
];
let NbSelectModule = class NbSelectModule {
};
NbSelectModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbSelectModule });
NbSelectModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbSelectModule_Factory(t) { return new (t || NbSelectModule)(); }, imports: [[
            NbSharedModule,
            NbOverlayModule,
            NbButtonModule,
            NbInputModule,
            NbCardModule,
            NbCheckboxModule,
            NbIconModule,
        ]] });

var NbWindowState;
(function (NbWindowState) {
    NbWindowState["MINIMIZED"] = "minimized";
    NbWindowState["MAXIMIZED"] = "maximized";
    NbWindowState["FULL_SCREEN"] = "full-screen";
})(NbWindowState || (NbWindowState = {}));
/**
 * Window configuration options.
 */
class NbWindowConfig {
    constructor(...configs) {
        /**
         * Window title.
         */
        this.title = '';
        /**
         * Initial window state. Full screen by default.
         */
        this.initialState = NbWindowState.FULL_SCREEN;
        /**
         * If true than backdrop will be rendered behind window.
         * By default set to true.
         */
        this.hasBackdrop = true;
        /**
         * If set to true mouse clicks on backdrop will close a window.
         * Default is true.
         */
        this.closeOnBackdropClick = true;
        /**
         * If true then escape press will close a window.
         * Default is true.
         */
        this.closeOnEsc = true;
        /**
         * Class to be applied to the window.
         */
        this.windowClass = '';
        /**
         * Both, template and component may receive data through `config.context` property.
         * For components, this data will be set as component properties.
         * For templates, you can access it inside template as $implicit.
         */
        this.context = {};
        /**
         * Where the attached component should live in Angular's *logical* component tree.
         * This affects what is available for injection and the change detection order for the
         * component instantiated inside of the window. This does not affect where the window
         * content will be rendered.
         */
        this.viewContainerRef = null;
        Object.assign(this, ...configs);
    }
}
const NB_WINDOW_CONTENT = new InjectionToken('Nebular Window Content');
const NB_WINDOW_CONFIG = new InjectionToken('Nebular Window Config');
const NB_WINDOW_CONTEXT = new InjectionToken('Nebular Window Context');

/**
 * The `NbWindowRef` helps to manipulate window after it was created.
 * The window can be dismissed by using `close` method of the windowRef.
 * You can access rendered component as `componentRef` property of the windowRef.
 */
class NbWindowRef {
    constructor(config) {
        this.config = config;
        this.stateChange$ = new ReplaySubject(1);
        this._closed = false;
        this.closed$ = new Subject();
        this.state = config.initialState;
    }
    /**
     * Current window state.
     */
    get state() {
        return this.stateValue;
    }
    set state(newState) {
        if (newState && this.stateValue !== newState) {
            this.prevStateValue = this.state;
            this.stateValue = newState;
            this.stateChange$.next({ oldState: this.prevStateValue, newState });
        }
    }
    /**
     * Emits when window state change.
     */
    get stateChange() {
        return this.stateChange$.asObservable();
    }
    /**
     * Emits when window was closed.
     */
    get onClose() {
        return this.closed$.asObservable();
    }
    /**
     * Minimize window.
     */
    minimize() {
        this.state = NbWindowState.MINIMIZED;
    }
    /**
     * Maximize window.
     */
    maximize() {
        this.state = NbWindowState.MAXIMIZED;
    }
    /**
     * Set window on top.
     */
    fullScreen() {
        this.state = NbWindowState.FULL_SCREEN;
    }
    toPreviousState() {
        this.state = this.prevStateValue;
    }
    /**
     * Closes window.
     * */
    close() {
        if (this._closed) {
            return;
        }
        this._closed = true;
        this.componentRef.destroy();
        this.stateChange$.complete();
        this.closed$.next();
        this.closed$.complete();
    }
}

var __decorate$140 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$93 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbWindowsContainerComponent = class NbWindowsContainerComponent {
};
NbWindowsContainerComponent.ɵfac = function NbWindowsContainerComponent_Factory(t) { return new (t || NbWindowsContainerComponent)(); };
NbWindowsContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbWindowsContainerComponent, selectors: [["nb-windows-container"]], viewQuery: function NbWindowsContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(_c43, true, ViewContainerRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.viewContainerRef = _t.first);
    } }, decls: 2, vars: 0, consts: [["viewContainerRef", ""]], template: function NbWindowsContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, null, 0);
    } }, styles: ["[_nghost-%COMP%]{display:flex;align-items:flex-end;overflow-x:auto}[_nghost-%COMP%]     nb-window:not(.full-screen){margin:0 2rem}"] });
__decorate$140([
    ViewChild('viewContainerRef', { read: ViewContainerRef, static: true }),
    __metadata$93("design:type", ViewContainerRef)
], NbWindowsContainerComponent.prototype, "viewContainerRef", void 0);

var __decorate$141 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$94 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$22 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
let NbWindowComponent = class NbWindowComponent {
    constructor(content, context, windowRef, config, focusTrapFactory, elementRef, renderer) {
        this.content = content;
        this.context = context;
        this.windowRef = windowRef;
        this.config = config;
        this.focusTrapFactory = focusTrapFactory;
        this.elementRef = elementRef;
        this.renderer = renderer;
    }
    get isFullScreen() {
        return this.windowRef.state === NbWindowState.FULL_SCREEN;
    }
    get maximized() {
        return this.windowRef.state === NbWindowState.MAXIMIZED;
    }
    get minimized() {
        return this.windowRef.state === NbWindowState.MINIMIZED;
    }
    ngOnInit() {
        this.focusTrap = this.focusTrapFactory.create(this.elementRef.nativeElement);
        this.focusTrap.blurPreviouslyFocusedElement();
        this.focusTrap.focusInitialElement();
        if (this.config.windowClass) {
            this.renderer.addClass(this.elementRef.nativeElement, this.config.windowClass);
        }
    }
    ngAfterViewChecked() {
        if (!this.overlayContainer || this.overlayContainer.isAttached) {
            return;
        }
        if (this.content instanceof TemplateRef) {
            this.attachTemplate();
        }
        else {
            this.attachComponent();
        }
    }
    ngOnDestroy() {
        if (this.focusTrap) {
            this.focusTrap.restoreFocus();
        }
        this.close();
    }
    minimize() {
        if (this.windowRef.state === NbWindowState.MINIMIZED) {
            this.windowRef.toPreviousState();
        }
        else {
            this.windowRef.minimize();
        }
    }
    maximize() {
        this.windowRef.maximize();
    }
    fullScreen() {
        this.windowRef.fullScreen();
    }
    maximizeOrFullScreen() {
        if (this.windowRef.state === NbWindowState.MINIMIZED) {
            this.maximize();
        }
        else {
            this.fullScreen();
        }
    }
    close() {
        this.windowRef.close();
    }
    attachTemplate() {
        this.overlayContainer
            .attachTemplatePortal(new NbTemplatePortal(this.content, null, this.context));
    }
    attachComponent() {
        const portal = new NbComponentPortal(this.content, null, null, this.cfr);
        const ref = this.overlayContainer.attachComponentPortal(portal, this.context);
        ref.changeDetectorRef.detectChanges();
    }
};
NbWindowComponent.ɵfac = function NbWindowComponent_Factory(t) { return new (t || NbWindowComponent)(ɵngcc0.ɵɵdirectiveInject(NB_WINDOW_CONTENT), ɵngcc0.ɵɵdirectiveInject(NB_WINDOW_CONTEXT), ɵngcc0.ɵɵdirectiveInject(NbWindowRef), ɵngcc0.ɵɵdirectiveInject(NbWindowConfig), ɵngcc0.ɵɵdirectiveInject(NbFocusTrapFactoryService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
NbWindowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbWindowComponent, selectors: [["nb-window"]], viewQuery: function NbWindowComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(NbOverlayContainerComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    } }, hostVars: 6, hostBindings: function NbWindowComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("full-screen", ctx.isFullScreen)("maximized", ctx.maximized)("minimized", ctx.minimized);
    } }, inputs: { cfr: "cfr" }, decls: 12, vars: 4, consts: [["cdkFocusInitial", "", "tabindex", "-1", 1, "title"], [1, "buttons"], ["nbButton", "", "ghost", "", 3, "click"], ["icon", "minus-outline", "pack", "nebular-essentials"], ["nbButton", "", "ghost", "", 3, "click", 4, "ngIf"], ["icon", "close-outline", "pack", "nebular-essentials"], [4, "ngIf"], ["icon", "collapse-outline", "pack", "nebular-essentials"], ["icon", "expand-outline", "pack", "nebular-essentials"]], template: function NbWindowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "nb-card");
        ɵngcc0.ɵɵelementStart(1, "nb-card-header");
        ɵngcc0.ɵɵelementStart(2, "div", 0);
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 1);
        ɵngcc0.ɵɵelementStart(5, "button", 2);
        ɵngcc0.ɵɵlistener("click", function NbWindowComponent_Template_button_click_5_listener() { return ctx.minimize(); });
        ɵngcc0.ɵɵelement(6, "nb-icon", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(7, NbWindowComponent_button_7_Template, 2, 0, "button", 4);
        ɵngcc0.ɵɵtemplate(8, NbWindowComponent_button_8_Template, 2, 0, "button", 4);
        ɵngcc0.ɵɵelementStart(9, "button", 2);
        ɵngcc0.ɵɵlistener("click", function NbWindowComponent_Template_button_click_9_listener() { return ctx.close(); });
        ɵngcc0.ɵɵelement(10, "nb-icon", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(11, NbWindowComponent_nb_card_body_11_Template, 2, 0, "nb-card-body", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵtextInterpolate(ctx.config.title);
        ɵngcc0.ɵɵadvance(4);
        ɵngcc0.ɵɵproperty("ngIf", ctx.isFullScreen);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.minimized || ctx.maximized);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.maximized || ctx.isFullScreen);
    } }, directives: [NbCardComponent,
        NbCardHeaderComponent,
        NbButtonComponent,
        NbIconComponent, ɵngcc2.NgIf, NbCardBodyComponent,
        NbOverlayContainerComponent], styles: ["[_nghost-%COMP%]{flex:1 0 auto;min-width:20rem}[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{margin:0}[_nghost-%COMP%]   nb-card-header[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;overflow:hidden}[_nghost-%COMP%]   .title[_ngcontent-%COMP%]{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]{width:9.5rem;display:flex;justify-content:space-evenly}[_nghost-%COMP%]   .buttons[_ngcontent-%COMP%]   [nbButton][_ngcontent-%COMP%]{flex:0 0 3rem}.full-screen[_nghost-%COMP%]{position:fixed;top:50%;left:50%;transform:translate(-50%, -50%)}.maximized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}.minimized[_nghost-%COMP%]   nb-card[_ngcontent-%COMP%]   nb-card-header[_ngcontent-%COMP%]{border-bottom:none}"] });
__decorate$141([
    Input(),
    __metadata$94("design:type", ComponentFactoryResolver)
], NbWindowComponent.prototype, "cfr", void 0);
__decorate$141([
    HostBinding('class.full-screen'),
    __metadata$94("design:type", Object),
    __metadata$94("design:paramtypes", [])
], NbWindowComponent.prototype, "isFullScreen", null);
__decorate$141([
    HostBinding('class.maximized'),
    __metadata$94("design:type", Object),
    __metadata$94("design:paramtypes", [])
], NbWindowComponent.prototype, "maximized", null);
__decorate$141([
    HostBinding('class.minimized'),
    __metadata$94("design:type", Object),
    __metadata$94("design:paramtypes", [])
], NbWindowComponent.prototype, "minimized", null);
__decorate$141([
    ViewChild(NbOverlayContainerComponent, { static: false }),
    __metadata$94("design:type", NbOverlayContainerComponent)
], NbWindowComponent.prototype, "overlayContainer", void 0);
NbWindowComponent = __decorate$141([ __param$22(0, Inject(NB_WINDOW_CONTENT)),
    __param$22(1, Inject(NB_WINDOW_CONTEXT)),
    __metadata$94("design:paramtypes", [Object, Object,
        NbWindowRef,
        NbWindowConfig,
        NbFocusTrapFactoryService,
        ElementRef,
        Renderer2])
], NbWindowComponent);

var __decorate$139 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$92 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$21 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * The `NbWindowService` can be used to open windows.
 *
 * @stacked-example(Showcase, window/window-showcase.component)
 *
 * ### Installation
 *
 * Import `NbWindowModule` to your app module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbWindowModule.forRoot(config),
 *   ],
 * })
 * export class AppModule { }
 * ```
 *
 * If you are using it in a lazy loaded module than you have to install `NbWindowModule.forChild`:
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbWindowModule.forChild(config),
 *   ],
 * })
 * export class LazyLoadedModule { }
 * ```
 *
 * ### Usage
 *
 * A new window can be opened by calling the `open` method with a component or template to be loaded
 * and an optional configuration.
 * `open` method will return `NbWindowRef` that can be used for the further manipulations.
 *
 * ```ts
 * const windowRef = this.windowService.open(MyComponent, { ... });
 * ```
 *
 * `NbWindowRef` gives you ability manipulate opened window.
 * Also, you can inject `NbWindowRef` inside provided component which rendered in window.
 *
 * ```ts
 * this.windowService.open(MyWindowComponent, { ... });
 *
 * // my.component.ts
 * constructor(protected windowRef: NbWindowRef) {
 * }
 *
 * minimize() {
 *   this.windowRef.minimize();
 * }
 *
 * close() {
 *   this.windowRef.close();
 * }
 * ```
 *
 * Instead of component you can create window from TemplateRef. As usual you can access context provided via config
 * via `let-` variables. Also you can get reference to the `NbWindowRef` in context's `windowRef` property.
 *
 * @stacked-example(Window content from TemplateRef, window/template-window.component)
 *
 * ### Configuration
 *
 * As mentioned above, `open` method of the `NbWindowService` may receive optional configuration options.
 * Also, you can modify default windows configuration through `NbWindowModule.forRoot({ ... })`.
 * You can read about all available options on [API tab](docs/components/window/api#nbwindowconfig).
 *
 * @stacked-example(Configuration, window/windows-backdrop.component)
 */
let NbWindowService = class NbWindowService {
    constructor(componentFactoryResolver, overlayService, overlayPositionBuilder, blockScrollStrategy, defaultWindowsConfig, cfr, document) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.overlayService = overlayService;
        this.overlayPositionBuilder = overlayPositionBuilder;
        this.blockScrollStrategy = blockScrollStrategy;
        this.defaultWindowsConfig = defaultWindowsConfig;
        this.cfr = cfr;
        this.openWindows = [];
        this.document = document;
    }
    /**
     * Opens new window.
     * @param windowContent
     * @param windowConfig
     * */
    open(windowContent, windowConfig = {}) {
        if (this.shouldCreateWindowsContainer()) {
            this.createWindowsContainer();
        }
        const config = new NbWindowConfig(this.defaultWindowsConfig, windowConfig);
        const windowRef = new NbWindowRef(config);
        windowRef.componentRef = this.appendWindow(windowContent, config, windowRef);
        this.openWindows.push(windowRef);
        this.subscribeToEvents(windowRef);
        return windowRef;
    }
    shouldCreateWindowsContainer() {
        if (this.windowsContainerViewRef) {
            const containerEl = this.windowsContainerViewRef.element.nativeElement;
            return !this.document.body.contains(containerEl);
        }
        return true;
    }
    createWindowsContainer() {
        if (this.overlayRef) {
            this.overlayRef.dispose();
        }
        this.overlayRef = this.overlayService.create({
            scrollStrategy: this.overlayService.scrollStrategies.noop(),
            positionStrategy: this.overlayPositionBuilder.global().bottom().right(),
            hasBackdrop: true,
        });
        const windowsContainerPortal = new NbComponentPortal(NbWindowsContainerComponent, null, null, this.cfr);
        const overlayRef = this.overlayRef.attach(windowsContainerPortal);
        this.windowsContainerViewRef = overlayRef.instance.viewContainerRef;
    }
    appendWindow(content, config, windowRef) {
        const context = content instanceof TemplateRef
            ? { $implicit: config.context, windowRef }
            : config.context;
        const providers = [
            { provide: NB_WINDOW_CONTENT, useValue: content },
            { provide: NB_WINDOW_CONTEXT, useValue: context },
            { provide: NbWindowConfig, useValue: config },
            { provide: NbWindowRef, useValue: windowRef },
        ];
        const parentInjector = config.viewContainerRef
            ? config.viewContainerRef.injector
            : this.windowsContainerViewRef.injector;
        const injector = Injector.create({ parent: parentInjector, providers });
        const windowFactory = this.componentFactoryResolver.resolveComponentFactory(NbWindowComponent);
        const ref = this.windowsContainerViewRef.createComponent(windowFactory, null, injector);
        ref.instance.cfr = this.cfr;
        ref.changeDetectorRef.detectChanges();
        return ref;
    }
    subscribeToEvents(windowRef) {
        if (windowRef.config.closeOnBackdropClick) {
            this.overlayRef.backdropClick().subscribe(() => windowRef.close());
        }
        if (windowRef.config.closeOnEsc) {
            this.overlayRef.keydownEvents()
                .pipe(filter((event) => event.keyCode === 27))
                .subscribe(() => windowRef.close());
        }
        windowRef.stateChange.subscribe(() => this.checkAndUpdateOverlay());
        windowRef.onClose.subscribe(() => {
            this.openWindows.splice(this.openWindows.indexOf(windowRef), 1);
            this.checkAndUpdateOverlay();
        });
    }
    checkAndUpdateOverlay() {
        const fullScreenWindows = this.openWindows.filter(w => w.state === NbWindowState.FULL_SCREEN);
        if (fullScreenWindows.length > 0) {
            this.blockScrollStrategy.enable();
        }
        else {
            this.blockScrollStrategy.disable();
        }
        if (fullScreenWindows.some(w => w.config.hasBackdrop)) {
            this.overlayRef.backdropElement.removeAttribute('hidden');
        }
        else {
            this.overlayRef.backdropElement.setAttribute('hidden', '');
        }
    }
};
NbWindowService.ɵfac = function NbWindowService_Factory(t) { return new (t || NbWindowService)(ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(NbOverlayService), ɵngcc0.ɵɵinject(NbOverlayPositionBuilder), ɵngcc0.ɵɵinject(NbBlockScrollStrategyAdapter), ɵngcc0.ɵɵinject(NB_WINDOW_CONFIG), ɵngcc0.ɵɵinject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵinject(NB_DOCUMENT)); };
NbWindowService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbWindowService, factory: NbWindowService.ɵfac });
NbWindowService = __decorate$139([ __param$21(4, Inject(NB_WINDOW_CONFIG)),
    __param$21(6, Inject(NB_DOCUMENT)),
    __metadata$92("design:paramtypes", [ComponentFactoryResolver,
        NbOverlayService,
        NbOverlayPositionBuilder,
        NbBlockScrollStrategyAdapter,
        NbWindowConfig,
        ComponentFactoryResolver, Object])
], NbWindowService);

var __decorate$138 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbWindowModule_1;
let NbWindowModule = NbWindowModule_1 = class NbWindowModule {
    static forRoot(defaultConfig) {
        return {
            ngModule: NbWindowModule_1,
            providers: [
                NbWindowService,
                { provide: NB_WINDOW_CONFIG, useValue: defaultConfig },
            ],
        };
    }
    static forChild(defaultConfig) {
        return {
            ngModule: NbWindowModule_1,
            providers: [
                NbWindowService,
                { provide: NB_WINDOW_CONFIG, useValue: defaultConfig },
            ],
        };
    }
};
NbWindowModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbWindowModule });
NbWindowModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbWindowModule_Factory(t) { return new (t || NbWindowModule)(); }, imports: [[CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule]] });

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$143 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$95 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$23 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NbDatepickerDirective_1;
/**
 * The `NbDatepickerAdapter` instances provide way how to parse, format and validate
 * different date types.
 * */
class NbDatepickerAdapter {
}
/**
 * Datepicker is an control that can pick any values anyway.
 * It has to be bound to the datepicker directive through nbDatepicker input.
 * */
class NbDatepicker {
}
const NB_DATE_ADAPTER = new InjectionToken('Datepicker Adapter');
const NB_DATE_SERVICE_OPTIONS = new InjectionToken('Date service options');
/**
 * The `NbDatepickerDirective` is form control that gives you ability to select dates and ranges. The datepicker
 * is shown when input receives a `focus` event.
 *
 * ```html
 * <input [nbDatepicker]="datepicker">
 * <nb-datepicker #datepicker></nb-datepicker>
 * ```
 *
 * @stacked-example(Showcase, datepicker/datepicker-showcase.component)
 *
 * ### Installation
 *
 * Import `NbDatepickerModule.forRoot()` to your root module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDatepickerModule.forRoot(),
 *   ],
 * })
 * export class AppModule { }
 * ```
 * And `NbDatepickerModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbDatepickerModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * If you want to use range selection, you have to use `NbRangepickerComponent` instead:
 *
 * ```html
 * <input [nbDatepicker]="rangepicker">
 * <nb-rangepicker #rangepicker></nb-rangepicker>
 * ```
 *
 * Both range and date pickers support all parameters as calendar, so, check `NbCalendarComponent` for additional
 * info.
 *
 * @stacked-example(Range showcase, datepicker/rangepicker-showcase.component)
 *
 * Datepicker is the form control so it can be bound with angular forms through ngModel and form controls.
 *
 * @stacked-example(Forms, datepicker/datepicker-forms.component)
 *
 * `NbDatepickerDirective` may be validated using `min` and `max` dates passed to the datepicker.
 * And `filter` predicate that receives date object and has to return a boolean value.
 *
 * @stacked-example(Validation, datepicker/datepicker-validation.component)
 *
 * The `NbDatepickerComponent` supports date formatting:
 *
 * ```html
 * <input [nbDatepicker]="datepicker">
 * <nb-datepicker #datepicker format="MM\dd\yyyy"></nb-datepicker>
 * ```
 *
 * ## Formatting Issue
 *
 * By default, datepicker uses angulars `LOCALE_ID` token for localization and `DatePipe` for dates formatting.
 * And native `Date.parse(...)` for dates parsing. But native `Date.parse` function doesn't support formats.
 * To provide custom formatting you have to use one of the following packages:
 *
 * - `@nebular/moment` - provides moment date adapter that uses moment for date objects. This means datepicker than
 * will operate only moment date objects. If you want to use it you have to install it: `npm i @nebular/moment`, and
 * import `NbMomentDateModule` from this package.
 *
 * - `@nebular/date-fns` - adapter for popular date-fns library. This way is preferred if you need only date formatting.
 * Because date-fns is treeshakable, tiny and operates native date objects. If you want to use it you have to
 * install it: `npm i @nebular/date-fns`, and import `NbDateFnsDateModule` from this package.
 *
 * ### NbDateFnsDateModule
 *
 * Format is required when using `NbDateFnsDateModule`. You can set it via `format` input on datepicker component:
 * ```html
 * <nb-datepicker format="dd.MM.yyyy"></nb-datepicker>
 * ```
 * Also format can be set globally with `NbDateFnsDateModule.forRoot({ format: 'dd.MM.yyyy' })` and
 * `NbDateFnsDateModule.forChild({ format: 'dd.MM.yyyy' })` methods.
 *
 * Please note to use some of the formatting tokens you also need to pass `{ awareOfUnicodeTokens: true }` to date-fns
 * parse and format functions. You can configure options passed this functions by setting `formatOptions` and
 * `parseOptions` of options object passed to `NbDateFnsDateModule.forRoot` and `NbDateFnsDateModule.forChild` methods.
 * ```ts
 * NbDateFnsDateModule.forRoot({
 *   parseOptions: { awareOfUnicodeTokens: true },
 *   formatOptions: { awareOfUnicodeTokens: true },
 * })
 * ```
 * Further info on `date-fns` formatting tokens could be found at
 * [date-fns docs](https://date-fns.org/v2.0.0-alpha.27/docs/Unicode-Tokens).
 *
 * You can also use `parseOptions` and `formatOptions` to provide locale.
 * ```ts
 * import { eo } from 'date-fns/locale';
 *
 * @NgModule({
 *   imports: [
 *     NbDateFnsDateModule.forRoot({
 *       parseOptions: { locale: eo },
 *       formatOptions: { locale: eo },
 *     }),
 *   ],
 * })
 * ```
 *
 * @styles
 *
 * datepicker-text-color:
 * datepicker-background-color:
 * datepicker-border-color:
 * datepicker-border-style:
 * datepicker-border-width:
 * datepicker-border-radius:
 * datepicker-shadow:
 * datepicker-arrow-size:
 * */
let NbDatepickerDirective = NbDatepickerDirective_1 = class NbDatepickerDirective {
    constructor(document, datepickerAdapters, hostRef, dateService, changeDetector) {
        this.document = document;
        this.datepickerAdapters = datepickerAdapters;
        this.hostRef = hostRef;
        this.dateService = dateService;
        this.changeDetector = changeDetector;
        this.alive = true;
        this.isDatepickerReady = false;
        this.onChange = () => { };
        this.onTouched = () => { };
        /**
         * Form control validators will be called in validators context, so, we need to bind them.
         * */
        this.validator = Validators.compose([
            this.parseValidator,
            this.minValidator,
            this.maxValidator,
            this.filterValidator,
        ].map(fn => fn.bind(this)));
        this.subscribeOnInputChange();
    }
    /**
     * Provides datepicker component.
     * */
    set setPicker(picker) {
        this.picker = picker;
        this.setupPicker();
    }
    /**
     * Returns html input element.
     * */
    get input() {
        return this.hostRef.nativeElement;
    }
    /**
     * Returns host input value.
     * */
    get inputValue() {
        return this.input.value;
    }
    ngOnDestroy() {
        this.alive = false;
    }
    /**
     * Writes value in picker and html input element.
     * */
    writeValue(value) {
        if (this.isDatepickerReady) {
            this.writePicker(value);
            this.writeInput(value);
        }
        else {
            this.queue = value;
        }
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    setDisabledState(isDisabled) {
        this.input.disabled = isDisabled;
    }
    /**
     * Form control validation based on picker validator config.
     * */
    validate() {
        return this.validator(null);
    }
    /**
     * Hides picker, focuses the input
     */
    hidePicker() {
        this.input.focus();
        this.picker.hide();
    }
    /**
     * Validates that we can parse value correctly.
     * */
    parseValidator() {
        /**
         * Date services treat empty string as invalid date.
         * That's why we're getting invalid formControl in case of empty input which is not required.
         * */
        if (this.inputValue === '') {
            return null;
        }
        const isValid = this.datepickerAdapter.isValid(this.inputValue, this.picker.format);
        return isValid ? null : { nbDatepickerParse: { value: this.inputValue } };
    }
    /**
     * Validates passed value is greater than min.
     * */
    minValidator() {
        const config = this.picker.getValidatorConfig();
        const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
        return (!config.min || !date || this.dateService.compareDates(config.min, date) <= 0) ?
            null : { nbDatepickerMin: { min: config.min, actual: date } };
    }
    /**
     * Validates passed value is smaller than max.
     * */
    maxValidator() {
        const config = this.picker.getValidatorConfig();
        const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
        return (!config.max || !date || this.dateService.compareDates(config.max, date) >= 0) ?
            null : { nbDatepickerMax: { max: config.max, actual: date } };
    }
    /**
     * Validates passed value satisfy the filter.
     * */
    filterValidator() {
        const config = this.picker.getValidatorConfig();
        const date = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
        return (!config.filter || !date || config.filter(date)) ?
            null : { nbDatepickerFilter: true };
    }
    /**
     * Chooses datepicker adapter based on passed picker component.
     * */
    chooseDatepickerAdapter() {
        this.datepickerAdapter = this.datepickerAdapters.find(({ picker }) => this.picker instanceof picker);
        if (this.noDatepickerAdapterProvided()) {
            throw new Error('No datepickerAdapter provided for picker');
        }
    }
    /**
     * Attaches picker to the host input element and subscribes on value changes.
     * */
    setupPicker() {
        this.chooseDatepickerAdapter();
        this.picker.attach(this.hostRef);
        if (this.inputValue) {
            this.picker.value = this.datepickerAdapter.parse(this.inputValue, this.picker.format);
        }
        // In case datepicker component placed after the input with datepicker directive,
        // we can't read `this.picker.format` on first change detection run,
        // since it's not bound yet, so we have to wait for datepicker component initialization.
        if (!this.isDatepickerReady) {
            this.picker.init
                .pipe(takeWhile(() => this.alive), take(1), tap(() => this.isDatepickerReady = true), filter(() => !!this.queue))
                .subscribe(() => {
                this.writeValue(this.queue);
                this.onChange(this.queue);
                this.changeDetector.detectChanges();
                this.queue = undefined;
            });
        }
        this.picker.valueChange
            .pipe(takeWhile(() => this.alive))
            .subscribe((value) => {
            this.writePicker(value);
            this.writeInput(value);
            this.onChange(value);
            if (this.picker.shouldHide()) {
                this.hidePicker();
            }
        });
        merge(this.picker.blur, fromEvent(this.input, 'blur').pipe(filter(() => !this.picker.isShown && this.document.activeElement !== this.input))).pipe(takeWhile(() => this.alive))
            .subscribe(() => this.onTouched());
    }
    writePicker(value) {
        this.picker.value = value;
    }
    writeInput(value) {
        const stringRepresentation = this.datepickerAdapter.format(value, this.picker.format);
        this.hostRef.nativeElement.value = stringRepresentation;
    }
    /**
     * Validates if no datepicker adapter provided.
     * */
    noDatepickerAdapterProvided() {
        return !this.datepickerAdapter || !(this.datepickerAdapter instanceof NbDatepickerAdapter);
    }
    subscribeOnInputChange() {
        fromEvent(this.input, 'input')
            .pipe(map(() => this.inputValue), takeWhile(() => this.alive))
            .subscribe((value) => this.handleInputChange(value));
    }
    /**
     * Parses input value and write if it isn't null.
     * */
    handleInputChange(value) {
        const date = this.parseInputValue(value);
        this.onChange(date);
        this.writePicker(date);
    }
    parseInputValue(value) {
        if (this.datepickerAdapter.isValid(value, this.picker.format)) {
            return this.datepickerAdapter.parse(value, this.picker.format);
        }
        return null;
    }
};
NbDatepickerDirective.ɵfac = function NbDatepickerDirective_Factory(t) { return new (t || NbDatepickerDirective)(ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NB_DATE_ADAPTER), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NbDateService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbDatepickerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbDatepickerDirective, selectors: [["input", "nbDatepicker", ""]], inputs: { setPicker: ["nbDatepicker", "setPicker"] }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbDatepickerDirective_1),
                multi: true
            },
            {
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => NbDatepickerDirective_1),
                multi: true
            },
        ])] });
__decorate$143([
    Input('nbDatepicker'),
    __metadata$95("design:type", NbDatepicker),
    __metadata$95("design:paramtypes", [NbDatepicker])
], NbDatepickerDirective.prototype, "setPicker", null);
NbDatepickerDirective = NbDatepickerDirective_1 = __decorate$143([ __param$23(0, Inject(NB_DOCUMENT)),
    __param$23(1, Inject(NB_DATE_ADAPTER)),
    __metadata$95("design:paramtypes", [Object, Array, ElementRef,
        NbDateService,
        ChangeDetectorRef])
], NbDatepickerDirective);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$144 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$96 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbDatepickerContainerComponent = class NbDatepickerContainerComponent extends NbPositionedContainer {
    attach(portal) {
        return this.overlayContainer.attachComponentPortal(portal);
    }
};
NbDatepickerContainerComponent.ɵfac = function NbDatepickerContainerComponent_Factory(t) { return ɵNbDatepickerContainerComponent_BaseFactory(t || NbDatepickerContainerComponent); };
NbDatepickerContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbDatepickerContainerComponent, selectors: [["nb-datepicker-container"]], viewQuery: function NbDatepickerContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵstaticViewQuery(NbOverlayContainerComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.overlayContainer = _t.first);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 0, consts: [[1, "arrow"]], template: function NbDatepickerContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0);
        ɵngcc0.ɵɵelement(1, "nb-overlay-container");
    } }, directives: [NbOverlayContainerComponent], styles: ["[_nghost-%COMP%]   .arrow[_ngcontent-%COMP%]{position:absolute;width:0;height:0}[_nghost-%COMP%]     nb-overlay-container .primitive-overlay{padding:0.75rem 1rem}"] });
__decorate$144([
    ViewChild(NbOverlayContainerComponent, { static: true }),
    __metadata$96("design:type", NbOverlayContainerComponent)
], NbDatepickerContainerComponent.prototype, "overlayContainer", void 0);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$145 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$97 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$24 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
/**
 * The `NbBasePicker` component concentrates overlay manipulation logic.
 * */
class NbBasePicker extends NbDatepicker {
    constructor(overlay, positionBuilder, triggerStrategyBuilder, cfr, dateService, dateServiceOptions) {
        super();
        this.overlay = overlay;
        this.positionBuilder = positionBuilder;
        this.triggerStrategyBuilder = triggerStrategyBuilder;
        this.cfr = cfr;
        this.dateService = dateService;
        this.dateServiceOptions = dateServiceOptions;
        /**
         * Size of the calendar and entire components.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        this.init$ = new ReplaySubject();
        /**
         * Stream of picker changes. Required to be the subject because picker hides and shows and picker
         * change stream becomes recreated.
         * */
        this.onChange$ = new Subject();
        this.alive = true;
        this.blur$ = new Subject();
    }
    /**
     * Returns picker instance.
     * */
    get picker() {
        return this.pickerRef && this.pickerRef.instance;
    }
    /**
     * Stream of picker value changes.
     * */
    get valueChange() {
        return this.onChange$.asObservable();
    }
    get isShown() {
        return this.ref && this.ref.hasAttached();
    }
    get init() {
        return this.init$.asObservable();
    }
    /**
     * Emits when datepicker looses focus.
     */
    get blur() {
        return this.blur$.asObservable();
    }
    ngOnInit() {
        this.checkFormat();
    }
    ngOnChanges(changes) {
        if (changes.format && !changes.format.isFirstChange()) {
            this.checkFormat();
        }
    }
    ngAfterViewInit() {
        this.init$.next();
    }
    ngOnDestroy() {
        this.alive = false;
        this.hide();
        this.init$.complete();
        if (this.ref) {
            this.ref.dispose();
        }
        if (this.triggerStrategy) {
            this.triggerStrategy.destroy();
        }
    }
    /**
     * Datepicker knows nothing about host html input element.
     * So, attach method attaches datepicker to the host input element.
     * */
    attach(hostRef) {
        this.hostRef = hostRef;
        this.subscribeOnTriggers();
    }
    getValidatorConfig() {
        return { min: this.min, max: this.max, filter: this.filter };
    }
    show() {
        if (!this.ref) {
            this.createOverlay();
        }
        this.openDatepicker();
    }
    shouldHide() {
        return this.hideOnSelect && !!this.value;
    }
    hide() {
        if (this.ref) {
            this.ref.detach();
        }
        // save current value if picker was rendered
        if (this.picker) {
            this.queue = this.value;
            this.pickerRef.destroy();
            this.pickerRef = null;
            this.container = null;
        }
    }
    createOverlay() {
        this.positionStrategy = this.createPositionStrategy();
        this.ref = this.overlay.create({
            positionStrategy: this.positionStrategy,
            scrollStrategy: this.overlay.scrollStrategies.reposition(),
        });
        this.subscribeOnPositionChange();
    }
    openDatepicker() {
        this.container = this.ref.attach(new NbComponentPortal(NbDatepickerContainerComponent, null, null, this.cfr));
        this.instantiatePicker();
        this.subscribeOnValueChange();
        this.writeQueue();
        this.patchWithInputs();
    }
    createPositionStrategy() {
        return this.positionBuilder
            .connectedTo(this.hostRef)
            .position(NbPosition.BOTTOM)
            .adjustment(NbAdjustment.COUNTERCLOCKWISE);
    }
    subscribeOnPositionChange() {
        this.positionStrategy.positionChange
            .pipe(takeWhile(() => this.alive))
            .subscribe((position) => patch(this.container, { position }));
    }
    createTriggerStrategy() {
        return this.triggerStrategyBuilder
            .trigger(NbTrigger.FOCUS)
            .host(this.hostRef.nativeElement)
            .container(() => this.container)
            .build();
    }
    subscribeOnTriggers() {
        this.triggerStrategy = this.createTriggerStrategy();
        this.triggerStrategy.show$.subscribe(() => this.show());
        this.triggerStrategy.hide$.subscribe(() => {
            this.blur$.next();
            this.hide();
        });
    }
    instantiatePicker() {
        this.pickerRef = this.container.instance.attach(new NbComponentPortal(this.pickerClass, null, null, this.cfr));
    }
    /**
     * Subscribes on picker value changes and emit data through this.onChange$ subject.
     * */
    subscribeOnValueChange() {
        this.pickerValueChange.subscribe(date => {
            this.onChange$.next(date);
        });
    }
    patchWithInputs() {
        this.picker.boundingMonth = this.boundingMonth;
        this.picker.startView = this.startView;
        this.picker.min = this.min;
        this.picker.max = this.max;
        this.picker.filter = this.filter;
        this.picker._cellComponent = this.dayCellComponent;
        this.picker.monthCellComponent = this.monthCellComponent;
        this.picker._yearCellComponent = this.yearCellComponent;
        this.picker.size = this.size;
        this.picker.showHeader = this.showHeader;
        this.picker.visibleDate = this.visibleDate;
        this.picker.showWeekNumber = this.showWeekNumber;
        this.picker.weekNumberSymbol = this.weekNumberSymbol;
    }
    checkFormat() {
        if (this.dateService.getId() === 'native' && this.format) {
            throw new Error('Can\'t format native date. To use custom formatting you have to install @nebular/moment or ' +
                '@nebular/date-fns package and import NbMomentDateModule or NbDateFnsDateModule accordingly.' +
                'More information at "Formatting issue" ' +
                'https://akveo.github.io/nebular/docs/components/datepicker/overview#nbdatepickercomponent');
        }
        const isFormatSet = this.format || (this.dateServiceOptions && this.dateServiceOptions.format);
        if (this.dateService.getId() === 'date-fns' && !isFormatSet) {
            throw new Error('format is required when using NbDateFnsDateModule');
        }
    }
}
NbBasePicker.ɵfac = function NbBasePicker_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
NbBasePicker.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbBasePicker, features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature()] });
let NbBasePickerComponent = class NbBasePickerComponent extends NbBasePicker {
    constructor(document, positionBuilder, triggerStrategyBuilder, overlay, cfr, dateService, dateServiceOptions) {
        super(overlay, positionBuilder, triggerStrategyBuilder, cfr, dateService, dateServiceOptions);
        /**
         * Defines if we should render previous and next months
         * in the current month view.
         * */
        this.boundingMonth = true;
        /**
         * Defines starting view for calendar.
         * */
        this.startView = NbCalendarViewMode.DATE;
        /**
         * Size of the calendar and entire components.
         * Can be 'medium' which is default or 'large'.
         * */
        this.size = NbCalendarSize.MEDIUM;
        /**
         * Hide picker when a date or a range is selected, `true` by default
         * @type {boolean}
         */
        this.hideOnSelect = true;
        /**
         * Determines should we show calendars header or not.
         * @type {boolean}
         */
        this.showHeader = true;
        /**
         * Sets symbol used as a header for week numbers column
         * */
        this.weekNumberSymbol = '#';
        this._showWeekNumber = false;
    }
    /**
     * Determines should we show week numbers column.
     * False by default.
     * */
    get showWeekNumber() {
        return this._showWeekNumber;
    }
    set showWeekNumber(value) {
        this._showWeekNumber = convertToBoolProperty(value);
    }
    get pickerValueChange() {
        return;
    }
    get value() {
        return undefined;
    }
    set value(value) { }
    writeQueue() {
    }
};
NbBasePickerComponent.ɵfac = function NbBasePickerComponent_Factory(t) { return new (t || NbBasePickerComponent)(ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NbPositionBuilderService), ɵngcc0.ɵɵdirectiveInject(NbTriggerStrategyBuilderService), ɵngcc0.ɵɵdirectiveInject(NbOverlayService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(NbDateService), ɵngcc0.ɵɵdirectiveInject(NB_DATE_SERVICE_OPTIONS, 8)); };
NbBasePickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbBasePickerComponent, selectors: [["ng-component"]], inputs: { boundingMonth: "boundingMonth", startView: "startView", size: "size", hideOnSelect: "hideOnSelect", showHeader: "showHeader", weekNumberSymbol: "weekNumberSymbol", showWeekNumber: "showWeekNumber", format: "format", min: "min", max: "max", filter: "filter", dayCellComponent: "dayCellComponent", monthCellComponent: "monthCellComponent", yearCellComponent: "yearCellComponent", visibleDate: "visibleDate" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NbBasePickerComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate$145([
    Input(),
    __metadata$97("design:type", String)
], NbBasePickerComponent.prototype, "format", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", Boolean)
], NbBasePickerComponent.prototype, "boundingMonth", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", String)
], NbBasePickerComponent.prototype, "startView", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", Object)
], NbBasePickerComponent.prototype, "min", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", Object)
], NbBasePickerComponent.prototype, "max", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", Function)
], NbBasePickerComponent.prototype, "filter", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", Type)
], NbBasePickerComponent.prototype, "dayCellComponent", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", Type)
], NbBasePickerComponent.prototype, "monthCellComponent", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", Type)
], NbBasePickerComponent.prototype, "yearCellComponent", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", String)
], NbBasePickerComponent.prototype, "size", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", Object)
], NbBasePickerComponent.prototype, "visibleDate", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", Boolean)
], NbBasePickerComponent.prototype, "hideOnSelect", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", Boolean)
], NbBasePickerComponent.prototype, "showHeader", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", String)
], NbBasePickerComponent.prototype, "weekNumberSymbol", void 0);
__decorate$145([
    Input(),
    __metadata$97("design:type", Boolean),
    __metadata$97("design:paramtypes", [Boolean])
], NbBasePickerComponent.prototype, "showWeekNumber", null);
NbBasePickerComponent = __decorate$145([ __param$24(0, Inject(NB_DOCUMENT)),
    __param$24(6, Optional()), __param$24(6, Inject(NB_DATE_SERVICE_OPTIONS)),
    __metadata$97("design:paramtypes", [Object, NbPositionBuilderService,
        NbTriggerStrategyBuilderService,
        NbOverlayService,
        ComponentFactoryResolver,
        NbDateService, Object])
], NbBasePickerComponent);
/**
 * The DatePicker components itself.
 * Provides a proxy to `NbCalendar` options as well as custom picker options.
 */
let NbDatepickerComponent = class NbDatepickerComponent extends NbBasePickerComponent {
    /**
     * The DatePicker components itself.
     * Provides a proxy to `NbCalendar` options as well as custom picker options.
     */
    constructor() {
        super(...arguments);
        this.pickerClass = NbCalendarComponent;
    }
    /**
     * Date which will be rendered as selected.
     * */
    set date(date) {
        this.value = date;
    }
    /**
     * Emits date when selected.
     * */
    get dateChange() {
        return this.valueChange;
    }
    get value() {
        return this.picker ? this.picker.date : undefined;
    }
    set value(date) {
        if (!this.picker) {
            this.queue = date;
            return;
        }
        if (date) {
            this.visibleDate = date;
            this.picker.visibleDate = date;
            this.picker.date = date;
        }
    }
    get pickerValueChange() {
        return this.picker.dateChange;
    }
    writeQueue() {
        if (this.queue) {
            const date = this.queue;
            this.queue = null;
            this.value = date;
        }
    }
};
NbDatepickerComponent.ɵfac = function NbDatepickerComponent_Factory(t) { return ɵNbDatepickerComponent_BaseFactory(t || NbDatepickerComponent); };
NbDatepickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbDatepickerComponent, selectors: [["nb-datepicker"]], inputs: { date: "date" }, outputs: { dateChange: "dateChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NbDatepickerComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate$145([
    Input(),
    __metadata$97("design:type", Object),
    __metadata$97("design:paramtypes", [Object])
], NbDatepickerComponent.prototype, "date", null);
__decorate$145([
    Output(),
    __metadata$97("design:type", EventEmitter),
    __metadata$97("design:paramtypes", [])
], NbDatepickerComponent.prototype, "dateChange", null);
/**
 * The RangeDatePicker components itself.
 * Provides a proxy to `NbCalendarRange` options as well as custom picker options.
 */
let NbRangepickerComponent = class NbRangepickerComponent extends NbBasePickerComponent {
    /**
     * The RangeDatePicker components itself.
     * Provides a proxy to `NbCalendarRange` options as well as custom picker options.
     */
    constructor() {
        super(...arguments);
        this.pickerClass = NbCalendarRangeComponent;
    }
    /**
     * Range which will be rendered as selected.
     * */
    set range(range) {
        this.value = range;
    }
    /**
     * Emits range when start selected and emits again when end selected.
     * */
    get rangeChange() {
        return this.valueChange;
    }
    get value() {
        return this.picker ? this.picker.range : undefined;
    }
    set value(range) {
        if (!this.picker) {
            this.queue = range;
            return;
        }
        if (range) {
            const visibleDate = range && range.start;
            this.visibleDate = visibleDate;
            this.picker.visibleDate = visibleDate;
            this.picker.range = range;
        }
    }
    get pickerValueChange() {
        return this.picker.rangeChange;
    }
    shouldHide() {
        return super.shouldHide() && !!(this.value && this.value.start && this.value.end);
    }
    writeQueue() {
        if (this.queue) {
            const range = this.queue;
            this.queue = null;
            this.value = range;
        }
    }
};
NbRangepickerComponent.ɵfac = function NbRangepickerComponent_Factory(t) { return ɵNbRangepickerComponent_BaseFactory(t || NbRangepickerComponent); };
NbRangepickerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRangepickerComponent, selectors: [["nb-rangepicker"]], inputs: { range: "range" }, outputs: { rangeChange: "rangeChange" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NbRangepickerComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate$145([
    Input(),
    __metadata$97("design:type", Object),
    __metadata$97("design:paramtypes", [Object])
], NbRangepickerComponent.prototype, "range", null);
__decorate$145([
    Output(),
    __metadata$97("design:type", EventEmitter),
    __metadata$97("design:paramtypes", [])
], NbRangepickerComponent.prototype, "rangeChange", null);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$146 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$98 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbDateAdapterService = class NbDateAdapterService extends NbDatepickerAdapter {
    constructor(dateService) {
        super();
        this.dateService = dateService;
        this.picker = NbDatepickerComponent;
    }
    parse(date, format) {
        return this.dateService.parse(date, format);
    }
    format(date, format) {
        return this.dateService.format(date, format);
    }
    isValid(date, format) {
        return this.dateService.isValidDateString(date, format);
    }
};
NbDateAdapterService.ɵfac = function NbDateAdapterService_Factory(t) { return new (t || NbDateAdapterService)(ɵngcc0.ɵɵinject(NbDateService)); };
NbDateAdapterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbDateAdapterService, factory: NbDateAdapterService.ɵfac });
NbDateAdapterService = __decorate$146([ __metadata$98("design:paramtypes", [NbDateService])
], NbDateAdapterService);
let NbRangeAdapterService = class NbRangeAdapterService extends NbDatepickerAdapter {
    constructor(dateService) {
        super();
        this.dateService = dateService;
        this.picker = NbRangepickerComponent;
    }
    parse(range, format) {
        const [start, end] = range.split('-').map(subDate => subDate.trim());
        return {
            start: this.dateService.parse(start, format),
            end: this.dateService.parse(end, format),
        };
    }
    format(range, format) {
        if (!range) {
            return '';
        }
        const start = this.dateService.format(range.start, format);
        const isStartValid = this.dateService.isValidDateString(start, format);
        if (!isStartValid) {
            return '';
        }
        const end = this.dateService.format(range.end, format);
        const isEndValid = this.dateService.isValidDateString(end, format);
        if (isEndValid) {
            return `${start} - ${end}`;
        }
        else {
            return start;
        }
    }
    isValid(range, format) {
        const [start, end] = range.split('-').map(subDate => subDate.trim());
        return this.dateService.isValidDateString(start, format) && this.dateService.isValidDateString(end, format);
    }
};
NbRangeAdapterService.ɵfac = function NbRangeAdapterService_Factory(t) { return new (t || NbRangeAdapterService)(ɵngcc0.ɵɵinject(NbDateService)); };
NbRangeAdapterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbRangeAdapterService, factory: NbRangeAdapterService.ɵfac });
NbRangeAdapterService = __decorate$146([ __metadata$98("design:paramtypes", [NbDateService])
], NbRangeAdapterService);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$142 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var NbDatepickerModule_1;
let NbDatepickerModule = NbDatepickerModule_1 = class NbDatepickerModule {
    static forRoot() {
        return {
            ngModule: NbDatepickerModule_1,
            providers: [
                DatePipe,
                {
                    provide: NB_DATE_ADAPTER,
                    multi: true,
                    useClass: NbDateAdapterService,
                },
                {
                    provide: NB_DATE_ADAPTER,
                    multi: true,
                    useClass: NbRangeAdapterService,
                },
            ],
        };
    }
};
NbDatepickerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbDatepickerModule });
NbDatepickerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbDatepickerModule_Factory(t) { return new (t || NbDatepickerModule)(); }, imports: [[NbOverlayModule, NbCalendarModule, NbCalendarRangeModule]] });

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$148 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$99 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * The `NbRadioComponent` provides the same functionality as native `<input type="radio">`
 * with Nebular styles and animations.
 *
 * @stacked-example(Showcase, radio/radio-showcase.component)
 *
 * ### Installation
 *
 * Import `NbRadioModule` to your feature module.
 *
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbRadioModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * ### Usage
 *
 * Radio buttons should be wrapped in `nb-radio-group` to provide form bindings.
 *
 * ```html
 * <nb-radio-group [(ngModel)]="selectedOption">
 *   <nb-radio value="1">Option 1</nb-radio>
 *   <nb-radio value="2">Option 2</nb-radio>
 *   <nb-radio value="3">Option 3</nb-radio>
 * </nb-radio-group>
 * ```
 *
 * You can disable some radios in the group using a `disabled` attribute.
 *
 * @stacked-example(Disabled, radio/radio-disabled.component)
 *
 *
 * @styles
 *
 * radio-width:
 * radio-height:
 * radio-border-style:
 * radio-border-width:
 * radio-text-font-family:
 * radio-text-font-size:
 * radio-text-font-weight:
 * radio-text-line-height:
 * radio-outline-color:
 * radio-outline-width:
 * radio-basic-text-color:
 * radio-basic-border-color:
 * radio-basic-background-color:
 * radio-basic-checked-background-color:
 * radio-basic-checked-border-color:
 * radio-basic-inner-circle-color:
 * radio-basic-focus-border-color:
 * radio-basic-focus-inner-circle-color:
 * radio-basic-hover-background-color:
 * radio-basic-hover-border-color:
 * radio-basic-hover-inner-circle-color:
 * radio-basic-hover-checked-background-color:
 * radio-basic-active-border-color:
 * radio-basic-active-inner-circle-color:
 * radio-basic-disabled-background-color:
 * radio-basic-disabled-border-color:
 * radio-basic-disabled-text-color:
 * radio-basic-disabled-checked-background-color:
 * radio-basic-disabled-checked-border-color:
 * radio-basic-disabled-checked-inner-circle-color:
 * radio-primary-text-color:
 * radio-primary-border-color:
 * radio-primary-background-color:
 * radio-primary-checked-background-color:
 * radio-primary-checked-border-color:
 * radio-primary-inner-circle-color:
 * radio-primary-focus-border-color:
 * radio-primary-focus-inner-circle-color:
 * radio-primary-hover-background-color:
 * radio-primary-hover-border-color:
 * radio-primary-hover-inner-circle-color:
 * radio-primary-hover-checked-background-color:
 * radio-primary-active-border-color:
 * radio-primary-active-inner-circle-color:
 * radio-primary-disabled-background-color:
 * radio-primary-disabled-border-color:
 * radio-primary-disabled-text-color:
 * radio-primary-disabled-checked-background-color:
 * radio-primary-disabled-checked-border-color:
 * radio-primary-disabled-checked-inner-circle-color:
 * radio-success-text-color:
 * radio-success-border-color:
 * radio-success-background-color:
 * radio-success-checked-background-color:
 * radio-success-checked-border-color:
 * radio-success-inner-circle-color:
 * radio-success-focus-border-color:
 * radio-success-focus-inner-circle-color:
 * radio-success-hover-background-color:
 * radio-success-hover-border-color:
 * radio-success-hover-inner-circle-color:
 * radio-success-hover-checked-background-color:
 * radio-success-active-border-color:
 * radio-success-active-inner-circle-color:
 * radio-success-disabled-background-color:
 * radio-success-disabled-border-color:
 * radio-success-disabled-text-color:
 * radio-success-disabled-checked-background-color:
 * radio-success-disabled-checked-border-color:
 * radio-success-disabled-checked-inner-circle-color:
 * radio-info-text-color:
 * radio-info-border-color:
 * radio-info-background-color:
 * radio-info-checked-background-color:
 * radio-info-checked-border-color:
 * radio-info-inner-circle-color:
 * radio-info-focus-border-color:
 * radio-info-focus-inner-circle-color:
 * radio-info-hover-background-color:
 * radio-info-hover-border-color:
 * radio-info-hover-inner-circle-color:
 * radio-info-hover-checked-background-color:
 * radio-info-active-border-color:
 * radio-info-active-inner-circle-color:
 * radio-info-disabled-background-color:
 * radio-info-disabled-border-color:
 * radio-info-disabled-text-color:
 * radio-info-disabled-checked-background-color:
 * radio-info-disabled-checked-border-color:
 * radio-info-disabled-checked-inner-circle-color:
 * radio-warning-text-color:
 * radio-warning-border-color:
 * radio-warning-background-color:
 * radio-warning-checked-background-color:
 * radio-warning-checked-border-color:
 * radio-warning-inner-circle-color:
 * radio-warning-focus-border-color:
 * radio-warning-focus-inner-circle-color:
 * radio-warning-hover-background-color:
 * radio-warning-hover-border-color:
 * radio-warning-hover-inner-circle-color:
 * radio-warning-hover-checked-background-color:
 * radio-warning-active-border-color:
 * radio-warning-active-inner-circle-color:
 * radio-warning-disabled-background-color:
 * radio-warning-disabled-border-color:
 * radio-warning-disabled-text-color:
 * radio-warning-disabled-checked-background-color:
 * radio-warning-disabled-checked-border-color:
 * radio-warning-disabled-checked-inner-circle-color:
 * radio-danger-text-color:
 * radio-danger-border-color:
 * radio-danger-background-color:
 * radio-danger-checked-background-color:
 * radio-danger-checked-border-color:
 * radio-danger-inner-circle-color:
 * radio-danger-focus-border-color:
 * radio-danger-focus-inner-circle-color:
 * radio-danger-hover-background-color:
 * radio-danger-hover-border-color:
 * radio-danger-hover-inner-circle-color:
 * radio-danger-hover-checked-background-color:
 * radio-danger-active-border-color:
 * radio-danger-active-inner-circle-color:
 * radio-danger-disabled-background-color:
 * radio-danger-disabled-border-color:
 * radio-danger-disabled-text-color:
 * radio-danger-disabled-checked-background-color:
 * radio-danger-disabled-checked-border-color:
 * radio-danger-disabled-checked-inner-circle-color:
 * radio-control-text-color:
 * radio-control-background-color:
 * radio-control-border-color:
 * radio-control-checked-background-color:
 * radio-control-checked-border-color:
 * radio-control-inner-circle-color:
 * radio-control-focus-border-color:
 * radio-control-focus-inner-circle-color:
 * radio-control-hover-background-color:
 * radio-control-hover-border-color:
 * radio-control-hover-inner-circle-color:
 * radio-control-hover-checked-background-color:
 * radio-control-active-border-color:
 * radio-control-active-inner-circle-color:
 * radio-control-disabled-background-color:
 * radio-control-disabled-border-color:
 * radio-control-disabled-text-color:
 * radio-control-disabled-checked-background-color:
 * radio-control-disabled-checked-border-color:
 * radio-control-disabled-checked-inner-circle-color:
 * */
let NbRadioComponent = class NbRadioComponent {
    constructor(cd) {
        this.cd = cd;
        this._checked = false;
        this._disabled = false;
        this._status = 'basic';
        this.valueChange = new EventEmitter();
        this.blur = new EventEmitter();
    }
    get name() {
        return this._name;
    }
    set name(value) {
        if (this._name !== value) {
            this._name = value;
            this.cd.detectChanges();
        }
    }
    get checked() {
        return this._checked;
    }
    set checked(value) {
        const boolValue = convertToBoolProperty(value);
        if (this._checked !== boolValue) {
            this._checked = boolValue;
            this.cd.markForCheck();
        }
    }
    get value() {
        return this._value;
    }
    set value(value) {
        if (this._value !== value) {
            this._value = value;
            this.cd.markForCheck();
        }
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(disabled) {
        const boolValue = convertToBoolProperty(disabled);
        if (this._disabled !== boolValue) {
            this._disabled = boolValue;
            this.cd.markForCheck();
        }
    }
    get status() {
        return this._status;
    }
    set status(value) {
        if (value === '') {
            emptyStatusWarning('NbRadio');
            value = 'basic';
        }
        if (this._status !== value) {
            this._status = value;
            this.cd.markForCheck();
        }
    }
    get isPrimary() {
        return this.status === 'primary';
    }
    get isSuccess() {
        return this.status === 'success';
    }
    get isWarning() {
        return this.status === 'warning';
    }
    get isDanger() {
        return this.status === 'danger';
    }
    get isInfo() {
        return this.status === 'info';
    }
    get isBasic() {
        return this.status === 'basic';
    }
    get isControl() {
        return this.status === 'control';
    }
    onChange(event) {
        event.stopPropagation();
        this.checked = true;
        this.valueChange.emit(this.value);
    }
    onClick(event) {
        event.stopPropagation();
    }
};
NbRadioComponent.ɵfac = function NbRadioComponent_Factory(t) { return new (t || NbRadioComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbRadioComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRadioComponent, selectors: [["nb-radio"]], hostVars: 14, hostBindings: function NbRadioComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("status-primary", ctx.isPrimary)("status-success", ctx.isSuccess)("status-warning", ctx.isWarning)("status-danger", ctx.isDanger)("status-info", ctx.isInfo)("status-basic", ctx.isBasic)("status-control", ctx.isControl);
    } }, inputs: { name: "name", checked: "checked", value: "value", disabled: "disabled", status: "status" }, outputs: { valueChange: "valueChange", blur: "blur" }, ngContentSelectors: _c0, decls: 6, vars: 4, consts: [["type", "radio", 1, "native-input", "visually-hidden", 3, "name", "value", "checked", "disabled", "change", "click"], [1, "outer-circle"], [1, "inner-circle"], [1, "text"]], template: function NbRadioComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label");
        ɵngcc0.ɵɵelementStart(1, "input", 0);
        ɵngcc0.ɵɵlistener("change", function NbRadioComponent_Template_input_change_1_listener($event) { return ctx.onChange($event); })("click", function NbRadioComponent_Template_input_click_1_listener($event) { return ctx.onClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(2, "span", 1);
        ɵngcc0.ɵɵelement(3, "span", 2);
        ɵngcc0.ɵɵelementStart(4, "span", 3);
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("name", ctx.name)("value", ctx.value)("checked", ctx.checked)("disabled", ctx.disabled);
    } }, styles: ["[_nghost-%COMP%]{display:block;position:relative}[_nghost-%COMP%]   label[_ngcontent-%COMP%]{display:inline-flex;margin:0;min-height:inherit;padding:0.375rem 0;align-items:center}[dir=ltr]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-right:1.5rem}[dir=rtl]   [_nghost-%COMP%]   label[_ngcontent-%COMP%]{padding-left:1.5rem}[_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=ltr]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{left:0}[dir=rtl]   [_nghost-%COMP%]   .outer-circle[_ngcontent-%COMP%], [dir=rtl]   [_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{right:0}[_nghost-%COMP%]   .inner-circle[_ngcontent-%COMP%]{transform:translateY(-50%) scale(0.65)}[dir=ltr]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-left:.5rem}[dir=rtl]   [_nghost-%COMP%]   .text[_ngcontent-%COMP%]{padding-right:.5rem}"], changeDetection: 0 });
__decorate$148([
    Input(),
    __metadata$99("design:type", String),
    __metadata$99("design:paramtypes", [String])
], NbRadioComponent.prototype, "name", null);
__decorate$148([
    Input(),
    __metadata$99("design:type", Boolean),
    __metadata$99("design:paramtypes", [Boolean])
], NbRadioComponent.prototype, "checked", null);
__decorate$148([
    Input(),
    __metadata$99("design:type", Object),
    __metadata$99("design:paramtypes", [Object])
], NbRadioComponent.prototype, "value", null);
__decorate$148([
    Input(),
    __metadata$99("design:type", Boolean),
    __metadata$99("design:paramtypes", [Boolean])
], NbRadioComponent.prototype, "disabled", null);
__decorate$148([
    Input(),
    __metadata$99("design:type", String),
    __metadata$99("design:paramtypes", [String])
], NbRadioComponent.prototype, "status", null);
__decorate$148([
    Output(),
    __metadata$99("design:type", EventEmitter)
], NbRadioComponent.prototype, "valueChange", void 0);
__decorate$148([
    Output(),
    __metadata$99("design:type", EventEmitter)
], NbRadioComponent.prototype, "blur", void 0);
__decorate$148([
    HostBinding('class.status-primary'),
    __metadata$99("design:type", Boolean),
    __metadata$99("design:paramtypes", [])
], NbRadioComponent.prototype, "isPrimary", null);
__decorate$148([
    HostBinding('class.status-success'),
    __metadata$99("design:type", Boolean),
    __metadata$99("design:paramtypes", [])
], NbRadioComponent.prototype, "isSuccess", null);
__decorate$148([
    HostBinding('class.status-warning'),
    __metadata$99("design:type", Boolean),
    __metadata$99("design:paramtypes", [])
], NbRadioComponent.prototype, "isWarning", null);
__decorate$148([
    HostBinding('class.status-danger'),
    __metadata$99("design:type", Boolean),
    __metadata$99("design:paramtypes", [])
], NbRadioComponent.prototype, "isDanger", null);
__decorate$148([
    HostBinding('class.status-info'),
    __metadata$99("design:type", Boolean),
    __metadata$99("design:paramtypes", [])
], NbRadioComponent.prototype, "isInfo", null);
__decorate$148([
    HostBinding('class.status-basic'),
    __metadata$99("design:type", Boolean),
    __metadata$99("design:paramtypes", [])
], NbRadioComponent.prototype, "isBasic", null);
__decorate$148([
    HostBinding('class.status-control'),
    __metadata$99("design:type", Boolean),
    __metadata$99("design:paramtypes", [])
], NbRadioComponent.prototype, "isControl", null);
NbRadioComponent = __decorate$148([ __metadata$99("design:paramtypes", [ChangeDetectorRef])
], NbRadioComponent);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$149 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$100 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$25 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NbRadioGroupComponent_1;
/**
 * The `NbRadioGroupComponent` is the wrapper for `nb-radio` button.
 * It provides form bindings:
 *
 * ```html
 * <nb-radio-group [(ngModel)]="selectedOption">
 *   <nb-radio value="1">Option 1</nb-radio>
 *   <nb-radio value="2">Option 2</nb-radio>
 *   <nb-radio value="3">Option 3</nb-radio>
 * </nb-radio-group>
 * ```
 *
 * Also, you can use `value` and `valueChange` for binding without forms.
 *
 * ```html
 * <nb-radio-group [(value)]="selectedOption">
 *   <nb-radio value="1">Option 1</nb-radio>
 *   <nb-radio value="2">Option 2</nb-radio>
 *   <nb-radio value="3">Option 3</nb-radio>
 * </nb-radio-group>
 * ```
 *
 * Radio items name has to be provided through `name` input property of the radio group.
 *
 * ```html
 * <nb-radio-group name="my-radio-group">
 *   ...
 * </nb-radio-group>
 * ```
 *
 * You can change radio group status by setting `status` input.
 * @stacked-example(Statuses, radio/radio-statuses.component)
 *
 * Also, you can disable the whole group using `disabled` attribute.
 * @stacked-example(Disabled group, radio/radio-disabled-group.component)
 *
 * */
let NbRadioGroupComponent = NbRadioGroupComponent_1 = class NbRadioGroupComponent {
    constructor(hostElement, platformId, document) {
        this.hostElement = hostElement;
        this.platformId = platformId;
        this.document = document;
        this.alive = true;
        this.onChange = (value) => { };
        this.onTouched = () => { };
        this._status = 'basic';
        this.valueChange = new EventEmitter();
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value;
        this.updateValues();
    }
    get name() {
        return this._name;
    }
    set name(name) {
        this._name = name;
        this.updateNames();
    }
    get disabled() {
        return this._disabled;
    }
    set disabled(disabled) {
        this._disabled = convertToBoolProperty(disabled);
        this.updateDisabled();
    }
    /**
     * Radio buttons status.
     * Possible values are `primary` (default), `success`, `warning`, `danger`, `info`.
     */
    get status() {
        return this._status;
    }
    set status(value) {
        if (value === '') {
            emptyStatusWarning('NbRadio');
            value = 'basic';
        }
        if (this._status !== value) {
            this._status = value;
            this.updateStatus();
        }
    }
    ngAfterContentInit() {
        // In case option 'name' isn't set on nb-radio component,
        // we need to set it's name right away, so it won't overlap with options
        // without names from other radio groups. Otherwise they all would have
        // same name and will be considered as options from one group so only the
        // last option will stay selected.
        this.updateNames();
        Promise.resolve().then(() => this.updateAndSubscribeToRadios());
        this.radios.changes
            .pipe(takeWhile(() => this.alive))
            .subscribe(() => {
            // 'changes' emit during change detection run and we can't update
            // option properties right of since they already was initialized.
            // Instead we schedule microtask to update radios after change detection
            // run is finished.
            Promise.resolve().then(() => this.updateAndSubscribeToRadios());
        });
    }
    ngOnDestroy() {
        this.alive = false;
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    writeValue(value) {
        this.value = value;
        if (typeof value !== 'undefined') {
            this.updateValues();
        }
    }
    updateAndSubscribeToRadios() {
        this.updateNames();
        this.updateValues();
        this.updateDisabled();
        this.updateStatus();
        this.subscribeOnRadiosValueChange();
        this.subscribeOnRadiosBlur();
    }
    updateNames() {
        if (this.radios) {
            this.radios.forEach((radio) => radio.name = this.name);
        }
    }
    updateValues() {
        if (this.radios && typeof this.value !== 'undefined') {
            this.radios.forEach((radio) => radio.checked = radio.value === this.value);
        }
    }
    updateDisabled() {
        if (this.radios && typeof this.disabled !== 'undefined') {
            this.radios.forEach((radio) => radio.disabled = this.disabled);
        }
    }
    subscribeOnRadiosValueChange() {
        if (!this.radios || !this.radios.length) {
            return;
        }
        merge(...this.radios.map((radio) => radio.valueChange))
            .pipe(takeWhile(() => this.alive), takeUntil(this.radios.changes))
            .subscribe((value) => {
            this.writeValue(value);
            this.propagateValue(value);
        });
    }
    propagateValue(value) {
        this.valueChange.emit(value);
        this.onChange(value);
    }
    subscribeOnRadiosBlur() {
        const hasNoRadios = !this.radios || !this.radios.length;
        if (!isPlatformBrowser(this.platformId) || hasNoRadios) {
            return;
        }
        const hostElement = this.hostElement.nativeElement;
        fromEvent(hostElement, 'focusin')
            .pipe(takeWhile(() => this.alive), filter(event => hostElement.contains(event.target)), switchMap(() => merge(fromEvent(this.document, 'focusin'), fromEvent(this.document, 'click'))), filter(event => !hostElement.contains(event.target)), takeUntil(this.radios.changes))
            .subscribe(() => this.onTouched());
    }
    updateStatus() {
        if (this.radios) {
            this.radios.forEach((radio) => radio.status = this.status);
        }
    }
};
NbRadioGroupComponent.ɵfac = function NbRadioGroupComponent_Factory(t) { return new (t || NbRadioGroupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT)); };
NbRadioGroupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbRadioGroupComponent, selectors: [["nb-radio-group"]], contentQueries: function NbRadioGroupComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbRadioComponent, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.radios = _t);
    } }, inputs: { value: "value", name: "name", disabled: "disabled", status: "status" }, outputs: { valueChange: "valueChange" }, features: [ɵngcc0.ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbRadioGroupComponent_1),
                multi: true
            },
        ])], ngContentSelectors: _c45, decls: 1, vars: 0, template: function NbRadioGroupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c44);
        ɵngcc0.ɵɵprojection(0);
    } }, encapsulation: 2, changeDetection: 0 });
__decorate$149([
    Input(),
    __metadata$100("design:type", Object),
    __metadata$100("design:paramtypes", [Object])
], NbRadioGroupComponent.prototype, "value", null);
__decorate$149([
    Input(),
    __metadata$100("design:type", String),
    __metadata$100("design:paramtypes", [String])
], NbRadioGroupComponent.prototype, "name", null);
__decorate$149([
    Input(),
    __metadata$100("design:type", Boolean),
    __metadata$100("design:paramtypes", [Boolean])
], NbRadioGroupComponent.prototype, "disabled", null);
__decorate$149([
    Input(),
    __metadata$100("design:type", String),
    __metadata$100("design:paramtypes", [String])
], NbRadioGroupComponent.prototype, "status", null);
__decorate$149([
    ContentChildren(NbRadioComponent, { descendants: true }),
    __metadata$100("design:type", QueryList)
], NbRadioGroupComponent.prototype, "radios", void 0);
__decorate$149([
    Output(),
    __metadata$100("design:type", EventEmitter)
], NbRadioGroupComponent.prototype, "valueChange", void 0);
NbRadioGroupComponent = NbRadioGroupComponent_1 = __decorate$149([ __param$25(1, Inject(PLATFORM_ID)),
    __param$25(2, Inject(NB_DOCUMENT)),
    __metadata$100("design:paramtypes", [ElementRef, Object, Object])
], NbRadioGroupComponent);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$147 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbRadioModule = class NbRadioModule {
};
NbRadioModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbRadioModule });
NbRadioModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbRadioModule_Factory(t) { return new (t || NbRadioModule)(); }, imports: [[]] });

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_DEFAULT_ROW_LEVEL = 0;
/**
 * Implicit context of cells and rows
 */
class NbTreeGridPresentationNode {
    constructor(
    /**
     * Data object associated with row
     */
    data, children, 
    /**
     * Row expand state
     */
    expanded, level) {
        this.data = data;
        this.children = children;
        this.expanded = expanded;
        this.level = level;
    }
    /**
     * True if row has child rows
     */
    hasChildren() {
        return !!this.children && !!this.children.length;
    }
}

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$153 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbTreeGridDataService = class NbTreeGridDataService {
    constructor() {
        this.defaultGetters = {
            dataGetter: node => node.data,
            childrenGetter: d => d.children || undefined,
            expandedGetter: d => !!d.expanded,
        };
    }
    toPresentationNodes(nodes, customGetters, level = NB_DEFAULT_ROW_LEVEL) {
        const getters = Object.assign({}, this.defaultGetters, customGetters);
        return this.mapNodes(nodes, getters, level);
    }
    mapNodes(nodes, getters, level) {
        const { dataGetter, childrenGetter, expandedGetter } = getters;
        return nodes.map(node => {
            const childrenNodes = childrenGetter(node);
            let children;
            if (childrenNodes) {
                children = this.toPresentationNodes(childrenNodes, getters, level + 1);
            }
            return new NbTreeGridPresentationNode(dataGetter(node), children, expandedGetter(node), level);
        });
    }
    flattenExpanded(nodes) {
        return nodes.reduce((res, node) => {
            res.push(node);
            if (node.expanded && node.hasChildren()) {
                res.push(...this.flattenExpanded(node.children));
            }
            return res;
        }, []);
    }
    copy(nodes) {
        return nodes.map((node) => {
            let children;
            if (node.hasChildren()) {
                children = this.copy(node.children);
            }
            return new NbTreeGridPresentationNode(node.data, children, node.expanded, node.level);
        });
    }
};
NbTreeGridDataService.ɵfac = function NbTreeGridDataService_Factory(t) { return new (t || NbTreeGridDataService)(); };
NbTreeGridDataService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTreeGridDataService, factory: NbTreeGridDataService.ɵfac });

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$154 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Service used to filter tree grid data. Searched searchString in all object values.
 * If you need custom filter, you can extend this service and override filterPredicate or whole filter method.
 */
let NbTreeGridFilterService = class NbTreeGridFilterService {
    filter(query, data) {
        if (!query) {
            return data;
        }
        return data.reduce((filtered, node) => {
            let filteredChildren;
            if (node.children) {
                filteredChildren = this.filter(query, node.children);
                node.children = filteredChildren;
            }
            node.expanded = false;
            if (filteredChildren && filteredChildren.length) {
                node.expanded = true;
                filtered.push(node);
            }
            else if (this.filterPredicate(node.data, query)) {
                filtered.push(node);
            }
            return filtered;
        }, []);
    }
    filterPredicate(data, searchQuery) {
        const preparedQuery = searchQuery.trim().toLocaleLowerCase();
        for (const val of Object.values(data)) {
            const preparedVal = `${val}`.trim().toLocaleLowerCase();
            if (preparedVal.includes(preparedQuery)) {
                return true;
            }
        }
        return false;
    }
};
NbTreeGridFilterService.ɵfac = function NbTreeGridFilterService_Factory(t) { return new (t || NbTreeGridFilterService)(); };
NbTreeGridFilterService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTreeGridFilterService, factory: NbTreeGridFilterService.ɵfac });

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$156 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$103 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$27 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NbSortDirection;
(function (NbSortDirection) {
    NbSortDirection["ASCENDING"] = "asc";
    NbSortDirection["DESCENDING"] = "desc";
    NbSortDirection["NONE"] = "";
})(NbSortDirection || (NbSortDirection = {}));
const sortDirections = [
    NbSortDirection.ASCENDING,
    NbSortDirection.DESCENDING,
    NbSortDirection.NONE,
];
/**
 * Directive triggers sort method of passed object when sort header changes direction
 */
let NbSortDirective = class NbSortDirective {
    /**
     * Directive triggers sort method of passed object when sort header changes direction
     */
    constructor() {
        this.sort = new EventEmitter();
    }
    emitSort(sortRequest) {
        if (this.sortable && this.sortable.sort) {
            this.sortable.sort(sortRequest);
        }
        this.sort.emit(sortRequest);
    }
};
NbSortDirective.ɵfac = function NbSortDirective_Factory(t) { return new (t || NbSortDirective)(); };
NbSortDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbSortDirective, selectors: [["", "nbSort", ""]], inputs: { sortable: ["nbSort", "sortable"] }, outputs: { sort: "sort" } });
__decorate$156([
    Input('nbSort'),
    __metadata$103("design:type", Object)
], NbSortDirective.prototype, "sortable", void 0);
__decorate$156([
    Output(),
    __metadata$103("design:type", EventEmitter)
], NbSortDirective.prototype, "sort", void 0);
/**
 * Directive for headers sort icons. Mark you icon implementation with this structural directive and
 * it'll set template's implicit context with current direction. Context also has `isAscending`,
 * `isDescending` and `isNone` properties.
 */
let NbSortHeaderIconDirective = class NbSortHeaderIconDirective {
};
NbSortHeaderIconDirective.ɵfac = function NbSortHeaderIconDirective_Factory(t) { return new (t || NbSortHeaderIconDirective)(); };
NbSortHeaderIconDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbSortHeaderIconDirective, selectors: [["", "nbSortHeaderIcon", ""]] });
let NbSortIconComponent = class NbSortIconComponent {
    constructor() {
        this.direction = NbSortDirection.NONE;
    }
    isAscending() {
        return this.direction === NbSortDirection.ASCENDING;
    }
    isDescending() {
        return this.direction === NbSortDirection.DESCENDING;
    }
    isDirectionSet() {
        return this.isAscending() || this.isDescending();
    }
};
NbSortIconComponent.ɵfac = function NbSortIconComponent_Factory(t) { return new (t || NbSortIconComponent)(); };
NbSortIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSortIconComponent, selectors: [["nb-sort-icon"]], inputs: { direction: "direction" }, decls: 1, vars: 1, consts: [[4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true", 4, "ngIf"], ["icon", "chevron-down-outline", "pack", "nebular-essentials", "aria-hidden", "true"], ["icon", "chevron-up-outline", "pack", "nebular-essentials", "aria-hidden", "true"]], template: function NbSortIconComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, NbSortIconComponent_ng_container_0_Template, 3, 2, "ng-container", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.isDirectionSet());
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], encapsulation: 2 });
__decorate$156([
    Input(),
    __metadata$103("design:type", String)
], NbSortIconComponent.prototype, "direction", void 0);
/**
 * Marks header as sort header so it emitting sort event when clicked.
 */
let NbSortHeaderComponent = class NbSortHeaderComponent {
    constructor(sort, columnDef) {
        this.sort = sort;
        this.columnDef = columnDef;
        this.disabledValue = false;
    }
    /**
     * Disable sort header
     */
    set disabled(value) {
        this.disabledValue = convertToBoolProperty(value);
    }
    get disabled() {
        return this.disabledValue;
    }
    sortIfEnabled() {
        if (!this.disabled) {
            this.sortData();
        }
    }
    isAscending() {
        return this.direction === NbSortDirection.ASCENDING;
    }
    isDescending() {
        return this.direction === NbSortDirection.DESCENDING;
    }
    sortData() {
        const sortRequest = this.createSortRequest();
        this.sort.emitSort(sortRequest);
    }
    getIconContext() {
        return {
            $implicit: this.direction,
            isAscending: this.isAscending(),
            isDescending: this.isDescending(),
            isNone: !this.isAscending() && !this.isDescending(),
        };
    }
    getDisabledAttributeValue() {
        return this.disabled ? '' : null;
    }
    createSortRequest() {
        this.direction = this.getNextDirection();
        return { direction: this.direction, column: this.columnDef.name };
    }
    getNextDirection() {
        const sortDirectionCycle = sortDirections;
        let nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
        if (nextDirectionIndex >= sortDirectionCycle.length) {
            nextDirectionIndex = 0;
        }
        return sortDirectionCycle[nextDirectionIndex];
    }
};
NbSortHeaderComponent.ɵfac = function NbSortHeaderComponent_Factory(t) { return new (t || NbSortHeaderComponent)(ɵngcc0.ɵɵdirectiveInject(NbSortDirective), ɵngcc0.ɵɵdirectiveInject(NB_SORT_HEADER_COLUMN_DEF)); };
NbSortHeaderComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbSortHeaderComponent, selectors: [["", "nbSortHeader", ""]], contentQueries: function NbSortHeaderComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbSortHeaderIconDirective, true, TemplateRef);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sortIcon = _t.first);
    } }, hostVars: 2, hostBindings: function NbSortHeaderComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbSortHeaderComponent_click_HostBindingHandler() { return ctx.sortIfEnabled(); });
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("disabled", ctx.disabled);
    } }, inputs: { disabled: "disabled", direction: ["nbSortHeader", "direction"] }, attrs: _c46, ngContentSelectors: _c0, decls: 5, vars: 5, consts: [["type", "button", 1, "nb-tree-grid-header-change-sort-button", 3, "click"], [3, "direction", 4, "ngIf", "ngIfElse"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["customIcon", ""], [3, "direction"]], template: function NbSortHeaderComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function NbSortHeaderComponent_Template_button_click_0_listener() { return ctx.sortData(); });
        ɵngcc0.ɵɵprojection(1);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(2, NbSortHeaderComponent_nb_sort_icon_2_Template, 1, 1, "nb-sort-icon", 1);
        ɵngcc0.ɵɵtemplate(3, NbSortHeaderComponent_ng_template_3_Template, 0, 0, "ng-template", 2, 3, ɵngcc0.ɵɵtemplateRefExtractor);
    } if (rf & 2) {
        const _r239 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵattribute("disabled", ctx.getDisabledAttributeValue());
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.sortIcon)("ngIfElse", _r239);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx.sortIcon)("ngTemplateOutletContext", ctx.getIconContext());
    } }, directives: [ɵngcc2.NgIf, ɵngcc2.NgTemplateOutlet, NbSortIconComponent], encapsulation: 2, changeDetection: 0 });
__decorate$156([
    ContentChild(NbSortHeaderIconDirective, { read: TemplateRef, static: false }),
    __metadata$103("design:type", TemplateRef)
], NbSortHeaderComponent.prototype, "sortIcon", void 0);
__decorate$156([
    Input('nbSortHeader'),
    __metadata$103("design:type", String)
], NbSortHeaderComponent.prototype, "direction", void 0);
__decorate$156([
    Input(),
    HostBinding('class.disabled'),
    __metadata$103("design:type", Boolean),
    __metadata$103("design:paramtypes", [Object])
], NbSortHeaderComponent.prototype, "disabled", null);
__decorate$156([
    HostListener('click'),
    __metadata$103("design:type", Function),
    __metadata$103("design:paramtypes", []),
    __metadata$103("design:returntype", void 0)
], NbSortHeaderComponent.prototype, "sortIfEnabled", null);
NbSortHeaderComponent = __decorate$156([ __param$27(1, Inject(NB_SORT_HEADER_COLUMN_DEF)),
    __metadata$103("design:paramtypes", [NbSortDirective, Object])
], NbSortHeaderComponent);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$155 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * Service used to sort tree grid data. Uses Array.prototype.sort method.
 * If you need custom sorting, you can extend this service and override comparator or whole sort method.
 */
let NbTreeGridSortService = class NbTreeGridSortService {
    sort(request, data) {
        if (!request) {
            return data;
        }
        const sorted = data.sort((na, nb) => this.comparator(request, na, nb));
        for (const node of data) {
            if (node.children) {
                node.children = this.sort(request, node.children);
            }
        }
        return sorted;
    }
    comparator(request, na, nb) {
        const key = request.column;
        const dir = request.direction;
        const a = na.data[key];
        const b = nb.data[key];
        let res = 0;
        if (a > b) {
            res = 1;
        }
        if (a < b) {
            res = -1;
        }
        return dir === NbSortDirection.ASCENDING ? res : res * -1;
    }
};
NbTreeGridSortService.ɵfac = function NbTreeGridSortService_Factory(t) { return new (t || NbTreeGridSortService)(); };
NbTreeGridSortService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTreeGridSortService, factory: NbTreeGridSortService.ɵfac });

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$157 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbTreeGridService = class NbTreeGridService {
    expand(data, row, options = {}) {
        const node = this.find(data, row);
        node.expanded = true;
        if (options.deep && node.hasChildren()) {
            node.children.forEach((n) => this.expand(data, n.data, options));
        }
    }
    collapse(data, row, options = {}) {
        const node = this.find(data, row);
        node.expanded = false;
        if (options.deep && node.hasChildren()) {
            node.children.forEach((n) => this.collapse(data, n.data, options));
        }
    }
    toggle(data, row, options = {}) {
        const node = this.find(data, row);
        if (node.expanded) {
            this.collapse(data, row, options);
        }
        else {
            this.expand(data, row, options);
        }
    }
    find(data, row) {
        const toCheck = [...data];
        for (const node of toCheck) {
            if (node.data === row) {
                return node;
            }
            if (node.hasChildren()) {
                toCheck.push(...node.children);
            }
        }
    }
};
NbTreeGridService.ɵfac = function NbTreeGridService_Factory(t) { return new (t || NbTreeGridService)(); };
NbTreeGridService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTreeGridService, factory: NbTreeGridService.ɵfac });

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$152 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$102 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
class NbTreeGridDataSource extends NbDataSource {
    constructor(sortService, filterService, treeGridService, treeGridDataService) {
        super();
        this.sortService = sortService;
        this.filterService = filterService;
        this.treeGridService = treeGridService;
        this.treeGridDataService = treeGridDataService;
        /** Stream emitting render data to the table (depends on ordered data changes). */
        this.renderData = new BehaviorSubject([]);
        this.filterRequest = new BehaviorSubject('');
        this.sortRequest = new BehaviorSubject(null);
    }
    setData(data, customGetters) {
        let presentationData = [];
        if (data) {
            presentationData = this.treeGridDataService.toPresentationNodes(data, customGetters);
        }
        this.data = new BehaviorSubject(presentationData);
        this.updateChangeSubscription();
    }
    connect(collectionViewer) {
        return this.renderData;
    }
    disconnect(collectionViewer) {
    }
    expand(row) {
        this.treeGridService.expand(this.data.value, row);
        this.data.next(this.data.value);
    }
    collapse(row) {
        this.treeGridService.collapse(this.data.value, row);
        this.data.next(this.data.value);
    }
    toggle(row, options) {
        this.treeGridService.toggle(this.data.value, row, options);
        this.data.next(this.data.value);
    }
    toggleByIndex(dataIndex, options) {
        const node = this.renderData.value && this.renderData.value[dataIndex];
        if (node) {
            this.toggle(node.data, options);
        }
    }
    getLevel(rowIndex) {
        const row = this.renderData.value[rowIndex];
        return row ? row.level : NB_DEFAULT_ROW_LEVEL;
    }
    sort(sortRequest) {
        this.sortRequest.next(sortRequest);
    }
    filter(searchQuery) {
        this.filterRequest.next(searchQuery);
    }
    updateChangeSubscription() {
        const dataStream = this.data;
        const filteredData = combineLatest(dataStream, this.filterRequest)
            .pipe(map(([data]) => this.treeGridDataService.copy(data)), map(data => this.filterData(data)));
        const sortedData = combineLatest(filteredData, this.sortRequest)
            .pipe(map(([data]) => this.sortData(data)));
        sortedData
            .pipe(map((data) => this.treeGridDataService.flattenExpanded(data)))
            .subscribe((data) => this.renderData.next(data));
    }
    filterData(data) {
        return this.filterService.filter(this.filterRequest.value, data);
    }
    sortData(data) {
        return this.sortService.sort(this.sortRequest.value, data);
    }
}
let NbTreeGridDataSourceBuilder = class NbTreeGridDataSourceBuilder {
    constructor(filterService, sortService, treeGridService, treeGridDataService) {
        this.filterService = filterService;
        this.sortService = sortService;
        this.treeGridService = treeGridService;
        this.treeGridDataService = treeGridDataService;
    }
    create(data, customGetters) {
        const dataSource = new NbTreeGridDataSource(this.sortService, this.filterService, this.treeGridService, this.treeGridDataService);
        dataSource.setData(data, customGetters);
        return dataSource;
    }
};
NbTreeGridDataSourceBuilder.ɵfac = function NbTreeGridDataSourceBuilder_Factory(t) { return new (t || NbTreeGridDataSourceBuilder)(ɵngcc0.ɵɵinject(NbTreeGridFilterService), ɵngcc0.ɵɵinject(NbTreeGridSortService), ɵngcc0.ɵɵinject(NbTreeGridService), ɵngcc0.ɵɵinject(NbTreeGridDataService)); };
NbTreeGridDataSourceBuilder.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbTreeGridDataSourceBuilder, factory: NbTreeGridDataSourceBuilder.ɵfac });
NbTreeGridDataSourceBuilder = __decorate$152([ __metadata$102("design:paramtypes", [NbTreeGridFilterService,
        NbTreeGridSortService,
        NbTreeGridService,
        NbTreeGridDataService])
], NbTreeGridDataSourceBuilder);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
const NB_TREE_GRID = new InjectionToken('NB_TREE_GRID');

const NbCdkRowDef = CdkRowDef;
const NbCdkRow = CdkRow;
const NbCdkCellDef = CdkCellDef;
const NbCdkHeaderRowDef = CdkHeaderRowDef;
const NbCdkHeaderRow = CdkHeaderRow;
const NbCdkHeaderCellDef = CdkHeaderCellDef;
const NbCdkFooterRowDef = CdkFooterRowDef;
const NbCdkFooterRow = CdkFooterRow;
const NbCdkFooterCellDef = CdkFooterCellDef;
const NbCdkColumnDef = CdkColumnDef;
const NbCdkCell = CdkCell;
const NbCdkHeaderCell = CdkHeaderCell;
const NbCdkFooterCell = CdkFooterCell;

var __decorate$158 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$104 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$28 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NbTreeGridRowComponent_1;
var NbTreeGridHeaderRowComponent_1;
var NbTreeGridFooterRowComponent_1;
const NB_ROW_DOUBLE_CLICK_DELAY = 200;
/**
 * Cells container. Adds the right class and role.
 */
let NbTreeGridRowComponent = NbTreeGridRowComponent_1 = class NbTreeGridRowComponent extends NbRowComponent {
    constructor(tree, elementRef) {
        super();
        this.elementRef = elementRef;
        this.doubleClick$ = new Subject();
        /**
         * Time to wait for second click to expand row deeply.
         * 200ms by default.
         */
        this.doubleClickDelay = NB_ROW_DOUBLE_CLICK_DELAY;
        /**
         * Toggle row on click. Enabled by default.
         */
        this.clickToToggle = true;
        this.tree = tree;
    }
    toggleIfEnabledNode() {
        if (!this.clickToToggle) {
            return;
        }
        timer(NB_ROW_DOUBLE_CLICK_DELAY)
            .pipe(take(1), takeUntil(this.doubleClick$))
            .subscribe(() => this.tree.toggleRow(this));
    }
    toggleIfEnabledNodeDeep() {
        if (!this.clickToToggle) {
            return;
        }
        this.doubleClick$.next();
        this.tree.toggleRow(this, { deep: true });
    }
    ngOnDestroy() {
        this.doubleClick$.complete();
    }
};
NbTreeGridRowComponent.ɵfac = function NbTreeGridRowComponent_Factory(t) { return new (t || NbTreeGridRowComponent)(ɵngcc0.ɵɵdirectiveInject(NB_TREE_GRID), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
NbTreeGridRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTreeGridRowComponent, selectors: [["tr", "nbTreeGridRow", ""]], hostAttrs: ["role", "row", 1, "nb-tree-grid-row"], hostBindings: function NbTreeGridRowComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbTreeGridRowComponent_click_HostBindingHandler() { return ctx.toggleIfEnabledNode(); })("dblclick", function NbTreeGridRowComponent_dblclick_HostBindingHandler() { return ctx.toggleIfEnabledNodeDeep(); });
    } }, inputs: { doubleClickDelay: "doubleClickDelay", clickToToggle: "clickToToggle" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkRow, useExisting: NbTreeGridRowComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c47, decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbTreeGridRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2, changeDetection: 0 });
__decorate$158([
    Input(),
    __metadata$104("design:type", Number)
], NbTreeGridRowComponent.prototype, "doubleClickDelay", void 0);
__decorate$158([
    Input(),
    __metadata$104("design:type", Boolean)
], NbTreeGridRowComponent.prototype, "clickToToggle", void 0);
__decorate$158([
    HostListener('click'),
    __metadata$104("design:type", Function),
    __metadata$104("design:paramtypes", []),
    __metadata$104("design:returntype", void 0)
], NbTreeGridRowComponent.prototype, "toggleIfEnabledNode", null);
__decorate$158([
    HostListener('dblclick'),
    __metadata$104("design:type", Function),
    __metadata$104("design:paramtypes", []),
    __metadata$104("design:returntype", void 0)
], NbTreeGridRowComponent.prototype, "toggleIfEnabledNodeDeep", null);
NbTreeGridRowComponent = NbTreeGridRowComponent_1 = __decorate$158([ __param$28(0, Inject(NB_TREE_GRID)),
    __metadata$104("design:paramtypes", [Object, ElementRef])
], NbTreeGridRowComponent);
let NbTreeGridHeaderRowComponent = NbTreeGridHeaderRowComponent_1 = class NbTreeGridHeaderRowComponent extends NbHeaderRowComponent {
};
NbTreeGridHeaderRowComponent.ɵfac = function NbTreeGridHeaderRowComponent_Factory(t) { return ɵNbTreeGridHeaderRowComponent_BaseFactory(t || NbTreeGridHeaderRowComponent); };
NbTreeGridHeaderRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTreeGridHeaderRowComponent, selectors: [["tr", "nbTreeGridHeaderRow", ""]], hostAttrs: ["role", "row", 1, "nb-tree-grid-header-row"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkHeaderRow, useExisting: NbTreeGridHeaderRowComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c48, decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbTreeGridHeaderRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2, changeDetection: 0 });
let NbTreeGridFooterRowComponent = NbTreeGridFooterRowComponent_1 = class NbTreeGridFooterRowComponent extends NbFooterRowComponent {
};
NbTreeGridFooterRowComponent.ɵfac = function NbTreeGridFooterRowComponent_Factory(t) { return ɵNbTreeGridFooterRowComponent_BaseFactory(t || NbTreeGridFooterRowComponent); };
NbTreeGridFooterRowComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTreeGridFooterRowComponent, selectors: [["tr", "nbTreeGridFooterRow", ""]], hostAttrs: ["role", "row", 1, "nb-tree-grid-footer-row"], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkFooterRow, useExisting: NbTreeGridFooterRowComponent_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c49, decls: 1, vars: 0, consts: [["nbCellOutlet", ""]], template: function NbTreeGridFooterRowComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
    } }, directives: [NbCellOutletDirective], encapsulation: 2, changeDetection: 0 });

var __decorate$159 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$105 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
let NbColumnsService = class NbColumnsService {
    constructor(differs) {
        this.differs = differs;
        this.columnHide$ = new Subject();
        this.columnShow$ = new Subject();
    }
    setColumns(columns) {
        if (!this.changesDiffer) {
            this.changesDiffer = this.differs.find(columns || []).create();
        }
        if (this.changesDiffer.diff(columns)) {
            this.allColumns = Array.from(columns);
            this.visibleColumns = Array.from(columns);
        }
    }
    getVisibleColumns() {
        return this.visibleColumns;
    }
    hideColumn(column) {
        const toRemove = this.visibleColumns.indexOf(column);
        if (toRemove > -1) {
            this.visibleColumns.splice(toRemove, 1);
            this.columnHide$.next();
        }
    }
    showColumn(column) {
        if (this.visibleColumns.includes(column)) {
            return;
        }
        this.visibleColumns.splice(this.findInsertIndex(column), 0, column);
        this.columnShow$.next();
    }
    onColumnsChange() {
        return merge(this.columnShow$, this.columnHide$);
    }
    findInsertIndex(column) {
        const initialIndex = this.allColumns.indexOf(column);
        if (initialIndex === 0 || !this.visibleColumns.length) {
            return 0;
        }
        if (initialIndex === this.allColumns.length - 1) {
            return this.visibleColumns.length;
        }
        const leftSiblingIndex = initialIndex - 1;
        for (let i = leftSiblingIndex; i >= 0; i--) {
            const leftSibling = this.allColumns[i];
            const index = this.visibleColumns.indexOf(leftSibling);
            if (index !== -1) {
                return index + 1;
            }
        }
        const rightSiblingIndex = initialIndex + 1;
        for (let i = rightSiblingIndex; i < this.allColumns.length; i++) {
            const rightSibling = this.allColumns[i];
            const index = this.visibleColumns.indexOf(rightSibling);
            if (index !== -1) {
                return index;
            }
        }
        throw new Error(`Can't restore column position.`);
    }
};
NbColumnsService.ɵfac = function NbColumnsService_Factory(t) { return new (t || NbColumnsService)(ɵngcc0.ɵɵinject(ɵngcc0.IterableDiffers)); };
NbColumnsService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: NbColumnsService, factory: NbColumnsService.ɵfac });
NbColumnsService = __decorate$159([ __metadata$105("design:paramtypes", [IterableDiffers])
], NbColumnsService);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$151 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$101 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$26 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NbTreeGridComponent_1;
/**
 * Tree grid component that can be used to display nested rows of data.
 * Supports filtering and sorting.
 * @stacked-example(Showcase, tree-grid/tree-grid-showcase.component)
 *
 * ### Installation
 *
 * Import `NbTreeGridModule` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbTreeGridModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 *
 * ### Usage
 *
 * As the most basic usage you need to define [nbTreeGridRowDef](docs/components/treegrid/api#nbtreegridrowdefdirective)
 * where you should pass columns to display in rows and
 * [nbTreeGridColumnDef](docs/components/treegrid/api#nbtreegridcolumndefdirective) - component containing cell
 * definitions for each column passed to row definition.
 * @stacked-example(Basic, tree-grid/tree-grid-basic.component)
 *
 * `NbTreeGridComponent`'s source input and `NbTreeGridDataSourceBuilder.create` expecting data to be an array of
 * objects with `data`, `children` and `expanded` properties. If your data doesn't match this interface, you can pass
 * getter functions for each property as arguments to `NbTreeGridDataSourceBuilder.create` method.
 * @stacked-example(Custom node structure, tree-grid/tree-grid-custom-node-structure.component)
 *
 * To use sorting you can add `nbSort` directive to table and subscribe to `sort` method. When user click on header,
 * sort event will be emitted. Event object contain clicked column name and desired sort direction.
 * @stacked-example(Sortable, tree-grid/tree-grid-sortable.component)
 *
 * You can use `Data Source Builder` to create `NbTreeGridDataSource` which would have toggle, sort and
 * filter methods. Then you can call this methods to change sort or toggle rows programmatically. Also `nbSort` and
 * `nbFilterInput` directives both support `NbTreeGridDataSource`, so you can pass it directly as an input and
 * directives will trigger sort, toggle themselves.
 * @stacked-example(Data Source Builder, tree-grid/tree-grid-showcase.component)
 *
 * You can create responsive grid by setting `hideOn` and `showOn` inputs of
 * [nbTreeGridColumnDef](docs/components/tree-grid/api#nbtreegridcolumndefdirective) directive.
 * When viewport reaches specified width grid hides or shows columns.
 * @stacked-example(Responsive columns, tree-grid/tree-grid-responsive.component)
 *
 * To customize sort or row toggle icons you can use `nbSortHeaderIcon` and `nbTreeGridRowToggle` directives
 * respectively. `nbSortHeaderIcon` is a structural directive and it's implicit context set to current direction.
 * Also context has three properties: `isAscending`, `isDescending` and `isNone`.
 * @stacked-example(Custom icons, tree-grid/tree-grid-custom-icons.component)
 *
 * By default, row to toggle happens when user clicks anywhere in the row. Also double click expands row deeply.
 * To disable this you can set `[clickToToggle]="false"` input of `nbTreeGridRow`.
 * @stacked-example(Disable click toggle, tree-grid/tree-grid-disable-click-toggle.component)
 *
 * @styles
 *
 * tree-grid-cell-border-width:
 * tree-grid-cell-border-style:
 * tree-grid-cell-border-color:
 * tree-grid-row-min-height:
 * tree-grid-cell-padding:
 * tree-grid-header-background-color:
 * tree-grid-header-text-color:
 * tree-grid-header-text-font-family:
 * tree-grid-header-text-font-size:
 * tree-grid-header-text-font-weight:
 * tree-grid-header-text-line-height:
 * tree-grid-footer-background-color:
 * tree-grid-footer-text-color:
 * tree-grid-footer-text-font-family:
 * tree-grid-footer-text-font-size:
 * tree-grid-footer-text-font-weight:
 * tree-grid-footer-text-line-height:
 * tree-grid-row-background-color:
 * tree-grid-row-even-background-color:
 * tree-grid-row-hover-background-color:
 * tree-grid-row-text-color:
 * tree-grid-row-text-font-family:
 * tree-grid-row-text-font-size:
 * tree-grid-row-text-font-weight:
 * tree-grid-row-text-line-height:
 * tree-grid-sort-header-button-background-color:
 * tree-grid-sort-header-button-border:
 * tree-grid-sort-header-button-padding:
 */
let NbTreeGridComponent = NbTreeGridComponent_1 = class NbTreeGridComponent extends NbTable {
    constructor(dataSourceBuilder, differs, changeDetectorRef, elementRef, role, dir, document, platform, window) {
        super(differs, changeDetectorRef, elementRef, role, dir, document, platform);
        this.dataSourceBuilder = dataSourceBuilder;
        this.window = window;
        this.alive = true;
        this.levelPadding = '';
        this.equalColumnsWidthValue = false;
        this.treeClass = true;
        this.platform = platform;
    }
    /**
     * The table's data
     * @param data
     * @type {<T>[] | NbTreeGridDataSource}
     */
    set source(data) {
        if (!data) {
            return;
        }
        if (data instanceof NbTreeGridDataSource) {
            this._source = data;
        }
        else {
            this._source = this.dataSourceBuilder.create(data);
        }
        this.dataSource = this._source;
    }
    /**
     * Make all columns equal width. False by default.
     */
    set equalColumnsWidth(value) {
        this.equalColumnsWidthValue = convertToBoolProperty(value);
    }
    get equalColumnsWidth() {
        return this.equalColumnsWidthValue;
    }
    ngAfterViewInit() {
        this.checkDefsCount();
        const rowsChange$ = merge(this._contentRowDefs.changes, this._contentHeaderRowDefs.changes, this._contentFooterRowDefs.changes);
        rowsChange$.pipe(takeWhile(() => this.alive))
            .subscribe(() => this.checkDefsCount());
        if (this.platform.isBrowser) {
            this.updateVisibleColumns();
            const windowResize$ = fromEvent(this.window, 'resize').pipe(debounceTime(50));
            merge(rowsChange$, this._contentColumnDefs.changes, windowResize$)
                .pipe(takeWhile(() => this.alive))
                .subscribe(() => this.updateVisibleColumns());
        }
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.alive = false;
    }
    toggleRow(row, options) {
        this._source.toggleByIndex(this.getDataIndex(row), options);
    }
    toggleCellRow(cell) {
        this.toggleRow(this.findCellRow(cell));
    }
    getColumnWidth() {
        if (this.equalColumnsWidth) {
            return `${100 / this.getColumnsCount()}%`;
        }
        return '';
    }
    getCellLevel(cell, columnName) {
        const isFirstColumn = this.isFirstColumn(columnName);
        const row = isFirstColumn && this.findCellRow(cell);
        const level = row && this.getRowLevel(row);
        if (level || level === 0) {
            return level;
        }
        return NB_DEFAULT_ROW_LEVEL;
    }
    getDataIndex(row) {
        const rowEl = row.elementRef.nativeElement;
        const parent = rowEl.parentElement;
        if (parent) {
            return Array.from(parent.children)
                .filter((child) => child.hasAttribute('nbtreegridrow'))
                .indexOf(rowEl);
        }
        return -1;
    }
    getRowLevel(row) {
        return this._source.getLevel(this.getDataIndex(row));
    }
    getColumns() {
        const { columns } = this._contentHeaderRowDefs.length
            ? this._contentHeaderRowDefs.first
            : this._contentRowDefs.first;
        return Array.from(columns || []);
    }
    getColumnsCount() {
        return this.getColumns().length;
    }
    isFirstColumn(columnName) {
        return this.getColumns()[0] === columnName;
    }
    findCellRow(cell) {
        const cellRowElement = cell.elementRef.nativeElement.parentElement;
        return this.rows.toArray()
            .find((row) => {
            return row.elementRef.nativeElement === cellRowElement;
        });
    }
    checkDefsCount() {
        if (this._contentRowDefs.length > 1) {
            throw new Error(`Found multiple row definitions`);
        }
        if (this._contentHeaderRowDefs.length > 1) {
            throw new Error(`Found multiple header row definitions`);
        }
        if (this._contentFooterRowDefs.length > 1) {
            throw new Error(`Found multiple footer row definitions`);
        }
    }
    updateVisibleColumns() {
        const width = this.window.innerWidth;
        const columnDefs = this._contentColumnDefs;
        const columnsToHide = columnDefs
            .filter((col) => col.shouldHide(width))
            .map(col => col.name);
        const columnsToShow = columnDefs
            .filter((col) => col.shouldShow(width))
            .map(col => col.name);
        if (!columnsToHide.length && !columnsToShow.length) {
            return;
        }
        const rowDefs = [
            this._contentHeaderRowDefs.first,
            this._contentRowDefs.first,
            this._contentFooterRowDefs.first,
        ].filter(d => !!d);
        for (const rowDef of rowDefs) {
            for (const column of columnsToHide) {
                rowDef.hideColumn(column);
            }
            for (const column of columnsToShow) {
                rowDef.showColumn(column);
            }
        }
    }
};
NbTreeGridComponent.ɵfac = function NbTreeGridComponent_Factory(t) { return new (t || NbTreeGridComponent)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridDataSourceBuilder), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵinjectAttribute('role'), ɵngcc0.ɵɵdirectiveInject(NbDirectionality), ɵngcc0.ɵɵdirectiveInject(NB_DOCUMENT), ɵngcc0.ɵɵdirectiveInject(NbPlatform$1), ɵngcc0.ɵɵdirectiveInject(NB_WINDOW)); };
NbTreeGridComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTreeGridComponent, selectors: [["table", "nbTreeGrid", ""]], contentQueries: function NbTreeGridComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NbTreeGridRowComponent, false);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.rows = _t);
    } }, hostVars: 2, hostBindings: function NbTreeGridComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("nb-tree-grid", ctx.treeClass);
    } }, inputs: { levelPadding: "levelPadding", source: ["nbTreeGrid", "source"], equalColumnsWidth: "equalColumnsWidth" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NB_TREE_GRID, useExisting: NbTreeGridComponent_1 },
            NbColumnsService,
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c50, decls: 3, vars: 0, consts: [["nbHeaderRowOutlet", ""], ["nbRowOutlet", ""], ["nbFooterRowOutlet", ""]], template: function NbTreeGridComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementContainer(0, 0);
        ɵngcc0.ɵɵelementContainer(1, 1);
        ɵngcc0.ɵɵelementContainer(2, 2);
    } }, directives: [NbHeaderRowOutletDirective,
        NbDataRowOutletDirective,
        NbFooterRowOutletDirective], styles: ["[_nghost-%COMP%]{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}  .nb-tree-grid-cell,   .nb-tree-grid-header-cell,   .nb-tree-grid-footer-cell{overflow:hidden}"], changeDetection: 0 });
__decorate$151([
    Input('nbTreeGrid'),
    __metadata$101("design:type", Object),
    __metadata$101("design:paramtypes", [Object])
], NbTreeGridComponent.prototype, "source", null);
__decorate$151([
    Input(),
    __metadata$101("design:type", String)
], NbTreeGridComponent.prototype, "levelPadding", void 0);
__decorate$151([
    Input(),
    __metadata$101("design:type", Boolean),
    __metadata$101("design:paramtypes", [Boolean])
], NbTreeGridComponent.prototype, "equalColumnsWidth", null);
__decorate$151([
    ContentChildren(NbTreeGridRowComponent),
    __metadata$101("design:type", QueryList)
], NbTreeGridComponent.prototype, "rows", void 0);
__decorate$151([
    HostBinding('class.nb-tree-grid'),
    __metadata$101("design:type", Object)
], NbTreeGridComponent.prototype, "treeClass", void 0);
NbTreeGridComponent = NbTreeGridComponent_1 = __decorate$151([ __param$26(4, Attribute('role')),
    __param$26(6, Inject(NB_DOCUMENT)),
    __param$26(8, Inject(NB_WINDOW)),
    __metadata$101("design:paramtypes", [NbTreeGridDataSourceBuilder,
        IterableDiffers,
        ChangeDetectorRef,
        ElementRef, String, NbDirectionality, Object, NbPlatform$1, Object])
], NbTreeGridComponent);

var __decorate$160 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$106 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NbTreeGridRowDefDirective_1;
var NbTreeGridHeaderRowDefDirective_1;
var NbTreeGridFooterRowDefDirective_1;
var NbTreeGridCellDefDirective_1;
var NbTreeGridHeaderCellDefDirective_1;
var NbTreeGridFooterCellDefDirective_1;
/**
 * Data row definition for the tree-grid.
 * Captures the header row's template and columns to display.
 */
let NbTreeGridRowDefDirective = NbTreeGridRowDefDirective_1 = class NbTreeGridRowDefDirective extends NbRowDefDirective {
    constructor(template, differs, columnsService) {
        super(template, differs);
        this.columnsService = columnsService;
    }
    /**
     * Columns to be displayed on this row
     */
    set columns(value) {
        this.columnsService.setColumns(value);
    }
    get columns() {
        return this.columnsService.getVisibleColumns();
    }
    /** @docs-private */
    hideColumn(column) {
        this.columnsService.hideColumn(column);
    }
    /** @docs-private */
    showColumn(column) {
        this.columnsService.showColumn(column);
    }
};
NbTreeGridRowDefDirective.ɵfac = function NbTreeGridRowDefDirective_Factory(t) { return new (t || NbTreeGridRowDefDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(NbColumnsService)); };
NbTreeGridRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridRowDefDirective, selectors: [["", "nbTreeGridRowDef", ""]], inputs: { columns: ["nbTreeGridRowDefColumns", "columns"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkRowDef, useExisting: NbTreeGridRowDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate$160([
    Input('nbTreeGridRowDefColumns'),
    __metadata$106("design:type", Object),
    __metadata$106("design:paramtypes", [Object])
], NbTreeGridRowDefDirective.prototype, "columns", null);
NbTreeGridRowDefDirective = NbTreeGridRowDefDirective_1 = __decorate$160([ __metadata$106("design:paramtypes", [TemplateRef,
        IterableDiffers,
        NbColumnsService])
], NbTreeGridRowDefDirective);
let NbTreeGridHeaderRowDefDirective = NbTreeGridHeaderRowDefDirective_1 = class NbTreeGridHeaderRowDefDirective extends NbHeaderRowDefDirective {
    constructor(template, differs, columnsService) {
        super(template, differs);
        this.columnsService = columnsService;
    }
    /**
     * Columns to be displayed on this row
     */
    set columns(value) {
        this.columnsService.setColumns(value);
    }
    get columns() {
        return this.columnsService.getVisibleColumns();
    }
    /** @docs-private */
    hideColumn(column) {
        this.columnsService.hideColumn(column);
    }
    /** @docs-private */
    showColumn(column) {
        this.columnsService.showColumn(column);
    }
};
NbTreeGridHeaderRowDefDirective.ɵfac = function NbTreeGridHeaderRowDefDirective_Factory(t) { return new (t || NbTreeGridHeaderRowDefDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(NbColumnsService)); };
NbTreeGridHeaderRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridHeaderRowDefDirective, selectors: [["", "nbTreeGridHeaderRowDef", ""]], inputs: { columns: ["nbTreeGridHeaderRowDef", "columns"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkHeaderRowDef, useExisting: NbTreeGridHeaderRowDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate$160([
    Input('nbTreeGridHeaderRowDef'),
    __metadata$106("design:type", Object),
    __metadata$106("design:paramtypes", [Object])
], NbTreeGridHeaderRowDefDirective.prototype, "columns", null);
NbTreeGridHeaderRowDefDirective = NbTreeGridHeaderRowDefDirective_1 = __decorate$160([ __metadata$106("design:paramtypes", [TemplateRef,
        IterableDiffers,
        NbColumnsService])
], NbTreeGridHeaderRowDefDirective);
let NbTreeGridFooterRowDefDirective = NbTreeGridFooterRowDefDirective_1 = class NbTreeGridFooterRowDefDirective extends NbFooterRowDefDirective {
    constructor(template, differs, columnsService) {
        super(template, differs);
        this.columnsService = columnsService;
    }
    /**
     * Columns to be displayed on this row
     */
    set columns(value) {
        this.columnsService.setColumns(value);
    }
    get columns() {
        return this.columnsService.getVisibleColumns();
    }
    /** @docs-private */
    hideColumn(column) {
        this.columnsService.hideColumn(column);
    }
    /** @docs-private */
    showColumn(column) {
        this.columnsService.showColumn(column);
    }
};
NbTreeGridFooterRowDefDirective.ɵfac = function NbTreeGridFooterRowDefDirective_Factory(t) { return new (t || NbTreeGridFooterRowDefDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.IterableDiffers), ɵngcc0.ɵɵdirectiveInject(NbColumnsService)); };
NbTreeGridFooterRowDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridFooterRowDefDirective, selectors: [["", "nbTreeGridFooterRowDef", ""]], inputs: { columns: ["nbTreeGridFooterRowDef", "columns"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkFooterRowDef, useExisting: NbTreeGridFooterRowDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate$160([
    Input('nbTreeGridFooterRowDef'),
    __metadata$106("design:type", Object),
    __metadata$106("design:paramtypes", [Object])
], NbTreeGridFooterRowDefDirective.prototype, "columns", null);
NbTreeGridFooterRowDefDirective = NbTreeGridFooterRowDefDirective_1 = __decorate$160([ __metadata$106("design:paramtypes", [TemplateRef,
        IterableDiffers,
        NbColumnsService])
], NbTreeGridFooterRowDefDirective);
/**
 * Cell definition for a nb-table.
 * Captures the template of a column's data row cell as well as cell-specific properties.
 */
let NbTreeGridCellDefDirective = NbTreeGridCellDefDirective_1 = class NbTreeGridCellDefDirective extends NbCellDefDirective {
};
NbTreeGridCellDefDirective.ɵfac = function NbTreeGridCellDefDirective_Factory(t) { return ɵNbTreeGridCellDefDirective_BaseFactory(t || NbTreeGridCellDefDirective); };
NbTreeGridCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridCellDefDirective, selectors: [["", "nbTreeGridCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkCellDef, useExisting: NbTreeGridCellDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * Header cell definition for the nb-table.
 * Captures the template of a column's header cell and as well as cell-specific properties.
 */
let NbTreeGridHeaderCellDefDirective = NbTreeGridHeaderCellDefDirective_1 = class NbTreeGridHeaderCellDefDirective extends NbHeaderCellDefDirective {
};
NbTreeGridHeaderCellDefDirective.ɵfac = function NbTreeGridHeaderCellDefDirective_Factory(t) { return ɵNbTreeGridHeaderCellDefDirective_BaseFactory(t || NbTreeGridHeaderCellDefDirective); };
NbTreeGridHeaderCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridHeaderCellDefDirective, selectors: [["", "nbTreeGridHeaderCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkHeaderCellDef, useExisting: NbTreeGridHeaderCellDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
/**
 * Footer cell definition for the nb-table.
 * Captures the template of a column's footer cell and as well as cell-specific properties.
 */
let NbTreeGridFooterCellDefDirective = NbTreeGridFooterCellDefDirective_1 = class NbTreeGridFooterCellDefDirective extends NbFooterCellDefDirective {
};
NbTreeGridFooterCellDefDirective.ɵfac = function NbTreeGridFooterCellDefDirective_Factory(t) { return ɵNbTreeGridFooterCellDefDirective_BaseFactory(t || NbTreeGridFooterCellDefDirective); };
NbTreeGridFooterCellDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridFooterCellDefDirective, selectors: [["", "nbTreeGridFooterCellDef", ""]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkFooterCellDef, useExisting: NbTreeGridFooterCellDefDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });

var __decorate$162 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$108 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NbTreeGridColumnDefDirective_1;
/**
 * Column definition for the tree-grid.
 * Defines a set of cells available for a table column.
 */
let NbTreeGridColumnDefDirective = NbTreeGridColumnDefDirective_1 = class NbTreeGridColumnDefDirective extends NbColumnDefDirective {
    /**
     * Column definition for the tree-grid.
     * Defines a set of cells available for a table column.
     */
    constructor() {
        super(...arguments);
        this.hideOnValue = null;
        this.showOnValue = null;
    }
    /**
     * Amount of pixels of viewport at which column should be hidden.
     * type number
     */
    get hideOn() {
        return this.hideOnValue;
    }
    set hideOn(value) {
        this.hideOnValue = !value && value !== 0
            ? null
            : parseInt(value, 10);
    }
    /**
     * Amount of pixels of viewport at which column should be shown.
     * type number
     */
    get showOn() {
        return this.showOnValue;
    }
    set showOn(value) {
        this.showOnValue = !value && value !== 0
            ? null
            : parseInt(value, 10);
    }
    ngOnChanges() {
        if (this.hideOn != null && this.showOn != null) {
            throw new Error(`hideOn and showOn are mutually exclusive and can't be used simultaneously.`);
        }
    }
    shouldHide(width) {
        return !this.shouldShow(width);
    }
    shouldShow(width) {
        if (this.hideOn == null && this.showOn == null) {
            return true;
        }
        if (this.hideOn != null) {
            return width > this.hideOn;
        }
        return width >= this.showOn;
    }
};
NbTreeGridColumnDefDirective.ɵfac = function NbTreeGridColumnDefDirective_Factory(t) { return ɵNbTreeGridColumnDefDirective_BaseFactory(t || NbTreeGridColumnDefDirective); };
NbTreeGridColumnDefDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridColumnDefDirective, selectors: [["", "nbTreeGridColumnDef", ""]], inputs: { hideOn: "hideOn", showOn: "showOn", name: ["nbTreeGridColumnDef", "name"] }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: NbCdkColumnDef, useExisting: NbTreeGridColumnDefDirective_1 },
            { provide: NB_SORT_HEADER_COLUMN_DEF, useExisting: NbTreeGridColumnDefDirective_1 },
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature()] });
__decorate$162([
    Input('nbTreeGridColumnDef'),
    __metadata$108("design:type", String)
], NbTreeGridColumnDefDirective.prototype, "name", void 0);
__decorate$162([
    Input(),
    __metadata$108("design:type", Number),
    __metadata$108("design:paramtypes", [Number])
], NbTreeGridColumnDefDirective.prototype, "hideOn", null);
__decorate$162([
    Input(),
    __metadata$108("design:type", Number),
    __metadata$108("design:paramtypes", [Number])
], NbTreeGridColumnDefDirective.prototype, "showOn", null);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$161 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$107 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param$29 = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var NbTreeGridCellDirective_1;
var NbTreeGridHeaderCellDirective_1;
var NbTreeGridFooterCellDirective_1;
let NbTreeGridCellDirective = NbTreeGridCellDirective_1 = class NbTreeGridCellDirective extends NbCellDirective {
    constructor(columnDef, elementRef, tree, platformId, window, sanitizer, directionService, columnService, cd) {
        super(columnDef, elementRef);
        this.platformId = platformId;
        this.window = window;
        this.sanitizer = sanitizer;
        this.directionService = directionService;
        this.columnService = columnService;
        this.cd = cd;
        this.alive = true;
        this.initialLeftPadding = '';
        this.initialRightPadding = '';
        this.tree = tree;
        this.columnDef = columnDef;
        this.elementRef = elementRef;
    }
    get columnWidth() {
        this.latestWidth = this.tree.getColumnWidth();
        return this.latestWidth || null;
    }
    get leftPadding() {
        if (this.directionService.isLtr()) {
            return this.getStartPadding();
        }
        return null;
    }
    get rightPadding() {
        if (this.directionService.isRtl()) {
            return this.getStartPadding();
        }
        return null;
    }
    ngOnInit() {
        if (isPlatformBrowser(this.platformId)) {
            const style$$1 = this.window.getComputedStyle(this.elementRef.nativeElement);
            this.initialLeftPadding = style$$1.paddingLeft;
            this.initialRightPadding = style$$1.paddingRight;
        }
        this.columnService.onColumnsChange()
            .pipe(takeWhile(() => this.alive), filter(() => this.latestWidth !== this.tree.getColumnWidth()))
            .subscribe(() => this.cd.detectChanges());
    }
    ngOnDestroy() {
        this.alive = false;
    }
    toggleRow() {
        this.tree.toggleCellRow(this);
    }
    get initialStartPadding() {
        return this.directionService.isLtr()
            ? this.initialLeftPadding
            : this.initialRightPadding;
    }
    getStartPadding() {
        const rowLevel = this.tree.getCellLevel(this, this.columnDef.name);
        if (rowLevel === NB_DEFAULT_ROW_LEVEL) {
            return null;
        }
        const nestingLevel = rowLevel + 1;
        let padding = '';
        if (this.tree.levelPadding) {
            padding = `calc(${this.tree.levelPadding} * ${nestingLevel})`;
        }
        else if (this.initialStartPadding) {
            padding = `calc(${this.initialStartPadding} * ${nestingLevel})`;
        }
        if (!padding) {
            return null;
        }
        return this.sanitizer.bypassSecurityTrustStyle(padding);
    }
};
NbTreeGridCellDirective.ɵfac = function NbTreeGridCellDirective_Factory(t) { return new (t || NbTreeGridCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NB_TREE_GRID), ɵngcc0.ɵɵdirectiveInject(PLATFORM_ID), ɵngcc0.ɵɵdirectiveInject(NB_WINDOW), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.DomSanitizer), ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService), ɵngcc0.ɵɵdirectiveInject(NbColumnsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbTreeGridCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridCellDirective, selectors: [["td", "nbTreeGridCell", ""]], hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-cell"], hostVars: 6, hostBindings: function NbTreeGridCellDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.columnWidth)("padding-left", ctx.leftPadding)("padding-right", ctx.rightPadding);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkCell, useExisting: NbTreeGridCellDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate$161([
    HostBinding('style.width'),
    __metadata$107("design:type", String),
    __metadata$107("design:paramtypes", [])
], NbTreeGridCellDirective.prototype, "columnWidth", null);
__decorate$161([
    HostBinding('style.padding-left'),
    __metadata$107("design:type", Object),
    __metadata$107("design:paramtypes", [])
], NbTreeGridCellDirective.prototype, "leftPadding", null);
__decorate$161([
    HostBinding('style.padding-right'),
    __metadata$107("design:type", Object),
    __metadata$107("design:paramtypes", [])
], NbTreeGridCellDirective.prototype, "rightPadding", null);
NbTreeGridCellDirective = NbTreeGridCellDirective_1 = __decorate$161([ __param$29(2, Inject(NB_TREE_GRID)),
    __param$29(3, Inject(PLATFORM_ID)),
    __param$29(4, Inject(NB_WINDOW)),
    __metadata$107("design:paramtypes", [NbTreeGridColumnDefDirective,
        ElementRef, Object, Object, Object, DomSanitizer,
        NbLayoutDirectionService,
        NbColumnsService,
        ChangeDetectorRef])
], NbTreeGridCellDirective);
let NbTreeGridHeaderCellDirective = NbTreeGridHeaderCellDirective_1 = class NbTreeGridHeaderCellDirective extends NbHeaderCellDirective {
    constructor(columnDef, elementRef, tree, columnService, cd) {
        super(columnDef, elementRef);
        this.columnService = columnService;
        this.cd = cd;
        this.alive = true;
        this.tree = tree;
    }
    get columnWidth() {
        this.latestWidth = this.tree.getColumnWidth();
        return this.latestWidth || null;
    }
    ngOnInit() {
        this.columnService.onColumnsChange()
            .pipe(takeWhile(() => this.alive), filter(() => this.latestWidth !== this.tree.getColumnWidth()))
            .subscribe(() => this.cd.detectChanges());
    }
    ngOnDestroy() {
        this.alive = false;
    }
};
NbTreeGridHeaderCellDirective.ɵfac = function NbTreeGridHeaderCellDirective_Factory(t) { return new (t || NbTreeGridHeaderCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NB_TREE_GRID), ɵngcc0.ɵɵdirectiveInject(NbColumnsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbTreeGridHeaderCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridHeaderCellDirective, selectors: [["th", "nbTreeGridHeaderCell", ""]], hostAttrs: ["role", "columnheader", 1, "nb-tree-grid-header-cell"], hostVars: 2, hostBindings: function NbTreeGridHeaderCellDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.columnWidth);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkHeaderCell, useExisting: NbTreeGridHeaderCellDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate$161([
    HostBinding('style.width'),
    __metadata$107("design:type", String),
    __metadata$107("design:paramtypes", [])
], NbTreeGridHeaderCellDirective.prototype, "columnWidth", null);
NbTreeGridHeaderCellDirective = NbTreeGridHeaderCellDirective_1 = __decorate$161([ __param$29(2, Inject(NB_TREE_GRID)),
    __metadata$107("design:paramtypes", [NbTreeGridColumnDefDirective,
        ElementRef, Object, NbColumnsService,
        ChangeDetectorRef])
], NbTreeGridHeaderCellDirective);
let NbTreeGridFooterCellDirective = NbTreeGridFooterCellDirective_1 = class NbTreeGridFooterCellDirective extends NbFooterCellDirective {
    constructor(columnDef, elementRef, tree, columnService, cd) {
        super(columnDef, elementRef);
        this.columnService = columnService;
        this.cd = cd;
        this.alive = true;
        this.tree = tree;
    }
    get columnWidth() {
        this.latestWidth = this.tree.getColumnWidth();
        return this.latestWidth || null;
    }
    ngOnInit() {
        this.columnService.onColumnsChange()
            .pipe(takeWhile(() => this.alive), filter(() => this.latestWidth !== this.tree.getColumnWidth()))
            .subscribe(() => this.cd.detectChanges());
    }
    ngOnDestroy() {
        this.alive = false;
    }
};
NbTreeGridFooterCellDirective.ɵfac = function NbTreeGridFooterCellDirective_Factory(t) { return new (t || NbTreeGridFooterCellDirective)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridColumnDefDirective), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NB_TREE_GRID), ɵngcc0.ɵɵdirectiveInject(NbColumnsService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };
NbTreeGridFooterCellDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridFooterCellDirective, selectors: [["td", "nbTreeGridFooterCell", ""]], hostAttrs: ["role", "gridcell", 1, "nb-tree-grid-footer-cell"], hostVars: 2, hostBindings: function NbTreeGridFooterCellDirective_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("width", ctx.columnWidth);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbCdkFooterCell, useExisting: NbTreeGridFooterCellDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate$161([
    HostBinding('style.width'),
    __metadata$107("design:type", String),
    __metadata$107("design:paramtypes", [])
], NbTreeGridFooterCellDirective.prototype, "columnWidth", null);
NbTreeGridFooterCellDirective = NbTreeGridFooterCellDirective_1 = __decorate$161([ __param$29(2, Inject(NB_TREE_GRID)),
    __metadata$107("design:paramtypes", [NbTreeGridColumnDefDirective,
        ElementRef, Object, NbColumnsService,
        ChangeDetectorRef])
], NbTreeGridFooterCellDirective);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$163 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$109 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NbFilterInputDirective_1;
let NbFilterDirective = class NbFilterDirective {
    filter(filterRequest) {
        this.filterable.filter(filterRequest);
    }
};
NbFilterDirective.ɵfac = function NbFilterDirective_Factory(t) { return new (t || NbFilterDirective)(); };
NbFilterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFilterDirective, selectors: [["", "nbFilter", ""]], inputs: { filterable: ["nbFilter", "filterable"] } });
__decorate$163([
    Input('nbFilter'),
    __metadata$109("design:type", Object)
], NbFilterDirective.prototype, "filterable", void 0);
/**
 * Helper directive to trigger data source's filter method when user types in input
 */
let NbFilterInputDirective = NbFilterInputDirective_1 = class NbFilterInputDirective extends NbFilterDirective {
    /**
     * Helper directive to trigger data source's filter method when user types in input
     */
    constructor() {
        super(...arguments);
        this.search$ = new Subject();
        this.alive = true;
        /**
         * Debounce time before triggering filter method. Set in milliseconds.
         * Default 200.
         */
        this.debounceTime = 200;
    }
    ngOnInit() {
        this.search$
            .pipe(takeWhile(() => this.alive), debounceTime(this.debounceTime))
            .subscribe((query) => {
            super.filter(query);
        });
    }
    ngOnDestroy() {
        this.alive = false;
        this.search$.complete();
    }
    filter(event) {
        this.search$.next(event.target.value);
    }
};
NbFilterInputDirective.ɵfac = function NbFilterInputDirective_Factory(t) { return ɵNbFilterInputDirective_BaseFactory(t || NbFilterInputDirective); };
NbFilterInputDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbFilterInputDirective, selectors: [["", "nbFilterInput", ""]], hostBindings: function NbFilterInputDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function NbFilterInputDirective_input_HostBindingHandler($event) { return ctx.filter($event); });
    } }, inputs: { debounceTime: "debounceTime", filterable: ["nbFilterInput", "filterable"] }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: NbFilterDirective, useExisting: NbFilterInputDirective_1 }]), ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate$163([
    Input('nbFilterInput'),
    __metadata$109("design:type", Object)
], NbFilterInputDirective.prototype, "filterable", void 0);
__decorate$163([
    Input(),
    __metadata$109("design:type", Number)
], NbFilterInputDirective.prototype, "debounceTime", void 0);
__decorate$163([
    HostListener('input', ['$event']),
    __metadata$109("design:type", Function),
    __metadata$109("design:paramtypes", [Object]),
    __metadata$109("design:returntype", void 0)
], NbFilterInputDirective.prototype, "filter", null);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$164 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$110 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * When using custom row toggle, apply this directive on your toggle to toggle row on element click.
 */
let NbTreeGridRowToggleDirective = class NbTreeGridRowToggleDirective {
    constructor(cell) {
        this.cell = cell;
    }
    toggleRow($event) {
        this.cell.toggleRow();
        $event.stopPropagation();
    }
};
NbTreeGridRowToggleDirective.ɵfac = function NbTreeGridRowToggleDirective_Factory(t) { return new (t || NbTreeGridRowToggleDirective)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridCellDirective)); };
NbTreeGridRowToggleDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NbTreeGridRowToggleDirective, selectors: [["", "nbTreeGridRowToggle", ""]], hostBindings: function NbTreeGridRowToggleDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbTreeGridRowToggleDirective_click_HostBindingHandler($event) { return ctx.toggleRow($event); });
    } } });
__decorate$164([
    HostListener('click', ['$event']),
    __metadata$110("design:type", Function),
    __metadata$110("design:paramtypes", [Object]),
    __metadata$110("design:returntype", void 0)
], NbTreeGridRowToggleDirective.prototype, "toggleRow", null);
NbTreeGridRowToggleDirective = __decorate$164([ __metadata$110("design:paramtypes", [NbTreeGridCellDirective])
], NbTreeGridRowToggleDirective);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$165 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$111 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/**
 * NbTreeGridRowToggleComponent
 */
let NbTreeGridRowToggleComponent = class NbTreeGridRowToggleComponent {
    constructor(cell) {
        this.cell = cell;
    }
    set expanded(value) {
        this.expandedValue = value;
    }
    get expanded() {
        return this.expandedValue;
    }
    toggleRow($event) {
        this.cell.toggleRow();
        $event.stopPropagation();
    }
};
NbTreeGridRowToggleComponent.ɵfac = function NbTreeGridRowToggleComponent_Factory(t) { return new (t || NbTreeGridRowToggleComponent)(ɵngcc0.ɵɵdirectiveInject(NbTreeGridCellDirective)); };
NbTreeGridRowToggleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbTreeGridRowToggleComponent, selectors: [["nb-tree-grid-row-toggle"]], hostBindings: function NbTreeGridRowToggleComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function NbTreeGridRowToggleComponent_click_HostBindingHandler($event) { return ctx.toggleRow($event); });
    } }, inputs: { expanded: "expanded" }, decls: 2, vars: 2, consts: [[1, "row-toggle-button"], ["pack", "nebular-essentials", "aria-hidden", "true", 3, "icon"]], template: function NbTreeGridRowToggleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵelement(1, "nb-icon", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-label", ctx.expanded ? "collapse" : "expand");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("icon", ctx.expanded ? "chevron-down-outline" : "chevron-right-outline");
    } }, directives: [NbIconComponent], styles: ["button[_ngcontent-%COMP%] {\n      background: transparent;\n      border: none;\n      padding: 0;\n    }"] });
__decorate$165([
    Input(),
    __metadata$111("design:type", Boolean),
    __metadata$111("design:paramtypes", [Boolean])
], NbTreeGridRowToggleComponent.prototype, "expanded", null);
__decorate$165([
    HostListener('click', ['$event']),
    __metadata$111("design:type", Function),
    __metadata$111("design:paramtypes", [Object]),
    __metadata$111("design:returntype", void 0)
], NbTreeGridRowToggleComponent.prototype, "toggleRow", null);
NbTreeGridRowToggleComponent = __decorate$165([ __metadata$111("design:paramtypes", [NbTreeGridCellDirective])
], NbTreeGridRowToggleComponent);

/*
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$150 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const COMPONENTS$2 = [
    // Tree Grid
    NbTreeGridComponent,
    NbTreeGridRowDefDirective,
    NbTreeGridRowComponent,
    NbTreeGridCellDefDirective,
    NbTreeGridCellDirective,
    NbTreeGridHeaderRowDefDirective,
    NbTreeGridHeaderRowComponent,
    NbTreeGridHeaderCellDefDirective,
    NbTreeGridHeaderCellDirective,
    NbTreeGridFooterRowDefDirective,
    NbTreeGridFooterRowComponent,
    NbTreeGridFooterCellDefDirective,
    NbTreeGridFooterCellDirective,
    NbTreeGridColumnDefDirective,
    // Sort directives
    NbSortDirective,
    NbSortHeaderComponent,
    NbSortIconComponent,
    // Filter directives
    NbFilterDirective,
    NbFilterInputDirective,
    NbTreeGridRowToggleDirective,
    NbTreeGridRowToggleComponent,
    NbSortHeaderIconDirective,
];
let NbTreeGridModule = class NbTreeGridModule {
};
NbTreeGridModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbTreeGridModule });
NbTreeGridModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbTreeGridModule_Factory(t) { return new (t || NbTreeGridModule)(); }, providers: [
        NbTreeGridSortService,
        NbTreeGridFilterService,
        NbTreeGridService,
        NbTreeGridDataService,
        NbTreeGridDataSourceBuilder,
    ], imports: [[CommonModule, NbTableModule, NbIconModule],
        NbTableModule] });

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$167 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$112 = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var NbToggleComponent_1;
/**
 * Toggle is a control representing `on` and `off` states.
 *
 * @stacked-example(Showcase, toggle/toggle-showcase.component)
 *
 * ### Installation
 *
 * Import `NbToggleComponent` to your feature module.
 * ```ts
 * @NgModule({
 *   imports: [
 *     // ...
 *     NbToggleModule,
 *   ],
 * })
 * export class PageModule { }
 * ```
 * ### Usage
 *
 * Toggle may have one of the following statuses: `basic`, `primary`, `success`, `warning`, `danger`, `info`, `control`
 *
 * @stacked-example(Toggle status, toggle/toggle-status.component)
 *
 * Toggle can be disabled via `disabled` input.
 *
 * @stacked-example(Disabled Toggles, toggle/toggle-disabled.component)
 *
 * Toggle may have a label with following positions: `left`, `right`, `start`, `end` (default)
 *
 * @stacked-example(Toggles With Labels, toggle/toggle-label-position.component.ts)
 *
 * You can set control state via `checked` binding:
 *
 * ```html
 * <nb-toggle [(checked)]="checked"></nb-toggle>
 * ```
 *
 * Or it could be set via reactive forms or ngModel bindings:
 *
 * @stacked-example(Toggle form binding, toggle/toggle-form.component)
 *
 * @styles
 *
 * toggle-height:
 * toggle-width:
 * toggle-border-width:
 * toggle-border-radius:
 * toggle-outline-width:
 * toggle-outline-color:
 * toggle-switcher-size:
 * toggle-text-font-family:
 * toggle-text-font-size:
 * toggle-text-font-weight:
 * toggle-text-line-height:
 * toggle-cursor:
 * toggle-disabled-cursor:
 * toggle-basic-text-color:
 * toggle-basic-background-color:
 * toggle-basic-border-color:
 * toggle-basic-checked-background-color:
 * toggle-basic-checked-border-color:
 * toggle-basic-checked-switcher-background-color:
 * toggle-basic-checked-switcher-checkmark-color:
 * toggle-basic-focus-background-color:
 * toggle-basic-focus-border-color:
 * toggle-basic-focus-checked-background-color:
 * toggle-basic-focus-checked-border-color:
 * toggle-basic-hover-background-color:
 * toggle-basic-hover-border-color:
 * toggle-basic-hover-checked-background-color:
 * toggle-basic-hover-checked-border-color:
 * toggle-basic-active-background-color:
 * toggle-basic-active-border-color:
 * toggle-basic-active-checked-background-color:
 * toggle-basic-active-checked-border-color:
 * toggle-basic-disabled-background-color:
 * toggle-basic-disabled-border-color:
 * toggle-basic-disabled-switcher-background-color:
 * toggle-basic-disabled-checked-switcher-checkmark-color:
 * toggle-basic-disabled-text-color:
 * toggle-primary-text-color:
 * toggle-primary-background-color:
 * toggle-primary-border-color:
 * toggle-primary-checked-background-color:
 * toggle-primary-checked-border-color:
 * toggle-primary-checked-switcher-background-color:
 * toggle-primary-checked-switcher-checkmark-color:
 * toggle-primary-focus-background-color:
 * toggle-primary-focus-border-color:
 * toggle-primary-focus-checked-background-color:
 * toggle-primary-focus-checked-border-color:
 * toggle-primary-hover-background-color:
 * toggle-primary-hover-border-color:
 * toggle-primary-hover-checked-background-color:
 * toggle-primary-hover-checked-border-color:
 * toggle-primary-active-background-color:
 * toggle-primary-active-border-color:
 * toggle-primary-active-checked-background-color:
 * toggle-primary-active-checked-border-color:
 * toggle-primary-disabled-background-color:
 * toggle-primary-disabled-border-color:
 * toggle-primary-disabled-switcher-background-color:
 * toggle-primary-disabled-checked-switcher-checkmark-color:
 * toggle-primary-disabled-text-color:
 * toggle-success-text-color:
 * toggle-success-background-color:
 * toggle-success-border-color:
 * toggle-success-checked-background-color:
 * toggle-success-checked-border-color:
 * toggle-success-checked-switcher-background-color:
 * toggle-success-checked-switcher-checkmark-color:
 * toggle-success-focus-background-color:
 * toggle-success-focus-border-color:
 * toggle-success-focus-checked-background-color:
 * toggle-success-focus-checked-border-color:
 * toggle-success-hover-background-color:
 * toggle-success-hover-border-color:
 * toggle-success-hover-checked-background-color:
 * toggle-success-hover-checked-border-color:
 * toggle-success-active-background-color:
 * toggle-success-active-border-color:
 * toggle-success-active-checked-background-color:
 * toggle-success-active-checked-border-color:
 * toggle-success-disabled-background-color:
 * toggle-success-disabled-border-color:
 * toggle-success-disabled-switcher-background-color:
 * toggle-success-disabled-checked-switcher-checkmark-color:
 * toggle-success-disabled-text-color:
 * toggle-info-text-color:
 * toggle-info-background-color:
 * toggle-info-border-color:
 * toggle-info-checked-background-color:
 * toggle-info-checked-border-color:
 * toggle-info-checked-switcher-background-color:
 * toggle-info-checked-switcher-checkmark-color:
 * toggle-info-focus-background-color:
 * toggle-info-focus-border-color:
 * toggle-info-focus-checked-background-color:
 * toggle-info-focus-checked-border-color:
 * toggle-info-hover-background-color:
 * toggle-info-hover-border-color:
 * toggle-info-hover-checked-background-color:
 * toggle-info-hover-checked-border-color:
 * toggle-info-active-background-color:
 * toggle-info-active-border-color:
 * toggle-info-active-checked-background-color:
 * toggle-info-active-checked-border-color:
 * toggle-info-disabled-background-color:
 * toggle-info-disabled-border-color:
 * toggle-info-disabled-switcher-background-color:
 * toggle-info-disabled-checked-switcher-checkmark-color:
 * toggle-info-disabled-text-color:
 * toggle-warning-text-color:
 * toggle-warning-background-color:
 * toggle-warning-border-color:
 * toggle-warning-checked-background-color:
 * toggle-warning-checked-border-color:
 * toggle-warning-checked-switcher-background-color:
 * toggle-warning-checked-switcher-checkmark-color:
 * toggle-warning-focus-background-color:
 * toggle-warning-focus-border-color:
 * toggle-warning-focus-checked-background-color:
 * toggle-warning-focus-checked-border-color:
 * toggle-warning-hover-background-color:
 * toggle-warning-hover-border-color:
 * toggle-warning-hover-checked-background-color:
 * toggle-warning-hover-checked-border-color:
 * toggle-warning-active-background-color:
 * toggle-warning-active-border-color:
 * toggle-warning-active-checked-background-color:
 * toggle-warning-active-checked-border-color:
 * toggle-warning-disabled-background-color:
 * toggle-warning-disabled-border-color:
 * toggle-warning-disabled-switcher-background-color:
 * toggle-warning-disabled-checked-switcher-checkmark-color:
 * toggle-warning-disabled-text-color:
 * toggle-danger-text-color:
 * toggle-danger-background-color:
 * toggle-danger-border-color:
 * toggle-danger-checked-background-color:
 * toggle-danger-checked-border-color:
 * toggle-danger-checked-switcher-background-color:
 * toggle-danger-checked-switcher-checkmark-color:
 * toggle-danger-focus-background-color:
 * toggle-danger-focus-border-color:
 * toggle-danger-focus-checked-background-color:
 * toggle-danger-focus-checked-border-color:
 * toggle-danger-hover-background-color:
 * toggle-danger-hover-border-color:
 * toggle-danger-hover-checked-background-color:
 * toggle-danger-hover-checked-border-color:
 * toggle-danger-active-background-color:
 * toggle-danger-active-border-color:
 * toggle-danger-active-checked-background-color:
 * toggle-danger-active-checked-border-color:
 * toggle-danger-disabled-background-color:
 * toggle-danger-disabled-border-color:
 * toggle-danger-disabled-switcher-background-color:
 * toggle-danger-disabled-checked-switcher-checkmark-color:
 * toggle-danger-disabled-text-color:
 * toggle-control-text-color:
 * toggle-control-background-color:
 * toggle-control-border-color:
 * toggle-control-checked-background-color:
 * toggle-control-checked-border-color:
 * toggle-control-checked-switcher-background-color:
 * toggle-control-checked-switcher-checkmark-color:
 * toggle-control-focus-background-color:
 * toggle-control-focus-border-color:
 * toggle-control-focus-checked-background-color:
 * toggle-control-focus-checked-border-color:
 * toggle-control-hover-background-color:
 * toggle-control-hover-border-color:
 * toggle-control-hover-checked-background-color:
 * toggle-control-hover-checked-border-color:
 * toggle-control-active-background-color:
 * toggle-control-active-border-color:
 * toggle-control-active-checked-background-color:
 * toggle-control-active-checked-border-color:
 * toggle-control-disabled-background-color:
 * toggle-control-disabled-border-color:
 * toggle-control-disabled-switcher-background-color:
 * toggle-control-disabled-checked-switcher-checkmark-color:
 * toggle-control-disabled-text-color:
 */
let NbToggleComponent = NbToggleComponent_1 = class NbToggleComponent {
    constructor(changeDetector, layoutDirection) {
        this.changeDetector = changeDetector;
        this.layoutDirection = layoutDirection;
        this.onChange = () => { };
        this.onTouched = () => { };
        this.destroy$ = new Subject();
        this._checked = false;
        this._disabled = false;
        this._status = 'basic';
        /**
         * Toggle label position.
         * Possible values are: `left`, `right`, `start`, `end` (default)
         */
        this.labelPosition = 'end';
        /**
         * Output when checked state is changed by a user
         * @type EventEmitter<boolean>
         */
        this.checkedChange = new EventEmitter();
    }
    /**
     * Toggle checked
     * @type {boolean}
     */
    get checked() {
        return this._checked;
    }
    set checked(value) {
        this._checked = convertToBoolProperty(value);
    }
    /**
     * Controls input disabled state
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = convertToBoolProperty(value);
    }
    /**
     * Toggle status.
     * Possible values are: `basic`, `primary`, `success`, `warning`, `danger`, `info`, `control`.
     */
    get status() {
        return this._status;
    }
    set status(value) {
        if (value === '') {
            emptyStatusWarning('NbToggle');
            value = 'basic';
        }
        this._status = value;
    }
    get primary() {
        return this.status === 'primary';
    }
    get success() {
        return this.status === 'success';
    }
    get warning() {
        return this.status === 'warning';
    }
    get danger() {
        return this.status === 'danger';
    }
    get info() {
        return this.status === 'info';
    }
    get basic() {
        return this.status === 'basic';
    }
    get control() {
        return this.status === 'control';
    }
    get labelLeft() {
        return this.labelPosition === 'left';
    }
    get labelRight() {
        return this.labelPosition === 'right';
    }
    get labelStart() {
        return this.labelPosition === 'start';
    }
    get labelEnd() {
        return this.labelPosition === 'end';
    }
    ngOnInit() {
        this.layoutDirection.onDirectionChange()
            .pipe(takeUntil(this.destroy$))
            .subscribe(() => this.changeDetector.detectChanges());
    }
    ngOnDestroy() {
        this.destroy$.next();
        this.destroy$.complete();
    }
    checkState() {
        if (this.checked) {
            return this.layoutDirection.isLtr() ? 'right' : 'left';
        }
        return this.layoutDirection.isLtr() ? 'left' : 'right';
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    writeValue(val) {
        this.checked = val;
        this.changeDetector.markForCheck();
    }
    setDisabledState(val) {
        this.disabled = convertToBoolProperty(val);
        this.changeDetector.markForCheck();
    }
    updateValue(event) {
        const input = event.target;
        this.checked = input.checked;
        this.checkedChange.emit(this.checked);
        this.onChange(this.checked);
    }
    onInputClick(event) {
        event.stopPropagation();
    }
};
NbToggleComponent.ɵfac = function NbToggleComponent_Factory(t) { return new (t || NbToggleComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NbLayoutDirectionService)); };
NbToggleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NbToggleComponent, selectors: [["nb-toggle"]], hostVars: 22, hostBindings: function NbToggleComponent_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("status-primary", ctx.primary)("status-success", ctx.success)("status-warning", ctx.warning)("status-danger", ctx.danger)("status-info", ctx.info)("status-basic", ctx.basic)("status-control", ctx.control)("toggle-label-left", ctx.labelLeft)("toggle-label-right", ctx.labelRight)("toggle-label-start", ctx.labelStart)("toggle-label-end", ctx.labelEnd);
    } }, inputs: { labelPosition: "labelPosition", checked: "checked", disabled: "disabled", status: "status" }, outputs: { checkedChange: "checkedChange" }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NbToggleComponent_1),
                multi: true
            }])], ngContentSelectors: _c0, decls: 7, vars: 7, consts: [[1, "toggle-label"], ["type", "checkbox", "role", "switch", 1, "native-input", "visually-hidden", 3, "disabled", "checked", "change", "blur", "click"], [1, "toggle"], [1, "toggle-switcher"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials", 4, "ngIf"], [1, "text"], ["icon", "checkmark-bold-outline", "pack", "nebular-essentials"]], template: function NbToggleComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef();
        ɵngcc0.ɵɵelementStart(0, "label", 0);
        ɵngcc0.ɵɵelementStart(1, "input", 1);
        ɵngcc0.ɵɵlistener("change", function NbToggleComponent_Template_input_change_1_listener($event) { return ctx.updateValue($event); })("blur", function NbToggleComponent_Template_input_blur_1_listener() { return ctx.onTouched(); })("click", function NbToggleComponent_Template_input_click_1_listener($event) { return ctx.onInputClick($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "span", 3);
        ɵngcc0.ɵɵtemplate(4, NbToggleComponent_nb_icon_4_Template, 1, 0, "nb-icon", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(5, "span", 5);
        ɵngcc0.ɵɵprojection(6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("disabled", ctx.disabled)("checked", ctx.checked);
        ɵngcc0.ɵɵattribute("aria-checked", ctx.checked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵclassProp("checked", ctx.checked);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("@position", ctx.checkState());
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.checked);
    } }, directives: [ɵngcc2.NgIf, NbIconComponent], styles: ["[_nghost-%COMP%]{display:inline-flex;outline:none}.toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:0.6875rem}[dir=ltr]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}[dir=rtl]   .toggle-label-left[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}.toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:0.6875rem}[dir=ltr]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:1}[dir=rtl]   .toggle-label-right[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){order:-1}.toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]{flex-direction:row-reverse}[dir=ltr]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}[dir=rtl]   .toggle-label-start[_nghost-%COMP%]   .toggle-label[_ngcontent-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=ltr]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-left:.6875rem}[dir=rtl]   .toggle-label-end[_nghost-%COMP%]   .text[_ngcontent-%COMP%]:not(:empty){padding-right:.6875rem}.toggle-label[_ngcontent-%COMP%]{position:relative;display:inline-flex;align-items:center}.toggle[_ngcontent-%COMP%]{position:relative;display:inline-flex;box-sizing:content-box;transition-duration:0.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-switcher[_ngcontent-%COMP%]{position:absolute;border-radius:50%;margin:1px}.toggle-switcher[_ngcontent-%COMP%]   nb-icon[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);width:40%}"], data: { animation: [
            trigger('position', [
                state('right', style({ right: 0, left: '*' })),
                state('left', style({ left: 0, right: '*' })),
                transition(':enter', [animate(0)]),
                transition('right <=> left', [animate('0.15s')]),
            ]),
        ] }, changeDetection: 0 });
__decorate$167([
    Input(),
    __metadata$112("design:type", Boolean),
    __metadata$112("design:paramtypes", [Boolean])
], NbToggleComponent.prototype, "checked", null);
__decorate$167([
    Input(),
    __metadata$112("design:type", Boolean),
    __metadata$112("design:paramtypes", [Boolean])
], NbToggleComponent.prototype, "disabled", null);
__decorate$167([
    Input(),
    __metadata$112("design:type", String),
    __metadata$112("design:paramtypes", [String])
], NbToggleComponent.prototype, "status", null);
__decorate$167([
    Input(),
    __metadata$112("design:type", String)
], NbToggleComponent.prototype, "labelPosition", void 0);
__decorate$167([
    Output(),
    __metadata$112("design:type", Object)
], NbToggleComponent.prototype, "checkedChange", void 0);
__decorate$167([
    HostBinding('class.status-primary'),
    __metadata$112("design:type", Object),
    __metadata$112("design:paramtypes", [])
], NbToggleComponent.prototype, "primary", null);
__decorate$167([
    HostBinding('class.status-success'),
    __metadata$112("design:type", Object),
    __metadata$112("design:paramtypes", [])
], NbToggleComponent.prototype, "success", null);
__decorate$167([
    HostBinding('class.status-warning'),
    __metadata$112("design:type", Object),
    __metadata$112("design:paramtypes", [])
], NbToggleComponent.prototype, "warning", null);
__decorate$167([
    HostBinding('class.status-danger'),
    __metadata$112("design:type", Object),
    __metadata$112("design:paramtypes", [])
], NbToggleComponent.prototype, "danger", null);
__decorate$167([
    HostBinding('class.status-info'),
    __metadata$112("design:type", Object),
    __metadata$112("design:paramtypes", [])
], NbToggleComponent.prototype, "info", null);
__decorate$167([
    HostBinding('class.status-basic'),
    __metadata$112("design:type", Object),
    __metadata$112("design:paramtypes", [])
], NbToggleComponent.prototype, "basic", null);
__decorate$167([
    HostBinding('class.status-control'),
    __metadata$112("design:type", Object),
    __metadata$112("design:paramtypes", [])
], NbToggleComponent.prototype, "control", null);
__decorate$167([
    HostBinding('class.toggle-label-left'),
    __metadata$112("design:type", Object),
    __metadata$112("design:paramtypes", [])
], NbToggleComponent.prototype, "labelLeft", null);
__decorate$167([
    HostBinding('class.toggle-label-right'),
    __metadata$112("design:type", Object),
    __metadata$112("design:paramtypes", [])
], NbToggleComponent.prototype, "labelRight", null);
__decorate$167([
    HostBinding('class.toggle-label-start'),
    __metadata$112("design:type", Object),
    __metadata$112("design:paramtypes", [])
], NbToggleComponent.prototype, "labelStart", null);
__decorate$167([
    HostBinding('class.toggle-label-end'),
    __metadata$112("design:type", Object),
    __metadata$112("design:paramtypes", [])
], NbToggleComponent.prototype, "labelEnd", null);
NbToggleComponent = NbToggleComponent_1 = __decorate$167([ __metadata$112("design:paramtypes", [ChangeDetectorRef,
        NbLayoutDirectionService])
], NbToggleComponent);

/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
var __decorate$166 = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NbToggleModule = class NbToggleModule {
};
NbToggleModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NbToggleModule });
NbToggleModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NbToggleModule_Factory(t) { return new (t || NbToggleModule)(); }, imports: [[
            CommonModule,
            NbIconModule,
        ]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbJSThemesRegistry, [{
        type: Injectable
    }], function () { return [{ type: Array, decorators: [{
                type: Inject,
                args: [NB_BUILT_IN_JS_THEMES]
            }] }, { type: Array, decorators: [{
                type: Inject,
                args: [NB_JS_THEMES]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbMediaBreakpointsService, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_MEDIA_BREAKPOINTS]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbThemeService, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_THEME_OPTIONS]
            }] }, { type: NbMediaBreakpointsService }, { type: NbJSThemesRegistry }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSpinnerService, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbLayoutDirectionService, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NB_LAYOUT_DIRECTION]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbLayoutScrollService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbLayoutRulerService, [{
        type: Injectable
    }], function () { return []; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSharedModule, { exports: function () { return [CommonModule,
        // TODO: probably we don't need FormsModule in SharedModule
        FormsModule,
        RouterModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSharedModule, [{
        type: NgModule,
        args: [{
                exports: [
                    CommonModule,
                    // TODO: probably we don't need FormsModule in SharedModule
                    FormsModule,
                    RouterModule,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbFocusTrapFactoryService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc1.InteractivityChecker }, { type: ɵngcc0.NgZone }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbA11yModule, [{
        type: NgModule,
        args: [{}]
    }], null, null); })();
const ɵNbPortalDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbPortalDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbPortalDirective, [{
        type: Directive,
        args: [{ selector: '[nbPortal]' }]
    }], null, null); })();
const ɵNbPortalOutletDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbPortalOutletDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbPortalOutletDirective, [{
        type: Directive,
        args: [{ selector: '[nbPortalOutlet]' }]
    }], null, null); })();
const ɵNbOverlay_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbOverlay);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbOverlay, [{
        type: Injectable
    }], null, null); })();
const ɵNbPlatform_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbPlatform);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbPlatform, [{
        type: Injectable
    }], null, null); })();
const ɵNbOverlayPositionBuilder_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbOverlayPositionBuilder);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbOverlayPositionBuilder, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCdkMappingModule, { declarations: [NbPortalDirective,
        NbPortalOutletDirective], imports: [OverlayModule, PortalModule], exports: [OverlayModule, PortalModule,
        NbPortalDirective,
        NbPortalOutletDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCdkMappingModule, [{
        type: NgModule,
        args: [{
                imports: [...CDK_MODULES],
                exports: [
                    ...CDK_MODULES,
                    NbPortalDirective,
                    NbPortalOutletDirective,
                ],
                declarations: [NbPortalDirective, NbPortalOutletDirective]
            }]
    }], null, null); })();
const ɵNbOverlayContainerAdapter_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbOverlayContainerAdapter);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbOverlayContainerAdapter, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbViewportRulerAdapter, [{
        type: Injectable
    }], function () { return [{ type: NbPlatform }, { type: ɵngcc0.NgZone }, { type: NbLayoutRulerService }, { type: NbLayoutScrollService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbPositionHelper, [{
        type: Injectable
    }], function () { return [{ type: NbLayoutDirectionService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbPositionBuilderService, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbViewportRulerAdapter }, { type: NbPlatform }, { type: NbOverlayPositionBuilder }, { type: NbOverlayContainerAdapter }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbPositionedContainer, [{
        type: Component,
        args: [{
                template: ''
            }]
    }], null, { top: [{
            type: HostBinding,
            args: ['class.nb-overlay-top']
        }], topStart: [{
            type: HostBinding,
            args: ['class.nb-overlay-top-start']
        }], topEnd: [{
            type: HostBinding,
            args: ['class.nb-overlay-top-end']
        }], right: [{
            type: HostBinding,
            args: ['class.nb-overlay-right']
        }], endTop: [{
            type: HostBinding,
            args: ['class.nb-overlay-end-top']
        }], endBottom: [{
            type: HostBinding,
            args: ['class.nb-overlay-end-bottom']
        }], bottom: [{
            type: HostBinding,
            args: ['class.nb-overlay-bottom']
        }], bottomStart: [{
            type: HostBinding,
            args: ['class.nb-overlay-bottom-start']
        }], bottomEnd: [{
            type: HostBinding,
            args: ['class.nb-overlay-bottom-end']
        }], left: [{
            type: HostBinding,
            args: ['class.nb-overlay-left']
        }], startTop: [{
            type: HostBinding,
            args: ['class.nb-overlay-start-top']
        }], startBottom: [{
            type: HostBinding,
            args: ['class.nb-overlay-start-bottom']
        }], position: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbOverlayContainerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-overlay-container',
                template: `
    <div *ngIf="isStringContent" class="primitive-overlay">{{ content }}</div>
    <ng-template nbPortalOutlet></ng-template>
  `
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ChangeDetectorRef }]; }, { portalOutlet: [{
            type: ViewChild,
            args: [NbPortalOutletDirective, { static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbOverlayService, [{
        type: Injectable
    }], function () { return [{ type: NbOverlay }, { type: NbLayoutDirectionService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbScrollDispatcherAdapter, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }, { type: NbPlatform }, { type: NbLayoutScrollService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbBlockScrollStrategyAdapter, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbViewportRulerAdapter }, { type: NbLayoutScrollService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbScrollStrategyOptions, [{
        type: Injectable
    }], function () { return [{ type: NbLayoutScrollService }, { type: ɵngcc3.ScrollDispatcher }, { type: NbViewportRulerAdapter }, { type: ɵngcc0.NgZone }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCdkAdapterModule, [{
        type: NgModule,
        args: [{}]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTriggerStrategyBuilderService, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbOverlayModule, { declarations: [NbPositionedContainer,
        NbOverlayContainerComponent], imports: [NbCdkMappingModule,
        NbSharedModule], exports: [NbCdkMappingModule,
        NbCdkAdapterModule,
        NbOverlayContainerComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbOverlayModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbCdkMappingModule,
                    NbSharedModule,
                ],
                declarations: [
                    NbPositionedContainer,
                    NbOverlayContainerComponent,
                ],
                exports: [
                    NbCdkMappingModule,
                    NbCdkAdapterModule,
                    NbOverlayContainerComponent,
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbThemeModule, { imports: function () { return [CommonModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbThemeModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                ],
                exports: []
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbIconLibraries, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbIconComponent, [{
        type: Component,
        args: [{
                selector: 'nb-icon',
                template: '',
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:inline-block}\n"]
            }]
    }], function () { return [{ type: ɵngcc4.DomSanitizer }, { type: NbIconLibraries }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { html: [{
            type: HostBinding,
            args: ['innerHtml']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], config: [{
            type: Input
        }], icon: [{
            type: Input
        }], pack: [{
            type: Input
        }], status: [{
            type: Input
        }], options: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbIconModule, { declarations: function () { return [NbIconComponent]; }, imports: function () { return [CommonModule]; }, exports: function () { return [NbIconComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbIconModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                ],
                declarations: [
                    NbIconComponent,
                ],
                exports: [
                    NbIconComponent,
                ]
            }]
    }], function () { return [{ type: NbIconLibraries }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCardHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card-header',
                template: `<ng-content></ng-content>`
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCardBodyComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card-body',
                template: `<ng-content></ng-content>`
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCardFooterComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card-footer',
                template: `<ng-content></ng-content>`
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCardComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card',
                template: `
    <ng-content select="nb-card-header"></ng-content>
    <ng-content select="nb-card-body"></ng-content>
    <ng-content></ng-content>
    <ng-content select="nb-card-footer"></ng-content>
  `,
                styles: [":host{display:flex;flex-direction:column}\n"]
            }]
    }], function () { return []; }, { status: [{
            type: Input
        }], accent: [{
            type: Input
        }], size: [{
            type: Input
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], hasAccent: [{
            type: HostBinding,
            args: ['class.accent']
        }], primaryAccent: [{
            type: HostBinding,
            args: ['class.accent-primary']
        }], infoAccent: [{
            type: HostBinding,
            args: ['class.accent-info']
        }], successAccent: [{
            type: HostBinding,
            args: ['class.accent-success']
        }], warningAccent: [{
            type: HostBinding,
            args: ['class.accent-warning']
        }], dangerAccent: [{
            type: HostBinding,
            args: ['class.accent-danger']
        }], basicAccent: [{
            type: HostBinding,
            args: ['class.accent-basic']
        }], controlAccent: [{
            type: HostBinding,
            args: ['class.accent-control']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbRevealCardComponent, [{
        type: Component,
        args: [{
                selector: 'nb-reveal-card',
                template: `
    <ng-content select="nb-card-front"></ng-content>
    <div class="second-card-container">
      <ng-content select="nb-card-back"></ng-content>
    </div>
    <a *ngIf="showToggleButton" class="reveal-button" (click)="toggle()">
      <nb-icon icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </a>
  `,
                styles: [":host{display:block;position:relative;overflow:hidden}:host .second-card-container{position:absolute;top:100%;right:0;left:0;overflow:hidden;transition:top 0s 0.5s}:host ::ng-deep nb-card-front nb-card,:host ::ng-deep nb-card-back nb-card{box-shadow:none;margin:0}:host ::ng-deep nb-card-front{display:block;height:100%}:host ::ng-deep nb-card-back{position:absolute;left:0;top:100%;width:100%;transition:top 0.5s}:host .reveal-button{cursor:pointer;position:absolute;right:0;bottom:0;transform:rotate(180deg);transition:transform 0.3s}:host(.revealed) .second-card-container{top:0;transition:none}:host(.revealed) .second-card-container ::ng-deep nb-card-back{top:0}:host(.revealed) .reveal-button{transform:none}\n"]
            }]
    }], function () { return []; }, { revealed: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.revealed']
        }], showToggleButton: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbFlipCardComponent, [{
        type: Component,
        args: [{
                selector: 'nb-flip-card',
                template: `
    <div class="flipcard-body">
      <div class="front-container">
        <ng-content select="nb-card-front"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
      <div class="back-container">
        <ng-content select="nb-card-back"></ng-content>
        <a *ngIf="showToggleButton" class="flip-button" (click)="toggle()">
          <nb-icon icon="chevron-left-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
        </a>
      </div>
    </div>
  `,
                styles: [":host{display:block;perspective:1200px;position:relative}:host-context(.flipped) .flipcard-body{transform:rotateY(-180deg)}:host-context(.flipped) .flipcard-body .front-container{opacity:0;transition:opacity 0s 0.25s;backface-visibility:hidden;-webkit-backface-visibility:hidden}:host-context(.flipped) .flipcard-body .front-container .flip-button{opacity:0;z-index:-1}:host-context(.flipped) .flipcard-body .back-container{backface-visibility:visible;-webkit-backface-visibility:visible}.flipcard-body{display:flex;transition:transform 0.5s;transform-style:preserve-3d}.flipcard-body .front-container,.flipcard-body .back-container{flex:1}.flipcard-body .front-container .flip-button,.flipcard-body .back-container .flip-button{cursor:pointer;position:absolute;right:0;bottom:0;opacity:1;transition:opacity 0s 0.15s}.flipcard-body .front-container{backface-visibility:visible;-webkit-backface-visibility:visible;transition:opacity 0s 0.2s}.flipcard-body .back-container{backface-visibility:hidden;-webkit-backface-visibility:hidden;transform:rotateY(180deg)}\n"]
            }]
    }], function () { return []; }, { flipped: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.flipped']
        }], showToggleButton: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCardFrontComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card-front',
                template: '<ng-content select="nb-card"></ng-content>'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCardBackComponent, [{
        type: Component,
        args: [{
                selector: 'nb-card-back',
                template: '<ng-content select="nb-card"></ng-content>'
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCardModule, { declarations: [NbCardComponent,
        NbCardBodyComponent,
        NbCardFooterComponent,
        NbCardHeaderComponent,
        NbRevealCardComponent,
        NbFlipCardComponent,
        NbCardFrontComponent,
        NbCardBackComponent], imports: [NbSharedModule,
        NbIconModule], exports: [NbCardComponent,
        NbCardBodyComponent,
        NbCardFooterComponent,
        NbCardHeaderComponent,
        NbRevealCardComponent,
        NbFlipCardComponent,
        NbCardFrontComponent,
        NbCardBackComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCardModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbIconModule,
                ],
                declarations: [
                    ...NB_CARD_COMPONENTS,
                ],
                exports: [
                    ...NB_CARD_COMPONENTS,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar',
                template: `
    <nb-base-calendar
      [boundingMonth]="boundingMonth"
      [startView]="startView"
      [date]="date"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [size]="size"
      [visibleDate]="visibleDate"
      [showHeader]="showHeader"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
      (dateChange)="dateChange.emit($event)"
    ></nb-base-calendar>
  `
            }]
    }], function () { return []; }, { boundingMonth: [{
            type: Input
        }], startView: [{
            type: Input
        }], size: [{
            type: Input
        }], showHeader: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }], dateChange: [{
            type: Output
        }], showWeekNumber: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], dayCellComponent: [{
            type: Input
        }], monthCellComponent: [{
            type: Input
        }], yearCellComponent: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }], date: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbButtonComponent, [{
        type: Component,
        args: [{
                selector: 'button[nbButton],a[nbButton],input[type="button"][nbButton],input[type="submit"][nbButton]',
                template: `
    <ng-content></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{appearance:none;text-align:center;text-decoration:none;display:inline-flex;align-items:center;justify-content:center;white-space:nowrap;vertical-align:middle;user-select:none}:host:hover,:host:focus{text-decoration:none}:host.full-width{width:100%}:host ::ng-deep nb-icon{vertical-align:top}[dir=ltr] :host.icon-start:not(.icon-end) ::ng-deep nb-icon{margin-right:.75rem}[dir=rtl] :host.icon-start:not(.icon-end) ::ng-deep nb-icon{margin-left:.75rem}[dir=ltr] :host.icon-end:not(.icon-start) ::ng-deep nb-icon{margin-left:.75rem}[dir=rtl] :host.icon-end:not(.icon-start) ::ng-deep nb-icon{margin-right:.75rem}:host(.transitions){transition-duration:0.15s;transition-property:background-color,border-color,box-shadow,color;transition-timing-function:ease-in}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { size: [{
            type: Input
        }], status: [{
            type: Input
        }], shape: [{
            type: Input
        }], appearance: [{
            type: Input
        }], filled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-filled']
        }], outline: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-outline']
        }], ghost: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-ghost']
        }], hero: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-hero']
        }], fullWidth: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.full-width']
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.aria-disabled']
        }, {
            type: HostBinding,
            args: ['class.btn-disabled']
        }], tabbable: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], rectangle: [{
            type: HostBinding,
            args: ['class.shape-rectangle']
        }], round: [{
            type: HostBinding,
            args: ['class.shape-round']
        }], semiRound: [{
            type: HostBinding,
            args: ['class.shape-semi-round']
        }], iconLeft: [{
            type: HostBinding,
            args: ['class.icon-start']
        }], iconRight: [{
            type: HostBinding,
            args: ['class.icon-end']
        }], transitions: [{
            type: HostBinding,
            args: ['class.transitions']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbButtonModule, { declarations: [NbButtonComponent], imports: [NbSharedModule], exports: [NbButtonComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbButtonModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                declarations: [
                    ...NB_BUTTON_COMPONENTS,
                ],
                exports: [
                    ...NB_BUTTON_COMPONENTS,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarMonthModelService, [{
        type: Injectable
    }], function () { return [{ type: NbDateService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarDayCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-day-cell',
                template: '{{ day }}',
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { 'class': 'day-cell' }
            }]
    }], function () { return [{ type: NbDateService }]; }, { select: [{
            type: Output
        }], today: [{
            type: HostBinding,
            args: ['class.today']
        }], boundingMonth: [{
            type: HostBinding,
            args: ['class.bounding-month']
        }], selected: [{
            type: HostBinding,
            args: ['class.selected']
        }], empty: [{
            type: HostBinding,
            args: ['class.empty']
        }], disabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], date: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarDayPickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-day-picker',
                template: `
    <nb-calendar-week-numbers *ngIf="showWeekNumber"
                              [weeks]="weeks"
                              [size]="size"
                              [weekNumberSymbol]="weekNumberSymbol">
    </nb-calendar-week-numbers>
    <div class="days-container">
      <nb-calendar-days-names></nb-calendar-days-names>
      <nb-calendar-picker
          [data]="weeks"
          [visibleDate]="visibleDate"
          [selectedValue]="date"
          [cellComponent]="cellComponent"
          [min]="min"
          [max]="max"
          [filter]="filter"
          (select)="onSelect($event)">
      </nb-calendar-picker>
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex}.days-container{width:100%}\n"]
            }]
    }], function () { return [{ type: NbCalendarMonthModelService }]; }, { boundingMonths: [{
            type: Input
        }], size: [{
            type: Input
        }], dateChange: [{
            type: Output
        }], setCellComponent: [{
            type: Input,
            args: ['cellComponent']
        }], showWeekNumber: [{
            type: Input
        }], medium: [{
            type: HostBinding,
            args: ['class.medium']
        }], large: [{
            type: HostBinding,
            args: ['class.large']
        }], visibleDate: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], date: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarDaysNamesComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-days-names',
                template: `
    <div class="day" *ngFor="let day of days" [class.holiday]="day.isHoliday">{{ day.name }}</div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex;justify-content:space-between}:host .day{display:flex;align-items:center;justify-content:center}\n"]
            }]
    }], function () { return [{ type: NbDateService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-header',
                template: `
    <div class="header">
      <span class="title" (click)="navigateToday.emit()">
        {{ date | date: 'mediumDate' }}
        <i [ngClass]="{ 'nb-arrow-dropright': isLtr, 'nb-arrow-dropleft': isRtl }"></i>
      </span>
      <span class="sub-title">Today</span>
    </div>
  `
            }]
    }], function () { return [{ type: NbLayoutDirectionService }, { type: NbDateService }]; }, { navigateToday: [{
            type: Output
        }], date: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarMonthCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-month-cell',
                template: `{{ month }}`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { 'class': 'month-cell' }
            }]
    }], function () { return [{ type: NbDateService }]; }, { select: [{
            type: Output
        }], selected: [{
            type: HostBinding,
            args: ['class.selected']
        }], today: [{
            type: HostBinding,
            args: ['class.today']
        }], disabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], date: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarMonthPickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-month-picker',
                template: `
    <nb-calendar-picker
      [data]="months"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="month"
      [cellComponent]="cellComponent"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbDateService }]; }, { size: [{
            type: Input
        }], monthChange: [{
            type: Output
        }], _cellComponent: [{
            type: Input,
            args: ['cellComponent']
        }], medium: [{
            type: HostBinding,
            args: ['class.medium']
        }], large: [{
            type: HostBinding,
            args: ['class.large']
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], month: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarNavigationComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-navigation',
                template: `
    <button nbButton (click)="changeMode.emit()">
      {{ date | date: 'MMM yyyy' }}
    </button>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    :host {
      display: flex;
      justify-content: center;
    }

    :host button {
      height: 3.125rem;
    }
  `]
            }]
    }], function () { return []; }, { changeMode: [{
            type: Output
        }], date: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarPageableNavigationComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-pageable-navigation',
                template: `
    <button nbButton (click)="prev.emit()" ghost size="small" class="prev-month">
      <nb-icon [icon]="isLtr ? 'chevron-left-outline' : 'chevron-right-outline'" pack="nebular-essentials"></nb-icon>
    </button>
    <nb-calendar-navigation [date]="date" (changeMode)="changeMode.emit()"></nb-calendar-navigation>
    <button nbButton (click)="next.emit()" ghost size="small" class="next-month">
      <nb-icon [icon]="isLtr ? 'chevron-right-outline' : 'chevron-left-outline'" pack="nebular-essentials"></nb-icon>
    </button>
  `,
                styles: [":host{display:flex;align-items:center;justify-content:space-between}[dir=ltr] :host .prev-month{margin-left:auto;margin-right:0.4rem}[dir=rtl] :host .prev-month{margin-left:0.4rem;margin-right:auto}[dir=ltr] :host .next-month{margin-left:0.4rem;margin-right:auto}[dir=rtl] :host .next-month{margin-left:auto;margin-right:0.4rem}nb-calendar-navigation{margin:0 0.5rem}\n"]
            }]
    }], function () { return [{ type: NbLayoutDirectionService }]; }, { changeMode: [{
            type: Output
        }], next: [{
            type: Output
        }], prev: [{
            type: Output
        }], date: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarPickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-picker',
                template: `
    <nb-calendar-picker-row
      *ngFor="let row of data"
      [row]="row"
      [visibleDate]="visibleDate"
      [selectedValue]="selectedValue"
      [component]="cellComponent"
      [min]="min"
      [max]="max"
      [filter]="filter"
      (select)="select.emit($event)">
    </nb-calendar-picker-row>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { select: [{
            type: Output
        }], data: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }], cellComponent: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarPickerRowComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-picker-row',
                template: '<ng-template></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
    :host {
      display: flex;
      justify-content: space-between;
    }
  `]
            }]
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }]; }, { select: [{
            type: Output
        }], row: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }], component: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], containerRef: [{
            type: ViewChild,
            args: [TemplateRef, { read: ViewContainerRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarYearCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-year-cell',
                template: `{{ year }}`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { 'class': 'year-cell' }
            }]
    }], function () { return [{ type: NbDateService }]; }, { select: [{
            type: Output
        }], selected: [{
            type: HostBinding,
            args: ['class.selected']
        }], today: [{
            type: HostBinding,
            args: ['class.today']
        }], disabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], date: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarYearPickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-year-picker',
                template: `
    <nb-calendar-picker
      [data]="years"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [selectedValue]="date"
      [visibleDate]="year"
      [cellComponent]="cellComponent"
      (select)="onSelect($event)">
    </nb-calendar-picker>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbDateService }]; }, { size: [{
            type: Input
        }], yearChange: [{
            type: Output
        }], _cellComponent: [{
            type: Input,
            args: ['cellComponent']
        }], medium: [{
            type: HostBinding,
            args: ['class.medium']
        }], large: [{
            type: HostBinding,
            args: ['class.large']
        }], date: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], year: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarWeekNumberComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-week-numbers',
                template: `
    <div class="sign">{{ weekNumberSymbol }}</div>
    <div class="week-cell" *ngFor="let week of getWeeks()">{{ week }}</div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex;flex-direction:column}\n"]
            }]
    }], function () { return [{ type: NbDateService }]; }, { isMedium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], isLarge: [{
            type: HostBinding,
            args: ['class.size-large']
        }], weeks: [{
            type: Input
        }], size: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbNativeDateService, [{
        type: Injectable
    }], function () { return [{ type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCalendarKitModule, { declarations: [NbCalendarHeaderComponent,
        NbCalendarNavigationComponent,
        NbCalendarPageableNavigationComponent,
        NbCalendarDaysNamesComponent,
        NbCalendarYearPickerComponent,
        NbCalendarMonthPickerComponent,
        NbCalendarDayPickerComponent,
        NbCalendarDayCellComponent,
        NbCalendarMonthCellComponent,
        NbCalendarYearCellComponent,
        NbCalendarPickerRowComponent,
        NbCalendarPickerComponent,
        NbCalendarWeekNumberComponent], imports: [NbSharedModule,
        NbButtonModule,
        NbIconModule], exports: [NbCalendarHeaderComponent,
        NbCalendarNavigationComponent,
        NbCalendarPageableNavigationComponent,
        NbCalendarDaysNamesComponent,
        NbCalendarYearPickerComponent,
        NbCalendarMonthPickerComponent,
        NbCalendarDayPickerComponent,
        NbCalendarDayCellComponent,
        NbCalendarMonthCellComponent,
        NbCalendarYearCellComponent,
        NbCalendarPickerRowComponent,
        NbCalendarPickerComponent,
        NbCalendarWeekNumberComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarKitModule, [{
        type: NgModule,
        args: [{
                imports: [NbSharedModule, NbButtonModule, NbIconModule],
                exports: [...COMPONENTS],
                declarations: [...COMPONENTS],
                providers: [...SERVICES],
                entryComponents: [
                    NbCalendarDayCellComponent,
                    NbCalendarMonthCellComponent,
                    NbCalendarYearCellComponent,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbBaseCalendarComponent, [{
        type: Component,
        args: [{
                selector: 'nb-base-calendar',
                template: "<nb-card>\n  <nb-card-header *ngIf=\"showHeader\">\n    <nb-calendar-header (navigateToday)=\"navigateToday()\"></nb-calendar-header>\n  </nb-card-header>\n\n  <nb-card-body [ngSwitch]=\"activeViewMode\">\n\n    <ng-container *ngSwitchCase=\"ViewMode.DATE\">\n\n      <nb-calendar-pageable-navigation\n        *ngSwitchCase=\"ViewMode.DATE\"\n        [date]=\"visibleDate\"\n        (next)=\"nextMonth()\"\n        (prev)=\"prevMonth()\"\n        (changeMode)=\"setViewMode(ViewMode.YEAR)\">\n      </nb-calendar-pageable-navigation>\n\n      <nb-calendar-day-picker\n        [boundingMonths]=\"boundingMonth\"\n        [cellComponent]=\"dayCellComponent\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [filter]=\"filter\"\n        [visibleDate]=\"visibleDate\"\n        [size]=\"size\"\n        [date]=\"date\"\n        [showWeekNumber]=\"showWeekNumber\"\n        (dateChange)=\"dateChange.emit($event)\"\n        [weekNumberSymbol]=\"weekNumberSymbol\">\n      </nb-calendar-day-picker>\n\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"ViewMode.YEAR\">\n\n      <nb-calendar-pageable-navigation\n        [date]=\"visibleDate\"\n        (next)=\"nextYears()\"\n        (prev)=\"prevYears()\"\n        (changeMode)=\"setViewMode(ViewMode.DATE)\">\n      </nb-calendar-pageable-navigation>\n\n      <nb-calendar-year-picker\n        [cellComponent]=\"yearCellComponent\"\n        [date]=\"date\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [filter]=\"filter\"\n        [size]=\"size\"\n        [year]=\"visibleDate\"\n        (yearChange)=\"setVisibleDate($event); setViewMode(ViewMode.MONTH)\">\n      </nb-calendar-year-picker>\n\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"ViewMode.MONTH\">\n\n      <nb-calendar-navigation\n        [date]=\"visibleDate\"\n        (changeMode)=\"setViewMode(ViewMode.DATE)\">\n      </nb-calendar-navigation>\n\n      <nb-calendar-month-picker\n        [cellComponent]=\"monthCellComponent\"\n        [min]=\"min\"\n        [max]=\"max\"\n        [filter]=\"filter\"\n        [size]=\"size\"\n        [month]=\"visibleDate\"\n        (monthChange)=\"setVisibleDate($event); setViewMode(ViewMode.DATE)\">\n      </nb-calendar-month-picker>\n\n    </ng-container>\n\n  </nb-card-body>\n\n</nb-card>\n"
            }]
    }], function () { return [{ type: NbDateService }]; }, { boundingMonth: [{
            type: Input
        }], activeViewMode: [{
            type: Input,
            args: ['startView']
        }], size: [{
            type: Input
        }], showHeader: [{
            type: Input
        }], dateChange: [{
            type: Output
        }], showWeekNumber: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.has-week-number']
        }], visibleDate: [{
            type: Input
        }], medium: [{
            type: HostBinding,
            args: ['class.medium']
        }], large: [{
            type: HostBinding,
            args: ['class.large']
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], dayCellComponent: [{
            type: Input
        }], monthCellComponent: [{
            type: Input
        }], yearCellComponent: [{
            type: Input
        }], date: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbBaseCalendarModule, { declarations: [NbBaseCalendarComponent], imports: [NbCalendarKitModule,
        NbSharedModule,
        NbCardModule], exports: [NbBaseCalendarComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbBaseCalendarModule, [{
        type: NgModule,
        args: [{
                imports: [NbCalendarKitModule, NbSharedModule, NbCardModule],
                exports: [NbBaseCalendarComponent],
                declarations: [NbBaseCalendarComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCalendarModule, { declarations: [NbCalendarComponent], imports: [NbBaseCalendarModule], exports: [NbCalendarComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarModule, [{
        type: NgModule,
        args: [{
                imports: [NbBaseCalendarModule],
                exports: [NbCalendarComponent],
                declarations: [NbCalendarComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarRangeDayCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-range-day-cell',
                template: `
    <div
      class="day-cell"
      [class.today]="today"
      [class.selected]="selected"
      [class.bounding-month]="boundingMonth"
      [class.start]="start"
      [class.end]="end"
      [class.in-range]="inRange"
      [class.disabled]="disabled">
      {{ day }}
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { '(click)': 'onClick()', 'class': 'range-cell' }
            }]
    }], function () { return [{ type: NbDateService }]; }, { select: [{
            type: Output
        }], inRange: [{
            type: HostBinding,
            args: ['class.in-range']
        }], start: [{
            type: HostBinding,
            args: ['class.start']
        }], end: [{
            type: HostBinding,
            args: ['class.end']
        }], date: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarRangeYearCellComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-range-year-cell',
                template: `{{ year }}`,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { 'class': 'year-cell' }
            }]
    }], function () { return [{ type: NbDateService }]; }, { select: [{
            type: Output
        }], selected: [{
            type: HostBinding,
            args: ['class.selected']
        }], today: [{
            type: HostBinding,
            args: ['class.today']
        }], disabled: [{
            type: HostBinding,
            args: ['class.disabled']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], date: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], selectedValue: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarRangeComponent, [{
        type: Component,
        args: [{
                selector: 'nb-calendar-range',
                template: `
    <nb-base-calendar
      [date]="range"
      (dateChange)="onChange($event)"
      [min]="min"
      [max]="max"
      [filter]="filter"
      [startView]="startView"
      [boundingMonth]="boundingMonth"
      [dayCellComponent]="dayCellComponent"
      [monthCellComponent]="monthCellComponent"
      [yearCellComponent]="yearCellComponent"
      [visibleDate]="visibleDate"
      [showHeader]="showHeader"
      [size]="size"
      [showWeekNumber]="showWeekNumber"
      [weekNumberSymbol]="weekNumberSymbol"
    ></nb-base-calendar>
  `
            }]
    }], function () { return [{ type: NbDateService }]; }, { boundingMonth: [{
            type: Input
        }], startView: [{
            type: Input
        }], size: [{
            type: Input
        }], showHeader: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }], rangeChange: [{
            type: Output
        }], _cellComponent: [{
            type: Input,
            args: ['dayCellComponent']
        }], _yearCellComponent: [{
            type: Input,
            args: ['yearCellComponent']
        }], showWeekNumber: [{
            type: Input
        }], range: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], monthCellComponent: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCalendarRangeModule, { declarations: [NbCalendarRangeComponent,
        NbCalendarRangeDayCellComponent,
        NbCalendarRangeYearCellComponent], imports: [NbBaseCalendarModule], exports: [NbCalendarRangeComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCalendarRangeModule, [{
        type: NgModule,
        args: [{
                imports: [NbBaseCalendarModule],
                exports: [NbCalendarRangeComponent],
                declarations: [
                    NbCalendarRangeComponent,
                    NbCalendarRangeDayCellComponent,
                    NbCalendarRangeYearCellComponent,
                ],
                entryComponents: [NbCalendarRangeDayCellComponent, NbCalendarRangeYearCellComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbRestoreScrollTopHelper, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc5.Router }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbLayoutComponent, [{
        type: Component,
        args: [{
                selector: 'nb-layout',
                template: `
    <div class="scrollable-container" #scrollableContainer (scroll)="onScroll($event)">
      <div class="layout" #layoutContainer>
        <ng-content select="nb-layout-header:not([subheader])"></ng-content>
        <div class="layout-container">
          <ng-content select="nb-sidebar"></ng-content>
          <div class="content" [class.center]="centerValue">
            <ng-content select="nb-layout-header[subheader]"></ng-content>
            <div class="columns">
              <ng-content select="nb-layout-column"></ng-content>
            </div>
            <ng-content select="nb-layout-footer"></ng-content>
          </div>
        </div>
      </div>
    </div>
  `,
                styles: [":host{-webkit-font-smoothing:antialiased}[dir=ltr] :host{text-align:left}[dir=rtl] :host{text-align:right}:host .layout{display:flex;flex-direction:column}:host ::ng-deep nb-layout-header{display:block}:host ::ng-deep nb-layout-header nav{align-items:center;justify-content:flex-start;display:flex}:host ::ng-deep nb-layout-header.fixed{position:fixed;top:0;left:0;right:0;z-index:1040}:host .layout-container{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.left{order:0}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.left{order:2}[dir=ltr] :host .layout-container ::ng-deep nb-sidebar.right{order:2}[dir=rtl] :host .layout-container ::ng-deep nb-sidebar.right{order:0}:host .layout-container ::ng-deep nb-sidebar.end{order:2}:host .layout-container ::ng-deep nb-sidebar .fixed{position:fixed;width:100%;overflow-y:auto;height:100%}:host .layout-container .content{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:column;min-width:0}:host .layout-container .content.center{max-width:100%;position:relative;margin-left:auto;margin-right:auto}:host .layout-container .content .columns{display:flex;flex:1;-ms-flex:1 1 auto;flex-direction:row;width:100%}:host .layout-container .content .columns ::ng-deep nb-layout-column{order:1;flex:1 0;min-width:0}[dir=ltr] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:0}[dir=rtl] :host .layout-container .content .columns ::ng-deep nb-layout-column.left{order:2}:host .layout-container .content .columns ::ng-deep nb-layout-column.start{order:0}:host .layout-container .content ::ng-deep nb-layout-footer{display:block;margin-top:auto}:host .layout-container .content ::ng-deep nb-layout-footer nav{justify-content:center;display:flex}\n"]
            }]
    }], function () { return [{ type: NbThemeService }, { type: NbSpinnerService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_WINDOW]
            }] }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: NbLayoutDirectionService }, { type: NbLayoutScrollService }, { type: NbLayoutRulerService }, { type: NbRestoreScrollTopHelper }, { type: NbOverlayContainerAdapter }]; }, { windowModeValue: [{
            type: HostBinding,
            args: ['class.window-mode']
        }], withScrollValue: [{
            type: HostBinding,
            args: ['class.with-scroll']
        }], withSubheader: [{
            type: HostBinding,
            args: ['class.with-subheader']
        }], center: [{
            type: Input
        }], windowMode: [{
            type: Input
        }], withScroll: [{
            type: Input
        }], restoreScrollTop: [{
            type: Input
        }], onScroll: [{
            type: HostListener,
            args: ['window:scroll', ['$event']]
        }], onResize: [{
            type: HostListener,
            args: ['window:resize', ['$event']]
        }], veryTopRef: [{
            type: ViewChild,
            args: ['layoutTopDynamicArea', { read: ViewContainerRef, static: false }]
        }], scrollableContainerRef: [{
            type: ViewChild,
            args: ['scrollableContainer', { read: ElementRef, static: false }]
        }], layoutContainerRef: [{
            type: ViewChild,
            args: ['layoutContainer', { read: ElementRef, static: false }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbLayoutColumnComponent, [{
        type: Component,
        args: [{
                selector: 'nb-layout-column',
                template: `
    <ng-content></ng-content>
  `
            }]
    }], null, { left: [{
            type: Input
        }], leftValue: [{
            type: HostBinding,
            args: ['class.left']
        }], startValue: [{
            type: HostBinding,
            args: ['class.start']
        }], start: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbLayoutHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'nb-layout-header',
                template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `
            }]
    }], function () { return [{ type: NbLayoutComponent }]; }, { fixed: [{
            type: Input
        }], fixedValue: [{
            type: HostBinding,
            args: ['class.fixed']
        }], subheader: [{
            type: Input
        }], subheaderValue: [{
            type: HostBinding,
            args: ['class.subheader']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbLayoutFooterComponent, [{
        type: Component,
        args: [{
                selector: 'nb-layout-footer',
                template: `
    <nav [class.fixed]="fixedValue">
      <ng-content></ng-content>
    </nav>
  `
            }]
    }], null, { fixed: [{
            type: Input
        }], fixedValue: [{
            type: HostBinding,
            args: ['class.fixed']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbLayoutModule, { declarations: [NbLayoutComponent,
        NbLayoutColumnComponent,
        NbLayoutFooterComponent,
        NbLayoutHeaderComponent], imports: [NbSharedModule], exports: [NbLayoutComponent,
        NbLayoutColumnComponent,
        NbLayoutFooterComponent,
        NbLayoutHeaderComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbLayoutModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                declarations: [
                    ...NB_LAYOUT_COMPONENTS,
                ],
                providers: [
                    NbRestoreScrollTopHelper,
                ],
                exports: [
                    ...NB_LAYOUT_COMPONENTS,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbMenuService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbMenuInternalService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc2.Location }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbMenuItemComponent, [{
        type: Component,
        args: [{
                selector: '[nbMenuItem]',
                template: "<span *ngIf=\"menuItem.group\">\n  <nb-icon class=\"menu-icon\" [config]=\"menuItem.icon\" *ngIf=\"menuItem.icon\"></nb-icon>\n  {{ menuItem.title }}\n</span>\n<a *ngIf=\"menuItem.link && !menuItem.url && !menuItem.children && !menuItem.group\"\n   [routerLink]=\"menuItem.link\"\n   [queryParams]=\"menuItem.queryParams\"\n   [fragment]=\"menuItem.fragment\"\n   [skipLocationChange]=\"menuItem.skipLocationChange\"\n   [attr.target]=\"menuItem.target\"\n   [attr.title]=\"menuItem.title\"\n   [class.active]=\"menuItem.selected\"\n   (mouseenter)=\"onHoverItem(menuItem)\"\n   (click)=\"onItemClick(menuItem);\">\n  <nb-icon class=\"menu-icon\" [config]=\"menuItem.icon\" *ngIf=\"menuItem.icon\"></nb-icon>\n  <span class=\"menu-title\">{{ menuItem.title }}</span>\n</a>\n<a *ngIf=\"menuItem.url && !menuItem.children && !menuItem.link && !menuItem.group\"\n   [attr.href]=\"menuItem.url\"\n   [attr.target]=\"menuItem.target\"\n   [attr.title]=\"menuItem.title\"\n   [class.active]=\"menuItem.selected\"\n   (mouseenter)=\"onHoverItem(menuItem)\"\n   (click)=\"onSelectItem(menuItem)\">\n  <nb-icon class=\"menu-icon\" [config]=\"menuItem.icon\" *ngIf=\"menuItem.icon\"></nb-icon>\n  <span class=\"menu-title\">{{ menuItem.title }}</span>\n</a>\n<a *ngIf=\"!menuItem.children && !menuItem.link && !menuItem.url && !menuItem.group\"\n   [attr.target]=\"menuItem.target\"\n   [attr.title]=\"menuItem.title\"\n   [class.active]=\"menuItem.selected\"\n   (mouseenter)=\"onHoverItem(menuItem)\"\n   (click)=\"$event.preventDefault(); onItemClick(menuItem);\">\n  <nb-icon class=\"menu-icon\" [config]=\"menuItem.icon\" *ngIf=\"menuItem.icon\"></nb-icon>\n  <span class=\"menu-title\">{{ menuItem.title }}</span>\n</a>\n<a *ngIf=\"menuItem.children\"\n   (click)=\"$event.preventDefault(); onToggleSubMenu(menuItem);\"\n   [attr.target]=\"menuItem.target\"\n   [attr.title]=\"menuItem.title\"\n   [class.active]=\"menuItem.selected\"\n   (mouseenter)=\"onHoverItem(menuItem)\"\n   href=\"#\">\n  <nb-icon class=\"menu-icon\" [config]=\"menuItem.icon\" *ngIf=\"menuItem.icon\"></nb-icon>\n  <span class=\"menu-title\">{{ menuItem.title }}</span>\n  <nb-icon class=\"expand-state\" [icon]=\"getExpandStateIcon()\" pack=\"nebular-essentials\"></nb-icon>\n</a>\n<ul *ngIf=\"menuItem.children\"\n    [class.collapsed]=\"!(menuItem.children && menuItem.expanded)\"\n    [class.expanded]=\"menuItem.expanded\"\n    [@toggle]=\"toggleState\"\n    class=\"menu-items\">\n  <ng-container *ngFor=\"let item of menuItem.children\">\n    <li nbMenuItem *ngIf=\"!item.hidden\"\n        [menuItem]=\"item\"\n        [class.menu-group]=\"item.group\"\n        (hoverItem)=\"onHoverItem($event)\"\n        (toggleSubMenu)=\"onToggleSubMenu($event)\"\n        (selectItem)=\"onSelectItem($event)\"\n        (itemClick)=\"onItemClick($event)\"\n        class=\"menu-item\">\n    </li>\n  </ng-container>\n</ul>\n",
                animations: [
                    trigger('toggle', [
                        state(NbToggleStates.Collapsed, style({ height: '0', margin: '0' })),
                        state(NbToggleStates.Expanded, style({ height: '*' })),
                        transition(`${NbToggleStates.Collapsed} <=> ${NbToggleStates.Expanded}`, animate(300)),
                    ]),
                ]
            }]
    }], function () { return [{ type: NbMenuService }, { type: NbLayoutDirectionService }]; }, { menuItem: [{
            type: Input
        }], hoverItem: [{
            type: Output
        }], toggleSubMenu: [{
            type: Output
        }], selectItem: [{
            type: Output
        }], itemClick: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbMenuComponent, [{
        type: Component,
        args: [{
                selector: 'nb-menu',
                template: `
    <ul class="menu-items">
      <ng-container *ngFor="let item of items">
        <li nbMenuItem *ngIf="!item.hidden"
            [menuItem]="item"
            [class.menu-group]="item.group"
            (hoverItem)="onHoverItem($event)"
            (toggleSubMenu)="onToggleSubMenu($event)"
            (selectItem)="onSelectItem($event)"
            (itemClick)="onItemClick($event)"
            class="menu-item">
        </li>
      </ng-container>
    </ul>
  `,
                styles: [":host ::ng-deep{display:block}:host ::ng-deep .menu-items,:host ::ng-deep .menu-item>.menu-items{list-style-type:none;overflow:hidden}:host ::ng-deep .menu-item a{display:flex;color:inherit;text-decoration:none;align-items:center}:host ::ng-deep .menu-item a .menu-title{flex:1 0 auto}[dir=rtl] :host ::ng-deep .menu-item a .menu-title{text-align:right}:host ::ng-deep .menu-group span{display:flex}\n"]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_WINDOW]
            }] }, { type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: NbMenuInternalService }, { type: ɵngcc5.Router }]; }, { autoCollapse: [{
            type: Input
        }], tag: [{
            type: Input
        }], items: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbMenuModule, { declarations: [NbMenuComponent,
        NbMenuItemComponent], imports: [NbSharedModule,
        NbIconModule], exports: [NbMenuComponent,
        NbMenuItemComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbMenuModule, [{
        type: NgModule,
        args: [{
                imports: [NbSharedModule, NbIconModule],
                declarations: [...nbMenuComponents],
                exports: [...nbMenuComponents]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbRouteTabsetComponent, [{
        type: Component,
        args: [{
                selector: 'nb-route-tabset',
                template: `
    <ul class="route-tabset">
      <ng-container *ngFor="let tab of tabs">
        <li *ngIf="tab.disabled; else enabled"
            [class.responsive]="tab.responsive"
            class="route-tab disabled"
            tabindex="-1">
          <a tabindex="-1" class="tab-link">
            <nb-icon *ngIf="tab.icon" [config]="tab.icon"></nb-icon>
            <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
          </a>
        </li>

        <ng-template #enabled>
          <li (click)="$event.preventDefault(); selectTab(tab)"
              [routerLink]="tab.route"
              routerLinkActive="active"
              [routerLinkActiveOptions]="activeLinkOptions"
              [class.responsive]="tab.responsive"
              tabindex="0"
              class="route-tab">
            <a tabindex="-1" class="tab-link">
              <nb-icon *ngIf="tab.icon" [icon]="tab.icon"></nb-icon>
              <span *ngIf="tab.title" class="tab-text">{{ tab.title }}</span>
            </a>
          </li>
        </ng-template>
      </ng-container>
    </ul>
    <router-outlet></router-outlet>
  `,
                styles: [".route-tabset{display:flex;flex-direction:row;list-style-type:none;margin:0}.route-tabset .route-tab{margin-bottom:-1px;text-align:center;padding:0}.route-tabset .route-tab.active a::before{display:block}.route-tabset .route-tab a{position:relative;text-decoration:none;display:inline-block}.route-tabset .route-tab a::before{position:absolute;content:'';width:100%;border-radius:3px;bottom:-2px;left:0}.route-tabset .route-tab a nb-icon{vertical-align:middle}[dir=ltr] .route-tabset .route-tab a nb-icon+span{margin-left:.5rem}[dir=rtl] .route-tabset .route-tab a nb-icon+span{margin-right:.5rem}:host.full-width .route-tabset{justify-content:space-around}\n"]
            }]
    }], function () { return []; }, { fullWidthValue: [{
            type: HostBinding,
            args: ['class.full-width']
        }], activeLinkOptions: [{
            type: Input
        }], changeTab: [{
            type: Output
        }], fullWidth: [{
            type: Input
        }], tabs: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbRouteTabsetModule, { declarations: [NbRouteTabsetComponent], imports: [NbSharedModule,
        NbIconModule], exports: [NbRouteTabsetComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbRouteTabsetModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbIconModule,
                ],
                declarations: [
                    NbRouteTabsetComponent,
                ],
                exports: [
                    NbRouteTabsetComponent,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSidebarService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSidebarHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'nb-sidebar-header',
                template: `
    <ng-content></ng-content>
  `
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSidebarFooterComponent, [{
        type: Component,
        args: [{
                selector: 'nb-sidebar-footer',
                template: `
    <ng-content></ng-content>
  `
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSidebarComponent, [{
        type: Component,
        args: [{
                selector: 'nb-sidebar',
                template: `
    <div class="main-container"
         [class.main-container-fixed]="containerFixedValue">
      <ng-content select="nb-sidebar-header"></ng-content>
      <div class="scrollable" (click)="onClick($event)">
        <ng-content></ng-content>
      </div>
      <ng-content select="nb-sidebar-footer"></ng-content>
    </div>
  `,
                styles: [":host{display:flex;flex-direction:column;overflow:hidden;z-index:auto;order:0}:host .scrollable{overflow-y:auto;overflow-x:hidden;flex:1}:host .main-container{transform:translate3d(0, 0, 0);display:flex;flex-direction:column}:host .main-container-fixed{position:fixed}:host.right{margin-right:0;margin-left:auto}[dir=ltr] :host.right{order:4}[dir=rtl] :host.right{order:0}:host.end{order:4}[dir=ltr] :host.end{margin-right:0;margin-left:auto}[dir=rtl] :host.end{margin-left:0;margin-right:auto}:host.fixed{position:fixed;height:100%;z-index:999;top:0;bottom:0;left:0}:host.fixed.right{right:0}[dir=ltr] :host.fixed.start{left:0}[dir=rtl] :host.fixed.start{right:0}[dir=ltr] :host.fixed.end{right:0}[dir=rtl] :host.fixed.end{left:0}:host ::ng-deep nb-sidebar-footer{margin-top:auto;display:block}:host ::ng-deep nb-sidebar-header{display:block}\n"]
            }]
    }], function () { return [{ type: NbSidebarService }, { type: NbThemeService }, { type: ɵngcc0.ElementRef }]; }, { fixedValue: [{
            type: HostBinding,
            args: ['class.fixed']
        }], rightValue: [{
            type: HostBinding,
            args: ['class.right']
        }], leftValue: [{
            type: HostBinding,
            args: ['class.left']
        }], startValue: [{
            type: HostBinding,
            args: ['class.start']
        }], endValue: [{
            type: HostBinding,
            args: ['class.end']
        }], compactedBreakpoints: [{
            type: Input
        }], collapsedBreakpoints: [{
            type: Input
        }], expanded: [{
            type: HostBinding,
            args: ['class.expanded']
        }], collapsed: [{
            type: HostBinding,
            args: ['class.collapsed']
        }], compacted: [{
            type: HostBinding,
            args: ['class.compacted']
        }], right: [{
            type: Input
        }], left: [{
            type: Input
        }], start: [{
            type: Input
        }], end: [{
            type: Input
        }], fixed: [{
            type: Input
        }], containerFixed: [{
            type: Input
        }], state: [{
            type: Input
        }], responsive: [{
            type: Input
        }], tag: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSidebarModule, { declarations: [NbSidebarComponent,
        NbSidebarFooterComponent,
        NbSidebarHeaderComponent], imports: [NbSharedModule], exports: [NbSidebarComponent,
        NbSidebarFooterComponent,
        NbSidebarHeaderComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSidebarModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                declarations: [
                    ...NB_SIDEBAR_COMPONENTS,
                ],
                exports: [
                    ...NB_SIDEBAR_COMPONENTS,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTabComponent, [{
        type: Component,
        args: [{
                selector: 'nb-tab',
                template: `
    <ng-container *ngIf="init">
      <ng-content></ng-content>
    </ng-container>
  `
            }]
    }], function () { return []; }, { activeValue: [{
            type: HostBinding,
            args: ['class.content-active']
        }], disabled: [{
            type: Input,
            args: ['disabled']
        }, {
            type: HostBinding,
            args: ['class.disabled']
        }], responsive: [{
            type: Input
        }], active: [{
            type: Input
        }], lazyLoad: [{
            type: Input
        }], tabTitle: [{
            type: Input
        }], tabId: [{
            type: Input
        }], tabIcon: [{
            type: Input
        }], route: [{
            type: Input
        }], badgeText: [{
            type: Input
        }], badgeStatus: [{
            type: Input
        }], badgePosition: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTabsetComponent, [{
        type: Component,
        args: [{
                selector: 'nb-tabset',
                template: `
    <ul class="tabset">
      <li *ngFor="let tab of tabs"
          (click)="selectTab(tab)"
          (keyup.space)="selectTab(tab)"
          (keyup.enter)="selectTab(tab)"
          [class.responsive]="tab.responsive"
          [class.active]="tab.active"
          [class.disabled]="tab.disabled"
          [attr.tabindex]="tab.disabled ? -1 : 0"
          class="tab">
        <a href (click)="$event.preventDefault()" tabindex="-1" class="tab-link">
          <nb-icon *ngIf="tab.tabIcon" [config]="tab.tabIcon"></nb-icon>
          <span *ngIf="tab.tabTitle" class="tab-text">{{ tab.tabTitle }}</span>
        </a>
        <nb-badge *ngIf="tab.badgeText"
          [text]="tab.badgeText"
          [status]="tab.badgeStatus"
          [position]="tab.badgePosition">
        </nb-badge>
      </li>
    </ul>
    <ng-content select="nb-tab"></ng-content>
  `,
                styles: [":host{display:block}:host.full-width .tabset{justify-content:space-around}:host ::ng-deep nb-tab{flex:1;-ms-flex:1 1 auto;overflow:auto;display:none}:host ::ng-deep nb-tab.content-active{display:block}:host .tabset{display:flex;flex-direction:row;list-style-type:none;margin:0;padding:0}:host .tabset .tab{margin-bottom:-1px;text-align:center;position:relative}:host .tabset .tab.active a::before{display:block}:host .tabset .tab a{display:flex;position:relative;text-decoration:none}:host .tabset .tab a::before{position:absolute;content:'';width:100%;border-radius:3px;bottom:-2px;left:0}:host .tabset .tab a nb-icon{vertical-align:middle}[dir=ltr] :host .tabset .tab a nb-icon+span{margin-left:.5rem}[dir=rtl] :host .tabset .tab a nb-icon+span{margin-right:.5rem}\n"]
            }]
    }], function () { return [{ type: ɵngcc5.ActivatedRoute }, { type: ɵngcc0.ChangeDetectorRef }]; }, { fullWidthValue: [{
            type: HostBinding,
            args: ['class.full-width']
        }], changeTab: [{
            type: Output
        }], fullWidth: [{
            type: Input
        }], tabs: [{
            type: ContentChildren,
            args: [NbTabComponent]
        }], routeParam: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbBadgeComponent, [{
        type: Component,
        args: [{
                selector: 'nb-badge',
                template: `{{text}}`,
                styles: [":host{position:absolute;text-align:center;white-space:nowrap;vertical-align:baseline}:host(.position-top){top:0}:host(.position-right){right:0}:host(.position-bottom){bottom:0}:host(.position-left){left:0}[dir=ltr] :host(.position-start){left:0}[dir=rtl] :host(.position-start){right:0}[dir=ltr] :host(.position-end){right:0}[dir=rtl] :host(.position-end){left:0}\n"]
            }]
    }], function () { return []; }, { text: [{
            type: Input
        }], status: [{
            type: Input
        }], position: [{
            type: Input
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], top: [{
            type: HostBinding,
            args: ['class.position-top']
        }], right: [{
            type: HostBinding,
            args: ['class.position-right']
        }], bottom: [{
            type: HostBinding,
            args: ['class.position-bottom']
        }], left: [{
            type: HostBinding,
            args: ['class.position-left']
        }], start: [{
            type: HostBinding,
            args: ['class.position-start']
        }], end: [{
            type: HostBinding,
            args: ['class.position-end']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbBadgeModule, { declarations: [NbBadgeComponent], exports: [NbBadgeComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbBadgeModule, [{
        type: NgModule,
        args: [{
                exports: [NbBadgeComponent],
                declarations: [NbBadgeComponent]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbTabsetModule, { declarations: [NbTabsetComponent,
        NbTabComponent], imports: [NbSharedModule,
        NbBadgeModule,
        NbIconModule], exports: [NbTabsetComponent,
        NbTabComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTabsetModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbBadgeModule,
                    NbIconModule,
                ],
                declarations: [
                    ...NB_TABSET_COMPONENTS,
                ],
                exports: [
                    ...NB_TABSET_COMPONENTS,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbUserComponent, [{
        type: Component,
        args: [{
                selector: 'nb-user',
                template: "<div class=\"user-container\">\n  <div *ngIf=\"imageBackgroundStyle\" class=\"user-picture image\" [style.background-image]=\"imageBackgroundStyle\">\n    <nb-badge *ngIf=\"badgeText\" [text]=\"badgeText\" [status]=\"badgeStatus\" [position]=\"badgePosition\"></nb-badge>\n  </div>\n  <div *ngIf=\"!imageBackgroundStyle\" class=\"user-picture initials\" [style.background-color]=\"color\">\n    <ng-container *ngIf=\"showInitials\">\n      {{ getInitials() }}\n    </ng-container>\n    <nb-badge *ngIf=\"badgeText\" [text]=\"badgeText\" [status]=\"badgeStatus\" [position]=\"badgePosition\"></nb-badge>\n  </div>\n\n  <div class=\"info-container\">\n    <div *ngIf=\"showName && name\" class=\"user-name\">{{ name }}</div>\n    <div *ngIf=\"showTitle && title\" class=\"user-title\">{{ title }}</div>\n  </div>\n</div>\n",
                styles: [":host{display:flex}:host .user-container{position:relative;display:flex;align-items:center}:host .user-picture{position:relative;flex-shrink:0}:host .user-picture.image{background-size:cover;background-repeat:no-repeat}:host .user-picture.initials{display:flex;align-items:center;justify-content:center}[dir=rtl] :host .user-name,[dir=rtl] :host .user-title{text-align:right}[dir=ltr] :host .info-container{margin-left:.5rem}[dir=rtl] :host .info-container{margin-right:.5rem}\n"]
            }]
    }], function () { return [{ type: ɵngcc4.DomSanitizer }]; }, { name: [{
            type: Input
        }], size: [{
            type: Input
        }], shape: [{
            type: Input
        }], picture: [{
            type: Input
        }], showName: [{
            type: Input
        }], showTitle: [{
            type: Input
        }], showInitials: [{
            type: Input
        }], onlyPicture: [{
            type: Input
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], rectangle: [{
            type: HostBinding,
            args: ['class.shape-rectangle']
        }], semiRound: [{
            type: HostBinding,
            args: ['class.shape-semi-round']
        }], round: [{
            type: HostBinding,
            args: ['class.shape-round']
        }], title: [{
            type: Input
        }], color: [{
            type: Input
        }], badgeText: [{
            type: Input
        }], badgeStatus: [{
            type: Input
        }], badgePosition: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbUserModule, { declarations: [NbUserComponent], imports: [NbSharedModule,
        NbBadgeModule], exports: [NbUserComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbUserModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbBadgeModule,
                ],
                declarations: [
                    ...NB_USER_COMPONENTS,
                ],
                exports: [
                    ...NB_USER_COMPONENTS,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbActionComponent, [{
        type: Component,
        args: [{
                selector: 'nb-action',
                template: `
    <ng-container *ngIf="icon; else projectedContent">
      <a class="icon-container"
         [routerLink]="link"
         [title]="title"
         *ngIf="link">
        <nb-icon [config]="icon"></nb-icon>
      </a>
      <a class="icon-container"
         [href]="href"
         [title]="title"
         *ngIf="href && !link">
        <nb-icon [config]="icon"></nb-icon>
      </a>
      <a class="icon-container"
         href="#"
         [title]="title"
         *ngIf="!href && !link"
         (click)="$event.preventDefault()">
        <nb-icon [config]="icon"></nb-icon>
      </a>
    </ng-container>

    <ng-template #projectedContent>
      <ng-content></ng-content>
    </ng-template>

    <nb-badge *ngIf="badgeText"
              [text]="badgeText"
              [status]="badgeStatus"
              [position]="badgePosition">
    </nb-badge>
  `,
                styles: [":host{background:transparent;display:flex;align-items:center;position:relative}:host(.disabled){cursor:not-allowed}:host(.disabled) a,:host(.disabled) nb-icon{cursor:not-allowed}:host-context(nb-actions.full-width){justify-content:center;width:100%}a.icon-container:hover,a.icon-container:focus{text-decoration:none}nb-icon:hover{cursor:pointer}\n"]
            }]
    }], function () { return []; }, { title: [{
            type: Input
        }], disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.disabled']
        }], link: [{
            type: Input
        }], href: [{
            type: Input
        }], icon: [{
            type: Input
        }], badgeText: [{
            type: Input
        }], badgeStatus: [{
            type: Input
        }], badgePosition: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbActionsComponent, [{
        type: Component,
        args: [{
                selector: 'nb-actions',
                template: `
    <ng-content select="nb-action"></ng-content>
  `,
                styles: [":host{display:flex;align-items:center}\n"]
            }]
    }], function () { return []; }, { size: [{
            type: Input
        }], fullWidth: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.full-width']
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbActionsModule, { declarations: [NbActionComponent,
        NbActionsComponent], imports: [NbSharedModule,
        NbBadgeModule,
        NbIconModule], exports: [NbActionComponent,
        NbActionsComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbActionsModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbBadgeModule,
                    NbIconModule,
                ],
                declarations: [
                    ...NB_ACTIONS_COMPONENTS,
                ],
                exports: [
                    ...NB_ACTIONS_COMPONENTS,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSearchService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSearchFieldComponent, [{
        type: Component,
        args: [{
                selector: 'nb-search-field',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <div class="search" (keyup.esc)="emitClose()">
      <button (click)="emitClose()" nbButton ghost class="close-button">
        <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
      </button>
      <div class="form-wrapper">
        <form class="form" (keyup.enter)="submitSearch(searchInput.value)">
          <div class="form-content">
            <input class="search-input"
                   #searchInput
                   (input)="emitSearchInput(searchInput.value)"
                   autocomplete="off"
                   [attr.placeholder]="placeholder"
                   tabindex="-1"
                   (blur)="focusInput()"/>
          </div>
          <span class="info">{{ hint }}</span>
        </form>
      </div>
    </div>
  `,
                styles: [":host button{margin:0;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}:host input{border-top:0;border-right:0;border-left:0;background:transparent;border-radius:0;line-height:1;display:inline-block;box-sizing:border-box;padding:0.05rem 0;-webkit-appearance:none}:host input:focus{outline:none}:host input::placeholder{opacity:0.3}:host span{font-size:90%;font-weight:bold;display:block;width:75%;margin:0 auto;padding:0.85rem 0;text-align:right}:host.modal-zoomin{display:block}:host.modal-zoomin .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity 0.5s}:host.modal-zoomin .search::before,:host.modal-zoomin .search::after{content:'';position:absolute;width:calc(100% + 15px);height:calc(100% + 15px);pointer-events:none}:host.modal-zoomin .search::before{top:0;left:0;border-right-width:0;border-bottom-width:0;transform:translate3d(-15px, -15px, 0)}:host.modal-zoomin .search::after{right:0;bottom:0;border-top-width:0;border-left-width:0;transform:translate3d(15px, 15px, 0)}:host.modal-zoomin .search button{position:absolute;top:3rem;font-size:2.5rem}[dir=ltr] :host.modal-zoomin .search button{right:3rem}[dir=rtl] :host.modal-zoomin .search button{left:3rem}:host.modal-zoomin .search input{font-size:10vw;width:75%}:host.modal-zoomin .search button{opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}:host.modal-zoomin .search form{opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}:host.modal-zoomin.show .search{pointer-events:auto;opacity:1}:host.modal-zoomin.show .search::before,:host.modal-zoomin.show .search::after{transform:translate3d(0, 0, 0);transition:transform 0.5s}:host.modal-zoomin.show .search button{opacity:1;transform:scale3d(1, 1, 1)}:host.modal-zoomin.show .search form{opacity:1;transform:scale3d(1, 1, 1)}@media screen and (max-width: 40rem){:host.modal-zoomin form{margin:5rem 0 1rem}:host.modal-zoomin span{text-align:left}}\n", "::ng-deep nb-layout.rotate-layout{position:fixed;overflow:hidden;width:100%}::ng-deep nb-layout.rotate-layout .scrollable-container{position:relative;z-index:10001;transition:transform 0.5s cubic-bezier(0.2, 1, 0.3, 1)}::ng-deep nb-layout.rotate-layout.with-search .scrollable-container{transition:transform 0.5s cubic-bezier(0.2, 1, 0.3, 1);transform-origin:50vw 50vh;transform:perspective(1000px) translate3d(0, 50vh, 0) rotate3d(1, 0, 0, 30deg);pointer-events:none}:host.rotate-layout{position:absolute;display:block;width:100vw;height:100vh;pointer-events:none;opacity:0;transition-property:opacity;transition-delay:0.4s}:host.rotate-layout .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:50vh;pointer-events:none;opacity:0;transition:opacity 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}:host.rotate-layout .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}[dir=ltr] :host.rotate-layout .search button{right:3rem}[dir=rtl] :host.rotate-layout .search button{left:3rem}:host.rotate-layout .search form{margin:5rem 0;opacity:0;transform:scale3d(0.7, 0.7, 1);transition:opacity 0.5s, transform 0.5s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}:host.rotate-layout .search input{font-size:7vw;width:75%}:host.rotate-layout.show{opacity:1;transition-delay:0s}:host.rotate-layout.show .search{pointer-events:auto;opacity:1}:host.rotate-layout.show .search button{opacity:1;transform:scale3d(1, 1, 1)}:host.rotate-layout.show .search form{opacity:1;transform:scale3d(1, 1, 1)}\n", "::ng-deep nb-layout.modal-move .layout{transition:transform 0.5s}::ng-deep nb-layout.modal-move.with-search .layout{transform:scale3d(0.8, 0.8, 1);pointer-events:none}:host.modal-move .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;position:fixed;z-index:1050;top:0;left:0;width:100%;height:100vh;pointer-events:none;opacity:0;transition:opacity 0.5s}:host.modal-move .search button{position:absolute;top:3rem;font-size:2.5rem;opacity:0;transition:opacity 0.5s}[dir=ltr] :host.modal-move .search button{right:3rem}[dir=rtl] :host.modal-move .search button{left:3rem}:host.modal-move .search form{margin:5rem 0;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}:host.modal-move .search input{font-size:10vw;width:75%;transform:scale3d(0, 1, 1);transform-origin:0 50%;transition:transform 0.3s}:host.modal-move.show .search{pointer-events:auto;opacity:1}:host.modal-move.show .search button{opacity:1}:host.modal-move.show .search form{opacity:1;transform:scale3d(1, 1, 1)}:host.modal-move.show .search input{transform:scale3d(1, 1, 1);transition-duration:0.5s}@media screen and (max-width: 40rem){:host.modal-move span{text-align:left}}\n", ":host.curtain .search{position:fixed;z-index:1050;top:0;left:100%;overflow:hidden;height:100vh;width:100%;padding:3rem;pointer-events:none;transition:transform 0.3s;transition-delay:0.4s;transition-timing-function:ease-out}:host.curtain .search::after{content:'';position:absolute;top:0;left:0;width:100%;height:100%;transition:transform 0.3s;transition-timing-function:ease-out}:host.curtain .search button{font-size:2.5rem;position:absolute;top:3rem;transition:opacity 0.1s;transition-delay:0.3s}[dir=ltr] :host.curtain .search button{right:3rem}[dir=rtl] :host.curtain .search button{left:3rem}:host.curtain .search form{width:50%;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.5s, transform 0.5s}:host.curtain .search input{width:100%;font-size:6vw}:host.curtain.show .search{width:100%;pointer-events:auto;transform:translate3d(-100%, 0, 0);transition-delay:0s}:host.curtain.show .search::after{transform:translate3d(100%, 0, 0);transition-delay:0.4s}:host.curtain.show .search button{opacity:1;transform:scale3d(1, 1, 1)}:host.curtain.show .search form{opacity:1;transform:scale3d(1, 1, 1)}@media screen and (max-width: 40em){:host.curtain span{width:90%}:host.curtain input{font-size:2em;width:90%}}::ng-deep nb-layout.curtain .scrollable-container{position:relative;z-index:0}\n", "::ng-deep nb-layout.column-curtain.with-search .layout{pointer-events:none}:host.column-curtain{display:block;position:fixed;z-index:1050;top:0;left:50%;overflow:hidden;width:50%;height:100vh;pointer-events:none}:host.column-curtain::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;transform:scale3d(0, 1, 1);transform-origin:0 50%;transition:transform 0.3s;transition-timing-function:cubic-bezier(0.86, 0, 0.07, 1)}:host.column-curtain .search{position:relative;padding:2.5rem 1.5rem 0;background:transparent}:host.column-curtain .search button{position:absolute;top:2rem;font-size:2.5rem;opacity:0;transition:opacity 0.5s}[dir=ltr] :host.column-curtain .search button{right:2rem}[dir=rtl] :host.column-curtain .search button{left:2rem}:host.column-curtain .search form{width:85%;transform:translate3d(-150%, 0, 0);transition:transform 0.3s}:host.column-curtain .search input{font-size:2.5rem;width:100%}:host.column-curtain .search span{font-size:85%}:host.column-curtain.show{pointer-events:auto}:host.column-curtain.show::before{transform:scale3d(1, 1, 1)}:host.column-curtain.show .search form{transform:translate3d(0, 0, 0);transition-delay:0.15s;transition-timing-function:cubic-bezier(0.86, 0, 0.07, 1)}:host.column-curtain.show .search button{opacity:1;z-index:100}@media screen and (max-width: 40rem){:host.column-curtain span{width:90%}:host.column-curtain input{font-size:2rem;width:90%}}\n", "::ng-deep nb-layout.modal-drop .layout{position:relative;transition:transform 0.4s, opacity 0.4s;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1)}::ng-deep nb-layout.modal-drop.with-search .layout{opacity:0;transform:scale3d(0.9, 0.9, 1);pointer-events:none}:host.modal-drop .search{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;z-index:1050;position:fixed;top:0;left:0;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-drop .search::before{content:'';position:absolute;top:0;right:0;width:100%;height:100%;opacity:0;transition:opacity 0.4s}:host.modal-drop .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;opacity:0;transition:opacity 0.4s}[dir=ltr] :host.modal-drop .search button{right:3rem}[dir=rtl] :host.modal-drop .search button{left:3rem}:host.modal-drop .search form{position:relative;margin:5rem 0 2rem}:host.modal-drop .search input{font-size:6vw;width:60%;padding:0.25rem;text-align:center;opacity:0;transition:opacity 0.4s}:host.modal-drop .search span{position:relative;z-index:9;display:block;width:60%;padding:0.85rem 0;opacity:0;transform:translate3d(0, -50px, 0);transition:opacity 0.4s, transform 0.4s}:host.modal-drop .search .form-content{position:relative;z-index:10;overflow:hidden;transform:translate3d(0, -50px, 0);transition:transform 0.4s}:host.modal-drop .search .form-content::after{content:'';position:absolute;top:0;left:20%;width:60%;height:105%;opacity:0;transform-origin:50% 0}:host.modal-drop.show .search{pointer-events:auto}:host.modal-drop.show .search::before{opacity:1}:host.modal-drop.show .search button{opacity:1}:host.modal-drop.show .search .form-content{transform:translate3d(0, 0, 0);transition:none}:host.modal-drop.show .search .form-content::after{animation:scaleUpDown 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards}:host.modal-drop.show .search input{opacity:1;transition:opacity 0s 0.4s}:host.modal-drop.show .search span{opacity:1;transform:translate3d(0, 0, 0);transition-delay:0.4s;transition-timing-function:ease-out}@keyframes scaleUpDown{0%{opacity:1;transform:scale3d(1, 0, 1)}50%{transform:scale3d(1, 1, 1);transform-origin:50% 0;transition-timing-function:ease-out}50.1%{transform-origin:50% 100%;transition-timing-function:ease-out}100%{opacity:1;transform:scale3d(1, 0, 1);transform-origin:50% 100%;transition-timing-function:ease-out}}@media screen and (max-width: 40rem){:host.modal-drop form{margin:2rem 0}:host.modal-drop input{width:100%;left:0}}\n", "::ng-deep nb-layout.modal-half .layout{transition:transform 0.6s, opacity 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}::ng-deep nb-layout.modal-half.with-search .layout{transform:scale3d(0.8, 0.8, 1);pointer-events:none}:host.modal-half .search{text-align:center;position:fixed;z-index:1050;top:0;left:0;overflow:hidden;width:100%;height:100vh;background:none;pointer-events:none}:host.modal-half .search::before{content:'';position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0;transition:opacity 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}:host.modal-half .search button{font-size:2.5rem;position:absolute;top:3rem;display:block;z-index:100;opacity:0;transform:scale3d(0.8, 0.8, 1);transition:opacity 0.6s, transform 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1)}[dir=ltr] :host.modal-half .search button{right:3rem}[dir=rtl] :host.modal-half .search button{left:3rem}:host.modal-half .search .form-wrapper{position:absolute;display:flex;justify-content:center;align-items:center;width:100%;height:50%;transition:transform 0.6s;transition-timing-function:cubic-bezier(0.2, 1, 0.3, 1);transform:translate3d(0, -100%, 0)}:host.modal-half .search form{width:75%;margin:0 auto}:host.modal-half .search input{font-size:7vw;width:100%}:host.modal-half.show .search{pointer-events:auto}:host.modal-half.show .search::before{opacity:1}:host.modal-half.show .search button{opacity:1;transform:scale3d(1, 1, 1)}:host.modal-half.show .search .form-wrapper{transform:translate3d(0, 0, 0)}\n"]
            }]
    }], function () { return []; }, { show: [{
            type: Input
        }], close: [{
            type: Output
        }], search: [{
            type: Output
        }], searchInput: [{
            type: Output
        }], showClass: [{
            type: HostBinding,
            args: ['class.show']
        }], modalZoomin: [{
            type: HostBinding,
            args: ['class.modal-zoomin']
        }], rotateLayout: [{
            type: HostBinding,
            args: ['class.rotate-layout']
        }], modalMove: [{
            type: HostBinding,
            args: ['class.modal-move']
        }], curtain: [{
            type: HostBinding,
            args: ['class.curtain']
        }], columnCurtain: [{
            type: HostBinding,
            args: ['class.column-curtain']
        }], modalDrop: [{
            type: HostBinding,
            args: ['class.modal-drop']
        }], modalHalf: [{
            type: HostBinding,
            args: ['class.modal-half']
        }], type: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], hint: [{
            type: Input
        }], inputElement: [{
            type: ViewChild,
            args: ['searchInput', { static: false }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSearchComponent, [{
        type: Component,
        args: [{
                selector: 'nb-search',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <button #searchButton class="start-search" (click)="emitActivate()" nbButton ghost>
      <nb-icon icon="search-outline" pack="nebular-essentials"></nb-icon>
    </button>
    <nb-search-field
      *nbPortal
      [show]="showSearchField"
      [type]="type"
      [placeholder]="placeholder"
      [hint]="hint"
      (search)="search($event)"
      (searchInput)="emitInput($event)"
      (close)="emitDeactivate()">
    </nb-search-field>
  `,
                styles: [":host button{font-size:2rem;margin:0 auto;padding:0;cursor:pointer;border:none;background:none}:host button:focus{box-shadow:none;outline:none}::ng-deep nb-layout.with-search .scrollable-container{position:relative;z-index:0}\n"]
            }]
    }], function () { return [{ type: NbSearchService }, { type: NbThemeService }, { type: ɵngcc5.Router }, { type: NbOverlayService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { placeholder: [{
            type: Input
        }], hint: [{
            type: Input
        }], tag: [{
            type: Input
        }], type: [{
            type: Input
        }], searchFieldPortal: [{
            type: ViewChild,
            args: [NbPortalDirective, { static: false }]
        }], searchButton: [{
            type: ViewChild,
            args: ['searchButton', { read: ElementRef, static: false }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSearchModule, { declarations: [NbSearchComponent,
        NbSearchFieldComponent], imports: [NbSharedModule,
        NbOverlayModule,
        NbIconModule,
        NbButtonModule], exports: [NbSearchComponent,
        NbSearchFieldComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSearchModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbOverlayModule,
                    NbIconModule,
                    NbButtonModule,
                ],
                declarations: [
                    NbSearchComponent,
                    NbSearchFieldComponent,
                ],
                exports: [
                    NbSearchComponent,
                    NbSearchFieldComponent,
                ],
                providers: [
                    NbSearchService,
                ],
                entryComponents: [
                    NbSearchFieldComponent,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCheckboxComponent, [{
        type: Component,
        args: [{
                selector: 'nb-checkbox',
                template: `
    <label class="label">
      <input type="checkbox" class="native-input visually-hidden"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValueAndIndeterminate($event)"
             (blur)="setTouched()"
             (click)="$event.stopPropagation()"
             [indeterminate]="indeterminate">
      <span [class.indeterminate]="indeterminate" [class.checked]="checked" class="custom-checkbox">
        <nb-icon *ngIf="indeterminate" icon="minus-bold-outline" pack="nebular-essentials"></nb-icon>
        <nb-icon *ngIf="checked && !indeterminate" icon="checkmark-bold-outline" pack="nebular-essentials"></nb-icon>
      </span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbCheckboxComponent_1),
                        multi: true
                    }],
                styles: [":host .label{position:relative;display:inline-flex;align-items:center;margin:0;min-height:inherit}:host .custom-checkbox{flex-shrink:0;transition-duration:0.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}:host .text{transition:color 0.15s ease-in}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { checkedChange: [{
            type: Output
        }], value: [{
            type: Input
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], status: [{
            type: Input
        }], indeterminate: [{
            type: Input
        }], valueChange: [{
            type: Output
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbCheckboxModule, { declarations: [NbCheckboxComponent], imports: [NbSharedModule,
        NbIconModule], exports: [NbCheckboxComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCheckboxModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbIconModule,
                ],
                declarations: [NbCheckboxComponent],
                exports: [NbCheckboxComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDynamicOverlay, [{
        type: Injectable
    }], function () { return [{ type: NbOverlayService }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.NgZone }, { type: NbOverlayContainer }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDynamicOverlayHandler, [{
        type: Injectable
    }], function () { return [{ type: NbPositionBuilderService }, { type: NbTriggerStrategyBuilderService }, { type: NbDynamicOverlay }]; }, null); })();
const ɵNbPopoverComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbPopoverComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbPopoverComponent, [{
        type: Component,
        args: [{
                selector: 'nb-popover',
                template: `
    <span class="arrow"></span>
    <nb-overlay-container></nb-overlay-container>
  `,
                styles: [":host .arrow{position:absolute;width:0;height:0}\n"]
            }]
    }], null, { overlayContainer: [{
            type: ViewChild,
            args: [NbOverlayContainerComponent, { static: false }]
        }], content: [{
            type: Input
        }], context: [{
            type: Input
        }], cfr: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbPopoverDirective, [{
        type: Directive,
        args: [{
                selector: '[nbPopover]',
                exportAs: 'nbPopover',
                providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NbDynamicOverlayHandler }]; }, { context: [{
            type: Input,
            args: ['nbPopoverContext']
        }], position: [{
            type: Input,
            args: ['nbPopoverPlacement']
        }], trigger: [{
            type: Input,
            args: ['nbPopoverTrigger']
        }], offset: [{
            type: Input,
            args: ['nbPopoverOffset']
        }], popoverClass: [{
            type: Input,
            args: ['nbPopoverClass']
        }], nbPopoverShowStateChange: [{
            type: Output
        }], adjustment: [{
            type: Input,
            args: ['nbPopoverAdjustment']
        }], content: [{
            type: Input,
            args: ['nbPopover']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbPopoverModule, { declarations: [NbPopoverDirective,
        NbPopoverComponent], imports: [NbOverlayModule], exports: [NbPopoverDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbPopoverModule, [{
        type: NgModule,
        args: [{
                imports: [NbOverlayModule],
                declarations: [NbPopoverDirective, NbPopoverComponent],
                exports: [NbPopoverDirective],
                entryComponents: [NbPopoverComponent]
            }]
    }], null, null); })();
const ɵNbContextMenuComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbContextMenuComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbContextMenuComponent, [{
        type: Component,
        args: [{
                selector: 'nb-context-menu',
                template: `
    <nb-menu class="context-menu" [items]="context.items" [tag]="context.tag"></nb-menu>
  `
            }]
    }], null, { items: [{
            type: Input
        }], context: [{
            type: Input
        }], tag: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbContextMenuDirective, [{
        type: Directive,
        args: [{
                selector: '[nbContextMenu]',
                providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NbMenuService }, { type: NbDynamicOverlayHandler }]; }, { contextMenuHost: [{
            type: HostBinding,
            args: ['class.context-menu-host']
        }], position: [{
            type: Input,
            args: ['nbContextMenuPlacement']
        }], adjustment: [{
            type: Input,
            args: ['nbContextMenuAdjustment']
        }], trigger: [{
            type: Input,
            args: ['nbContextMenuTrigger']
        }], contextMenuClass: [{
            type: Input,
            args: ['nbContextMenuClass']
        }], items: [{
            type: Input,
            args: ['nbContextMenu']
        }], tag: [{
            type: Input,
            args: ['nbContextMenuTag']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbContextMenuModule, { declarations: function () { return [NbContextMenuDirective,
        NbContextMenuComponent]; }, imports: function () { return [CommonModule,
        NbOverlayModule,
        NbMenuModule]; }, exports: function () { return [NbContextMenuDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbContextMenuModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, NbOverlayModule, NbMenuModule],
                exports: [NbContextMenuDirective],
                declarations: [NbContextMenuDirective, NbContextMenuComponent],
                entryComponents: [NbContextMenuComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbProgressBarComponent, [{
        type: Component,
        args: [{
                selector: 'nb-progress-bar',
                template: `
    <div class="progress-container">
      <div class="progress-value" [style.width.%]="value">
        <span *ngIf="displayValue">{{ value }}%</span>
        <ng-content></ng-content>
      </div>
    </div>
  `,
                styles: [":host{display:block}.progress-container{overflow:hidden}.progress-value{height:100%;text-align:center;overflow:hidden}\n"]
            }]
    }], function () { return []; }, { value: [{
            type: Input
        }], status: [{
            type: Input
        }], size: [{
            type: Input
        }], displayValue: [{
            type: Input
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbProgressBarModule, { declarations: [NbProgressBarComponent], imports: [NbSharedModule], exports: [NbProgressBarComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbProgressBarModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                declarations: [NbProgressBarComponent],
                exports: [NbProgressBarComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbAlertComponent, [{
        type: Component,
        args: [{
                selector: 'nb-alert',
                template: `
    <button *ngIf="closable" type="button" class="close" aria-label="Close" (click)="onClose()">
      <span aria-hidden="true">&times;</span>
    </button>
    <ng-content></ng-content>
  `,
                styles: [":host{display:flex;flex-direction:column;position:relative}[dir=ltr] :host .close{right:0}[dir=rtl] :host .close{left:0}.close{position:absolute;top:0;color:inherit;background-color:transparent;border:0;appearance:none}\n"]
            }]
    }], function () { return []; }, { size: [{
            type: Input
        }], accent: [{
            type: Input
        }], outline: [{
            type: Input
        }], close: [{
            type: Output
        }], status: [{
            type: Input
        }], closable: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.closable']
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], primaryAccent: [{
            type: HostBinding,
            args: ['class.accent-primary']
        }], successAccent: [{
            type: HostBinding,
            args: ['class.accent-success']
        }], infoAccent: [{
            type: HostBinding,
            args: ['class.accent-info']
        }], warningAccent: [{
            type: HostBinding,
            args: ['class.accent-warning']
        }], dangerAccent: [{
            type: HostBinding,
            args: ['class.accent-danger']
        }], basicAccent: [{
            type: HostBinding,
            args: ['class.accent-basic']
        }], controlAccent: [{
            type: HostBinding,
            args: ['class.accent-control']
        }], primaryOutline: [{
            type: HostBinding,
            args: ['class.outline-primary']
        }], successOutline: [{
            type: HostBinding,
            args: ['class.outline-success']
        }], infoOutline: [{
            type: HostBinding,
            args: ['class.outline-info']
        }], warningOutline: [{
            type: HostBinding,
            args: ['class.outline-warning']
        }], dangerOutline: [{
            type: HostBinding,
            args: ['class.outline-danger']
        }], basicOutline: [{
            type: HostBinding,
            args: ['class.outline-basic']
        }], controlOutline: [{
            type: HostBinding,
            args: ['class.outline-control']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbAlertModule, { declarations: [NbAlertComponent], imports: [NbSharedModule], exports: [NbAlertComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbAlertModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                declarations: [
                    NbAlertComponent,
                ],
                exports: [
                    NbAlertComponent,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbChatFormComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-form',
                template: `
    <div class="dropped-files" *ngIf="droppedFiles?.length">
      <ng-container *ngFor="let file of droppedFiles">
        <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle">
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>

        <div>
          <nb-icon *ngIf="!file.urlStyle" icon="file-text-outline" pack="nebular-essentials"></nb-icon>
          <span class="remove" (click)="removeFile(file)">&times;</span>
        </div>
      </ng-container>
    </div>
    <div class="message-row">
      <input nbInput
             fullWidth
             [status]="getInputStatus()"
             (focus)="inputFocus = true"
             (blur)="inputFocus = false"
             (mouseenter)="inputHover = true"
             (mouseleave)="inputHover = false"
             [(ngModel)]="message"
             [class.with-button]="showButton"
             type="text"
             placeholder="{{ fileOver ? 'Drop file to send' : 'Type a message' }}"
             (keyup.enter)="sendMessage()">
      <button nbButton
              [status]="getButtonStatus()"
              *ngIf="showButton"
              [class.with-icon]="!buttonTitle"
              (click)="sendMessage()"
              class="send-button">
        <nb-icon *ngIf="!buttonTitle; else title" [icon]="buttonIcon" pack="nebular-essentials"></nb-icon>
        <ng-template #title>{{ buttonTitle }}</ng-template>
      </button>
    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc4.DomSanitizer }]; }, { message: [{
            type: Input
        }], buttonTitle: [{
            type: Input
        }], buttonIcon: [{
            type: Input
        }], showButton: [{
            type: Input
        }], dropFiles: [{
            type: Input
        }], send: [{
            type: Output
        }], fileOver: [{
            type: HostBinding,
            args: ['class.file-over']
        }], onDrop: [{
            type: HostListener,
            args: ['drop', ['$event']]
        }], onDragOver: [{
            type: HostListener,
            args: ['dragover']
        }], onDragLeave: [{
            type: HostListener,
            args: ['dragleave']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbChatMessageComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-message',
                template: `
    <div class="avatar" [style.background-image]="avatarStyle" *ngIf="!reply">
      <ng-container *ngIf="!avatarStyle">
        {{ getInitials() }}
      </ng-container>
    </div>
    <div class="message">
      <ng-container [ngSwitch]="type">

        <nb-chat-message-file *ngSwitchCase="'file'"
                              [sender]="sender" [date]="date" [message]="message" [files]="files">
        </nb-chat-message-file>

        <nb-chat-message-quote *ngSwitchCase="'quote'"
                              [sender]="sender" [date]="date" [message]="message" [quote]="quote">
        </nb-chat-message-quote>

        <nb-chat-message-map *ngSwitchCase="'map'"
                              [sender]="sender" [date]="date"
                              [message]="message" [latitude]="latitude" [longitude]="longitude">
        </nb-chat-message-map>

        <nb-chat-message-text *ngSwitchDefault
                              [sender]="sender" [date]="date" [message]="message">
        </nb-chat-message-text>
      </ng-container>
    </div>
  `,
                animations: [
                    trigger('flyInOut', [
                        state('in', style({ transform: 'translateX(0)' })),
                        transition('void => *', [
                            style({ transform: 'translateX(-100%)' }),
                            animate(80),
                        ]),
                        transition('* => void', [
                            animate(80, style({ transform: 'translateX(100%)' })),
                        ]),
                    ]),
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc4.DomSanitizer }]; }, { flyInOut: [{
            type: HostBinding,
            args: ['@flyInOut']
        }], notReply: [{
            type: HostBinding,
            args: ['class.not-reply']
        }], reply: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.reply']
        }], avatar: [{
            type: Input
        }], message: [{
            type: Input
        }], sender: [{
            type: Input
        }], date: [{
            type: Input
        }], files: [{
            type: Input
        }], quote: [{
            type: Input
        }], latitude: [{
            type: Input
        }], longitude: [{
            type: Input
        }], type: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbChatComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat',
                template: `
    <div class="header">{{ title }}</div>
    <div class="scrollable" #scrollable>
      <div class="messages">
        <ng-content select="nb-chat-message"></ng-content>
        <p class="no-messages" *ngIf="!messages?.length">No messages yet.</p>
      </div>
    </div>
    <div class="form">
      <ng-content select="nb-chat-form"></ng-content>
    </div>
  `,
                styles: [":host{display:flex;flex-direction:column;position:relative;height:100%}\n"]
            }]
    }], function () { return []; }, { status: [{
            type: Input
        }], scrollBottom: [{
            type: Input
        }], messages: [{
            type: ContentChildren,
            args: [NbChatMessageComponent]
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], title: [{
            type: Input
        }], size: [{
            type: Input
        }], scrollable: [{
            type: ViewChild,
            args: ['scrollable', { static: false }]
        }], chatForm: [{
            type: ContentChild,
            args: [NbChatFormComponent, { static: false }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbChatMessageMapComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-message-map',
                template: `
    <nb-chat-message-file [files]="[file]" [message]="message" [sender]="sender" [date]="date"></nb-chat-message-file>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbChatOptions }]; }, { message: [{
            type: Input
        }], sender: [{
            type: Input
        }], date: [{
            type: Input
        }], latitude: [{
            type: Input
        }], longitude: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbChatMessageFileComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-message-file',
                template: `
    <nb-chat-message-text [sender]="sender" [date]="date" [message]="message">
      {{ message }}
    </nb-chat-message-text>

    <ng-container *ngIf="readyFiles?.length > 1">
      <div class="message-content-group">
        <a *ngFor="let file of readyFiles" [href]="file.url" target="_blank">
          <nb-icon [icon]="file.icon" *ngIf="!file.urlStyle && file.icon"></nb-icon>
          <div *ngIf="file.urlStyle" [style.background-image]="file.urlStyle"></div>
        </a>
      </div>
    </ng-container>

    <ng-container *ngIf="readyFiles?.length === 1">
      <a [href]="readyFiles[0].url" target="_blank">
        <nb-icon [icon]="readyFiles[0].icon" *ngIf="!readyFiles[0].urlStyle && readyFiles[0].icon"></nb-icon>
        <div *ngIf="readyFiles[0].urlStyle" [style.background-image]="readyFiles[0].urlStyle"></div>
      </a>
    </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc4.DomSanitizer }]; }, { files: [{
            type: Input
        }], message: [{
            type: Input
        }], sender: [{
            type: Input
        }], date: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbChatMessageQuoteComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-message-quote',
                template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date  | date:'shortTime' }}</time></p>
    <p class="quote">
      {{ quote }}
    </p>
    <nb-chat-message-text [message]="message">
      {{ message }}
    </nb-chat-message-text>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { message: [{
            type: Input
        }], sender: [{
            type: Input
        }], date: [{
            type: Input
        }], quote: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbChatMessageTextComponent, [{
        type: Component,
        args: [{
                selector: 'nb-chat-message-text',
                template: `
    <p class="sender" *ngIf="sender || date">{{ sender }} <time>{{ date  | date:'shortTime' }}</time></p>
    <p class="text" *ngIf="message">{{ message }}</p>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, { sender: [{
            type: Input
        }], message: [{
            type: Input
        }], date: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbInputDirective, [{
        type: Directive,
        args: [{
                selector: 'input[nbInput],textarea[nbInput]'
            }]
    }], function () { return []; }, { fieldSize: [{
            type: Input
        }], shape: [{
            type: Input
        }], status: [{
            type: Input
        }], fullWidth: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.input-full-width']
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], rectangle: [{
            type: HostBinding,
            args: ['class.shape-rectangle']
        }], semiRound: [{
            type: HostBinding,
            args: ['class.shape-semi-round']
        }], round: [{
            type: HostBinding,
            args: ['class.shape-round']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbInputModule, { declarations: [NbInputDirective], imports: [NbSharedModule], exports: [NbInputDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbInputModule, [{
        type: NgModule,
        args: [{
                imports: [NbSharedModule],
                declarations: NB_INPUT_COMPONENTS,
                exports: NB_INPUT_COMPONENTS
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbChatModule, { declarations: [NbChatComponent,
        NbChatMessageComponent,
        NbChatFormComponent,
        NbChatMessageTextComponent,
        NbChatMessageFileComponent,
        NbChatMessageQuoteComponent,
        NbChatMessageMapComponent], imports: [NbSharedModule,
        NbIconModule,
        NbInputModule,
        NbButtonModule], exports: [NbChatComponent,
        NbChatMessageComponent,
        NbChatFormComponent,
        NbChatMessageTextComponent,
        NbChatMessageFileComponent,
        NbChatMessageQuoteComponent,
        NbChatMessageMapComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbChatModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbIconModule,
                    NbInputModule,
                    NbButtonModule,
                ],
                declarations: [
                    ...NB_CHAT_COMPONENTS,
                ],
                exports: [
                    ...NB_CHAT_COMPONENTS,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSpinnerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-spinner',
                template: `
    <span class="spin-circle"></span>
    <span class="message" *ngIf="message">{{ message }}</span>
  `,
                styles: [":host{opacity:1;position:absolute;border-radius:inherit;top:0;right:0;left:0;bottom:0;overflow:hidden;z-index:9999;display:flex;justify-content:center;align-items:center;visibility:visible}:host .spin-circle{animation:spin 0.8s infinite linear;border-radius:50%;border-style:solid;border-width:0.125em;width:1em;height:1em}:host .message{margin-left:0.5rem}\n"]
            }]
    }], function () { return []; }, { message: [{
            type: Input
        }], size: [{
            type: Input
        }], status: [{
            type: Input
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSpinnerDirective, [{
        type: Directive,
        args: [{ selector: '[nbSpinner]' }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { spinnerStatus: [{
            type: Input,
            args: ['nbSpinnerStatus']
        }], spinnerSize: [{
            type: Input,
            args: ['nbSpinnerSize']
        }], isSpinnerExist: [{
            type: HostBinding,
            args: ['class.nb-spinner-container']
        }], nbSpinner: [{
            type: Input,
            args: ['nbSpinner']
        }], spinnerMessage: [{
            type: Input,
            args: ['nbSpinnerMessage']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSpinnerModule, { declarations: [NbSpinnerComponent,
        NbSpinnerDirective], imports: [NbSharedModule], exports: [NbSpinnerComponent,
        NbSpinnerDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSpinnerModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                ],
                exports: [NbSpinnerComponent, NbSpinnerDirective],
                declarations: [NbSpinnerComponent, NbSpinnerDirective],
                entryComponents: [NbSpinnerComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbStepComponent, [{
        type: Component,
        args: [{
                selector: 'nb-step',
                template: `
    <ng-template>
      <ng-content></ng-content>
    </ng-template>
  `
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_STEPPER]
            }] }]; }, { completed: [{
            type: Input
        }], content: [{
            type: ViewChild,
            args: [TemplateRef, { static: true }]
        }], stepControl: [{
            type: Input
        }], label: [{
            type: Input
        }], hidden: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbStepperComponent, [{
        type: Component,
        args: [{
                selector: 'nb-stepper',
                template: "<ng-template><ng-content select=\"nb-step\"></ng-content></ng-template>\n<div class=\"header\">\n  <ng-container *ngFor=\"let step of steps; let index = index; let first = first\">\n\n    <div *ngIf=\"!first && !step.hidden\"\n         [class.connector-past]=\"index <= selectedIndex\"\n         class=\"connector\"></div>\n\n    <div *ngIf=\"!step.hidden\" class=\"step\"\n         [class.selected]=\"isStepSelected(step)\"\n         [class.completed]=\"!isStepSelected(step) && step.completed\"\n         [class.noninteractive]=\"disableStepNavigation\"\n         (click)=\"!disableStepNavigation && step.select()\">\n      <div class=\"label-index\">\n        <span *ngIf=\"!step.completed || isStepSelected(step)\">{{ index + 1 }}</span>\n        <nb-icon *ngIf=\"!isStepSelected(step) && step.completed\" icon=\"checkmark-outline\" pack=\"nebular-essentials\">\n        </nb-icon>\n      </div>\n      <div class=\"label\">\n        <ng-container *ngIf=\"step.isLabelTemplate\">\n          <ng-container *ngTemplateOutlet=\"step.label\"></ng-container>\n        </ng-container>\n        <span *ngIf=\"!step.isLabelTemplate\">{{ step.label }}</span>\n      </div>\n    </div>\n  </ng-container>\n</div>\n<div class=\"step-content\">\n  <ng-container [ngTemplateOutlet]=\"selected?.content\"></ng-container>\n</div>\n",
                providers: [{ provide: NB_STEPPER, useExisting: NbStepperComponent_1 }],
                styles: [":host(.horizontal) .header .step{flex-direction:column}:host(.horizontal) .header .connector{height:2px}:host(.horizontal) .label-index{margin-bottom:10px}:host(.vertical){display:flex;height:100%}:host(.vertical) .header{flex-direction:column}:host(.vertical) .header .label{margin:0 10px}:host(.vertical) .header .connector{width:2px}.header{display:flex;justify-content:space-between;align-items:flex-start;margin-bottom:10px}.header .connector{flex:auto}.header .step{display:flex;align-items:center;cursor:pointer}.header .step.noninteractive{cursor:default}.header .label-index{display:flex;justify-content:center;align-items:center}.header .label{width:max-content}\n"]
            }]
    }], function () { return []; }, { orientation: [{
            type: Input
        }], selectedIndex: [{
            type: Input
        }], disableStepNavigation: [{
            type: Input
        }], selected: [{
            type: Input
        }], linear: [{
            type: Input
        }], vertical: [{
            type: HostBinding,
            args: ['class.vertical']
        }], horizontal: [{
            type: HostBinding,
            args: ['class.horizontal']
        }], steps: [{
            type: ContentChildren,
            args: [NbStepComponent]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbStepperNextDirective, [{
        type: Directive,
        args: [{
                selector: 'button[nbStepperNext]'
            }]
    }], function () { return [{ type: NbStepperComponent }]; }, { type: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.type']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbStepperPreviousDirective, [{
        type: Directive,
        args: [{
                selector: 'button[nbStepperPrevious]'
            }]
    }], function () { return [{ type: NbStepperComponent }]; }, { type: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.type']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbStepperModule, { declarations: [NbStepperComponent,
        NbStepComponent,
        NbStepperNextDirective,
        NbStepperPreviousDirective], imports: [NbSharedModule,
        NbIconModule], exports: [NbStepperComponent,
        NbStepComponent,
        NbStepperNextDirective,
        NbStepperPreviousDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbStepperModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbIconModule,
                ],
                declarations: [
                    NbStepperComponent,
                    NbStepComponent,
                    NbStepperNextDirective,
                    NbStepperPreviousDirective,
                ],
                exports: [
                    NbStepperComponent,
                    NbStepComponent,
                    NbStepperNextDirective,
                    NbStepperPreviousDirective,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbAccordionComponent, [{
        type: Component,
        args: [{
                selector: 'nb-accordion',
                template: `
    <ng-content select="nb-accordion-item"></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { multi: [{
            type: Input,
            args: ['multi']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbAccordionItemComponent, [{
        type: Component,
        args: [{
                selector: 'nb-accordion-item',
                template: `
    <ng-content select="nb-accordion-item-header"></ng-content>
    <ng-content select="nb-accordion-item-body"></ng-content>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex;flex-direction:column}\n"]
            }]
    }], function () { return [{ type: NbAccordionComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, { collapsedChange: [{
            type: Output
        }], collapsed: [{
            type: Input,
            args: ['collapsed']
        }, {
            type: HostBinding,
            args: ['class.collapsed']
        }], expanded: [{
            type: Input,
            args: ['expanded']
        }, {
            type: HostBinding,
            args: ['class.expanded']
        }], disabled: [{
            type: Input,
            args: ['disabled']
        }, {
            type: HostBinding,
            args: ['class.disabled']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbAccordionItemBodyComponent, [{
        type: Component,
        args: [{
                selector: 'nb-accordion-item-body',
                template: `
    <div [@accordionItemBody]="{ value: state }">
      <div class="item-body">
        <ng-content></ng-content>
      </div>
    </div>
  `,
                animations: [accordionItemBodyTrigger],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbAccordionItemComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbAccordionItemHeaderComponent, [{
        type: Component,
        args: [{
                selector: 'nb-accordion-item-header',
                template: `
    <ng-content select="nb-accordion-item-title"></ng-content>
    <ng-content select="nb-accordion-item-description"></ng-content>
    <ng-content></ng-content>
    <nb-icon icon="chevron-down-outline"
             pack="nebular-essentials"
             [@expansionIndicator]="state"
             *ngIf="!disabled"
             class="expansion-indicator">
    </nb-icon>
  `,
                animations: [
                    trigger('expansionIndicator', [
                        state('expanded', style({
                            transform: 'rotate(180deg)'
                        })),
                        transition('collapsed => expanded', animate('100ms ease-in')),
                        transition('expanded => collapsed', animate('100ms ease-out')),
                    ]),
                ],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:flex;align-items:center;cursor:pointer}:host:focus{outline:0}\n"]
            }]
    }], function () { return [{ type: NbAccordionItemComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, { isCollapsed: [{
            type: HostBinding,
            args: ['class.accordion-item-header-collapsed']
        }], expanded: [{
            type: HostBinding,
            args: ['class.accordion-item-header-expanded']
        }, {
            type: HostBinding,
            args: ['attr.aria-expanded']
        }], tabbable: [{
            type: HostBinding,
            args: ['attr.tabindex']
        }], disabled: [{
            type: HostBinding,
            args: ['attr.aria-disabled']
        }], toggle: [{
            type: HostListener,
            args: ['click']
        }, {
            type: HostListener,
            args: ['keydown.space']
        }, {
            type: HostListener,
            args: ['keydown.enter']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbAccordionModule, { declarations: function () { return [NbAccordionComponent,
        NbAccordionItemComponent,
        NbAccordionItemHeaderComponent,
        NbAccordionItemBodyComponent]; }, imports: function () { return [CommonModule,
        NbIconModule]; }, exports: function () { return [NbAccordionComponent,
        NbAccordionItemComponent,
        NbAccordionItemHeaderComponent,
        NbAccordionItemBodyComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbAccordionModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, NbIconModule],
                exports: [...NB_ACCORDION_COMPONENTS],
                declarations: [...NB_ACCORDION_COMPONENTS],
                providers: []
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbListComponent, [{
        type: Component,
        args: [{
                selector: 'nb-list',
                template: `<ng-content select="nb-list-item"></ng-content>`,
                styles: [":host{display:flex;flex-direction:column;flex:1 1 auto;overflow:auto}\n"]
            }]
    }], function () { return []; }, { role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbListItemComponent, [{
        type: Component,
        args: [{
                selector: 'nb-list-item',
                template: `<ng-content></ng-content>`,
                styles: [":host{display:flex;align-items:center;flex-shrink:0}\n"]
            }]
    }], function () { return []; }, { role: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['attr.role']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbListPageTrackerDirective, [{
        type: Directive,
        args: [{
                selector: '[nbListPageTracker]'
            }]
    }], function () { return []; }, { startPage: [{
            type: Input
        }], pageChange: [{
            type: Output
        }], pageSize: [{
            type: Input
        }], listItems: [{
            type: ContentChildren,
            args: [NbListItemComponent, { read: ElementRef }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbInfiniteListDirective, [{
        type: Directive,
        args: [{
                selector: '[nbInfiniteList]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NbLayoutScrollService }, { type: NbLayoutRulerService }]; }, { bottomThreshold: [{
            type: Output
        }], topThreshold: [{
            type: Output
        }], listenWindowScroll: [{
            type: Input
        }], onElementScroll: [{
            type: HostListener,
            args: ['scroll']
        }], threshold: [{
            type: Input
        }], listItems: [{
            type: ContentChildren,
            args: [NbListItemComponent]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbListModule, { declarations: [NbListComponent,
        NbListItemComponent,
        NbListPageTrackerDirective,
        NbInfiniteListDirective], exports: [NbListComponent,
        NbListItemComponent,
        NbListPageTrackerDirective,
        NbInfiniteListDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbListModule, [{
        type: NgModule,
        args: [{
                declarations: components,
                exports: components
            }]
    }], null, null); })();
const ɵNbDirectionality_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbDirectionality);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDirectionality, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbBidiModule, [{
        type: NgModule,
        args: [{
                providers: [
                    { provide: NbDirectionality, useExisting: Directionality },
                ]
            }]
    }], null, null); })();
const ɵNbBidiModule_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbBidiModule);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbPlatformModule, [{
        type: NgModule,
        args: [{
                providers: [
                    { provide: NbPlatform$1, useExisting: Platform },
                ]
            }]
    }], null, null); })();
const ɵNbPlatformModule_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbPlatformModule);
const ɵNbCellDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbCellDefDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbCellDef]',
                providers: [{ provide: CdkCellDef, useExisting: NbCellDefDirective_1 }]
            }]
    }], null, null); })();
const ɵNbHeaderCellDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbHeaderCellDefDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbHeaderCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbHeaderCellDef]',
                providers: [{ provide: CdkHeaderCellDef, useExisting: NbHeaderCellDefDirective_1 }]
            }]
    }], null, null); })();
const ɵNbFooterCellDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbFooterCellDefDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbFooterCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbFooterCellDef]',
                providers: [{ provide: CdkFooterCellDef, useExisting: NbFooterCellDefDirective_1 }]
            }]
    }], null, null); })();
const ɵNbColumnDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbColumnDefDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbColumnDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbColumnDef]',
                providers: [
                    { provide: CdkColumnDef, useExisting: NbColumnDefDirective_1 },
                    { provide: NB_SORT_HEADER_COLUMN_DEF, useExisting: NbColumnDefDirective_1 },
                ]
            }]
    }], null, { name: [{
            type: Input,
            args: ['nbColumnDef']
        }], sticky: [{
            type: Input
        }], stickyEnd: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbHeaderCellDirective, [{
        type: Directive,
        args: [{
                selector: 'nb-header-cell, th[nbHeaderCell]',
                host: {
                    'class': 'nb-header-cell',
                    'role': 'columnheader'
                }
            }]
    }], function () { return [{ type: NbColumnDefDirective }, { type: ɵngcc0.ElementRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbFooterCellDirective, [{
        type: Directive,
        args: [{
                selector: 'nb-footer-cell, td[nbFooterCell]',
                host: {
                    'class': 'nb-footer-cell',
                    'role': 'gridcell'
                }
            }]
    }], function () { return [{ type: NbColumnDefDirective }, { type: ɵngcc0.ElementRef }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCellDirective, [{
        type: Directive,
        args: [{
                selector: 'nb-cell, td[nbCell]',
                host: {
                    'class': 'nb-cell',
                    'role': 'gridcell'
                }
            }]
    }], function () { return [{ type: NbColumnDefDirective }, { type: ɵngcc0.ElementRef }]; }, null); })();
const ɵNbDataRowOutletDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbDataRowOutletDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDataRowOutletDirective, [{
        type: Directive,
        args: [{
                selector: '[nbRowOutlet]',
                providers: [{ provide: DataRowOutlet, useExisting: NbDataRowOutletDirective_1 }]
            }]
    }], null, null); })();
const ɵNbHeaderRowOutletDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbHeaderRowOutletDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbHeaderRowOutletDirective, [{
        type: Directive,
        args: [{
                selector: '[nbHeaderRowOutlet]',
                providers: [{ provide: HeaderRowOutlet, useExisting: NbHeaderRowOutletDirective_1 }]
            }]
    }], null, null); })();
const ɵNbFooterRowOutletDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbFooterRowOutletDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbFooterRowOutletDirective, [{
        type: Directive,
        args: [{
                selector: '[nbFooterRowOutlet]',
                providers: [{ provide: FooterRowOutlet, useExisting: NbFooterRowOutletDirective_1 }]
            }]
    }], null, null); })();
const ɵNbCellOutletDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbCellOutletDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbCellOutletDirective, [{
        type: Directive,
        args: [{
                selector: '[nbCellOutlet]',
                providers: [{ provide: CdkCellOutlet, useExisting: NbCellOutletDirective_1 }]
            }]
    }], null, null); })();
const ɵNbHeaderRowDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbHeaderRowDefDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbHeaderRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbHeaderRowDef]',
                providers: [{ provide: CdkHeaderRowDef, useExisting: NbHeaderRowDefDirective_1 }]
            }]
    }], null, { columns: [{
            type: Input,
            args: ['nbHeaderRowDef']
        }], sticky: [{
            type: Input,
            args: ['nbHeaderRowDefSticky']
        }] }); })();
const ɵNbFooterRowDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbFooterRowDefDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbFooterRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbFooterRowDef]',
                providers: [{ provide: CdkFooterRowDef, useExisting: NbFooterRowDefDirective_1 }]
            }]
    }], null, { columns: [{
            type: Input,
            args: ['nbFooterRowDef']
        }], sticky: [{
            type: Input,
            args: ['nbFooterRowDefSticky']
        }] }); })();
const ɵNbRowDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbRowDefDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbRowDef]',
                providers: [{ provide: CdkRowDef, useExisting: NbRowDefDirective_1 }]
            }]
    }], null, { columns: [{
            type: Input,
            args: ['nbRowDefColumns']
        }], when: [{
            type: Input,
            args: ['nbRowDefWhen']
        }] }); })();
const ɵNbHeaderRowComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbHeaderRowComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbHeaderRowComponent, [{
        type: Component,
        args: [{
                selector: 'nb-header-row, tr[nbHeaderRow]',
                template: `
    <ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-header-row',
                    'role': 'row'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: CdkHeaderRow, useExisting: NbHeaderRowComponent_1 }]
            }]
    }], null, null); })();
const ɵNbFooterRowComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbFooterRowComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbFooterRowComponent, [{
        type: Component,
        args: [{
                selector: 'nb-footer-row, tr[nbFooterRow]',
                template: `
    <ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-footer-row',
                    'role': 'row'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: CdkFooterRow, useExisting: NbFooterRowComponent_1 }]
            }]
    }], null, null); })();
const ɵNbRowComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbRowComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbRowComponent, [{
        type: Component,
        args: [{
                selector: 'nb-row, tr[nbRow]',
                template: `
    <ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-row',
                    'role': 'row'
                },
                providers: [{ provide: CdkRow, useExisting: NbRowComponent_1 }],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbTableModule, { declarations: [NbTable,
        NbHeaderCellDefDirective,
        NbHeaderRowDefDirective,
        NbColumnDefDirective,
        NbCellDefDirective,
        NbRowDefDirective,
        NbFooterCellDefDirective,
        NbFooterRowDefDirective,
        NbDataRowOutletDirective,
        NbHeaderRowOutletDirective,
        NbFooterRowOutletDirective,
        NbCellOutletDirective,
        NbHeaderCellDirective,
        NbCellDirective,
        NbFooterCellDirective,
        NbHeaderRowComponent,
        NbRowComponent,
        NbFooterRowComponent], imports: [NbBidiModule,
        NbPlatformModule], exports: [NbTable,
        NbHeaderCellDefDirective,
        NbHeaderRowDefDirective,
        NbColumnDefDirective,
        NbCellDefDirective,
        NbRowDefDirective,
        NbFooterCellDefDirective,
        NbFooterRowDefDirective,
        NbDataRowOutletDirective,
        NbHeaderRowOutletDirective,
        NbFooterRowOutletDirective,
        NbCellOutletDirective,
        NbHeaderCellDirective,
        NbCellDirective,
        NbFooterCellDirective,
        NbHeaderRowComponent,
        NbRowComponent,
        NbFooterRowComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTableModule, [{
        type: NgModule,
        args: [{
                imports: [NbBidiModule, NbPlatformModule],
                declarations: [...COMPONENTS$1],
                exports: [...COMPONENTS$1]
            }]
    }], null, null); })();
const ɵNbTableModule_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbTableModule);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDialogContainerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-dialog-container',
                template: '<ng-template nbPortalOutlet></ng-template>'
            }]
    }], function () { return [{ type: NbDialogConfig }, { type: ɵngcc0.ElementRef }, { type: NbFocusTrapFactoryService }]; }, { portalOutlet: [{
            type: ViewChild,
            args: [NbPortalOutletDirective, { static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDialogService, [{
        type: Injectable
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_DIALOG_CONFIG]
            }] }, { type: NbPositionBuilderService }, { type: NbOverlayService }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ComponentFactoryResolver }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbDialogModule, { declarations: [NbDialogContainerComponent], imports: [NbSharedModule,
        NbOverlayModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDialogModule, [{
        type: NgModule,
        args: [{
                imports: [NbSharedModule, NbOverlayModule],
                declarations: [NbDialogContainerComponent],
                entryComponents: [NbDialogContainerComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbToastComponent, [{
        type: Component,
        args: [{
                selector: 'nb-toast',
                template: "<div class=\"icon-container\" *ngIf=\"hasIcon && icon\">\n  <nb-icon [config]=\"iconConfig\"></nb-icon>\n</div>\n<div class=\"content-container\">\n  <span class=\"title subtitle\">{{ toast.title }}</span>\n  <div class=\"message\">{{ toast.message }}</div>\n</div>\n",
                styles: [":host{display:flex;align-items:center;width:25rem;margin:0.5rem}:host .title{margin-right:0.25rem}:host.default .content-container,:host:not(.has-icon) .content-container{display:flex;flex-direction:row}:host.destroy-by-click{cursor:pointer}:host nb-icon{font-size:2.5rem}:host svg{width:2.5rem;height:2.5rem}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: ɵngcc0.ElementRef }]; }, { destroy: [{
            type: Output
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], destroyByClick: [{
            type: HostBinding,
            args: ['class.destroy-by-click']
        }], hasIcon: [{
            type: HostBinding,
            args: ['class.has-icon']
        }], customIcon: [{
            type: HostBinding,
            args: ['class.custom-icon']
        }], onClick: [{
            type: HostListener,
            args: ['click']
        }], toast: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbToastrContainerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-toastr-container',
                template: `
    <nb-toast [@fadeIn]="fadeIn" *ngFor="let toast of content" [toast]="toast"></nb-toast>`,
                animations: [
                    trigger('fadeIn', [
                        transition(':enter', [voidState, animate(100)], defaultOptions),
                        transition(':leave', [animate(100, voidState)], defaultOptions),
                    ]),
                ]
            }]
    }], function () { return [{ type: NbLayoutDirectionService }, { type: NbPositionHelper }]; }, { content: [{
            type: Input
        }], context: [{
            type: Input
        }], position: [{
            type: Input
        }], toasts: [{
            type: ViewChildren,
            args: [NbToastComponent]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbToastrContainerRegistry, [{
        type: Injectable
    }], function () { return [{ type: NbOverlayService }, { type: NbPositionBuilderService }, { type: NbPositionHelper }, { type: ɵngcc0.ComponentFactoryResolver }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbToastrService, [{
        type: Injectable
    }], function () { return [{ type: NbToastrConfig, decorators: [{
                type: Inject,
                args: [NB_TOASTR_CONFIG]
            }] }, { type: NbToastrContainerRegistry }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbToastrModule, { declarations: [NbToastrContainerComponent,
        NbToastComponent], imports: [NbSharedModule,
        NbOverlayModule,
        NbIconModule] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbToastrModule, [{
        type: NgModule,
        args: [{
                imports: [NbSharedModule, NbOverlayModule, NbIconModule],
                declarations: [NbToastrContainerComponent, NbToastComponent],
                entryComponents: [NbToastrContainerComponent, NbToastComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTooltipComponent, [{
        type: Component,
        args: [{
                selector: 'nb-tooltip',
                template: `
    <span class="arrow"></span>
    <div class="content">
      <nb-icon *ngIf="context?.icon" [config]="context.icon"></nb-icon>
      <span *ngIf="content">{{ content }}</span>
    </div>
  `,
                animations: [
                    trigger('showTooltip', [
                        state('in', style({ opacity: 1 })),
                        transition('void => *', [
                            style({ opacity: 0 }),
                            animate(100),
                        ]),
                        transition('* => void', [
                            animate(100, style({ opacity: 0 })),
                        ]),
                    ]),
                ],
                styles: [":host{z-index:10000}:host .content{display:flex;align-items:center}:host.right .content{flex-direction:row-reverse}:host .arrow{position:absolute;width:0;height:0}:host nb-icon+span{margin-left:0.5rem}:host.right nb-icon+span{margin-right:0.5rem}:host .arrow{border-left:6px solid transparent;border-right:6px solid transparent}:host(.bottom) .arrow{top:-6px;left:calc(50% - 6px)}:host(.bottom-start) .arrow{top:-6px}[dir=ltr] :host(.bottom-start) .arrow{right:6px}[dir=rtl] :host(.bottom-start) .arrow{left:6px}:host(.bottom-end) .arrow{top:-6px}[dir=ltr] :host(.bottom-end) .arrow{left:6px}[dir=rtl] :host(.bottom-end) .arrow{right:6px}:host(.left) .arrow,:host(.start) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.left) .arrow,[dir=ltr] :host(.start) .arrow{right:-8px;transform:rotate(90deg)}[dir=rtl] :host(.left) .arrow,[dir=rtl] :host(.start) .arrow{left:-8px;transform:rotate(270deg)}:host(.start-top) .arrow{right:-8px;bottom:6px;transform:rotate(90deg)}:host(.start-bottom) .arrow{right:-8px;top:6px;transform:rotate(90deg)}:host(.top) .arrow{bottom:-6px;left:calc(50% - 6px);transform:rotate(180deg)}:host(.top-start) .arrow{bottom:calc(-1 * 6px + 1px);transform:rotate(180deg)}[dir=ltr] :host(.top-start) .arrow{right:6px}[dir=rtl] :host(.top-start) .arrow{left:6px}:host(.top-end) .arrow{bottom:calc(-6px + 1px);transform:rotate(180deg)}[dir=ltr] :host(.top-end) .arrow{left:6px}[dir=rtl] :host(.top-end) .arrow{right:6px}:host(.right) .arrow,:host(.end) .arrow{top:calc(50% - 2.4px)}[dir=ltr] :host(.right) .arrow,[dir=ltr] :host(.end) .arrow{left:-8px;transform:rotate(270deg)}[dir=rtl] :host(.right) .arrow,[dir=rtl] :host(.end) .arrow{right:-8px;transform:rotate(90deg)}:host(.end-top) .arrow{left:calc(-6px - 6px / 2.5);bottom:6px;transform:rotate(270deg)}:host(.end-bottom) .arrow{left:calc(-6px - 6px / 2.5);top:6px;transform:rotate(270deg)}\n"]
            }]
    }], function () { return []; }, { position: [{
            type: Input
        }], context: [{
            type: Input
        }], binding: [{
            type: HostBinding,
            args: ['class']
        }], show: [{
            type: HostBinding,
            args: ['@showTooltip']
        }], content: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTooltipDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTooltip]',
                exportAs: 'nbTooltip',
                providers: [NbDynamicOverlayHandler, NbDynamicOverlay]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: NbDynamicOverlayHandler }]; }, { position: [{
            type: Input,
            args: ['nbTooltipPlacement']
        }], tooltipClass: [{
            type: Input,
            args: ['nbTooltipClass']
        }], trigger: [{
            type: Input,
            args: ['nbTooltipTrigger']
        }], nbTooltipShowStateChange: [{
            type: Output
        }], adjustment: [{
            type: Input,
            args: ['nbTooltipAdjustment']
        }], icon: [{
            type: Input,
            args: ['nbTooltipIcon']
        }], status: [{
            type: Input,
            args: ['nbTooltipStatus']
        }], content: [{
            type: Input,
            args: ['nbTooltip']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbTooltipModule, { declarations: [NbTooltipComponent,
        NbTooltipDirective], imports: [NbSharedModule,
        NbOverlayModule,
        NbIconModule], exports: [NbTooltipDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTooltipModule, [{
        type: NgModule,
        args: [{
                imports: [NbSharedModule, NbOverlayModule, NbIconModule],
                declarations: [NbTooltipComponent, NbTooltipDirective],
                exports: [NbTooltipDirective],
                entryComponents: [NbTooltipComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbOptionComponent, [{
        type: Component,
        args: [{
                selector: 'nb-option',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <nb-checkbox *ngIf="withCheckbox"
                 [checked]="selected"
                 [disabled]="disabled"
                 aria-hidden="true">
    </nb-checkbox>
    <ng-content></ng-content>
  `,
                styles: ["/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:flex;transition-duration:0.15s;transition-property:background-color,color;transition-timing-function:ease-in}:host:hover{cursor:pointer}:host nb-checkbox{display:flex;pointer-events:none}[dir=ltr] :host nb-checkbox{margin-right:.5rem}[dir=rtl] :host nb-checkbox{margin-left:.5rem}:host nb-checkbox ::ng-deep .label{padding:0}:host([disabled]){pointer-events:none}\n"]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_SELECT_INJECTION_TOKEN]
            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ChangeDetectorRef }]; }, { selectionChange: [{
            type: Output
        }], disabled: [{
            type: Input
        }], selectedClass: [{
            type: HostBinding,
            args: ['class.selected']
        }], disabledAttribute: [{
            type: HostBinding,
            args: ['attr.disabled']
        }], tabindex: [{
            type: HostBinding,
            args: ['tabIndex']
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.space', ['$event']]
        }, {
            type: HostListener,
            args: ['keydown.enter', ['$event']]
        }], value: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSelectLabelComponent, [{
        type: Component,
        args: [{
                selector: 'nb-select-label',
                template: '<ng-content></ng-content>'
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSelectComponent, [{
        type: Component,
        args: [{
                selector: 'nb-select',
                template: "<button [disabled]=\"disabled\"\n        [ngClass]=\"selectButtonClasses\"\n        (blur)=\"trySetTouched()\"\n        (keydown.arrowDown)=\"show()\"\n        (keydown.arrowUp)=\"show()\"\n        class=\"select-button\"\n        type=\"button\"\n        #selectButton>\n\n    <ng-container *ngIf=\"selectionModel.length; else placeholderTemplate\">\n      <ng-container *ngIf=\"customLabel; else defaultSelectionTemplate\">\n        <ng-content select=\"nb-select-label\"></ng-content>\n      </ng-container>\n\n      <ng-template #defaultSelectionTemplate>{{ selectionView }}</ng-template>\n    </ng-container>\n\n    <ng-template #placeholderTemplate>{{ placeholder }}</ng-template>\n\n    <nb-icon icon=\"chevron-down-outline\" pack=\"nebular-essentials\" (click)=\"disabled && $event.stopPropagation()\" aria-hidden=\"true\">\n    </nb-icon>\n</button>\n\n<div *nbPortal [ngClass]=\"optionsListClasses\" [style.width.px]=\"hostWidth\" class=\"options-list-container\">\n  <ul class=\"options-list\" [class.full-width]=\"fullWidth\">\n    <ng-content select=\"nb-option, nb-option-group\"></ng-content>\n  </ul>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbSelectComponent_1),
                        multi: true
                    },
                    { provide: NB_SELECT_INJECTION_TOKEN, useExisting: NbSelectComponent_1 },
                ],
                styles: ["/*!\n * @license\n * Copyright Akveo. All Rights Reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */:host{display:inline-block;max-width:100%}[dir=ltr] :host .select-button{text-align:left}[dir=ltr] :host .select-button nb-icon{right:0.2em}[dir=rtl] :host .select-button{text-align:right}[dir=rtl] :host .select-button nb-icon{left:0.2em}:host .select-button.bottom{border-bottom-left-radius:0;border-bottom-right-radius:0}:host .select-button.top{border-top-left-radius:0;border-top-right-radius:0}:host(.full-width){width:100%}.select-button{position:relative;width:100%;overflow:hidden;text-overflow:ellipsis;text-transform:none;white-space:nowrap;transition-duration:0.15s;transition-property:background-color,border-color,border-radius,box-shadow,color;transition-timing-function:ease-in}nb-icon{font-size:1.5em;position:absolute;top:50%;transform:translateY(-50%);transition-duration:0.15s;transition-property:transform;transition-timing-function:ease-in}[dir=ltr] nb-icon{right:.5rem}[dir=rtl] nb-icon{left:.5rem}:host(.open) nb-icon{transform:translateY(-50%) rotate(180deg)}\n"]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbOverlayService }, { type: ɵngcc0.ElementRef }, { type: NbPositionBuilderService }, { type: NbTriggerStrategyBuilderService }, { type: ɵngcc0.ChangeDetectorRef }, { type: NbFocusKeyManagerFactoryService }]; }, { size: [{
            type: Input
        }], status: [{
            type: Input
        }], shape: [{
            type: Input
        }], appearance: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], selectedChange: [{
            type: Output
        }], outline: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-outline']
        }], filled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-filled']
        }], hero: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.appearance-hero']
        }], disabled: [{
            type: Input
        }], fullWidth: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.full-width']
        }], selected: [{
            type: Input
        }], multiple: [{
            type: Input
        }], isOpen: [{
            type: HostBinding,
            args: ['class.open']
        }], tiny: [{
            type: HostBinding,
            args: ['class.size-tiny']
        }], small: [{
            type: HostBinding,
            args: ['class.size-small']
        }], medium: [{
            type: HostBinding,
            args: ['class.size-medium']
        }], large: [{
            type: HostBinding,
            args: ['class.size-large']
        }], giant: [{
            type: HostBinding,
            args: ['class.size-giant']
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], rectangle: [{
            type: HostBinding,
            args: ['class.shape-rectangle']
        }], round: [{
            type: HostBinding,
            args: ['class.shape-round']
        }], semiRound: [{
            type: HostBinding,
            args: ['class.shape-semi-round']
        }], options: [{
            type: ContentChildren,
            args: [NbOptionComponent, { descendants: true }]
        }], customLabel: [{
            type: ContentChild,
            args: [NbSelectLabelComponent, { static: false }]
        }], portal: [{
            type: ViewChild,
            args: [NbPortalDirective, { static: false }]
        }], button: [{
            type: ViewChild,
            args: ['selectButton', { read: ElementRef, static: false }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbOptionGroupComponent, [{
        type: Component,
        args: [{
                selector: 'nb-option-group',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
    <span class="option-group-title">{{ title }}</span>
    <ng-content select="nb-option, ng-container"></ng-content>
  `,
                styles: [":host{display:block}.option-group-title{display:block}\n"]
            }]
    }], function () { return []; }, { disabled: [{
            type: Input
        }], disabledAttribute: [{
            type: HostBinding,
            args: ['attr.disabled']
        }], title: [{
            type: Input
        }], options: [{
            type: ContentChildren,
            args: [NbOptionComponent, { descendants: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbSelectModule, { declarations: [NbSelectComponent,
        NbOptionComponent,
        NbOptionGroupComponent,
        NbSelectLabelComponent], imports: [NbSharedModule,
        NbOverlayModule,
        NbButtonModule,
        NbInputModule,
        NbCardModule,
        NbCheckboxModule,
        NbIconModule], exports: [NbSelectComponent,
        NbOptionComponent,
        NbOptionGroupComponent,
        NbSelectLabelComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSelectModule, [{
        type: NgModule,
        args: [{
                imports: [
                    NbSharedModule,
                    NbOverlayModule,
                    NbButtonModule,
                    NbInputModule,
                    NbCardModule,
                    NbCheckboxModule,
                    NbIconModule,
                ],
                exports: [...NB_SELECT_COMPONENTS],
                declarations: [...NB_SELECT_COMPONENTS]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbWindowsContainerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-windows-container',
                template: `<ng-container #viewContainerRef></ng-container>`,
                styles: [":host{display:flex;align-items:flex-end;overflow-x:auto}:host ::ng-deep nb-window:not(.full-screen){margin:0 2rem}\n"]
            }]
    }], null, { viewContainerRef: [{
            type: ViewChild,
            args: ['viewContainerRef', { read: ViewContainerRef, static: true }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbWindowComponent, [{
        type: Component,
        args: [{
                selector: 'nb-window',
                template: `
    <nb-card>
      <nb-card-header>
        <div cdkFocusInitial class="title" tabindex="-1">{{ config.title }}</div>

        <div class="buttons">
          <button nbButton ghost (click)="minimize()">
            <nb-icon icon="minus-outline" pack="nebular-essentials"></nb-icon>
          </button>
          <button nbButton ghost *ngIf="isFullScreen" (click)="maximize()">
            <nb-icon icon="collapse-outline" pack="nebular-essentials"></nb-icon>
          </button>
          <button nbButton ghost *ngIf="minimized || maximized" (click)="maximizeOrFullScreen()">
            <nb-icon icon="expand-outline" pack="nebular-essentials"></nb-icon>
          </button>
          <button nbButton ghost (click)="close()">
            <nb-icon icon="close-outline" pack="nebular-essentials"></nb-icon>
          </button>
        </div>
      </nb-card-header>
      <nb-card-body *ngIf="maximized || isFullScreen">
        <nb-overlay-container></nb-overlay-container>
      </nb-card-body>
    </nb-card>
  `,
                styles: [":host{flex:1 0 auto;min-width:20rem}:host nb-card{margin:0}:host nb-card-header{display:flex;justify-content:space-between;align-items:center;overflow:hidden}:host .title{flex:1 0 auto;margin-right:3rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host .buttons{width:9.5rem;display:flex;justify-content:space-evenly}:host .buttons [nbButton]{flex:0 0 3rem}:host(.full-screen){position:fixed;top:50%;left:50%;transform:translate(-50%, -50%)}:host(.maximized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0}:host(.minimized) nb-card{border-bottom-left-radius:0;border-bottom-right-radius:0;height:auto}:host(.minimized) nb-card nb-card-header{border-bottom:none}\n"]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_WINDOW_CONTENT]
            }] }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_WINDOW_CONTEXT]
            }] }, { type: NbWindowRef }, { type: NbWindowConfig }, { type: NbFocusTrapFactoryService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { isFullScreen: [{
            type: HostBinding,
            args: ['class.full-screen']
        }], maximized: [{
            type: HostBinding,
            args: ['class.maximized']
        }], minimized: [{
            type: HostBinding,
            args: ['class.minimized']
        }], cfr: [{
            type: Input
        }], overlayContainer: [{
            type: ViewChild,
            args: [NbOverlayContainerComponent, { static: false }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbWindowService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: NbOverlayService }, { type: NbOverlayPositionBuilder }, { type: NbBlockScrollStrategyAdapter }, { type: NbWindowConfig, decorators: [{
                type: Inject,
                args: [NB_WINDOW_CONFIG]
            }] }, { type: ɵngcc0.ComponentFactoryResolver }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbWindowModule, { declarations: function () { return [NbWindowsContainerComponent,
        NbWindowComponent]; }, imports: function () { return [CommonModule,
        NbOverlayModule,
        NbCardModule,
        NbIconModule,
        NbButtonModule]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbWindowModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, NbOverlayModule, NbCardModule, NbIconModule, NbButtonModule],
                declarations: [
                    NbWindowsContainerComponent,
                    NbWindowComponent,
                ],
                entryComponents: [NbWindowsContainerComponent, NbWindowComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDatepickerDirective, [{
        type: Directive,
        args: [{
                selector: 'input[nbDatepicker]',
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbDatepickerDirective_1),
                        multi: true
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => NbDatepickerDirective_1),
                        multi: true
                    },
                ]
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: Array, decorators: [{
                type: Inject,
                args: [NB_DATE_ADAPTER]
            }] }, { type: ɵngcc0.ElementRef }, { type: NbDateService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { setPicker: [{
            type: Input,
            args: ['nbDatepicker']
        }] }); })();
const ɵNbDatepickerContainerComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbDatepickerContainerComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDatepickerContainerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-datepicker-container',
                template: `
    <span class="arrow"></span>
    <nb-overlay-container></nb-overlay-container>
  `,
                styles: [":host .arrow{position:absolute;width:0;height:0}:host ::ng-deep nb-overlay-container .primitive-overlay{padding:0.75rem 1rem}\n"]
            }]
    }], null, { overlayContainer: [{
            type: ViewChild,
            args: [NbOverlayContainerComponent, { static: true }]
        }] }); })();

/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbBasePickerComponent, [{
        type: Component,
        args: [{
                template: ''
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbPositionBuilderService }, { type: NbTriggerStrategyBuilderService }, { type: NbOverlayService }, { type: ɵngcc0.ComponentFactoryResolver }, { type: NbDateService }, { type: Object, decorators: [{
                type: Optional
            }, {
                type: Inject,
                args: [NB_DATE_SERVICE_OPTIONS]
            }] }]; }, { boundingMonth: [{
            type: Input
        }], startView: [{
            type: Input
        }], size: [{
            type: Input
        }], hideOnSelect: [{
            type: Input
        }], showHeader: [{
            type: Input
        }], weekNumberSymbol: [{
            type: Input
        }], showWeekNumber: [{
            type: Input
        }], format: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], filter: [{
            type: Input
        }], dayCellComponent: [{
            type: Input
        }], monthCellComponent: [{
            type: Input
        }], yearCellComponent: [{
            type: Input
        }], visibleDate: [{
            type: Input
        }] }); })();
const ɵNbDatepickerComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbDatepickerComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDatepickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-datepicker',
                template: ''
            }]
    }], null, { date: [{
            type: Input
        }], dateChange: [{
            type: Output
        }] }); })();
const ɵNbRangepickerComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbRangepickerComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbRangepickerComponent, [{
        type: Component,
        args: [{
                selector: 'nb-rangepicker',
                template: ''
            }]
    }], null, { range: [{
            type: Input
        }], rangeChange: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDateAdapterService, [{
        type: Injectable
    }], function () { return [{ type: NbDateService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbRangeAdapterService, [{
        type: Injectable
    }], function () { return [{ type: NbDateService }]; }, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbDatepickerModule, { declarations: [NbDatepickerDirective,
        NbDatepickerContainerComponent,
        NbDatepickerComponent,
        NbRangepickerComponent,
        NbBasePickerComponent], imports: [NbOverlayModule,
        NbCalendarModule,
        NbCalendarRangeModule], exports: [NbDatepickerDirective,
        NbDatepickerComponent,
        NbRangepickerComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbDatepickerModule, [{
        type: NgModule,
        args: [{
                imports: [NbOverlayModule, NbCalendarModule, NbCalendarRangeModule],
                exports: [NbDatepickerDirective, NbDatepickerComponent, NbRangepickerComponent],
                declarations: [
                    NbDatepickerDirective,
                    NbDatepickerContainerComponent,
                    NbDatepickerComponent,
                    NbRangepickerComponent,
                    NbBasePickerComponent,
                ],
                entryComponents: [NbCalendarComponent, NbCalendarRangeComponent, NbDatepickerContainerComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbRadioComponent, [{
        type: Component,
        args: [{
                selector: 'nb-radio',
                template: `
    <label>
      <input
        type="radio"
        class="native-input visually-hidden"
        [name]="name"
        [value]="value"
        [checked]="checked"
        [disabled]="disabled"
        (change)="onChange($event)"
        (click)="onClick($event)">
      <span class="outer-circle"></span>
      <span class="inner-circle"></span>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:block;position:relative}:host label{display:inline-flex;margin:0;min-height:inherit;padding:0.375rem 0;align-items:center}[dir=ltr] :host label{padding-right:1.5rem}[dir=rtl] :host label{padding-left:1.5rem}:host .outer-circle,:host .inner-circle{border-radius:50%;position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] :host .outer-circle,[dir=ltr] :host .inner-circle{left:0}[dir=rtl] :host .outer-circle,[dir=rtl] :host .inner-circle{right:0}:host .inner-circle{transform:translateY(-50%) scale(0.65)}[dir=ltr] :host .text{padding-left:.5rem}[dir=rtl] :host .text{padding-right:.5rem}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }]; }, { valueChange: [{
            type: Output
        }], blur: [{
            type: Output
        }], name: [{
            type: Input
        }], checked: [{
            type: Input
        }], value: [{
            type: Input
        }], disabled: [{
            type: Input
        }], status: [{
            type: Input
        }], isPrimary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], isSuccess: [{
            type: HostBinding,
            args: ['class.status-success']
        }], isWarning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], isDanger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], isInfo: [{
            type: HostBinding,
            args: ['class.status-info']
        }], isBasic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], isControl: [{
            type: HostBinding,
            args: ['class.status-control']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbRadioGroupComponent, [{
        type: Component,
        args: [{
                selector: 'nb-radio-group',
                template: `
    <ng-content select="nb-radio"></ng-content>`,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbRadioGroupComponent_1),
                        multi: true
                    },
                ],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }]; }, { valueChange: [{
            type: Output
        }], value: [{
            type: Input
        }], name: [{
            type: Input
        }], disabled: [{
            type: Input
        }], status: [{
            type: Input
        }], radios: [{
            type: ContentChildren,
            args: [NbRadioComponent, { descendants: true }]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbRadioModule, { declarations: [NbRadioComponent,
        NbRadioGroupComponent], exports: [NbRadioComponent,
        NbRadioGroupComponent] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbRadioModule, [{
        type: NgModule,
        args: [{
                imports: [],
                exports: [NbRadioComponent, NbRadioGroupComponent],
                declarations: [NbRadioComponent, NbRadioGroupComponent]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridDataService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridFilterService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSortDirective, [{
        type: Directive,
        args: [{ selector: '[nbSort]' }]
    }], function () { return []; }, { sort: [{
            type: Output
        }], sortable: [{
            type: Input,
            args: ['nbSort']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSortHeaderIconDirective, [{
        type: Directive,
        args: [{ selector: '[nbSortHeaderIcon]' }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSortIconComponent, [{
        type: Component,
        args: [{
                selector: 'nb-sort-icon',
                template: `
    <ng-container *ngIf="isDirectionSet()">
      <nb-icon *ngIf="isAscending()" icon="chevron-down-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
      <nb-icon *ngIf="isDescending()" icon="chevron-up-outline" pack="nebular-essentials" aria-hidden="true"></nb-icon>
    </ng-container>
  `
            }]
    }], function () { return []; }, { direction: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbSortHeaderComponent, [{
        type: Component,
        args: [{
                selector: '[nbSortHeader]',
                template: `
    <button
      class="nb-tree-grid-header-change-sort-button"
      type="button"
      [attr.disabled]="getDisabledAttributeValue()"
      (click)="sortData()">
      <ng-content></ng-content>
    </button>
    <nb-sort-icon *ngIf="!sortIcon; else customIcon" [direction]="direction"></nb-sort-icon>
    <ng-template #customIcon [ngTemplateOutlet]="sortIcon" [ngTemplateOutletContext]="getIconContext()"></ng-template>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: NbSortDirective }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_SORT_HEADER_COLUMN_DEF]
            }] }]; }, { disabled: [{
            type: Input
        }, {
            type: HostBinding,
            args: ['class.disabled']
        }], sortIfEnabled: [{
            type: HostListener,
            args: ['click']
        }], direction: [{
            type: Input,
            args: ['nbSortHeader']
        }], sortIcon: [{
            type: ContentChild,
            args: [NbSortHeaderIconDirective, { read: TemplateRef, static: false }]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridSortService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridService, [{
        type: Injectable
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridDataSourceBuilder, [{
        type: Injectable
    }], function () { return [{ type: NbTreeGridFilterService }, { type: NbTreeGridSortService }, { type: NbTreeGridService }, { type: NbTreeGridDataService }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridRowComponent, [{
        type: Component,
        args: [{
                selector: 'tr[nbTreeGridRow]',
                template: `<ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-tree-grid-row',
                    'role': 'row'
                },
                providers: [{ provide: NbCdkRow, useExisting: NbTreeGridRowComponent_1 }],
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return [{ type: Object, decorators: [{
                type: Inject,
                args: [NB_TREE_GRID]
            }] }, { type: ɵngcc0.ElementRef }]; }, { doubleClickDelay: [{
            type: Input
        }], clickToToggle: [{
            type: Input
        }], toggleIfEnabledNode: [{
            type: HostListener,
            args: ['click']
        }], toggleIfEnabledNodeDeep: [{
            type: HostListener,
            args: ['dblclick']
        }] }); })();
const ɵNbTreeGridHeaderRowComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridHeaderRowComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridHeaderRowComponent, [{
        type: Component,
        args: [{
                selector: 'tr[nbTreeGridHeaderRow]',
                template: `
    <ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-tree-grid-header-row',
                    'role': 'row'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: NbCdkHeaderRow, useExisting: NbTreeGridHeaderRowComponent_1 }]
            }]
    }], null, null); })();
const ɵNbTreeGridFooterRowComponent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridFooterRowComponent);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridFooterRowComponent, [{
        type: Component,
        args: [{
                selector: 'tr[nbTreeGridFooterRow]',
                template: `
    <ng-container nbCellOutlet></ng-container>`,
                host: {
                    'class': 'nb-tree-grid-footer-row',
                    'role': 'row'
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: NbCdkFooterRow, useExisting: NbTreeGridFooterRowComponent_1 }]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbColumnsService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.IterableDiffers }]; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridComponent, [{
        type: Component,
        args: [{
                selector: 'table[nbTreeGrid]',
                template: NB_TABLE_TEMPLATE,
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    { provide: NB_TREE_GRID, useExisting: NbTreeGridComponent_1 },
                    NbColumnsService,
                ],
                styles: [":host{table-layout:fixed;border-spacing:0;border-collapse:collapse;width:100%;max-width:100%;overflow:auto}::ng-deep .nb-tree-grid-cell,::ng-deep .nb-tree-grid-header-cell,::ng-deep .nb-tree-grid-footer-cell{overflow:hidden}\n"]
            }]
    }], function () { return [{ type: NbTreeGridDataSourceBuilder }, { type: ɵngcc0.IterableDiffers }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: String, decorators: [{
                type: Attribute,
                args: ['role']
            }] }, { type: NbDirectionality }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_DOCUMENT]
            }] }, { type: NbPlatform$1 }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_WINDOW]
            }] }]; }, { levelPadding: [{
            type: Input
        }], treeClass: [{
            type: HostBinding,
            args: ['class.nb-tree-grid']
        }], source: [{
            type: Input,
            args: ['nbTreeGrid']
        }], equalColumnsWidth: [{
            type: Input
        }], rows: [{
            type: ContentChildren,
            args: [NbTreeGridRowComponent]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridRowDef]',
                providers: [{ provide: NbCdkRowDef, useExisting: NbTreeGridRowDefDirective_1 }]
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: NbColumnsService }]; }, { columns: [{
            type: Input,
            args: ['nbTreeGridRowDefColumns']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridHeaderRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridHeaderRowDef]',
                providers: [{ provide: NbCdkHeaderRowDef, useExisting: NbTreeGridHeaderRowDefDirective_1 }]
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: NbColumnsService }]; }, { columns: [{
            type: Input,
            args: ['nbTreeGridHeaderRowDef']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridFooterRowDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridFooterRowDef]',
                providers: [{ provide: NbCdkFooterRowDef, useExisting: NbTreeGridFooterRowDefDirective_1 }]
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.IterableDiffers }, { type: NbColumnsService }]; }, { columns: [{
            type: Input,
            args: ['nbTreeGridFooterRowDef']
        }] }); })();
const ɵNbTreeGridCellDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridCellDefDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridCellDef]',
                providers: [{ provide: NbCdkCellDef, useExisting: NbTreeGridCellDefDirective_1 }]
            }]
    }], null, null); })();
const ɵNbTreeGridHeaderCellDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridHeaderCellDefDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridHeaderCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridHeaderCellDef]',
                providers: [{ provide: NbCdkHeaderCellDef, useExisting: NbTreeGridHeaderCellDefDirective_1 }]
            }]
    }], null, null); })();
const ɵNbTreeGridFooterCellDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridFooterCellDefDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridFooterCellDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridFooterCellDef]',
                providers: [{ provide: NbCdkFooterCellDef, useExisting: NbTreeGridFooterCellDefDirective_1 }]
            }]
    }], null, null); })();
const ɵNbTreeGridColumnDefDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbTreeGridColumnDefDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridColumnDefDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridColumnDef]',
                providers: [
                    { provide: NbCdkColumnDef, useExisting: NbTreeGridColumnDefDirective_1 },
                    { provide: NB_SORT_HEADER_COLUMN_DEF, useExisting: NbTreeGridColumnDefDirective_1 },
                ]
            }]
    }], null, { hideOn: [{
            type: Input
        }], showOn: [{
            type: Input
        }], name: [{
            type: Input,
            args: ['nbTreeGridColumnDef']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridCellDirective, [{
        type: Directive,
        args: [{
                selector: 'td[nbTreeGridCell]',
                host: {
                    'class': 'nb-tree-grid-cell',
                    'role': 'gridcell'
                },
                providers: [{ provide: NbCdkCell, useExisting: NbTreeGridCellDirective_1 }]
            }]
    }], function () { return [{ type: NbTreeGridColumnDefDirective }, { type: ɵngcc0.ElementRef }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_TREE_GRID]
            }] }, { type: Object, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_WINDOW]
            }] }, { type: ɵngcc4.DomSanitizer }, { type: NbLayoutDirectionService }, { type: NbColumnsService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { columnWidth: [{
            type: HostBinding,
            args: ['style.width']
        }], leftPadding: [{
            type: HostBinding,
            args: ['style.padding-left']
        }], rightPadding: [{
            type: HostBinding,
            args: ['style.padding-right']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridHeaderCellDirective, [{
        type: Directive,
        args: [{
                selector: 'th[nbTreeGridHeaderCell]',
                host: {
                    'class': 'nb-tree-grid-header-cell',
                    'role': 'columnheader'
                },
                providers: [{ provide: NbCdkHeaderCell, useExisting: NbTreeGridHeaderCellDirective_1 }]
            }]
    }], function () { return [{ type: NbTreeGridColumnDefDirective }, { type: ɵngcc0.ElementRef }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_TREE_GRID]
            }] }, { type: NbColumnsService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { columnWidth: [{
            type: HostBinding,
            args: ['style.width']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridFooterCellDirective, [{
        type: Directive,
        args: [{
                selector: 'td[nbTreeGridFooterCell]',
                host: {
                    'class': 'nb-tree-grid-footer-cell',
                    'role': 'gridcell'
                },
                providers: [{ provide: NbCdkFooterCell, useExisting: NbTreeGridFooterCellDirective_1 }]
            }]
    }], function () { return [{ type: NbTreeGridColumnDefDirective }, { type: ɵngcc0.ElementRef }, { type: Object, decorators: [{
                type: Inject,
                args: [NB_TREE_GRID]
            }] }, { type: NbColumnsService }, { type: ɵngcc0.ChangeDetectorRef }]; }, { columnWidth: [{
            type: HostBinding,
            args: ['style.width']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbFilterDirective, [{
        type: Directive,
        args: [{ selector: '[nbFilter]' }]
    }], null, { filterable: [{
            type: Input,
            args: ['nbFilter']
        }] }); })();
const ɵNbFilterInputDirective_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(NbFilterInputDirective);
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbFilterInputDirective, [{
        type: Directive,
        args: [{
                selector: '[nbFilterInput]',
                providers: [{ provide: NbFilterDirective, useExisting: NbFilterInputDirective_1 }]
            }]
    }], null, { debounceTime: [{
            type: Input
        }], filter: [{
            type: HostListener,
            args: ['input', ['$event']]
        }], filterable: [{
            type: Input,
            args: ['nbFilterInput']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridRowToggleDirective, [{
        type: Directive,
        args: [{
                selector: '[nbTreeGridRowToggle]'
            }]
    }], function () { return [{ type: NbTreeGridCellDirective }]; }, { toggleRow: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridRowToggleComponent, [{
        type: Component,
        args: [{
                selector: 'nb-tree-grid-row-toggle',
                template: `
    <button class="row-toggle-button" [attr.aria-label]="expanded ? 'collapse' : 'expand'">
      <nb-icon [icon]="expanded ? 'chevron-down-outline' : 'chevron-right-outline'"
               pack="nebular-essentials"
               aria-hidden="true">
      </nb-icon>
    </button>
  `,
                styles: [`
    button {
      background: transparent;
      border: none;
      padding: 0;
    }
  `]
            }]
    }], function () { return [{ type: NbTreeGridCellDirective }]; }, { expanded: [{
            type: Input
        }], toggleRow: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbTreeGridModule, { declarations: function () { return [NbTreeGridComponent,
        NbTreeGridRowDefDirective,
        NbTreeGridRowComponent,
        NbTreeGridCellDefDirective,
        NbTreeGridCellDirective,
        NbTreeGridHeaderRowDefDirective,
        NbTreeGridHeaderRowComponent,
        NbTreeGridHeaderCellDefDirective,
        NbTreeGridHeaderCellDirective,
        NbTreeGridFooterRowDefDirective,
        NbTreeGridFooterRowComponent,
        NbTreeGridFooterCellDefDirective,
        NbTreeGridFooterCellDirective,
        NbTreeGridColumnDefDirective,
        NbSortDirective,
        NbSortHeaderComponent,
        NbSortIconComponent,
        NbFilterDirective,
        NbFilterInputDirective,
        NbTreeGridRowToggleDirective,
        NbTreeGridRowToggleComponent,
        NbSortHeaderIconDirective]; }, imports: function () { return [CommonModule,
        NbTableModule,
        NbIconModule]; }, exports: function () { return [NbTableModule,
        NbTreeGridComponent,
        NbTreeGridRowDefDirective,
        NbTreeGridRowComponent,
        NbTreeGridCellDefDirective,
        NbTreeGridCellDirective,
        NbTreeGridHeaderRowDefDirective,
        NbTreeGridHeaderRowComponent,
        NbTreeGridHeaderCellDefDirective,
        NbTreeGridHeaderCellDirective,
        NbTreeGridFooterRowDefDirective,
        NbTreeGridFooterRowComponent,
        NbTreeGridFooterCellDefDirective,
        NbTreeGridFooterCellDirective,
        NbTreeGridColumnDefDirective,
        NbSortDirective,
        NbSortHeaderComponent,
        NbSortIconComponent,
        NbFilterDirective,
        NbFilterInputDirective,
        NbTreeGridRowToggleDirective,
        NbTreeGridRowToggleComponent,
        NbSortHeaderIconDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbTreeGridModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule, NbTableModule, NbIconModule],
                declarations: [...COMPONENTS$2],
                exports: [NbTableModule, ...COMPONENTS$2],
                providers: [
                    NbTreeGridSortService,
                    NbTreeGridFilterService,
                    NbTreeGridService,
                    NbTreeGridDataService,
                    NbTreeGridDataSourceBuilder,
                ]
            }]
    }], null, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbToggleComponent, [{
        type: Component,
        args: [{
                selector: 'nb-toggle',
                animations: [
                    trigger('position', [
                        state('right', style({ right: 0, left: '*' })),
                        state('left', style({ left: 0, right: '*' })),
                        transition(':enter', [animate(0)]),
                        transition('right <=> left', [animate('0.15s')]),
                    ]),
                ],
                template: `
    <label class="toggle-label">
      <input type="checkbox"
             class="native-input visually-hidden"
             role="switch"
             [attr.aria-checked]="checked"
             [disabled]="disabled"
             [checked]="checked"
             (change)="updateValue($event)"
             (blur)="onTouched()"
             (click)="onInputClick($event)">
      <div class="toggle" [class.checked]="checked">
        <span [@position]="checkState()" class="toggle-switcher">
          <nb-icon *ngIf="checked" icon="checkmark-bold-outline" pack="nebular-essentials"></nb-icon>
        </span>
      </div>
      <span class="text">
        <ng-content></ng-content>
      </span>
    </label>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NbToggleComponent_1),
                        multi: true
                    }],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{display:inline-flex;outline:none}:host(.toggle-label-left) .text:not(:empty){padding-right:0.6875rem}[dir=ltr] :host(.toggle-label-left) .text:not(:empty){order:-1}[dir=rtl] :host(.toggle-label-left) .text:not(:empty){order:1}:host(.toggle-label-right) .text:not(:empty){padding-left:0.6875rem}[dir=ltr] :host(.toggle-label-right) .text:not(:empty){order:1}[dir=rtl] :host(.toggle-label-right) .text:not(:empty){order:-1}:host(.toggle-label-start) .toggle-label{flex-direction:row-reverse}[dir=ltr] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-right:.6875rem}[dir=rtl] :host(.toggle-label-start) .toggle-label .text:not(:empty){padding-left:.6875rem}[dir=ltr] :host(.toggle-label-end) .text:not(:empty){padding-left:.6875rem}[dir=rtl] :host(.toggle-label-end) .text:not(:empty){padding-right:.6875rem}.toggle-label{position:relative;display:inline-flex;align-items:center}.toggle{position:relative;display:inline-flex;box-sizing:content-box;transition-duration:0.15s;transition-property:background-color,border,box-shadow;transition-timing-function:ease-in}.toggle-switcher{position:absolute;border-radius:50%;margin:1px}.toggle-switcher nb-icon{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);width:40%}\n"]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: NbLayoutDirectionService }]; }, { labelPosition: [{
            type: Input
        }], checkedChange: [{
            type: Output
        }], checked: [{
            type: Input
        }], disabled: [{
            type: Input
        }], status: [{
            type: Input
        }], primary: [{
            type: HostBinding,
            args: ['class.status-primary']
        }], success: [{
            type: HostBinding,
            args: ['class.status-success']
        }], warning: [{
            type: HostBinding,
            args: ['class.status-warning']
        }], danger: [{
            type: HostBinding,
            args: ['class.status-danger']
        }], info: [{
            type: HostBinding,
            args: ['class.status-info']
        }], basic: [{
            type: HostBinding,
            args: ['class.status-basic']
        }], control: [{
            type: HostBinding,
            args: ['class.status-control']
        }], labelLeft: [{
            type: HostBinding,
            args: ['class.toggle-label-left']
        }], labelRight: [{
            type: HostBinding,
            args: ['class.toggle-label-right']
        }], labelStart: [{
            type: HostBinding,
            args: ['class.toggle-label-start']
        }], labelEnd: [{
            type: HostBinding,
            args: ['class.toggle-label-end']
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NbToggleModule, { declarations: function () { return [NbToggleComponent]; }, imports: function () { return [CommonModule,
        NbIconModule]; }, exports: function () { return [NbToggleComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NbToggleModule, [{
        type: NgModule,
        args: [{
                imports: [
                    CommonModule,
                    NbIconModule,
                ],
                declarations: [NbToggleComponent],
                exports: [NbToggleComponent]
            }]
    }], null, null); })();


/**
 * @license
 * Copyright Akveo. All Rights Reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 */
// TODO: export all components

/**
 * Generated bundle index. Do not edit.
 */

export { NbCalendarWeekNumberComponent as ɵe, NbFocusKeyManagerFactoryService as ɵd, NbScrollStrategyOptions as ɵb, NbPlatform$1 as ɵf, NbMenuInternalService as ɵa, NbSharedModule as ɵc, NbCalendarHeaderComponent, NbCalendarDayCellComponent, NbCalendarYearPickerComponent, YEARS_IN_VIEW, YEARS_IN_COLUMN, NbCalendarMonthPickerComponent, MONTHS_IN_VIEW, MONTHS_IN_COLUMN, NbCalendarDayPickerComponent, NbCalendarNavigationComponent, NbCalendarPageableNavigationComponent, NbCalendarDaysNamesComponent, NbCalendarMonthCellComponent, NbCalendarYearCellComponent, NbCalendarPickerRowComponent, NbCalendarPickerComponent, NbCalendarMonthModelService, NbNativeDateService, NbDateService, NbMenuService, NbMenuItem, NbBlockScrollStrategyAdapter, NB_THEME_OPTIONS, NB_MEDIA_BREAKPOINTS, NB_BUILT_IN_JS_THEMES, NB_JS_THEMES, NB_WINDOW, NB_DOCUMENT, windowFactory, NbThemeModule, NbThemeService, NbSpinnerService, DEFAULT_MEDIA_BREAKPOINTS, NbMediaBreakpointsService, NbColorHelper, NbLayoutDirection, NB_LAYOUT_DIRECTION, NbLayoutDirectionService, NbLayoutScrollService, NbLayoutRulerService, BUILT_IN_THEMES, NbJSThemesRegistry, CORPORATE_THEME, COSMIC_THEME, DEFAULT_THEME, DARK_THEME, NbCardModule, NbCardHeaderComponent, NbCardBodyComponent, NbCardFooterComponent, NbCardComponent, NbFlipCardComponent, NbRevealCardComponent, NbCardFrontComponent, NbCardBackComponent, NbCalendarModule, NbCalendarComponent, NbCalendarRangeModule, NbCalendarRangeComponent, NbBaseCalendarComponent, NbBaseCalendarModule, NbCalendarRangeDayCellComponent, NbCalendarRangeYearCellComponent, NbCalendarViewMode, NbCalendarSize, NbCalendarKitModule, NbLayoutModule, NbLayoutComponent, NbLayoutColumnComponent, NbLayoutHeaderComponent, NbLayoutFooterComponent, NbRestoreScrollTopHelper, NbMenuModule, NbToggleStates, NbMenuItemComponent, NbMenuComponent, NbRouteTabsetModule, NbRouteTabsetComponent, NbSidebarModule, NbSidebarService, NbSidebarHeaderComponent, NbSidebarFooterComponent, NbSidebarComponent, NbTabsetModule, NbTabComponent, NbTabsetComponent, NbUserModule, NbUserComponent, NbActionsModule, NbActionComponent, NbActionsComponent, NbSearchModule, NbSearchService, NbSearchFieldComponent, NbSearchComponent, NbCheckboxComponent, NbCheckboxModule, NbBadgeComponent, NbBadgeModule, NbPopoverDirective, NbPopoverModule, NbPopoverComponent, NbContextMenuDirective, NbContextMenuComponent, NbContextMenuModule, NbProgressBarComponent, NbProgressBarModule, NbAlertComponent, NbAlertModule, NbChatComponent, NbChatMessageComponent, NbChatMessageMapComponent, NbChatMessageFileComponent, NbChatMessageQuoteComponent, NbChatMessageTextComponent, NbChatFormComponent, NbChatModule, NbChatOptions, NbSpinnerComponent, NbSpinnerDirective, NbSpinnerModule, NB_STEPPER, NbStepperComponent, NbStepComponent, NbStepperNextDirective, NbStepperPreviousDirective, NbStepperModule, NbAccordionComponent, NbAccordionItemComponent, NbAccordionItemBodyComponent, NbAccordionItemHeaderComponent, NbAccordionModule, NbButtonComponent, NbButtonModule, NbListComponent, NbListItemComponent, NbListModule, NbListPageTrackerDirective, NbScrollableContainerDimentions, NbInfiniteListDirective, NbInputDirective, NbInputModule, NbOverlayModule, patch, createContainer, NbOverlayService, NbAdjustment, NbPosition, NbAdjustableConnectedPositionStrategy, NbGlobalPositionStrategy, NbPositionBuilderService, NbPositionedContainer, NbOverlayContainerComponent, NbTrigger, NbTriggerStrategyBase, NbClickTriggerStrategy, NbHoverTriggerStrategy, NbHintTriggerStrategy, NbFocusTriggerStrategy, NbNoopTriggerStrategy, NbTriggerStrategyBuilderService, NbPortalDirective, NbPortalOutletDirective, NbComponentPortal, NbOverlay, NbPlatform, NbOverlayPositionBuilder, NbTemplatePortal, NbOverlayContainer, NbFlexibleConnectedPositionStrategy, NbPortalInjector, NbCdkMappingModule, NbGlobalLogicalPosition, NbGlobalPhysicalPosition, NbPositionHelper, NbDynamicOverlay, NbDynamicOverlayChange, NbDynamicOverlayHandler, NbA11yModule, NbFocusTrap, NbFocusTrapFactoryService, NbCdkAdapterModule, NbOverlayContainerAdapter, NbScrollDispatcherAdapter, NbViewportRulerAdapter, NbDirectionality, NbBidiModule, NbPlatformModule, NbCellDefDirective, NbHeaderCellDefDirective, NbFooterCellDefDirective, NB_SORT_HEADER_COLUMN_DEF, NbColumnDefDirective, NbHeaderCellDirective, NbFooterCellDirective, NbCellDirective, NbDataSource, NbDataRowOutletDirective, NbHeaderRowOutletDirective, NbFooterRowOutletDirective, NbCellOutletDirective, NbHeaderRowDefDirective, NbFooterRowDefDirective, NbRowDefDirective, NbHeaderRowComponent, NbFooterRowComponent, NbRowComponent, NB_TABLE_TEMPLATE, NbTable, NbTableModule, NB_DIALOG_CONFIG, NbDialogConfig, NbDialogRef, NbDialogService, NbDialogModule, NbToastrModule, NbToastRef, NbToastContainer, NbToastrContainerRegistry, NbToastrService, NbToast, NbToastComponent, NB_TOASTR_CONFIG, NbToastrConfig, NbToastrContainerComponent, NbTooltipModule, NbTooltipDirective, NbTooltipComponent, NbSelectModule, NbSelectLabelComponent, NbSelectComponent, NbOptionComponent, NbOptionGroupComponent, NB_SELECT_INJECTION_TOKEN, NbWindowModule, NbWindowService, NbWindowRef, NbWindowState, NbWindowConfig, NB_WINDOW_CONTENT, NB_WINDOW_CONFIG, NB_WINDOW_CONTEXT, NbWindowComponent, NbWindowsContainerComponent, NbDatepickerModule, NbDatepickerAdapter, NbDatepicker, NB_DATE_ADAPTER, NB_DATE_SERVICE_OPTIONS, NbDatepickerDirective, NbDateAdapterService, NbRangeAdapterService, NbDatepickerContainerComponent, NbBasePicker, NbBasePickerComponent, NbDatepickerComponent, NbRangepickerComponent, NbDialogContainerComponent, NbRadioModule, NbRadioGroupComponent, NbRadioComponent, NbTreeGridModule, NbTreeGridComponent, NB_ROW_DOUBLE_CLICK_DELAY, NbTreeGridRowComponent, NbTreeGridHeaderRowComponent, NbTreeGridFooterRowComponent, NB_TREE_GRID, NbSortDirection, NbSortDirective, NbSortHeaderIconDirective, NbSortIconComponent, NbSortHeaderComponent, NbTreeGridRowToggleComponent, NbTreeGridColumnDefDirective, NbTreeGridCellDirective, NbTreeGridHeaderCellDirective, NbTreeGridFooterCellDirective, NbTreeGridRowDefDirective, NbTreeGridHeaderRowDefDirective, NbTreeGridFooterRowDefDirective, NbTreeGridCellDefDirective, NbTreeGridHeaderCellDefDirective, NbTreeGridFooterCellDefDirective, NbFilterDirective, NbFilterInputDirective, NbTreeGridRowToggleDirective, NB_DEFAULT_ROW_LEVEL, NbTreeGridPresentationNode, NbTreeGridDataSource, NbTreeGridDataSourceBuilder, NbTreeGridDataService, NbTreeGridFilterService, NbTreeGridService, NbTreeGridSortService, NbColumnsService, NbIconModule, NbIconComponent, NbFontIcon, NbSvgIcon, NbIconPackType, NbIconDefinition, NbIconLibraries, NbToggleModule, NbToggleComponent };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0hBcVJFO21DQUNpQyxBQUVoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MklBNEdEOzBDQUN3QyxBQUV2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswR0FpSEQ7K0JBQzZCLEFBRTVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnSEE4RUQ7aUNBQytCLEFBRTlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3SUEyRUQ7eUNBQ3VDLEFBRXRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBNEZELDZIQUd3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMkN4QiwwSEFHdUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFjdkIsdUJBVWlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJJQStDakI7MkNBQ3lDLEFBRXhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQThCRCwrSEFHZTs7Ozs7Ozs7Ozs7O0VBVWYsK0pBR29COzs7O0VBRXBCLGlMQUcwQjs7Ozs7O0VBSTFCLHlGQUdZOzs7O0VBRVosNEZBR2E7Ozs7RUFFYixzSUFHMkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBNkIzQixzQ0FXcUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE2QnJCLHlJQUc0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0lBdUM1Qjt3Q0FDc0MsQUFFckM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnSEFnSEQ7a0NBQ2dDLEFBRS9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dJQXNPRDswQ0FDd0MsQUFFdkM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrSkF3REQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eURBZ0V1RCxBQU8vQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpRkE4Q3hCOzs7Ozs2Q0FLMkMsQUFRMUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnSEFxQ0Q7a0NBQ2dDLEFBRS9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJJQW9CRDsyQ0FDeUMsQUFFeEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0pBZ0NEOzhDQUM0QyxBQUUzQzs7Ozs7Ozs7Ozs7Ozs7OztxSUFjRDt5Q0FDdUMsQUFFdEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE2QkQsaUpBR3FCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZKQXVLckI7aURBQytDLEFBRTlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUEwQkQsNkJBaUJrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUEwRGxCLFlBUWdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lJQTRPaEI7b0xBQ2tMLEFBR2hLOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MlNBK0tsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQ0E2RCtCLEFBTzlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztjQW9ERDs4QkFDNEIsQUFZM0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUE0Q0QsMkJBTXdCOzs7Ozs7Ozs7OztFQU14QiwyQkFNc0I7Ozs7Ozs7Ozs7O0VBTXRCLDJCQU13Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZFQXFQeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FEQWlIbUQsQUFZakM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O204QkF1SWxCOzs7Ozs7Ozs7Z0VBUzhELEFBZXRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxK0RBeUl4Qjs7Ozs7Ozs7OzhEQVM0RCxBQXNCdEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFjdEIsMkJBTXVCOzs7Ozs7Ozs7Ozs7RUFPdkIsMkJBTXNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXdCdEIsWUFjZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRGQTZZZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3REE2RHNELEFBd0JoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrM0JBeXFCdEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQTJKaUMsQUFTaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQW9CRCxZQWFpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lKQXVKakI7NkNBQzJDLEFBRTFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpREF1REQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0Q0E0RDBDLEFBT3pDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkpBd0VEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OENBeUQ0QyxBQTBCM0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lPQXNDRDs4Q0FDNEMsQUFTM0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUZBOEJEOzs7Ozs7Ozs7MkNBU3lDLEFBYXhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpREFvREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0EwQzRDLEFBTzNDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0hBcUREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dEQXdDOEMsQUFnQjdDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2UUFxQkQ7Ozs7Ozs7O2tFQVFnRSxBQXFCaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NmtCQTZCaEM7Ozs7Ozs7Ozs7Ozs7Ozs7O3VEQWlCcUQsQUFjcEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxSUFxQkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBEQWdDd0QsQUFtQjVCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUlBdUM1Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0FxQzRDLEFBWTNDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpREFvREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2Q0EwQzJDLEFBTzFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswRkFvREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytDQTRDNkMsQUFpQjVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0hBcUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQ0F1QjZDLEFBVTVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lIQXlJRDtxQ0FDbUMsQUFFbEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBc0RELHlPQWFzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkRBa0d0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5Q0F5RXVDLEFBS3RDOzs7Ozs7Ozs7Ozs7Ozs7OztFQWVELHVOQU91Qjs7Ozs7Ozs7Ozs7Ozs7OztFQWN2Qiw4S0FPbUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lEQStEbkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lEQTRDK0MsQUFtQjlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpREFxQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrREEwQ2dELEFBTy9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0VBNE5EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBDQWdFd0MsQUF1QnZDOzs7Ozs7Ozs7Ozs7Ozs7OztFQWVELDZMQVl3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dJQTBEeEI7MENBQ3dDLEFBRXZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2a0ZBa1lEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBeURpQyxBQXNCaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQXdDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FEQWtCbUQsQUFRekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQXNEMUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUNBbUJ1QyxBQVN0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZCQStCRDs7Ozs7Ozs7O3FEQVNtRCxBQVV6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFvQjFCLFlBZ0JpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFrSGpCLHFHQUdnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0hBcUtoQjt1Q0FDcUMsQUFFcEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUFtRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQ0FxQm1DLEFBWWxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Z0JBME5EOzs7Ozs7Ozs7Ozs7OztpQ0FjK0IsQUFvQjlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBNkJELDBLQU9lOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bTRDQW9MZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBEQXFCd0QsQUFxQy9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBY3pCLFlBY3NCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBa0d0Qiw4R0FHbUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBd0JuQiwyQkFRMkI7Ozs7Ozs7Ozs7Ozs7RUFRM0IsMkJBUTJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZtQ0FpVTNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJEQThGeUQsQUFleEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBa0NELFlBYWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3REFzRmxCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzREFxRG9ELEFBVW5DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Oys5Q0FpSWpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQXNCaUMsQUE2QmhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrZEFrTkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0Q0E4RTBDLEFBT3ZCOzs7Ozs7Ozs7Ozs7Ozs7O0VBY25CLGtJQU1nQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBa0JoQixZQWVpQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzekJBa05qQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUNBa0crQixBQU05Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFrQkQsWUFjZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MGpCQXlDZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5REFrQ3VELEFBdUNuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswRUF1THBCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBb0M4QyxBQVN6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBa0JyQixZQWVrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXNGbEIsMkdBR2tCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttbmdCQWtGbEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0RBK0VzRCxBQTRCN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OFZBK0h6Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttQ0F5QmlDLEFBcUJoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQW1CRCxZQXdCaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyY0FtWGpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZEQXNFMkQsQUE0QjFEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWVELFlBVW1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0hBeUtuQjtrQ0FDZ0MsQUFFL0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxSUEwTUQ7eUNBQ3VDLEFBRXRDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29KQXFFRDs7Ozs7Ozs7Ozs7Ozs7OztnREFnQjhDLEFBVXpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lvQkErTHJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29DQWtDa0MsQUFNakM7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWdCRCxzS0FRa0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NERBdURsQjs7Ozs7Ozs7Ozs7O3dEQVlzRCxBQVE3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29hQStMekI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3Q0E4QnNDLEFBS3JDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBaUJELDhNQVFzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsyTkErT3RCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NEQTRFb0QsQUFjM0I7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWN6QixZQVNzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aVhBdVZ0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1REE2SnFELEFBWWxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFjbkIsWUFhZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1RUEwSmhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztxQ0ErQ21DLEFBMENsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBK0ZEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0NBc0RzQyxBQTZDckM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NJQWdZRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytDQTBGNkMsQUFrQjNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUhBdUNsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJDQXFCeUMsQUFReEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUtBdUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7NENBa0IwQyxBQTBCekM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrTEFxQkQ7Ozs7Ozs7Ozs7Ozs7Ozs7MkRBZ0J5RCxBQWUzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0dBb0I5Qjs7Ozs7Ozs7Ozs7O3lEQVl1RCxBQVUxQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eUdBeWM3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0E4RjRDLEFBS3pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBaUJuQiwrSkFPZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBd0NoQixZQWdCZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29lQTJKZjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrREF5RWdELEFBVTNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJNQXFIckI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUNBc0JtQyxBQUVsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWtCRCxZQVVrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2QkErRGxCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQXNCZ0MsQUFTL0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswdkNBZ1REOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrREFzQ2dELEFBUTNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3FDQW1CckI7Ozs7Ozs7Ozs7O3lDQVd1QyxBQUl0Qzs7Ozs7Ozs7Ozs7Ozs7OztxQ0FVRDs7Ozs7Ozs7Ozs7NkNBVzJDLEFBSTFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWVELFlBb0JrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aURBK0psQjs7Ozs7a0RBS2dELEFBU3pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUdBZ0h2Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MkNBdUJ5QyxBQVV4Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0dBc0REOytDQUM2QyxBQWE1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBOEREOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aURBOEIrQyxBQTBCOUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXNCRCxzTUFRb0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lHQThGcEI7Ozs7OzhDQUs0QyxBQU8xQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3RkFrQmxCOzs7OztrREFLZ0QsQUFPMUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0R0FtRnRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs2Q0FpQjJDLEFBSTFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3S0F1SEQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MENBNEJ3QyxBQUl2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFrQkQsK0hBTWU7Ozs7Ozs7Ozs7O0VBU2YsOEdBR21COzs7Ozs7Ozs7Ozs7O0VBU25CLE9BT2U7Ozs7Ozs7Ozs7Ozs7Ozs7RUFZZixPQU9tQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBeUJuQiwyUEFNcUI7Ozs7Ozs7O0VBTXJCLHlSQU0yQjs7Ozs7Ozs7RUFNM0IseVJBTTJCOzs7Ozs7Ozs7Ozs7a0RBTzNCOzs7Ozs7Ozs7Ozs7d0RBWXNELEFBUy9COzs7Ozs7Ozs7NlBBT3ZCO3dDQUNzQyxBQVFyQzs7Ozs7Ozs7Ozs7eVBBU0Q7d0NBQ3NDLEFBUXJDOzs7Ozs7Ozs7Ozt5TkFTRDtrQ0FDZ0MsQUFRL0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMkJELGtSQU0yQjs7OztFQUUzQixnU0FNNkI7Ozs7RUFFN0IsZ1NBTTZCOzs7O0VBRTdCLDBRQU13Qjs7Ozs7Ozs7c1hBTXhCOzs7Ozs7Ozt3REFRc0QsQUFNNUI7Ozs7Ozs7O3NYQU0xQjs7Ozs7Ozs7d0RBUXNELEFBTTVCOzs7Ozs7Ozs7NlVBTzFCOzs7Ozs7OztnREFROEMsQUFNMUI7Ozs7Ozs7RUFHcEIsb0ZBYXVCOzs7Ozs7O0VBR3ZCLG9GQWF1Qjs7Ozs7OztFQUd2QixvRkFhaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpVEFzQmpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWlDQSxtTUFPZ0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvRUFxSGhCOzs7Ozs2Q0FLMkMsQUFLMUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZHQWlPRDtrQ0FDZ0MsQUFFL0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBdUNELG1MQU9pQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aWpCQW1LakI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQWlFaUMsQUFNaEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBOENEOzs7Ozs7Ozs7Ozs7Ozs7Ozs2Q0FpQjJDLEFBWTFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJJQStPRDs0Q0FDMEMsQUFFekM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzZHQXVJRDtrQ0FDZ0MsQUFFL0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTRCRCxpTUFPaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7ZUErSGpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29EQXNCa0QsQUF5QjdCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3duQkEySnJCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUNBb0NtQyxBQU1sQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBZ0JELG9NQVFrQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21uQkFnSGxCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29DQXFDa0MsQUFjakM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBd0JELDJCQU15Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aTdDQWcrQnpCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBEQWdLd0QsQUFldkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lJQWlFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dEQWtCc0QsQUFXN0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFlekIsWUFlaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsySkFnSmpCOzs7O3NFQUlvRSxBQU90Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21pQ0E0RjlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0NBd0JrQyxBQThCakM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs2R0E4TEQ7a0NBQ2dDLEFBRS9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQW9DRCw2TkFVaUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2VBZ1dqQjs7Ozs7O2tFQU1nRSxBQWdCL0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NPQXlCRDs7Ozt5RUFJdUUsQUFVdEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttSkEwTWxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRxQkFxREM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3dDQThEc0MsQUFJckM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzRVQXlERDs7Ozs7Ozs7Ozt3REFVc0QsQUFNOUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29WQXNEeEI7Ozs7Ozs7Ozs7MERBVXdELEFBTS9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NEhBK0J6Qjt1Q0FDcUMsQUFFcEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrSEFxQ0Q7d0NBQ3NDLEFBRXJDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFrQ0Qsd05BY3FCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0aUNBdVNyQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O21DQXFFaUMsQUF3QmhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpREFpTUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tFQTZCZ0UsQUFjL0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFpQkQsaUpBT2dCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBc0ZoQiw2SEFHd0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQWlEeEIsbUlBRzBCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUxBOEMxQjs7Ozs7Ozs7OENBUTRDLEFBRzFCOzs7Ozs7Ozs7RUFPbEIsd0lBRzRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5RUFjNUI7Ozs7dURBSXFELEFBVy9COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswSEF5RHRCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7d0NBcUJzQyxBQWdCckM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQThDRCw2SEFHd0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBZ0R4QixpSEFHb0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7aUpBa0dwQjs4Q0FDNEMsQUFFM0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NGQWdGRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O29FQXFCa0UsQUFXakU7Ozs7Ozs7O0VBSUQsb0ZBYStCOzs7Ozs7RUFFL0Isb0ZBYStCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnSEF3RS9CO21DQUNpQyxBQUVoQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OFJBMlBEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4REF1QjRELEFBVzNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3VWQWtERDs7Ozs7OzBFQU13RSxBQUt2RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvWEEwQkQ7Ozs7OztzRkFNb0YsQUFLbkY7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b1hBMEJEOzs7Ozs7c0ZBTW9GLEFBS25GOzs7Ozs7Ozs7OztFQVNELDZSQU02Qjs7Ozs7Ozs7RUFNN0IsMlRBTW1DOzs7Ozs7OztFQU1uQywyVEFNbUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpRkFtRW5DOzs7Ozs7Ozs7Ozs7OzsyREFjeUQsQUFTMUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUpBNkYvQjs7Ozs7Ozs7Ozs7Ozs7OztzRUFnQm9FLEFBU25FOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUtBNkJEOzs7Ozs7a0ZBTWdGLEFBUy9FOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzttS0F5QkQ7Ozs7OztrRkFNZ0YsQUFTL0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzS0F5QkQ7Ozs7c0RBSW9ELEFBR2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cVBBZ0NwQjs7Ozs7Ozs7Ozs7Ozs7cURBY21ELEFBTTFCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1dBMkJ6Qjs7Ozs7OzsrQ0FPNkMsQUFJNUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0tBa0NEOzs7Ozs7Ozs7Ozs7K0NBWTZDLEFBbUI1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMENELHdCQWNtQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bUNBK1duQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswREErRXdELEFBd0N2RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBZ0JEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFVaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBdHRyaWJ1dGUsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdCwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0b3IsIElucHV0LCBJdGVyYWJsZURpZmZlcnMsIExPQ0FMRV9JRCwgTmdNb2R1bGUsIE5nWm9uZSwgT3B0aW9uYWwsIE91dHB1dCwgUExBVEZPUk1fSUQsIFF1ZXJ5TGlzdCwgUmVuZGVyZXIyLCBTaW1wbGVDaGFuZ2UsIFRlbXBsYXRlUmVmLCBUeXBlLCBWaWV3Q2hpbGQsIFZpZXdDaGlsZHJlbiwgVmlld0NvbnRhaW5lclJlZiwgZm9yd2FyZFJlZiwgybXJtWRlZmluZUluamVjdGFibGUsIMm1ybVpbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlLCBET0NVTUVOVCwgRGF0ZVBpcGUsIEZvcm1TdHlsZSwgTG9jYXRpb24sIFRyYW5zbGF0aW9uV2lkdGgsIGdldExvY2FsZURheU5hbWVzLCBnZXRMb2NhbGVGaXJzdERheU9mV2VlaywgZ2V0TG9jYWxlTW9udGhOYW1lcywgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0ICogYXMgaTEgZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgRU1QVFksIE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QsIFN1YmplY3QsIGNvbWJpbmVMYXRlc3QsIGZvcmtKb2luLCBmcm9tRXZlbnQsIGludGVydmFsLCBtZXJnZSwgb2YsIHRpbWVyIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIGRlbGF5LCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZmlsdGVyLCBtYXAsIHBhaXJ3aXNlLCByZXBlYXQsIHNoYXJlLCBza2lwLCBzdGFydFdpdGgsIHN3aXRjaE1hcCwgdGFrZSwgdGFrZVVudGlsLCB0YWtlV2hpbGUsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgRm9ybXNNb2R1bGUsIE5HX1ZBTElEQVRPUlMsIE5HX1ZBTFVFX0FDQ0VTU09SLCBWYWxpZGF0b3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQWN0aXZhdGVkUm91dGUsIE5hdmlnYXRpb25FbmQsIFJvdXRlciwgUm91dGVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEZvY3VzS2V5TWFuYWdlciwgRm9jdXNUcmFwLCBGb2N1c1RyYXBGYWN0b3J5LCBJbnRlcmFjdGl2aXR5Q2hlY2tlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENka1BvcnRhbCwgQ2RrUG9ydGFsT3V0bGV0LCBDb21wb25lbnRQb3J0YWwsIFBvcnRhbEluamVjdG9yLCBQb3J0YWxNb2R1bGUsIFRlbXBsYXRlUG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQgeyBCbG9ja1Njcm9sbFN0cmF0ZWd5LCBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3ksIE92ZXJsYXksIE92ZXJsYXlDb250YWluZXIsIE92ZXJsYXlNb2R1bGUsIE92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIsIFNjcm9sbERpc3BhdGNoZXIsIFNjcm9sbFN0cmF0ZWd5T3B0aW9ucywgVmlld3BvcnRSdWxlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IFBsYXRmb3JtLCBQbGF0Zm9ybU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IGFuaW1hdGUsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0ICdpbnRlcnNlY3Rpb24tb2JzZXJ2ZXInO1xuaW1wb3J0IHsgQmlkaU1vZHVsZSwgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQgeyBDZGtDZWxsLCBDZGtDZWxsRGVmLCBDZGtDZWxsT3V0bGV0LCBDZGtDb2x1bW5EZWYsIENka0Zvb3RlckNlbGwsIENka0Zvb3RlckNlbGxEZWYsIENka0Zvb3RlclJvdywgQ2RrRm9vdGVyUm93RGVmLCBDZGtIZWFkZXJDZWxsLCBDZGtIZWFkZXJDZWxsRGVmLCBDZGtIZWFkZXJSb3csIENka0hlYWRlclJvd0RlZiwgQ2RrUm93LCBDZGtSb3dEZWYsIENka1RhYmxlLCBDZGtUYWJsZU1vZHVsZSwgRGF0YVJvd091dGxldCwgRGF0YVNvdXJjZSwgRm9vdGVyUm93T3V0bGV0LCBIZWFkZXJSb3dPdXRsZXQgfSBmcm9tICdAYW5ndWxhci9jZGsvdGFibGUnO1xuaW1wb3J0IHsgRVNDQVBFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCAqIGFzIF9hbmd1bGFyX2Nka19rZXljb2RlcyBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBOQl9USEVNRV9PUFRJT05TID0gbmV3IEluamVjdGlvblRva2VuKCdOZWJ1bGFyIFRoZW1lIE9wdGlvbnMnKTtcbmNvbnN0IE5CX01FRElBX0JSRUFLUE9JTlRTID0gbmV3IEluamVjdGlvblRva2VuKCdOZWJ1bGFyIE1lZGlhIEJyZWFrcG9pbnRzJyk7XG5jb25zdCBOQl9CVUlMVF9JTl9KU19USEVNRVMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05lYnVsYXIgQnVpbHQtaW4gSlMgVGhlbWVzJyk7XG5jb25zdCBOQl9KU19USEVNRVMgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05lYnVsYXIgSlMgVGhlbWVzJyk7XG4vKipcbiAqIFdlJ3JlIHByb3ZpZGluZyBicm93c2VyIGFwaXMgd2l0aCB0b2tlbnMgdG8gaW1wcm92ZSB0ZXN0aW5nIGNhcGFiaWxpdGllcy5cbiAqICovXG5jb25zdCBOQl9XSU5ET1cgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ1dpbmRvdycpO1xuY29uc3QgTkJfRE9DVU1FTlQgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0RvY3VtZW50Jyk7XG5cbmNvbnN0IHBhbGV0dGUgPSB7XG4gICAgcHJpbWFyeTogJyMzMzY2ZmYnLFxuICAgIHN1Y2Nlc3M6ICcjMDBkNjhmJyxcbiAgICBpbmZvOiAnIzAwOTVmZicsXG4gICAgd2FybmluZzogJyNmZmFhMDAnLFxuICAgIGRhbmdlcjogJyNmZjNkNzEnLFxufTtcbmNvbnN0IERFRkFVTFRfVEhFTUUgPSB7XG4gICAgbmFtZTogJ2RlZmF1bHQnLFxuICAgIHZhcmlhYmxlczoge1xuICAgICAgICBmb250TWFpbjogJ09wZW4gU2Fucywgc2Fucy1zZXJpZicsXG4gICAgICAgIGZvbnRTZWNvbmRhcnk6ICdSYWxld2F5LCBzYW5zLXNlcmlmJyxcbiAgICAgICAgYmc6ICcjZmZmZmZmJyxcbiAgICAgICAgYmcyOiAnI2Y3ZjlmYycsXG4gICAgICAgIGJnMzogJyNlZGYxZjcnLFxuICAgICAgICBiZzQ6ICcjZTRlOWYyJyxcbiAgICAgICAgYm9yZGVyOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcjI6ICcjZjdmOWZjJyxcbiAgICAgICAgYm9yZGVyMzogJyNlZGYxZjcnLFxuICAgICAgICBib3JkZXI0OiAnI2U0ZTlmMicsXG4gICAgICAgIGJvcmRlcjU6ICcjYzVjZWUwJyxcbiAgICAgICAgZmc6ICcjOGY5YmIzJyxcbiAgICAgICAgZmdIZWFkaW5nOiAnIzFhMjEzOCcsXG4gICAgICAgIGZnVGV4dDogJyMxYTIxMzgnLFxuICAgICAgICBmZ0hpZ2hsaWdodDogcGFsZXR0ZS5wcmltYXJ5LFxuICAgICAgICBsYXlvdXRCZzogJyNmN2Y5ZmMnLFxuICAgICAgICBzZXBhcmF0b3I6ICcjZWRmMWY3JyxcbiAgICAgICAgcHJpbWFyeTogcGFsZXR0ZS5wcmltYXJ5LFxuICAgICAgICBzdWNjZXNzOiBwYWxldHRlLnN1Y2Nlc3MsXG4gICAgICAgIGluZm86IHBhbGV0dGUuaW5mbyxcbiAgICAgICAgd2FybmluZzogcGFsZXR0ZS53YXJuaW5nLFxuICAgICAgICBkYW5nZXI6IHBhbGV0dGUuZGFuZ2VyLFxuICAgICAgICBwcmltYXJ5TGlnaHQ6ICcjNTk4YmZmJyxcbiAgICAgICAgc3VjY2Vzc0xpZ2h0OiAnIzJjZTY5YicsXG4gICAgICAgIGluZm9MaWdodDogJyM0MmFhZmYnLFxuICAgICAgICB3YXJuaW5nTGlnaHQ6ICcjZmZjOTRkJyxcbiAgICAgICAgZGFuZ2VyTGlnaHQ6ICcjZmY3MDhkJyxcbiAgICB9LFxufTtcblxuY29uc3QgcGFsZXR0ZSQxID0ge1xuICAgIHByaW1hcnk6ICcjYTE2ZWZmJyxcbiAgICBzdWNjZXNzOiAnIzAwZDY4ZicsXG4gICAgaW5mbzogJyMwMDk1ZmYnLFxuICAgIHdhcm5pbmc6ICcjZmZhYTAwJyxcbiAgICBkYW5nZXI6ICcjZmYzZDcxJyxcbn07XG5jb25zdCBDT1NNSUNfVEhFTUUgPSB7XG4gICAgbmFtZTogJ2Nvc21pYycsXG4gICAgdmFyaWFibGVzOiB7XG4gICAgICAgIGZvbnRNYWluOiAnT3BlbiBTYW5zLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgZm9udFNlY29uZGFyeTogJ1JhbGV3YXksIHNhbnMtc2VyaWYnLFxuICAgICAgICBiZzogJyMzMjMyNTknLFxuICAgICAgICBiZzI6ICcjMjUyNTQ3JyxcbiAgICAgICAgYmczOiAnIzFiMWIzOCcsXG4gICAgICAgIGJnNDogJyMxMzEzMmInLFxuICAgICAgICBib3JkZXI6ICcjMzIzMjU5JyxcbiAgICAgICAgYm9yZGVyMjogJyMyNTI1NDcnLFxuICAgICAgICBib3JkZXIzOiAnIzFiMWIzOCcsXG4gICAgICAgIGJvcmRlcjQ6ICcjMTMxMzJiJyxcbiAgICAgICAgYm9yZGVyNTogJyMxMzEzMmInLFxuICAgICAgICBmZzogJyNiNGI0ZGInLFxuICAgICAgICBmZ0hlYWRpbmc6ICcjZmZmZmZmJyxcbiAgICAgICAgZmdUZXh0OiAnI2ZmZmZmZicsXG4gICAgICAgIGZnSGlnaGxpZ2h0OiBwYWxldHRlJDEucHJpbWFyeSxcbiAgICAgICAgbGF5b3V0Qmc6ICcjMTUxYTMwJyxcbiAgICAgICAgc2VwYXJhdG9yOiAnIzE1MWEzMCcsXG4gICAgICAgIHByaW1hcnk6IHBhbGV0dGUkMS5wcmltYXJ5LFxuICAgICAgICBzdWNjZXNzOiBwYWxldHRlJDEuc3VjY2VzcyxcbiAgICAgICAgaW5mbzogcGFsZXR0ZSQxLmluZm8sXG4gICAgICAgIHdhcm5pbmc6IHBhbGV0dGUkMS53YXJuaW5nLFxuICAgICAgICBkYW5nZXI6IHBhbGV0dGUkMS5kYW5nZXIsXG4gICAgICAgIHByaW1hcnlMaWdodDogJyNiMThhZmYnLFxuICAgICAgICBzdWNjZXNzTGlnaHQ6ICcjMmNlNjliJyxcbiAgICAgICAgaW5mb0xpZ2h0OiAnIzQyYWFmZicsXG4gICAgICAgIHdhcm5pbmdMaWdodDogJyNmZmM5NGQnLFxuICAgICAgICBkYW5nZXJMaWdodDogJyNmZjcwOGQnLFxuICAgIH0sXG59O1xuXG5jb25zdCBwYWxldHRlJDIgPSB7XG4gICAgcHJpbWFyeTogJyM3M2ExZmYnLFxuICAgIHN1Y2Nlc3M6ICcjNWRjZmUzJyxcbiAgICBpbmZvOiAnI2JhN2ZlYycsXG4gICAgd2FybmluZzogJyNmZmEzNmInLFxuICAgIGRhbmdlcjogJyNmZjZiODMnLFxufTtcbmNvbnN0IENPUlBPUkFURV9USEVNRSA9IHtcbiAgICBuYW1lOiAnY29ycG9yYXRlJyxcbiAgICBiYXNlOiAnZGVmYXVsdCcsXG4gICAgdmFyaWFibGVzOiB7XG4gICAgICAgIGZvbnRNYWluOiAnT3BlbiBTYW5zLCBzYW5zLXNlcmlmJyxcbiAgICAgICAgZm9udFNlY29uZGFyeTogJ1JhbGV3YXksIHNhbnMtc2VyaWYnLFxuICAgICAgICBiZzogJyNmZmZmZmYnLFxuICAgICAgICBiZzI6ICcjZjdmOWZjJyxcbiAgICAgICAgYmczOiAnI2VkZjFmNycsXG4gICAgICAgIGJnNDogJyNlNGU5ZjInLFxuICAgICAgICBib3JkZXI6ICcjZmZmZmZmJyxcbiAgICAgICAgYm9yZGVyMjogJyNmN2Y5ZmMnLFxuICAgICAgICBib3JkZXIzOiAnI2VkZjFmNycsXG4gICAgICAgIGJvcmRlcjQ6ICcjZTRlOWYyJyxcbiAgICAgICAgYm9yZGVyNTogJyNjNWNlZTAnLFxuICAgICAgICBmZzogJyM4ZjliYjMnLFxuICAgICAgICBmZ0hlYWRpbmc6ICcjMWEyMTM4JyxcbiAgICAgICAgZmdUZXh0OiAnIzFhMjEzOCcsXG4gICAgICAgIGZnSGlnaGxpZ2h0OiBwYWxldHRlJDIucHJpbWFyeSxcbiAgICAgICAgbGF5b3V0Qmc6ICcjZjdmOWZjJyxcbiAgICAgICAgc2VwYXJhdG9yOiAnI2VkZjFmNycsXG4gICAgICAgIHByaW1hcnk6IHBhbGV0dGUkMi5wcmltYXJ5LFxuICAgICAgICBzdWNjZXNzOiBwYWxldHRlJDIuc3VjY2VzcyxcbiAgICAgICAgaW5mbzogcGFsZXR0ZSQyLmluZm8sXG4gICAgICAgIHdhcm5pbmc6IHBhbGV0dGUkMi53YXJuaW5nLFxuICAgICAgICBkYW5nZXI6IHBhbGV0dGUkMi5kYW5nZXIsXG4gICAgICAgIHByaW1hcnlMaWdodDogJyM1OThiZmYnLFxuICAgICAgICBzdWNjZXNzTGlnaHQ6ICcjMmNlNjliJyxcbiAgICAgICAgaW5mb0xpZ2h0OiAnIzQyYWFmZicsXG4gICAgICAgIHdhcm5pbmdMaWdodDogJyNmZmM5NGQnLFxuICAgICAgICBkYW5nZXJMaWdodDogJyNmZjcwOGQnLFxuICAgIH0sXG59O1xuXG5jb25zdCBwYWxldHRlJDMgPSB7XG4gICAgcHJpbWFyeTogJyMzMzY2ZmYnLFxuICAgIHN1Y2Nlc3M6ICcjMDBkNjhmJyxcbiAgICBpbmZvOiAnIzAwOTVmZicsXG4gICAgd2FybmluZzogJyNmZmFhMDAnLFxuICAgIGRhbmdlcjogJyNmZjNkNzEnLFxufTtcbmNvbnN0IERBUktfVEhFTUUgPSB7XG4gICAgbmFtZTogJ2RhcmsnLFxuICAgIHZhcmlhYmxlczoge1xuICAgICAgICBmb250TWFpbjogJ09wZW4gU2Fucywgc2Fucy1zZXJpZicsXG4gICAgICAgIGZvbnRTZWNvbmRhcnk6ICdSYWxld2F5LCBzYW5zLXNlcmlmJyxcbiAgICAgICAgYmc6ICcjMjIyYjQ1JyxcbiAgICAgICAgYmcyOiAnIzFhMjEzOCcsXG4gICAgICAgIGJnMzogJyMxNTFhMzAnLFxuICAgICAgICBiZzQ6ICcjMTAxNDI2JyxcbiAgICAgICAgYm9yZGVyOiAnIzIyMmI0NScsXG4gICAgICAgIGJvcmRlcjI6ICcjMWEyMTM4JyxcbiAgICAgICAgYm9yZGVyMzogJyMxNTFhMzAnLFxuICAgICAgICBib3JkZXI0OiAnIzEwMTQyNicsXG4gICAgICAgIGJvcmRlcjU6ICcjMTAxNDI2JyxcbiAgICAgICAgZmc6ICcjOGY5YmIzJyxcbiAgICAgICAgZmdIZWFkaW5nOiAnI2ZmZmZmZicsXG4gICAgICAgIGZnVGV4dDogJyNmZmZmZmYnLFxuICAgICAgICBmZ0hpZ2hsaWdodDogcGFsZXR0ZSQzLnByaW1hcnksXG4gICAgICAgIGxheW91dEJnOiAnIzFiMWIzOCcsXG4gICAgICAgIHNlcGFyYXRvcjogJyMxYjFiMzgnLFxuICAgICAgICBwcmltYXJ5OiBwYWxldHRlJDMucHJpbWFyeSxcbiAgICAgICAgc3VjY2VzczogcGFsZXR0ZSQzLnN1Y2Nlc3MsXG4gICAgICAgIGluZm86IHBhbGV0dGUkMy5pbmZvLFxuICAgICAgICB3YXJuaW5nOiBwYWxldHRlJDMud2FybmluZyxcbiAgICAgICAgZGFuZ2VyOiBwYWxldHRlJDMuZGFuZ2VyLFxuICAgICAgICBwcmltYXJ5TGlnaHQ6ICcjNTk4YmZmJyxcbiAgICAgICAgc3VjY2Vzc0xpZ2h0OiAnIzJjZTY5YicsXG4gICAgICAgIGluZm9MaWdodDogJyM0MmFhZmYnLFxuICAgICAgICB3YXJuaW5nTGlnaHQ6ICcjZmZjOTRkJyxcbiAgICAgICAgZGFuZ2VyTGlnaHQ6ICcjZmY3MDhkJyxcbiAgICB9LFxufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuY29uc3QgQlVJTFRfSU5fVEhFTUVTID0gW1xuICAgIERFRkFVTFRfVEhFTUUsXG4gICAgQ09TTUlDX1RIRU1FLFxuICAgIENPUlBPUkFURV9USEVNRSxcbiAgICBEQVJLX1RIRU1FLFxuXTtcbi8qKlxuICogSnMgVGhlbWVzIHJlZ2lzdHJ5IC0gcHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBKUyB0aGVtZXMnIHZhcmlhYmxlcy5cbiAqIFVzdWFsbHkgc2hvdWxkbid0IGJlIHVzZWQgZGlyZWN0bHksIGJ1dCB0aHJvdWdoIHRoZSBOYlRoZW1lU2VydmljZSBjbGFzcyBtZXRob2RzIChnZXRKc1RoZW1lKS5cbiAqL1xubGV0IE5iSlNUaGVtZXNSZWdpc3RyeSA9IGNsYXNzIE5iSlNUaGVtZXNSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoYnVpbHRJblRoZW1lcywgbmV3VGhlbWVzID0gW10pIHtcbiAgICAgICAgdGhpcy50aGVtZXMgPSB7fTtcbiAgICAgICAgY29uc3QgdGhlbWVzID0gdGhpcy5jb21iaW5lQnlOYW1lcyhuZXdUaGVtZXMsIGJ1aWx0SW5UaGVtZXMpO1xuICAgICAgICB0aGVtZXMuZm9yRWFjaCgodGhlbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIodGhlbWUsIHRoZW1lLm5hbWUsIHRoZW1lLmJhc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IEpTIHRoZW1lXG4gICAgICogQHBhcmFtIGNvbmZpZyBhbnlcbiAgICAgKiBAcGFyYW0gdGhlbWVOYW1lIHN0cmluZ1xuICAgICAqIEBwYXJhbSBiYXNlVGhlbWUgc3RyaW5nXG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29uZmlnLCB0aGVtZU5hbWUsIGJhc2VUaGVtZSkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5oYXMoYmFzZVRoZW1lKSA/IHRoaXMuZ2V0KGJhc2VUaGVtZSkgOiB7fTtcbiAgICAgICAgdGhpcy50aGVtZXNbdGhlbWVOYW1lXSA9IHRoaXMubWVyZ2VEZWVwKHt9LCBiYXNlLCBjb25maWcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgdGhlbWUgaXMgcmVnaXN0ZXJlZFxuICAgICAqIEBwYXJhbSB0aGVtZU5hbWVcbiAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICovXG4gICAgaGFzKHRoZW1lTmFtZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnRoZW1lc1t0aGVtZU5hbWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB0aGVtZVxuICAgICAqIEBwYXJhbSB0aGVtZU5hbWVcbiAgICAgKiBAcmV0dXJucyBOYkpTVGhlbWVPcHRpb25zXG4gICAgICovXG4gICAgZ2V0KHRoZW1lTmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMudGhlbWVzW3RoZW1lTmFtZV0pIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBOYlRoZW1lQ29uZmlnOiBubyB0aGVtZSAnJHt0aGVtZU5hbWV9JyBmb3VuZCByZWdpc3RlcmVkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMudGhlbWVzW3RoZW1lTmFtZV0pKTtcbiAgICB9XG4gICAgY29tYmluZUJ5TmFtZXMobmV3VGhlbWVzLCBvbGRUaGVtZXMpIHtcbiAgICAgICAgaWYgKG5ld1RoZW1lcykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkVGhlbWVzID0gW107XG4gICAgICAgICAgICBuZXdUaGVtZXMuZm9yRWFjaCgodGhlbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1lT2xkID0gb2xkVGhlbWVzLmZpbmQoKHRtKSA9PiB0bS5uYW1lID09PSB0aGVtZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICB8fCB7fTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWRUaGVtZSA9IHRoaXMubWVyZ2VEZWVwKHt9LCBzYW1lT2xkLCB0aGVtZSk7XG4gICAgICAgICAgICAgICAgbWVyZ2VkVGhlbWVzLnB1c2gobWVyZ2VkVGhlbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvbGRUaGVtZXMuZm9yRWFjaCgodGhlbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW1lcmdlZFRoZW1lcy5maW5kKCh0bSkgPT4gdG0ubmFtZSA9PT0gdGhlbWUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkVGhlbWVzLnB1c2godGhlbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZFRoZW1lcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2xkVGhlbWVzO1xuICAgIH1cbiAgICBpc09iamVjdChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpdGVtKTtcbiAgICB9XG4gICAgLy8gVE9ETzogbW92ZSB0byBoZWxwZXJzXG4gICAgbWVyZ2VEZWVwKHRhcmdldCwgLi4uc291cmNlcykge1xuICAgICAgICBpZiAoIXNvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNPYmplY3QodGFyZ2V0KSAmJiB0aGlzLmlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzT2JqZWN0KHNvdXJjZVtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRhcmdldFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgeyBba2V5XToge30gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB7IFtrZXldOiBzb3VyY2Vba2V5XSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VEZWVwKHRhcmdldCwgLi4uc291cmNlcyk7XG4gICAgfVxufTtcbk5iSlNUaGVtZXNSZWdpc3RyeSA9IF9fZGVjb3JhdGUkMihbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fcGFyYW0kMSgwLCBJbmplY3QoTkJfQlVJTFRfSU5fSlNfVEhFTUVTKSksXG4gICAgX19wYXJhbSQxKDEsIEluamVjdChOQl9KU19USEVNRVMpKSxcbiAgICBfX21ldGFkYXRhJDEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQXJyYXksIEFycmF5XSlcbl0sIE5iSlNUaGVtZXNSZWdpc3RyeSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDMgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMiA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmNvbnN0IERFRkFVTFRfTUVESUFfQlJFQUtQT0lOVFMgPSBbXG4gICAge1xuICAgICAgICBuYW1lOiAneHMnLFxuICAgICAgICB3aWR0aDogMCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2lzJyxcbiAgICAgICAgd2lkdGg6IDQwMCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3NtJyxcbiAgICAgICAgd2lkdGg6IDU3NixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ21kJyxcbiAgICAgICAgd2lkdGg6IDc2OCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ2xnJyxcbiAgICAgICAgd2lkdGg6IDk5MixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3hsJyxcbiAgICAgICAgd2lkdGg6IDEyMDAsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICd4eGwnLFxuICAgICAgICB3aWR0aDogMTQwMCxcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogJ3h4eGwnLFxuICAgICAgICB3aWR0aDogMTYwMCxcbiAgICB9LFxuXTtcbi8qKlxuICogTWFuYWdlcyBtZWRpYSBicmVha3BvaW50c1xuICpcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byBhdmFpbGFibGUgbWVkaWEgYnJlYWtwb2ludHMgdG8gY29udmVydCB3aW5kb3cgd2lkdGggdG8gYSBjb25maWd1cmVkIGJyZWFrcG9pbnQsXG4gKiBlLmcuIDIwMHB4IC0gKnhzKiBicmVha3BvaW50XG4gKi9cbmxldCBOYk1lZGlhQnJlYWtwb2ludHNTZXJ2aWNlID0gY2xhc3MgTmJNZWRpYUJyZWFrcG9pbnRzU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoYnJlYWtwb2ludHMpIHtcbiAgICAgICAgdGhpcy5icmVha3BvaW50cyA9IGJyZWFrcG9pbnRzO1xuICAgICAgICB0aGlzLmJyZWFrcG9pbnRzTWFwID0gdGhpcy5icmVha3BvaW50cy5yZWR1Y2UoKHJlcywgYikgPT4ge1xuICAgICAgICAgICAgcmVzW2IubmFtZV0gPSBiLndpZHRoO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29uZmlndXJlZCBicmVha3BvaW50IGJ5IHdpZHRoXG4gICAgICogQHBhcmFtIHdpZHRoIG51bWJlclxuICAgICAqIEByZXR1cm5zIHtafHtuYW1lOiBzdHJpbmcsIHdpZHRoOiBudW1iZXJ9fVxuICAgICAqL1xuICAgIGdldEJ5V2lkdGgod2lkdGgpIHtcbiAgICAgICAgY29uc3QgdW5rbm93biA9IHsgbmFtZTogJ3Vua25vd24nLCB3aWR0aDogd2lkdGggfTtcbiAgICAgICAgY29uc3QgYnJlYWtwb2ludHMgPSB0aGlzLmdldEJyZWFrcG9pbnRzKCk7XG4gICAgICAgIHJldHVybiBicmVha3BvaW50c1xuICAgICAgICAgICAgLmZpbmQoKHBvaW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGJyZWFrcG9pbnRzW2luZGV4ICsgMV07XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPj0gcG9pbnQud2lkdGggJiYgKCFuZXh0IHx8IHdpZHRoIDwgbmV4dC53aWR0aCk7XG4gICAgICAgIH0pIHx8IHVua25vd247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb25maWd1cmVkIGJyZWFrcG9pbnQgYnkgbmFtZVxuICAgICAqIEBwYXJhbSBuYW1lIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIE5iTWVkaWFCcmVha3BvaW50XG4gICAgICovXG4gICAgZ2V0QnlOYW1lKG5hbWUpIHtcbiAgICAgICAgY29uc3QgdW5rbm93biA9IHsgbmFtZTogJ3Vua25vd24nLCB3aWR0aDogTmFOIH07XG4gICAgICAgIGNvbnN0IGJyZWFrcG9pbnRzID0gdGhpcy5nZXRCcmVha3BvaW50cygpO1xuICAgICAgICByZXR1cm4gYnJlYWtwb2ludHMuZmluZCgocG9pbnQpID0+IG5hbWUgPT09IHBvaW50Lm5hbWUpIHx8IHVua25vd247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNvbmZpZ3VyZWQgYnJlYWtwb2ludHMgZm9yIHRoZSB0aGVtZVxuICAgICAqIEByZXR1cm5zIE5iTWVkaWFCcmVha3BvaW50W11cbiAgICAgKi9cbiAgICBnZXRCcmVha3BvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJlYWtwb2ludHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXAgb2YgY29uZmlndXJlZCBicmVha3BvaW50cyBmb3IgdGhlIHRoZW1lXG4gICAgICogQHJldHVybnMge1twOiBzdHJpbmddOiBudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0QnJlYWtwb2ludHNNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyZWFrcG9pbnRzTWFwO1xuICAgIH1cbn07XG5OYk1lZGlhQnJlYWtwb2ludHNTZXJ2aWNlID0gX19kZWNvcmF0ZSQzKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSQyKDAsIEluamVjdChOQl9NRURJQV9CUkVBS1BPSU5UUykpLFxuICAgIF9fbWV0YWRhdGEkMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgTmJNZWRpYUJyZWFrcG9pbnRzU2VydmljZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBNYWluIE5lYnVsYXIgc2VydmljZS4gSW5jbHVkZXMgdmFyaW91cyBoZWxwZXIgbWV0aG9kcy5cbiAqL1xubGV0IE5iVGhlbWVTZXJ2aWNlID0gY2xhc3MgTmJUaGVtZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGJyZWFrcG9pbnRTZXJ2aWNlLCBqc1RoZW1lc1JlZ2lzdHJ5KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYnJlYWtwb2ludFNlcnZpY2UgPSBicmVha3BvaW50U2VydmljZTtcbiAgICAgICAgdGhpcy5qc1RoZW1lc1JlZ2lzdHJ5ID0ganNUaGVtZXNSZWdpc3RyeTtcbiAgICAgICAgdGhpcy50aGVtZUNoYW5nZXMkID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG4gICAgICAgIHRoaXMuYXBwZW5kTGF5b3V0Q2xhc3MkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMYXlvdXRDbGFzcyQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmNoYW5nZVdpbmRvd1dpZHRoJCA9IG5ldyBSZXBsYXlTdWJqZWN0KDIpO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLm5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVGhlbWUob3B0aW9ucy5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgY3VycmVudCBhcHBsaWNhdGlvbiB0aGVtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgY2hhbmdlVGhlbWUobmFtZSkge1xuICAgICAgICB0aGlzLnRoZW1lQ2hhbmdlcyQubmV4dCh7IG5hbWUsIHByZXZpb3VzOiB0aGlzLmN1cnJlbnRUaGVtZSB9KTtcbiAgICAgICAgdGhpcy5jdXJyZW50VGhlbWUgPSBuYW1lO1xuICAgIH1cbiAgICBjaGFuZ2VXaW5kb3dXaWR0aCh3aWR0aCkge1xuICAgICAgICB0aGlzLmNoYW5nZVdpbmRvd1dpZHRoJC5uZXh0KHdpZHRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHRoZW1lIG9iamVjdCB3aXRoIHZhcmlhYmxlcyAoY29sb3IvcGFkZGluZ3MvZXRjKSBvbiBhIHRoZW1lIGNoYW5nZS5cbiAgICAgKiBPbmNlIHN1YnNjcmliZWQgLSByZXR1cm5zIGN1cnJlbnQgdGhlbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxOYkpTVGhlbWVPcHRpb25zPn1cbiAgICAgKi9cbiAgICBnZXRKc1RoZW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vblRoZW1lQ2hhbmdlKCkucGlwZShtYXAoKHRoZW1lKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5qc1RoZW1lc1JlZ2lzdHJ5LmdldCh0aGVtZS5uYW1lKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBtZWRpYSBxdWVyeSBicmVha3BvaW50IGNoYW5nZVxuICAgICAqIFJldHVybnMgYSBwYWlyIHdoZXJlIHRoZSBmaXJzdCBpdGVtIGlzIHByZXZpb3VzIG1lZGlhIGJyZWFrcG9pbnQgYW5kIHRoZSBzZWNvbmQgaXRlbSBpcyBjdXJyZW50IGJyZWFrcG9pdC5cbiAgICAgKiBgYGB0c1xuICAgICAqICBbeyBuYW1lOiAneHMnLCB3aWR0aDogMCB9LCB7IG5hbWU6ICdtZCcsIHdpZHRoOiA3NjggfV0gLy8gY2hhbmdlIGZyb20gYHhzYCB0byBgbWRgXG4gICAgICogYGBgXG4gICAgICogQHJldHVybnMge09ic2VydmFibGU8W05iTWVkaWFCcmVha3BvaW50LCBOYk1lZGlhQnJlYWtwb2ludF0+fVxuICAgICAqL1xuICAgIG9uTWVkaWFRdWVyeUNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlV2luZG93V2lkdGgkXG4gICAgICAgICAgICAucGlwZShzdGFydFdpdGgodW5kZWZpbmVkKSwgcGFpcndpc2UoKSwgbWFwKChbcHJldldpZHRoLCB3aWR0aF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5icmVha3BvaW50U2VydmljZS5nZXRCeVdpZHRoKHByZXZXaWR0aCksXG4gICAgICAgICAgICAgICAgdGhpcy5icmVha3BvaW50U2VydmljZS5nZXRCeVdpZHRoKHdpZHRoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pLCBmaWx0ZXIoKFtwcmV2UG9pbnQsIHBvaW50XSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZQb2ludC5uYW1lICE9PSBwb2ludC5uYW1lO1xuICAgICAgICB9KSwgZGlzdGluY3RVbnRpbENoYW5nZWQobnVsbCwgcGFyYW1zID0+IHBhcmFtc1swXS5uYW1lICsgcGFyYW1zWzFdLm5hbWUpLCBzaGFyZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcmVkIHdoZW4gY3VycmVudCB0aGVtZSBpcyBjaGFuZ2VkXG4gICAgICogQHJldHVybnMge09ic2VydmFibGU8YW55Pn1cbiAgICAgKi9cbiAgICBvblRoZW1lQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVtZUNoYW5nZXMkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZCBhIGNsYXNzIHRvIG5iLWxheW91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICAgKi9cbiAgICBhcHBlbmRMYXlvdXRDbGFzcyhjbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRMYXlvdXRDbGFzcyQubmV4dChjbGFzc05hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIG5ldyBjbGFzcyBpcyBhZGRlZCB0byBuYi1sYXlvdXQgdGhyb3VnaCBgYXBwZW5kTGF5b3V0Q2xhc3NgIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPGFueT59XG4gICAgICovXG4gICAgb25BcHBlbmRMYXlvdXRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZW5kTGF5b3V0Q2xhc3MkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIG5iLWxheW91dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICAgKi9cbiAgICByZW1vdmVMYXlvdXRDbGFzcyhjbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMYXlvdXRDbGFzcyQubmV4dChjbGFzc05hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBhIGNsYXNzIGlzIHJlbW92ZWQgZnJvbSBuYi1sYXlvdXQgdGhyb3VnaCBgcmVtb3ZlTGF5b3V0Q2xhc3NgIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPGFueT59XG4gICAgICovXG4gICAgb25SZW1vdmVMYXlvdXRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGF5b3V0Q2xhc3MkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxufTtcbk5iVGhlbWVTZXJ2aWNlID0gX19kZWNvcmF0ZSQxKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSgwLCBJbmplY3QoTkJfVEhFTUVfT1BUSU9OUykpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBOYk1lZGlhQnJlYWtwb2ludHNTZXJ2aWNlLFxuICAgICAgICBOYkpTVGhlbWVzUmVnaXN0cnldKVxuXSwgTmJUaGVtZVNlcnZpY2UpO1xuXG52YXIgX19kZWNvcmF0ZSQ0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDMgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDMgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFNlcnZpY2UgdG8gY29udHJvbCB0aGUgZ2xvYmFsIHBhZ2Ugc3Bpbm5lci5cbiAqL1xubGV0IE5iU3Bpbm5lclNlcnZpY2UgPSBjbGFzcyBOYlNwaW5uZXJTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMubG9hZGVycyA9IFtdO1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gJ25iLWdsb2JhbC1zcGlubmVyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBuZXcgbG9hZGVyIHRvIHRoZSBsaXN0IG9mIGxvYWRlciB0byBiZSBjb21wbGV0ZWQgYmVmb3JlXG4gICAgICogc3Bpbm5lciB3aWxsIGJlIGhpZGRlblxuICAgICAqIEBwYXJhbSBtZXRob2QgUHJvbWlzZTxhbnk+XG4gICAgICovXG4gICAgcmVnaXN0ZXJMb2FkZXIobWV0aG9kKSB7XG4gICAgICAgIHRoaXMubG9hZGVycy5wdXNoKG1ldGhvZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgbGlzdCBvZiBsb2FkZXJcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5sb2FkZXJzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBsb2FkZXIgcHJvY2Vzcywgc2hvdyBzcGlubmRlciBhbmQgZXhlY3V0ZSBsb2FkZXJzXG4gICAgICovXG4gICAgbG9hZCgpIHtcbiAgICAgICAgdGhpcy5zaG93U3Bpbm5lcigpO1xuICAgICAgICB0aGlzLmV4ZWN1dGVBbGwoKTtcbiAgICB9XG4gICAgZXhlY3V0ZUFsbChkb25lID0gKCkgPT4geyB9KSB7XG4gICAgICAgIFByb21pc2UuYWxsKHRoaXMubG9hZGVycykudGhlbigodmFsdWVzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGVTcGlubmVyKCk7XG4gICAgICAgICAgICBkb25lLmNhbGwobnVsbCwgdmFsdWVzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE86IFByb21pc2UucmVqZWN0XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRPRE8gaXMgdGhlcmUgYW55IGJldHRlciB3YXkgb2YgZG9pbmcgdGhpcz9cbiAgICBzaG93U3Bpbm5lcigpIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmdldFNwaW5uZXJFbGVtZW50KCk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgZWwuc3R5bGVbJ2Rpc3BsYXknXSA9ICdibG9jayc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGlkZVNwaW5uZXIoKSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5nZXRTcGlubmVyRWxlbWVudCgpO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlWydkaXNwbGF5J10gPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U3Bpbm5lckVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuc2VsZWN0b3IpO1xuICAgIH1cbn07XG5OYlNwaW5uZXJTZXJ2aWNlID0gX19kZWNvcmF0ZSQ0KFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSQzKDAsIEluamVjdChOQl9ET0NVTUVOVCkpLFxuICAgIF9fbWV0YWRhdGEkMyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgTmJTcGlubmVyU2VydmljZSk7XG5cbnZhciBfX2RlY29yYXRlJDUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kNCA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogTGF5b3V0IGRpcmVjdGlvbi5cbiAqICovXG52YXIgTmJMYXlvdXREaXJlY3Rpb247XG4oZnVuY3Rpb24gKE5iTGF5b3V0RGlyZWN0aW9uKSB7XG4gICAgTmJMYXlvdXREaXJlY3Rpb25bXCJMVFJcIl0gPSBcImx0clwiO1xuICAgIE5iTGF5b3V0RGlyZWN0aW9uW1wiUlRMXCJdID0gXCJydGxcIjtcbn0pKE5iTGF5b3V0RGlyZWN0aW9uIHx8IChOYkxheW91dERpcmVjdGlvbiA9IHt9KSk7XG5cbi8qKlxuICogTGF5b3V0IGRpcmVjdGlvbiBzZXR0aW5nIGluamVjdGlvbiB0b2tlbi5cbiAqICovXG5jb25zdCBOQl9MQVlPVVRfRElSRUNUSU9OID0gbmV3IEluamVjdGlvblRva2VuKCdMYXlvdXQgZGlyZWN0aW9uJyk7XG4vKipcbiAqIExheW91dCBEaXJlY3Rpb24gU2VydmljZS5cbiAqIEFsbG93cyB0byBzZXQgb3IgZ2V0IGxheW91dCBkaXJlY3Rpb24gYW5kIGxpc3RlbiB0byBpdHMgY2hhbmdlc1xuICovXG5sZXQgTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlID0gY2xhc3MgTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihkaXJlY3Rpb24gPSBOYkxheW91dERpcmVjdGlvbi5MVFIpIHtcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuJGRpcmVjdGlvbkNoYW5nZSA9IG5ldyBSZXBsYXlTdWJqZWN0KDEpO1xuICAgICAgICB0aGlzLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgbGF5b3V0IGRpcmVjdGlvbiBzZXQgdG8gbGVmdCB0byByaWdodC5cbiAgICAgKiBAcmV0dXJucyBib29sZWFuLlxuICAgICAqICovXG4gICAgaXNMdHIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gTmJMYXlvdXREaXJlY3Rpb24uTFRSO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgbGF5b3V0IGRpcmVjdGlvbiBzZXQgdG8gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyBib29sZWFuLlxuICAgICAqICovXG4gICAgaXNSdGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gTmJMYXlvdXREaXJlY3Rpb24uUlRMO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnQgbGF5b3V0IGRpcmVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBOYkxheW91dERpcmVjdGlvbi5cbiAgICAgKiAqL1xuICAgIGdldERpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGxheW91dCBkaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0ge05iTGF5b3V0RGlyZWN0aW9ufSBkaXJlY3Rpb25cbiAgICAgKi9cbiAgICBzZXREaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLiRkaXJlY3Rpb25DaGFuZ2UubmV4dChkaXJlY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyZWQgd2hlbiBkaXJlY3Rpb24gd2FzIGNoYW5nZWQuXG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZTxOYkxheW91dERpcmVjdGlvbj4uXG4gICAgICovXG4gICAgb25EaXJlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRkaXJlY3Rpb25DaGFuZ2UucGlwZShzaGFyZSgpKTtcbiAgICB9XG59O1xuTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlID0gX19kZWNvcmF0ZSQ1KFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSQ0KDAsIE9wdGlvbmFsKCkpLCBfX3BhcmFtJDQoMCwgSW5qZWN0KE5CX0xBWU9VVF9ESVJFQ1RJT04pKSxcbiAgICBfX21ldGFkYXRhJDQoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIE5iTGF5b3V0RGlyZWN0aW9uU2VydmljZSk7XG5cbnZhciBfX2RlY29yYXRlJDYgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuLyoqXG4gKiBMYXlvdXQgc2Nyb2xsIHNlcnZpY2UuIFByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLFxuICogYXMgd2VsbCBhcyBtZXRob2RzIHRvIHVwZGF0ZSBwb3NpdGlvbiBvZiB0aGUgc2Nyb2xsLlxuICpcbiAqIFRoZSByZWFzb24gd2UgYWRkZWQgdGhpcyBzZXJ2aWNlIGlzIHRoYXQgaW4gTmVidWxhciB0aGVyZSBhcmUgdHdvIHNjcm9sbCBtb2RlczpcbiAqIC0gdGhlIGRlZmF1bHQgbW9kZSB3aGVuIHNjcm9sbCBpcyBvbiBib2R5XG4gKiAtIGFuZCB0aGUgYHdpdGhTY3JvbGxgIG1vZGUsIHdoZW4gc2Nyb2xsIGlzIHJlbW92ZWQgZnJvbSB0aGUgYm9keSBhbmQgbW92ZWQgdG8gYW4gZWxlbWVudCBpbnNpZGUgb2YgdGhlXG4gKiBgbmItbGF5b3V0YCBjb21wb25lbnRcbiAqL1xubGV0IE5iTGF5b3V0U2Nyb2xsU2VydmljZSA9IGNsYXNzIE5iTGF5b3V0U2Nyb2xsU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogTGF5b3V0IHNjcm9sbCBzZXJ2aWNlLiBQcm92aWRlcyBpbmZvcm1hdGlvbiBhYm91dCBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbixcbiAgICAgKiBhcyB3ZWxsIGFzIG1ldGhvZHMgdG8gdXBkYXRlIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGwuXG4gICAgICpcbiAgICAgKiBUaGUgcmVhc29uIHdlIGFkZGVkIHRoaXMgc2VydmljZSBpcyB0aGF0IGluIE5lYnVsYXIgdGhlcmUgYXJlIHR3byBzY3JvbGwgbW9kZXM6XG4gICAgICogLSB0aGUgZGVmYXVsdCBtb2RlIHdoZW4gc2Nyb2xsIGlzIG9uIGJvZHlcbiAgICAgKiAtIGFuZCB0aGUgYHdpdGhTY3JvbGxgIG1vZGUsIHdoZW4gc2Nyb2xsIGlzIHJlbW92ZWQgZnJvbSB0aGUgYm9keSBhbmQgbW92ZWQgdG8gYW4gZWxlbWVudCBpbnNpZGUgb2YgdGhlXG4gICAgICogYG5iLWxheW91dGAgY29tcG9uZW50XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb25SZXEkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5tYW51YWxTY3JvbGwkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5zY3JvbGwkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxOYlNjcm9sbFBvc2l0aW9uPn1cbiAgICAgKi9cbiAgICBnZXRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICAgICAgbGlzdGVuZXIuc3Vic2NyaWJlKG9ic2VydmVyKTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb25SZXEkLm5leHQoeyBsaXN0ZW5lciB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBsaXN0ZW5lci5jb21wbGV0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBzY3JvbGwgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgICBzY3JvbGxUbyh4ID0gbnVsbCwgeSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5tYW51YWxTY3JvbGwkLm5leHQoeyB4LCB5IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyZWFtIG9mIHNjcm9sbCBldmVudHNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPGFueT59XG4gICAgICovXG4gICAgb25TY3JvbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbCQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlPE5iU2Nyb2xsUG9zaXRpb24+LlxuICAgICAqL1xuICAgIG9uTWFudWFsU2Nyb2xsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYW51YWxTY3JvbGwkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1N1YmplY3Q8YW55Pn1cbiAgICAgKi9cbiAgICBvbkdldFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxQb3NpdGlvblJlcSQ7XG4gICAgfVxuICAgIG9uU2Nyb2xsYWJsZUNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsYWJsZSQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2FueX0gZXZlbnRcbiAgICAgKi9cbiAgICBmaXJlU2Nyb2xsQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsJC5uZXh0KGV2ZW50KTtcbiAgICB9XG4gICAgc2Nyb2xsYWJsZShzY3JvbGxhYmxlKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZSQubmV4dChzY3JvbGxhYmxlKTtcbiAgICB9XG59O1xuTmJMYXlvdXRTY3JvbGxTZXJ2aWNlID0gX19kZWNvcmF0ZSQ2KFtcbiAgICBJbmplY3RhYmxlKClcbl0sIE5iTGF5b3V0U2Nyb2xsU2VydmljZSk7XG5cbnZhciBfX2RlY29yYXRlJDcgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuLyoqXG4gKiBTaW1wbGUgaGVscGVyIHNlcnZpY2UgdG8gcmV0dXJuIExheW91dCBkaW1lbnNpb25zXG4gKiBEZXBlbmRpbmcgb2YgY3VycmVudCBMYXlvdXQgc2Nyb2xsIG1vZGUgKGRlZmF1bHQgb3IgYHdpdGhTY3JvbGxgIHdoZW4gc2Nyb2xsIGlzIG1vdmVkIHRvIGFuIGVsZW1lbnRcbiAqIGluc2lkZSBvZiB0aGUgbGF5b3V0KSBjb3JyZXNwb25kaW5nIGRpbWVuc2lvbnMgd2lsbCBiZSByZXR1cm5zICAtIG9mIGBkb2N1bWVudEVsZW1lbnRgIGluIGZpcnN0IGNhc2UgYW5kXG4gKiBgLnNjcm9sbGFibGUtY29udGFpbmVyYCBpbiB0aGUgc2Vjb25kLlxuICovXG5sZXQgTmJMYXlvdXRSdWxlclNlcnZpY2UgPSBjbGFzcyBOYkxheW91dFJ1bGVyU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogU2ltcGxlIGhlbHBlciBzZXJ2aWNlIHRvIHJldHVybiBMYXlvdXQgZGltZW5zaW9uc1xuICAgICAqIERlcGVuZGluZyBvZiBjdXJyZW50IExheW91dCBzY3JvbGwgbW9kZSAoZGVmYXVsdCBvciBgd2l0aFNjcm9sbGAgd2hlbiBzY3JvbGwgaXMgbW92ZWQgdG8gYW4gZWxlbWVudFxuICAgICAqIGluc2lkZSBvZiB0aGUgbGF5b3V0KSBjb3JyZXNwb25kaW5nIGRpbWVuc2lvbnMgd2lsbCBiZSByZXR1cm5zICAtIG9mIGBkb2N1bWVudEVsZW1lbnRgIGluIGZpcnN0IGNhc2UgYW5kXG4gICAgICogYC5zY3JvbGxhYmxlLWNvbnRhaW5lcmAgaW4gdGhlIHNlY29uZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb250ZW50RGltZW5zaW9uc1JlcSQgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGRpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxOYkxheW91dERpbWVuc2lvbnM+fVxuICAgICAqL1xuICAgIGdldERpbWVuc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLnN1YnNjcmliZShvYnNlcnZlcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnREaW1lbnNpb25zUmVxJC5uZXh0KHsgbGlzdGVuZXIgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1N1YmplY3Q8YW55Pn1cbiAgICAgKi9cbiAgICBvbkdldERpbWVuc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnREaW1lbnNpb25zUmVxJDtcbiAgICB9XG59O1xuTmJMYXlvdXRSdWxlclNlcnZpY2UgPSBfX2RlY29yYXRlJDcoW1xuICAgIEluamVjdGFibGUoKVxuXSwgTmJMYXlvdXRSdWxlclNlcnZpY2UpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ5ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmxldCBOYlNoYXJlZE1vZHVsZSA9IGNsYXNzIE5iU2hhcmVkTW9kdWxlIHtcbn07XG5OYlNoYXJlZE1vZHVsZSA9IF9fZGVjb3JhdGUkOShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgICAgICAvLyBUT0RPOiBwcm9iYWJseSB3ZSBkb24ndCBuZWVkIEZvcm1zTW9kdWxlIGluIFNoYXJlZE1vZHVsZVxuICAgICAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgICAgICBSb3V0ZXJNb2R1bGUsXG4gICAgICAgIF0sXG4gICAgfSlcbl0sIE5iU2hhcmVkTW9kdWxlKTtcblxudmFyIF9fZGVjb3JhdGUkMTEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kNSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogT3ZlcnJpZGVzIGFuZ3VsYXIgY2RrIGZvY3VzIHRyYXAgdG8ga2VlcCByZXN0b3JlIGZ1bmN0aW9uYWxpdHkgaW5zaWRlIHRyYXAuXG4gKiAqL1xuY2xhc3MgTmJGb2N1c1RyYXAgZXh0ZW5kcyBGb2N1c1RyYXAge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNoZWNrZXIsIG5nWm9uZSwgZG9jdW1lbnQsIGRlZmVyQW5jaG9ycykge1xuICAgICAgICBzdXBlcihlbGVtZW50LCBjaGVja2VyLCBuZ1pvbmUsIGRvY3VtZW50LCBkZWZlckFuY2hvcnMpO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmNoZWNrZXIgPSBjaGVja2VyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLnNhdmVQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICB9XG4gICAgcmVzdG9yZUZvY3VzKCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzbHlGb2N1c2VkRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgYmx1clByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQuYmx1cigpO1xuICAgIH1cbiAgICBzYXZlUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkge1xuICAgICAgICB0aGlzLnByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IHRoaXMuZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9XG59XG5sZXQgTmJGb2N1c1RyYXBGYWN0b3J5U2VydmljZSA9IGNsYXNzIE5iRm9jdXNUcmFwRmFjdG9yeVNlcnZpY2UgZXh0ZW5kcyBGb2N1c1RyYXBGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihjaGVja2VyLCBuZ1pvbmUsIGRvY3VtZW50KSB7XG4gICAgICAgIHN1cGVyKGNoZWNrZXIsIG5nWm9uZSwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLmNoZWNrZXIgPSBjaGVja2VyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIH1cbiAgICBjcmVhdGUoZWxlbWVudCwgZGVmZXJDYXB0dXJlRWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYkZvY3VzVHJhcChlbGVtZW50LCB0aGlzLmNoZWNrZXIsIHRoaXMubmdab25lLCB0aGlzLmRvY3VtZW50LCBkZWZlckNhcHR1cmVFbGVtZW50cyk7XG4gICAgfVxufTtcbk5iRm9jdXNUcmFwRmFjdG9yeVNlcnZpY2UgPSBfX2RlY29yYXRlJDExKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSQ1KDIsIEluamVjdChOQl9ET0NVTUVOVCkpLFxuICAgIF9fbWV0YWRhdGEkNShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtJbnRlcmFjdGl2aXR5Q2hlY2tlcixcbiAgICAgICAgTmdab25lLCBPYmplY3RdKVxuXSwgTmJGb2N1c1RyYXBGYWN0b3J5U2VydmljZSk7XG5cbmNsYXNzIE5iRm9jdXNLZXlNYW5hZ2VyIGV4dGVuZHMgRm9jdXNLZXlNYW5hZ2VyIHtcbn1cbmNsYXNzIE5iRm9jdXNLZXlNYW5hZ2VyRmFjdG9yeVNlcnZpY2Uge1xuICAgIGNyZWF0ZShpdGVtcykge1xuICAgICAgICByZXR1cm4gbmV3IE5iRm9jdXNLZXlNYW5hZ2VyKGl0ZW1zKTtcbiAgICB9XG59XG5cbnZhciBfX2RlY29yYXRlJDEwID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBOYkExMXlNb2R1bGVfMTtcbmxldCBOYkExMXlNb2R1bGUgPSBOYkExMXlNb2R1bGVfMSA9IGNsYXNzIE5iQTExeU1vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTmJBMTF5TW9kdWxlXzEsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBOYkZvY3VzVHJhcEZhY3RvcnlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIE5iRm9jdXNLZXlNYW5hZ2VyRmFjdG9yeVNlcnZpY2UsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5OYkExMXlNb2R1bGUgPSBOYkExMXlNb2R1bGVfMSA9IF9fZGVjb3JhdGUkMTAoW1xuICAgIE5nTW9kdWxlKHt9KVxuXSwgTmJBMTF5TW9kdWxlKTtcblxudmFyIF9fZGVjb3JhdGUkMTIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIE5iQ2RrTWFwcGluZ01vZHVsZV8xO1xubGV0IE5iUG9ydGFsRGlyZWN0aXZlID0gY2xhc3MgTmJQb3J0YWxEaXJlY3RpdmUgZXh0ZW5kcyBDZGtQb3J0YWwge1xufTtcbk5iUG9ydGFsRGlyZWN0aXZlID0gX19kZWNvcmF0ZSQxMihbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmJQb3J0YWxdJyB9KVxuXSwgTmJQb3J0YWxEaXJlY3RpdmUpO1xubGV0IE5iUG9ydGFsT3V0bGV0RGlyZWN0aXZlID0gY2xhc3MgTmJQb3J0YWxPdXRsZXREaXJlY3RpdmUgZXh0ZW5kcyBDZGtQb3J0YWxPdXRsZXQge1xufTtcbk5iUG9ydGFsT3V0bGV0RGlyZWN0aXZlID0gX19kZWNvcmF0ZSQxMihbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmJQb3J0YWxPdXRsZXRdJyB9KVxuXSwgTmJQb3J0YWxPdXRsZXREaXJlY3RpdmUpO1xuY2xhc3MgTmJDb21wb25lbnRQb3J0YWwgZXh0ZW5kcyBDb21wb25lbnRQb3J0YWwge1xufVxubGV0IE5iT3ZlcmxheSA9IGNsYXNzIE5iT3ZlcmxheSBleHRlbmRzIE92ZXJsYXkge1xufTtcbk5iT3ZlcmxheSA9IF9fZGVjb3JhdGUkMTIoW1xuICAgIEluamVjdGFibGUoKVxuXSwgTmJPdmVybGF5KTtcbmxldCBOYlBsYXRmb3JtID0gY2xhc3MgTmJQbGF0Zm9ybSBleHRlbmRzIFBsYXRmb3JtIHtcbn07XG5OYlBsYXRmb3JtID0gX19kZWNvcmF0ZSQxMihbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBOYlBsYXRmb3JtKTtcbmxldCBOYk92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIgPSBjbGFzcyBOYk92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIgZXh0ZW5kcyBPdmVybGF5UG9zaXRpb25CdWlsZGVyIHtcbn07XG5OYk92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIgPSBfX2RlY29yYXRlJDEyKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIE5iT3ZlcmxheVBvc2l0aW9uQnVpbGRlcik7XG5jbGFzcyBOYlRlbXBsYXRlUG9ydGFsIGV4dGVuZHMgVGVtcGxhdGVQb3J0YWwge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCB2aWV3Q29udGFpbmVyUmVmLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKHRlbXBsYXRlLCB2aWV3Q29udGFpbmVyUmVmLCBjb250ZXh0KTtcbiAgICB9XG59XG5jbGFzcyBOYk92ZXJsYXlDb250YWluZXIgZXh0ZW5kcyBPdmVybGF5Q29udGFpbmVyIHtcbn1cbk5iT3ZlcmxheUNvbnRhaW5lci5uZ0luamVjdGFibGVEZWYgPSDJtcm1ZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIE5iT3ZlcmxheUNvbnRhaW5lcl9GYWN0b3J5KCkgeyByZXR1cm4gbmV3IE5iT3ZlcmxheUNvbnRhaW5lcijJtcm1aW5qZWN0KERPQ1VNRU5UKSk7IH0sIHRva2VuOiBOYk92ZXJsYXlDb250YWluZXIsIHByb3ZpZGVkSW46IFwicm9vdFwiIH0pO1xuY2xhc3MgTmJGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kge1xufVxuY2xhc3MgTmJQb3J0YWxJbmplY3RvciBleHRlbmRzIFBvcnRhbEluamVjdG9yIHtcbn1cbmNvbnN0IENES19NT0RVTEVTID0gW092ZXJsYXlNb2R1bGUsIFBvcnRhbE1vZHVsZV07XG4vKipcbiAqIFRoaXMgbW9kdWxlIGhlbHBzIHVzIHRvIGtlZXAgYWxsIGFuZ3VsYXIvY2RrIGRlcHMgaW5zaWRlIG91ciBjZGsgbW9kdWxlIHZpYSBwcm92aWRpbmcgYWxpYXNlcy5cbiAqIEFwcHJvYWNoIHdpbGwgaGVscCB1cyBtb3ZlIGNkayBpbiBzZXBhcmF0ZSBucG0gcGFja2FnZSBhbmQgcmVmYWN0b3IgbmVidWxhci90aGVtZSBjb2RlLlxuICogKi9cbmxldCBOYkNka01hcHBpbmdNb2R1bGUgPSBOYkNka01hcHBpbmdNb2R1bGVfMSA9IGNsYXNzIE5iQ2RrTWFwcGluZ01vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTmJDZGtNYXBwaW5nTW9kdWxlXzEsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBOYk92ZXJsYXksXG4gICAgICAgICAgICAgICAgTmJQbGF0Zm9ybSxcbiAgICAgICAgICAgICAgICBOYk92ZXJsYXlQb3NpdGlvbkJ1aWxkZXIsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5OYkNka01hcHBpbmdNb2R1bGUgPSBOYkNka01hcHBpbmdNb2R1bGVfMSA9IF9fZGVjb3JhdGUkMTIoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogWy4uLkNES19NT0RVTEVTXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgLi4uQ0RLX01PRFVMRVMsXG4gICAgICAgICAgICBOYlBvcnRhbERpcmVjdGl2ZSxcbiAgICAgICAgICAgIE5iUG9ydGFsT3V0bGV0RGlyZWN0aXZlLFxuICAgICAgICBdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYlBvcnRhbERpcmVjdGl2ZSwgTmJQb3J0YWxPdXRsZXREaXJlY3RpdmVdLFxuICAgIH0pXG5dLCBOYkNka01hcHBpbmdNb2R1bGUpO1xuXG52YXIgX19kZWNvcmF0ZSQxNCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG4vKipcbiAqIFByb3ZpZGVzIG5iLWxheW91dCBhcyBvdmVybGF5IGNvbnRhaW5lci5cbiAqIENvbnRhaW5lciBoYXMgdG8gYmUgY2xlYXJlZCB3aGVuIGxheW91dCBkZXN0cm95cy5cbiAqIEFub3RoZXIgd2F5IHByZXZpb3VzIHZlcnNpb24gb2YgdGhlIGNvbnRhaW5lciB3aWxsIGJlIHVzZWRcbiAqIGJ1dCBpdCBpc24ndCBpbnNlcnRlZCBpbiBET00gYW5kIGV4aXN0cyBpbiBtZW1vcnkgb25seS5cbiAqIFRoaXMgY2FzZSBpbXBvcnRhbnQgb25seSBpZiB5b3Ugc3dpdGNoIGJldHdlZW4gbXVsdGlwbGUgbGF5b3V0cy5cbiAqICovXG5sZXQgTmJPdmVybGF5Q29udGFpbmVyQWRhcHRlciA9IGNsYXNzIE5iT3ZlcmxheUNvbnRhaW5lckFkYXB0ZXIgZXh0ZW5kcyBOYk92ZXJsYXlDb250YWluZXIge1xuICAgIHNldENvbnRhaW5lcihjb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgfVxuICAgIGNsZWFyQ29udGFpbmVyKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lckVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICBfY3JlYXRlQ29udGFpbmVyKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2Nkay1vdmVybGF5LWNvbnRhaW5lcicpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICB0aGlzLl9jb250YWluZXJFbGVtZW50ID0gY29udGFpbmVyO1xuICAgIH1cbn07XG5OYk92ZXJsYXlDb250YWluZXJBZGFwdGVyID0gX19kZWNvcmF0ZSQxNChbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBOYk92ZXJsYXlDb250YWluZXJBZGFwdGVyKTtcblxudmFyIF9fZGVjb3JhdGUkMTUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xubGV0IE5iVmlld3BvcnRSdWxlckFkYXB0ZXIgPSBjbGFzcyBOYlZpZXdwb3J0UnVsZXJBZGFwdGVyIGV4dGVuZHMgVmlld3BvcnRSdWxlciB7XG4gICAgY29uc3RydWN0b3IocGxhdGZvcm0sIG5nWm9uZSwgcnVsZXIsIHNjcm9sbCkge1xuICAgICAgICBzdXBlcihwbGF0Zm9ybSwgbmdab25lKTtcbiAgICAgICAgdGhpcy5ydWxlciA9IHJ1bGVyO1xuICAgICAgICB0aGlzLnNjcm9sbCA9IHNjcm9sbDtcbiAgICB9XG4gICAgZ2V0Vmlld3BvcnRTaXplKCkge1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICAvKlxuICAgICAgICAqIGdldERpbWVuc2lvbnMgY2FsbCBpcyByZWFsbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uLlxuICAgICAgICAqIEFuZCB3ZSBoYXZlIHRvIGNvbmZvcm0gd2l0aCB0aGUgaW50ZXJmYWNlIG9mIHRoZSBvcmlnaW5hbCBzZXJ2aWNlLlxuICAgICAgICAqICovXG4gICAgICAgIHRoaXMucnVsZXIuZ2V0RGltZW5zaW9ucygpXG4gICAgICAgICAgICAucGlwZShtYXAoZGltZW5zaW9ucyA9PiAoeyB3aWR0aDogZGltZW5zaW9ucy5jbGllbnRXaWR0aCwgaGVpZ2h0OiBkaW1lbnNpb25zLmNsaWVudEhlaWdodCB9KSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHJlY3QgPT4gcmVzID0gcmVjdCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgICAgIGxldCByZXM7XG4gICAgICAgIC8qXG4gICAgICAgICogZ2V0UG9zaXRpb24gY2FsbCBpcyByZWFsbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uLlxuICAgICAgICAqIEFuZCB3ZSBoYXZlIHRvIGNvbmZvcm0gd2l0aCB0aGUgaW50ZXJmYWNlIG9mIHRoZSBvcmlnaW5hbCBzZXJ2aWNlLlxuICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2Nyb2xsLmdldFBvc2l0aW9uKClcbiAgICAgICAgICAgIC5waXBlKG1hcCgocG9zaXRpb24pID0+ICh7IHRvcDogcG9zaXRpb24ueSwgbGVmdDogcG9zaXRpb24ueCB9KSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHBvc2l0aW9uID0+IHJlcyA9IHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuTmJWaWV3cG9ydFJ1bGVyQWRhcHRlciA9IF9fZGVjb3JhdGUkMTUoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhJDcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJQbGF0Zm9ybSwgTmdab25lLFxuICAgICAgICBOYkxheW91dFJ1bGVyU2VydmljZSxcbiAgICAgICAgTmJMYXlvdXRTY3JvbGxTZXJ2aWNlXSlcbl0sIE5iVmlld3BvcnRSdWxlckFkYXB0ZXIpO1xuXG52YXIgX19kZWNvcmF0ZSQxNiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb247XG4oZnVuY3Rpb24gKE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uKSB7XG4gICAgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb25bXCJUT1BfU1RBUlRcIl0gPSBcInRvcC1zdGFydFwiO1xuICAgIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uW1wiVE9QX0VORFwiXSA9IFwidG9wLWVuZFwiO1xuICAgIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uW1wiQk9UVE9NX1NUQVJUXCJdID0gXCJib3R0b20tc3RhcnRcIjtcbiAgICBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbltcIkJPVFRPTV9FTkRcIl0gPSBcImJvdHRvbS1lbmRcIjtcbn0pKE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uIHx8IChOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbiA9IHt9KSk7XG52YXIgTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uO1xuKGZ1bmN0aW9uIChOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24pIHtcbiAgICBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb25bXCJUT1BfUklHSFRcIl0gPSBcInRvcC1yaWdodFwiO1xuICAgIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbltcIlRPUF9MRUZUXCJdID0gXCJ0b3AtbGVmdFwiO1xuICAgIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbltcIkJPVFRPTV9SSUdIVFwiXSA9IFwiYm90dG9tLXJpZ2h0XCI7XG4gICAgTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uW1wiQk9UVE9NX0xFRlRcIl0gPSBcImJvdHRvbS1sZWZ0XCI7XG59KShOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24gfHwgKE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbiA9IHt9KSk7XG5sZXQgTmJQb3NpdGlvbkhlbHBlciA9IGNsYXNzIE5iUG9zaXRpb25IZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dERpcmVjdGlvbikge1xuICAgICAgICB0aGlzLmxheW91dERpcmVjdGlvbiA9IGxheW91dERpcmVjdGlvbjtcbiAgICB9XG4gICAgdG9Mb2dpY2FsUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24pLmluY2x1ZGVzKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxheW91dERpcmVjdGlvbi5pc0x0cigpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0xvZ2ljYWxQb3NpdGlvbldoZW5MdHIocG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9Mb2dpY2FsUG9zaXRpb25XaGVuUnRsKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1BoeXNpY2FsUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uKS5pbmNsdWRlcyhwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXlvdXREaXJlY3Rpb24uaXNMdHIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9QaHlzaWNhbFBvc2l0aW9uV2hlbkx0cihwb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1BoeXNpY2FsUG9zaXRpb25XaGVuUnRsKHBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1RvcFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGxvZ2ljYWxQb3NpdGlvbiA9IHRoaXMudG9Mb2dpY2FsUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gbG9naWNhbFBvc2l0aW9uID09PSBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5UT1BfRU5EXG4gICAgICAgICAgICB8fCBsb2dpY2FsUG9zaXRpb24gPT09IE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLlRPUF9TVEFSVDtcbiAgICB9XG4gICAgaXNSaWdodFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHBoeXNpY2FsUG9zaXRpb24gPSB0aGlzLnRvUGh5c2ljYWxQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiBwaHlzaWNhbFBvc2l0aW9uID09PSBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uVE9QX1JJR0hUXG4gICAgICAgICAgICB8fCBwaHlzaWNhbFBvc2l0aW9uID09PSBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uQk9UVE9NX1JJR0hUO1xuICAgIH1cbiAgICB0b0xvZ2ljYWxQb3NpdGlvbldoZW5MdHIocG9zaXRpb24pIHtcbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uVE9QX1JJR0hUOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5UT1BfRU5EO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uVE9QX0xFRlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLlRPUF9TVEFSVDtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLkJPVFRPTV9SSUdIVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uQk9UVE9NX0VORDtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLkJPVFRPTV9MRUZUOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5CT1RUT01fU1RBUlQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9Mb2dpY2FsUG9zaXRpb25XaGVuUnRsKHBvc2l0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLlRPUF9SSUdIVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX1NUQVJUO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uVE9QX0xFRlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLlRPUF9FTkQ7XG4gICAgICAgICAgICBjYXNlIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbi5CT1RUT01fUklHSFQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLkJPVFRPTV9TVEFSVDtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLkJPVFRPTV9MRUZUOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5CT1RUT01fRU5EO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvUGh5c2ljYWxQb3NpdGlvbldoZW5MdHIocG9zaXRpb24pIHtcbiAgICAgICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5UT1BfU1RBUlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbi5UT1BfTEVGVDtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX0VORDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLlRPUF9SSUdIVDtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uQk9UVE9NX1NUQVJUOlxuICAgICAgICAgICAgICAgIHJldHVybiBOYkdsb2JhbFBoeXNpY2FsUG9zaXRpb24uQk9UVE9NX0xFRlQ7XG4gICAgICAgICAgICBjYXNlIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLkJPVFRPTV9FTkQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbi5CT1RUT01fUklHSFQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9QaHlzaWNhbFBvc2l0aW9uV2hlblJ0bChwb3NpdGlvbikge1xuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLlRPUF9TVEFSVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLlRPUF9SSUdIVDtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX0VORDpcbiAgICAgICAgICAgICAgICByZXR1cm4gTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLlRPUF9MRUZUO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5CT1RUT01fU1RBUlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbi5CT1RUT01fUklHSFQ7XG4gICAgICAgICAgICBjYXNlIE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLkJPVFRPTV9FTkQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5iR2xvYmFsUGh5c2ljYWxQb3NpdGlvbi5CT1RUT01fTEVGVDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5OYlBvc2l0aW9uSGVscGVyID0gX19kZWNvcmF0ZSQxNihbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEkOChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYkxheW91dERpcmVjdGlvblNlcnZpY2VdKVxuXSwgTmJQb3NpdGlvbkhlbHBlcik7XG5cbnZhciBfX2RlY29yYXRlJDEzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDYgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDYgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG52YXIgTmJBZGp1c3RtZW50O1xuKGZ1bmN0aW9uIChOYkFkanVzdG1lbnQpIHtcbiAgICBOYkFkanVzdG1lbnRbXCJOT09QXCJdID0gXCJub29wXCI7XG4gICAgTmJBZGp1c3RtZW50W1wiQ0xPQ0tXSVNFXCJdID0gXCJjbG9ja3dpc2VcIjtcbiAgICBOYkFkanVzdG1lbnRbXCJDT1VOVEVSQ0xPQ0tXSVNFXCJdID0gXCJjb3VudGVyY2xvY2t3aXNlXCI7XG4gICAgTmJBZGp1c3RtZW50W1wiVkVSVElDQUxcIl0gPSBcInZlcnRpY2FsXCI7XG4gICAgTmJBZGp1c3RtZW50W1wiSE9SSVpPTlRBTFwiXSA9IFwiaG9yaXpvbnRhbFwiO1xufSkoTmJBZGp1c3RtZW50IHx8IChOYkFkanVzdG1lbnQgPSB7fSkpO1xudmFyIE5iUG9zaXRpb247XG4oZnVuY3Rpb24gKE5iUG9zaXRpb24pIHtcbiAgICBOYlBvc2l0aW9uW1wiVE9QXCJdID0gXCJ0b3BcIjtcbiAgICBOYlBvc2l0aW9uW1wiQk9UVE9NXCJdID0gXCJib3R0b21cIjtcbiAgICBOYlBvc2l0aW9uW1wiTEVGVFwiXSA9IFwibGVmdFwiO1xuICAgIE5iUG9zaXRpb25bXCJSSUdIVFwiXSA9IFwicmlnaHRcIjtcbiAgICBOYlBvc2l0aW9uW1wiU1RBUlRcIl0gPSBcInN0YXJ0XCI7XG4gICAgTmJQb3NpdGlvbltcIkVORFwiXSA9IFwiZW5kXCI7XG4gICAgTmJQb3NpdGlvbltcIlRPUF9FTkRcIl0gPSBcInRvcC1lbmRcIjtcbiAgICBOYlBvc2l0aW9uW1wiVE9QX1NUQVJUXCJdID0gXCJ0b3Atc3RhcnRcIjtcbiAgICBOYlBvc2l0aW9uW1wiQk9UVE9NX0VORFwiXSA9IFwiYm90dG9tLWVuZFwiO1xuICAgIE5iUG9zaXRpb25bXCJCT1RUT01fU1RBUlRcIl0gPSBcImJvdHRvbS1zdGFydFwiO1xuICAgIE5iUG9zaXRpb25bXCJFTkRfVE9QXCJdID0gXCJlbmQtdG9wXCI7XG4gICAgTmJQb3NpdGlvbltcIkVORF9CT1RUT01cIl0gPSBcImVuZC1ib3R0b21cIjtcbiAgICBOYlBvc2l0aW9uW1wiU1RBUlRfVE9QXCJdID0gXCJzdGFydC10b3BcIjtcbiAgICBOYlBvc2l0aW9uW1wiU1RBUlRfQk9UVE9NXCJdID0gXCJzdGFydC1ib3R0b21cIjtcbn0pKE5iUG9zaXRpb24gfHwgKE5iUG9zaXRpb24gPSB7fSkpO1xuY29uc3QgUE9TSVRJT05TID0ge1xuICAgIFtOYlBvc2l0aW9uLlJJR0hUXShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICdjZW50ZXInLCBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICdjZW50ZXInLCBvZmZzZXRYOiBvZmZzZXQgfTtcbiAgICB9LFxuICAgIFtOYlBvc2l0aW9uLkJPVFRPTV0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdjZW50ZXInLCBvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVg6ICdjZW50ZXInLCBvdmVybGF5WTogJ3RvcCcsIG9mZnNldFk6IG9mZnNldCB9O1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uTEVGVF0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdjZW50ZXInLCBvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnY2VudGVyJywgb2Zmc2V0WDogLW9mZnNldCB9O1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uVE9QXShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2NlbnRlcicsIG9yaWdpblk6ICd0b3AnLCBvdmVybGF5WDogJ2NlbnRlcicsIG92ZXJsYXlZOiAnYm90dG9tJywgb2Zmc2V0WTogLW9mZnNldCB9O1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uU1RBUlRdKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpc1tOYlBvc2l0aW9uLkxFRlRdKG9mZnNldCk7XG4gICAgfSxcbiAgICBbTmJQb3NpdGlvbi5FTkRdKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpc1tOYlBvc2l0aW9uLlJJR0hUXShvZmZzZXQpO1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uRU5EX1RPUF0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnYm90dG9tJywgb2Zmc2V0WDogb2Zmc2V0IH07XG4gICAgfSxcbiAgICBbTmJQb3NpdGlvbi5FTkRfQk9UVE9NXShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ2VuZCcsIG9yaWdpblk6ICd0b3AnLCBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnLCBvZmZzZXRYOiBvZmZzZXQgfTtcbiAgICB9LFxuICAgIFtOYlBvc2l0aW9uLkJPVFRPTV9TVEFSVF0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdlbmQnLCBvcmlnaW5ZOiAnYm90dG9tJywgb3ZlcmxheVg6ICdlbmQnLCBvdmVybGF5WTogJ3RvcCcsIG9mZnNldFk6IG9mZnNldCB9O1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uQk9UVE9NX0VORF0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nLCBvdmVybGF5WDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnLCBvZmZzZXRZOiBvZmZzZXQgfTtcbiAgICB9LFxuICAgIFtOYlBvc2l0aW9uLlNUQVJUX1RPUF0ob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nLCBvdmVybGF5WDogJ2VuZCcsIG92ZXJsYXlZOiAnYm90dG9tJywgb2Zmc2V0WDogLW9mZnNldCB9O1xuICAgIH0sXG4gICAgW05iUG9zaXRpb24uU1RBUlRfQk9UVE9NXShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICd0b3AnLCBvZmZzZXRYOiAtb2Zmc2V0IH07XG4gICAgfSxcbiAgICBbTmJQb3NpdGlvbi5UT1BfU1RBUlRdKG9mZnNldCkge1xuICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnZW5kJywgb3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICdib3R0b20nLCBvZmZzZXRZOiAtb2Zmc2V0IH07XG4gICAgfSxcbiAgICBbTmJQb3NpdGlvbi5UT1BfRU5EXShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ3RvcCcsIG92ZXJsYXlYOiAnc3RhcnQnLCBvdmVybGF5WTogJ2JvdHRvbScsIG9mZnNldFk6IC1vZmZzZXQgfTtcbiAgICB9LFxufTtcbmNvbnN0IENPVU5URVJfQ0xPQ0tXSVNFX1BPU0lUSU9OUyA9IFtcbiAgICBOYlBvc2l0aW9uLlRPUCxcbiAgICBOYlBvc2l0aW9uLlRPUF9FTkQsXG4gICAgTmJQb3NpdGlvbi5UT1BfU1RBUlQsXG4gICAgTmJQb3NpdGlvbi5TVEFSVCxcbiAgICBOYlBvc2l0aW9uLlNUQVJUX1RPUCxcbiAgICBOYlBvc2l0aW9uLlNUQVJUX0JPVFRPTSxcbiAgICBOYlBvc2l0aW9uLkJPVFRPTSxcbiAgICBOYlBvc2l0aW9uLkJPVFRPTV9TVEFSVCxcbiAgICBOYlBvc2l0aW9uLkJPVFRPTV9FTkQsXG4gICAgTmJQb3NpdGlvbi5FTkQsXG4gICAgTmJQb3NpdGlvbi5FTkRfQk9UVE9NLFxuICAgIE5iUG9zaXRpb24uRU5EX1RPUCxcbl07XG5jb25zdCBDTE9DS1dJU0VfUE9TSVRJT05TID0gW1xuICAgIE5iUG9zaXRpb24uVE9QLFxuICAgIE5iUG9zaXRpb24uVE9QX1NUQVJULFxuICAgIE5iUG9zaXRpb24uVE9QX0VORCxcbiAgICBOYlBvc2l0aW9uLkVORCxcbiAgICBOYlBvc2l0aW9uLkVORF9UT1AsXG4gICAgTmJQb3NpdGlvbi5FTkRfQk9UVE9NLFxuICAgIE5iUG9zaXRpb24uQk9UVE9NLFxuICAgIE5iUG9zaXRpb24uQk9UVE9NX0VORCxcbiAgICBOYlBvc2l0aW9uLkJPVFRPTV9TVEFSVCxcbiAgICBOYlBvc2l0aW9uLlNUQVJULFxuICAgIE5iUG9zaXRpb24uU1RBUlRfQk9UVE9NLFxuICAgIE5iUG9zaXRpb24uU1RBUlRfVE9QLFxuXTtcbmNvbnN0IFZFUlRJQ0FMX1BPU0lUSU9OUyA9IFtOYlBvc2l0aW9uLkJPVFRPTSwgTmJQb3NpdGlvbi5UT1BdO1xuY29uc3QgSE9SSVpPTlRBTF9QT1NJVElPTlMgPSBbTmJQb3NpdGlvbi5TVEFSVCwgTmJQb3NpdGlvbi5FTkRdO1xuZnVuY3Rpb24gY29tcGFyZVBvc2l0aW9ucyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEub3JpZ2luWCA9PT0gcDIub3JpZ2luWFxuICAgICAgICAmJiBwMS5vcmlnaW5ZID09PSBwMi5vcmlnaW5ZXG4gICAgICAgICYmIHAxLm92ZXJsYXlYID09PSBwMi5vdmVybGF5WFxuICAgICAgICAmJiBwMS5vdmVybGF5WSA9PT0gcDIub3ZlcmxheVk7XG59XG4vKipcbiAqIFRoZSBtYWluIGlkZWEgb2YgdGhlIGFkanVzdGFibGUgY29ubmVjdGVkIHN0cmF0ZWd5IGlzIHRvIHByb3ZpZGUgcHJlZGVmaW5lZCBzZXQgb2YgcG9zaXRpb25zIGZvciB5b3VyIG92ZXJsYXkuXG4gKiBZb3UgaGF2ZSB0byBwcm92aWRlIGFkanVzdG1lbnQgYW5kIGFwcHJvcHJpYXRlIHN0cmF0ZWd5IHdpbGwgYmUgY2hvc2VuIGluIHJ1bnRpbWUuXG4gKiAqL1xuY2xhc3MgTmJBZGp1c3RhYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSBleHRlbmRzIE5iRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMTU7XG4gICAgICAgIHRoaXMucG9zaXRpb25DaGFuZ2UgPSB0aGlzLnBvc2l0aW9uQ2hhbmdlcy5waXBlKG1hcCgocG9zaXRpb25DaGFuZ2UpID0+IHBvc2l0aW9uQ2hhbmdlLmNvbm5lY3Rpb25QYWlyKSwgbWFwKChjb25uZWN0aW9uUGFpcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGllZFBvc2l0aW9ucy5maW5kKCh7IGNvbm5lY3RlZFBvc2l0aW9uIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZVBvc2l0aW9ucyhjb25uZWN0ZWRQb3NpdGlvbiwgY29ubmVjdGlvblBhaXIpO1xuICAgICAgICAgICAgfSkua2V5O1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGF0dGFjaChvdmVybGF5UmVmKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBoYXZlIHRvIGFwcGx5IHBvc2l0aW9ucyBiZWZvcmUgYXR0YWNoIGJlY2F1c2Ugc3VwZXIuYXR0YWNoKCkgdmFsaWRhdGVzIHBvc2l0aW9ucyBhbmQgY3Jhc2hlcyBhcHBcbiAgICAgICAgICogaWYgbm8gcG9zaXRpb25zIHByb3ZpZGVkLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmFwcGx5UG9zaXRpb25zKCk7XG4gICAgICAgIHN1cGVyLmF0dGFjaChvdmVybGF5UmVmKTtcbiAgICB9XG4gICAgYXBwbHkoKSB7XG4gICAgICAgIHRoaXMuYXBwbHlQb3NpdGlvbnMoKTtcbiAgICAgICAgc3VwZXIuYXBwbHkoKTtcbiAgICB9XG4gICAgcG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkanVzdG1lbnQoYWRqdXN0bWVudCkge1xuICAgICAgICB0aGlzLl9hZGp1c3RtZW50ID0gYWRqdXN0bWVudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXBwbHlQb3NpdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMuY3JlYXRlUG9zaXRpb25zKCk7XG4gICAgICAgIHRoaXMucGVyc2lzdENob3NlblBvc2l0aW9ucyhwb3NpdGlvbnMpO1xuICAgICAgICB0aGlzLndpdGhQb3NpdGlvbnModGhpcy5hcHBsaWVkUG9zaXRpb25zLm1hcCgoeyBjb25uZWN0ZWRQb3NpdGlvbiB9KSA9PiBjb25uZWN0ZWRQb3NpdGlvbikpO1xuICAgIH1cbiAgICBjcmVhdGVQb3NpdGlvbnMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fYWRqdXN0bWVudCkge1xuICAgICAgICAgICAgY2FzZSBOYkFkanVzdG1lbnQuTk9PUDpcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMuX3Bvc2l0aW9uXTtcbiAgICAgICAgICAgIGNhc2UgTmJBZGp1c3RtZW50LkNMT0NLV0lTRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW9yZGVyUHJlZmVycmVkUG9zaXRpb25zKENMT0NLV0lTRV9QT1NJVElPTlMpO1xuICAgICAgICAgICAgY2FzZSBOYkFkanVzdG1lbnQuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW9yZGVyUHJlZmVycmVkUG9zaXRpb25zKENPVU5URVJfQ0xPQ0tXSVNFX1BPU0lUSU9OUyk7XG4gICAgICAgICAgICBjYXNlIE5iQWRqdXN0bWVudC5IT1JJWk9OVEFMOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlb3JkZXJQcmVmZXJyZWRQb3NpdGlvbnMoSE9SSVpPTlRBTF9QT1NJVElPTlMpO1xuICAgICAgICAgICAgY2FzZSBOYkFkanVzdG1lbnQuVkVSVElDQUw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVvcmRlclByZWZlcnJlZFBvc2l0aW9ucyhWRVJUSUNBTF9QT1NJVElPTlMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBlcnNpc3RDaG9zZW5Qb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgICAgIHRoaXMuYXBwbGllZFBvc2l0aW9ucyA9IHBvc2l0aW9ucy5tYXAocG9zaXRpb24gPT4gKHtcbiAgICAgICAgICAgIGtleTogcG9zaXRpb24sXG4gICAgICAgICAgICBjb25uZWN0ZWRQb3NpdGlvbjogUE9TSVRJT05TW3Bvc2l0aW9uXSh0aGlzLl9vZmZzZXQpLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJlb3JkZXJQcmVmZXJyZWRQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgICAgIC8vIFBoeXNpY2FsIHBvc2l0aW9ucyBzaG91bGQgYmUgbWFwcGVkIHRvIGxvZ2ljYWwgYXMgYWRqdXN0bWVudHMgdXNlIGxvZ2ljYWwgcG9zaXRpb25zLlxuICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uSW5kZXggPSBwb3NpdGlvbnMuaW5kZXhPZih0aGlzLm1hcFRvTG9naWNhbFBvc2l0aW9uKHRoaXMuX3Bvc2l0aW9uKSk7XG4gICAgICAgIGNvbnN0IGZpcnN0UGFydCA9IHBvc2l0aW9ucy5zbGljZShzdGFydFBvc2l0aW9uSW5kZXgpO1xuICAgICAgICBjb25zdCBzZWNvbmRQYXJ0ID0gcG9zaXRpb25zLnNsaWNlKDAsIHN0YXJ0UG9zaXRpb25JbmRleCk7XG4gICAgICAgIHJldHVybiBmaXJzdFBhcnQuY29uY2F0KHNlY29uZFBhcnQpO1xuICAgIH1cbiAgICBtYXBUb0xvZ2ljYWxQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPT09IE5iUG9zaXRpb24uTEVGVCkge1xuICAgICAgICAgICAgcmV0dXJuIE5iUG9zaXRpb24uU1RBUlQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSBOYlBvc2l0aW9uLlJJR0hUKSB7XG4gICAgICAgICAgICByZXR1cm4gTmJQb3NpdGlvbi5FTkQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uO1xuICAgIH1cbn1cbmNsYXNzIE5iR2xvYmFsUG9zaXRpb25TdHJhdGVneSBleHRlbmRzIEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIHBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX1NUQVJUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcCgpLmxlZnQoKTtcbiAgICAgICAgICAgIGNhc2UgTmJHbG9iYWxMb2dpY2FsUG9zaXRpb24uVE9QX0VORDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b3AoKS5yaWdodCgpO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5CT1RUT01fU1RBUlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tKCkubGVmdCgpO1xuICAgICAgICAgICAgY2FzZSBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbi5CT1RUT01fRU5EOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSgpLnJpZ2h0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgTmJQb3NpdGlvbkJ1aWxkZXJTZXJ2aWNlID0gY2xhc3MgTmJQb3NpdGlvbkJ1aWxkZXJTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgdmlld3BvcnRSdWxlciwgcGxhdGZvcm0sIHBvc2l0aW9uQnVpbGRlciwgb3ZlcmxheUNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMudmlld3BvcnRSdWxlciA9IHZpZXdwb3J0UnVsZXI7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkJ1aWxkZXIgPSBwb3NpdGlvbkJ1aWxkZXI7XG4gICAgICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lciA9IG92ZXJsYXlDb250YWluZXI7XG4gICAgfVxuICAgIGdsb2JhbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOYkdsb2JhbFBvc2l0aW9uU3RyYXRlZ3koKTtcbiAgICB9XG4gICAgY29ubmVjdGVkVG8oZWxlbWVudFJlZikge1xuICAgICAgICByZXR1cm4gbmV3IE5iQWRqdXN0YWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3koZWxlbWVudFJlZiwgdGhpcy52aWV3cG9ydFJ1bGVyLCB0aGlzLmRvY3VtZW50LCB0aGlzLnBsYXRmb3JtLCB0aGlzLm92ZXJsYXlDb250YWluZXIpXG4gICAgICAgICAgICAud2l0aEZsZXhpYmxlRGltZW5zaW9ucyhmYWxzZSlcbiAgICAgICAgICAgIC53aXRoUHVzaChmYWxzZSk7XG4gICAgfVxufTtcbk5iUG9zaXRpb25CdWlsZGVyU2VydmljZSA9IF9fZGVjb3JhdGUkMTMoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtJDYoMCwgSW5qZWN0KE5CX0RPQ1VNRU5UKSksXG4gICAgX19tZXRhZGF0YSQ2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdCwgTmJWaWV3cG9ydFJ1bGVyQWRhcHRlcixcbiAgICAgICAgTmJQbGF0Zm9ybSxcbiAgICAgICAgTmJPdmVybGF5UG9zaXRpb25CdWlsZGVyLFxuICAgICAgICBOYk92ZXJsYXlDb250YWluZXJBZGFwdGVyXSlcbl0sIE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSk7XG5cbnZhciBfX2RlY29yYXRlJDE3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYlBvc2l0aW9uZWRDb250YWluZXIgPSBcbi8vIEBicmVha2luZy1jaGFuZ2UgQDUuMC4wIFJlbmFtZSB0byBOYlBvc2l0aW9uZWRDb250YWluZXJDb21wb25lbnQgYW5kIGVuYWJsZSB0cyBsaW50XG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbmNsYXNzIE5iUG9zaXRpb25lZENvbnRhaW5lciB7XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uVE9QO1xuICAgIH1cbiAgICBnZXQgdG9wU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID09PSBOYlBvc2l0aW9uLlRPUF9TVEFSVDtcbiAgICB9XG4gICAgZ2V0IHRvcEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uVE9QX0VORDtcbiAgICB9XG4gICAgZ2V0IHJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA9PT0gTmJQb3NpdGlvbi5SSUdIVCB8fCB0aGlzLnBvc2l0aW9uID09PSBOYlBvc2l0aW9uLkVORDtcbiAgICB9XG4gICAgZ2V0IGVuZFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uRU5EX1RPUDtcbiAgICB9XG4gICAgZ2V0IGVuZEJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uRU5EX0JPVFRPTTtcbiAgICB9XG4gICAgZ2V0IGJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uQk9UVE9NO1xuICAgIH1cbiAgICBnZXQgYm90dG9tU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID09PSBOYlBvc2l0aW9uLkJPVFRPTV9TVEFSVDtcbiAgICB9XG4gICAgZ2V0IGJvdHRvbUVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uQk9UVE9NX0VORDtcbiAgICB9XG4gICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uID09PSBOYlBvc2l0aW9uLkxFRlQgfHwgdGhpcy5wb3NpdGlvbiA9PT0gTmJQb3NpdGlvbi5TVEFSVDtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0VG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiA9PT0gTmJQb3NpdGlvbi5TVEFSVF9UT1A7XG4gICAgfVxuICAgIGdldCBzdGFydEJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24gPT09IE5iUG9zaXRpb24uU1RBUlRfQk9UVE9NO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDE3KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iUG9zaXRpb25lZENvbnRhaW5lci5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5uYi1vdmVybGF5LXRvcCcpLFxuICAgIF9fbWV0YWRhdGEkOShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJQb3NpdGlvbmVkQ29udGFpbmVyLnByb3RvdHlwZSwgXCJ0b3BcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubmItb3ZlcmxheS10b3Atc3RhcnQnKSxcbiAgICBfX21ldGFkYXRhJDkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iUG9zaXRpb25lZENvbnRhaW5lci5wcm90b3R5cGUsIFwidG9wU3RhcnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubmItb3ZlcmxheS10b3AtZW5kJyksXG4gICAgX19tZXRhZGF0YSQ5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlBvc2l0aW9uZWRDb250YWluZXIucHJvdG90eXBlLCBcInRvcEVuZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5uYi1vdmVybGF5LXJpZ2h0JyksXG4gICAgX19tZXRhZGF0YSQ5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlBvc2l0aW9uZWRDb250YWluZXIucHJvdG90eXBlLCBcInJpZ2h0XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxNyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLm5iLW92ZXJsYXktZW5kLXRvcCcpLFxuICAgIF9fbWV0YWRhdGEkOShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJQb3NpdGlvbmVkQ29udGFpbmVyLnByb3RvdHlwZSwgXCJlbmRUb3BcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubmItb3ZlcmxheS1lbmQtYm90dG9tJyksXG4gICAgX19tZXRhZGF0YSQ5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlBvc2l0aW9uZWRDb250YWluZXIucHJvdG90eXBlLCBcImVuZEJvdHRvbVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5uYi1vdmVybGF5LWJvdHRvbScpLFxuICAgIF9fbWV0YWRhdGEkOShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJQb3NpdGlvbmVkQ29udGFpbmVyLnByb3RvdHlwZSwgXCJib3R0b21cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubmItb3ZlcmxheS1ib3R0b20tc3RhcnQnKSxcbiAgICBfX21ldGFkYXRhJDkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iUG9zaXRpb25lZENvbnRhaW5lci5wcm90b3R5cGUsIFwiYm90dG9tU3RhcnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubmItb3ZlcmxheS1ib3R0b20tZW5kJyksXG4gICAgX19tZXRhZGF0YSQ5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlBvc2l0aW9uZWRDb250YWluZXIucHJvdG90eXBlLCBcImJvdHRvbUVuZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5uYi1vdmVybGF5LWxlZnQnKSxcbiAgICBfX21ldGFkYXRhJDkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iUG9zaXRpb25lZENvbnRhaW5lci5wcm90b3R5cGUsIFwibGVmdFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5uYi1vdmVybGF5LXN0YXJ0LXRvcCcpLFxuICAgIF9fbWV0YWRhdGEkOShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJQb3NpdGlvbmVkQ29udGFpbmVyLnByb3RvdHlwZSwgXCJzdGFydFRvcFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5uYi1vdmVybGF5LXN0YXJ0LWJvdHRvbScpLFxuICAgIF9fbWV0YWRhdGEkOShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJQb3NpdGlvbmVkQ29udGFpbmVyLnByb3RvdHlwZSwgXCJzdGFydEJvdHRvbVwiLCBudWxsKTtcbk5iUG9zaXRpb25lZENvbnRhaW5lciA9IF9fZGVjb3JhdGUkMTcoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pXG4gICAgLy8gQGJyZWFraW5nLWNoYW5nZSBANS4wLjAgUmVuYW1lIHRvIE5iUG9zaXRpb25lZENvbnRhaW5lckNvbXBvbmVudCBhbmQgZW5hYmxlIHRzIGxpbnRcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbl0sIE5iUG9zaXRpb25lZENvbnRhaW5lcik7XG5sZXQgTmJPdmVybGF5Q29udGFpbmVyQ29tcG9uZW50ID0gY2xhc3MgTmJPdmVybGF5Q29udGFpbmVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih2Y3IsIGluamVjdG9yLCBjaGFuZ2VEZXRlY3RvclJlZikge1xuICAgICAgICB0aGlzLnZjciA9IHZjcjtcbiAgICAgICAgdGhpcy5pbmplY3RvciA9IGluamVjdG9yO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmID0gY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgaXNTdHJpbmdDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmNvbnRlbnQ7XG4gICAgfVxuICAgIGF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwsIGNvbnRleHQpIHtcbiAgICAgICAgcG9ydGFsLmluamVjdG9yID0gdGhpcy5jcmVhdGVDaGlsZEluamVjdG9yKHBvcnRhbC5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpO1xuICAgICAgICBjb25zdCBjb21wb25lbnRSZWYgPSB0aGlzLnBvcnRhbE91dGxldC5hdHRhY2hDb21wb25lbnRQb3J0YWwocG9ydGFsKTtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29tcG9uZW50UmVmLmluc3RhbmNlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb21wb25lbnRSZWYuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIGNvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRSZWY7XG4gICAgfVxuICAgIGF0dGFjaFRlbXBsYXRlUG9ydGFsKHBvcnRhbCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZVJlZiA9IHRoaXMucG9ydGFsT3V0bGV0LmF0dGFjaFRlbXBsYXRlUG9ydGFsKHBvcnRhbCk7XG4gICAgICAgIHRlbXBsYXRlUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlUmVmO1xuICAgIH1cbiAgICBhdHRhY2hTdHJpbmdDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICAgIGRldGFjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9ydGFsT3V0bGV0Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMucG9ydGFsT3V0bGV0LmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXR0YWNoU3RyaW5nQ29udGVudChudWxsKTtcbiAgICAgICAgdGhpcy5pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGNyZWF0ZUNoaWxkSW5qZWN0b3IoY2ZyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmJQb3J0YWxJbmplY3Rvcih0aGlzLmluamVjdG9yLCBuZXcgV2Vha01hcChbXG4gICAgICAgICAgICBbQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBjZnJdLFxuICAgICAgICBdKSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTcoW1xuICAgIFZpZXdDaGlsZChOYlBvcnRhbE91dGxldERpcmVjdGl2ZSwgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YSQ5KFwiZGVzaWduOnR5cGVcIiwgTmJQb3J0YWxPdXRsZXREaXJlY3RpdmUpXG5dLCBOYk92ZXJsYXlDb250YWluZXJDb21wb25lbnQucHJvdG90eXBlLCBcInBvcnRhbE91dGxldFwiLCB2b2lkIDApO1xuTmJPdmVybGF5Q29udGFpbmVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxNyhbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1vdmVybGF5LWNvbnRhaW5lcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiAqbmdJZj1cImlzU3RyaW5nQ29udGVudFwiIGNsYXNzPVwicHJpbWl0aXZlLW92ZXJsYXlcIj57eyBjb250ZW50IH19PC9kaXY+XG4gICAgPG5nLXRlbXBsYXRlIG5iUG9ydGFsT3V0bGV0PjwvbmctdGVtcGxhdGU+XG4gIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgSW5qZWN0b3IsIENoYW5nZURldGVjdG9yUmVmXSlcbl0sIE5iT3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudCk7XG5cbnZhciBfX2RlY29yYXRlJDE4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5mdW5jdGlvbiBwYXRjaChjb250YWluZXIsIGNvbnRhaW5lckNvbnRleHQpIHtcbiAgICBPYmplY3QuYXNzaWduKGNvbnRhaW5lci5pbnN0YW5jZSwgY29udGFpbmVyQ29udGV4dCk7XG4gICAgY29udGFpbmVyLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKHJlZiwgY29udGFpbmVyLCBjb250ZXh0LCBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpIHtcbiAgICBjb25zdCBjb250YWluZXJSZWYgPSByZWYuYXR0YWNoKG5ldyBOYkNvbXBvbmVudFBvcnRhbChjb250YWluZXIsIG51bGwsIG51bGwsIGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcikpO1xuICAgIHBhdGNoKGNvbnRhaW5lclJlZiwgY29udGV4dCk7XG4gICAgcmV0dXJuIGNvbnRhaW5lclJlZjtcbn1cbmxldCBOYk92ZXJsYXlTZXJ2aWNlID0gY2xhc3MgTmJPdmVybGF5U2VydmljZSB7XG4gICAgY29uc3RydWN0b3Iob3ZlcmxheSwgbGF5b3V0RGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMubGF5b3V0RGlyZWN0aW9uID0gbGF5b3V0RGlyZWN0aW9uO1xuICAgIH1cbiAgICBnZXQgc2Nyb2xsU3RyYXRlZ2llcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzO1xuICAgIH1cbiAgICBjcmVhdGUoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB0aGlzLm92ZXJsYXkuY3JlYXRlKGNvbmZpZyk7XG4gICAgICAgIHRoaXMubGF5b3V0RGlyZWN0aW9uLm9uRGlyZWN0aW9uQ2hhbmdlKClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZGlyID0+IG92ZXJsYXlSZWYuc2V0RGlyZWN0aW9uKGRpcikpO1xuICAgICAgICByZXR1cm4gb3ZlcmxheVJlZjtcbiAgICB9XG59O1xuTmJPdmVybGF5U2VydmljZSA9IF9fZGVjb3JhdGUkMTgoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhJDEwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iT3ZlcmxheSwgTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlXSlcbl0sIE5iT3ZlcmxheVNlcnZpY2UpO1xuXG52YXIgX19kZWNvcmF0ZSQyMCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxMSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xubGV0IE5iU2Nyb2xsRGlzcGF0Y2hlckFkYXB0ZXIgPSBjbGFzcyBOYlNjcm9sbERpc3BhdGNoZXJBZGFwdGVyIGV4dGVuZHMgU2Nyb2xsRGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3Iobmdab25lLCBwbGF0Zm9ybSwgc2Nyb2xsU2VydmljZSkge1xuICAgICAgICBzdXBlcihuZ1pvbmUsIHBsYXRmb3JtKTtcbiAgICAgICAgdGhpcy5zY3JvbGxTZXJ2aWNlID0gc2Nyb2xsU2VydmljZTtcbiAgICB9XG4gICAgc2Nyb2xsZWQoYXVkaXRUaW1lSW5Ncykge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxTZXJ2aWNlLm9uU2Nyb2xsKCk7XG4gICAgfVxufTtcbk5iU2Nyb2xsRGlzcGF0Y2hlckFkYXB0ZXIgPSBfX2RlY29yYXRlJDIwKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YSQxMShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOZ1pvbmUsIE5iUGxhdGZvcm0sIE5iTGF5b3V0U2Nyb2xsU2VydmljZV0pXG5dLCBOYlNjcm9sbERpc3BhdGNoZXJBZGFwdGVyKTtcblxudmFyIF9fZGVjb3JhdGUkMjEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDcgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIE92ZXJyaWRlcyBkZWZhdWx0IGJsb2NrIHNjcm9sbCBzdHJhdGVneSBiZWNhdXNlIGRlZmF1bHQgc3RyYXRlZ3kgYmxvY2tzIHNjcm9sbGluZyBvbiB0aGUgYm9keSBvbmx5LlxuICogQnV0IE5lYnVsYXIgaGFzIGl0cyBvd24gc2Nyb2xsYWJsZSBjb250YWluZXIgLSBuYi1sYXlvdXQuIFNvLCB3ZSBuZWVkIHRvIGJsb2NrIHNjcm9sbGluZyBpbiBpdCB0by5cbiAqICovXG5sZXQgTmJCbG9ja1Njcm9sbFN0cmF0ZWd5QWRhcHRlciA9IGNsYXNzIE5iQmxvY2tTY3JvbGxTdHJhdGVneUFkYXB0ZXIgZXh0ZW5kcyBCbG9ja1Njcm9sbFN0cmF0ZWd5IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgdmlld3BvcnRSdWxlciwgc2Nyb2xsU2VydmljZSkge1xuICAgICAgICBzdXBlcih2aWV3cG9ydFJ1bGVyLCBkb2N1bWVudCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZSA9IHNjcm9sbFNlcnZpY2U7XG4gICAgfVxuICAgIGVuYWJsZSgpIHtcbiAgICAgICAgc3VwZXIuZW5hYmxlKCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZS5zY3JvbGxhYmxlKGZhbHNlKTtcbiAgICB9XG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgc3VwZXIuZGlzYWJsZSgpO1xuICAgICAgICB0aGlzLnNjcm9sbFNlcnZpY2Uuc2Nyb2xsYWJsZSh0cnVlKTtcbiAgICB9XG59O1xuTmJCbG9ja1Njcm9sbFN0cmF0ZWd5QWRhcHRlciA9IF9fZGVjb3JhdGUkMjEoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtJDcoMCwgSW5qZWN0KE5CX0RPQ1VNRU5UKSksXG4gICAgX19tZXRhZGF0YSQxMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIE5iVmlld3BvcnRSdWxlckFkYXB0ZXIsXG4gICAgICAgIE5iTGF5b3V0U2Nyb2xsU2VydmljZV0pXG5dLCBOYkJsb2NrU2Nyb2xsU3RyYXRlZ3lBZGFwdGVyKTtcbmxldCBOYlNjcm9sbFN0cmF0ZWd5T3B0aW9ucyA9IGNsYXNzIE5iU2Nyb2xsU3RyYXRlZ3lPcHRpb25zIGV4dGVuZHMgU2Nyb2xsU3RyYXRlZ3lPcHRpb25zIHtcbiAgICBjb25zdHJ1Y3RvcihzY3JvbGxTZXJ2aWNlLCBzY3JvbGxEaXNwYXRjaGVyLCB2aWV3cG9ydFJ1bGVyLCBuZ1pvbmUsIGRvY3VtZW50KSB7XG4gICAgICAgIHN1cGVyKHNjcm9sbERpc3BhdGNoZXIsIHZpZXdwb3J0UnVsZXIsIG5nWm9uZSwgZG9jdW1lbnQpO1xuICAgICAgICB0aGlzLnNjcm9sbFNlcnZpY2UgPSBzY3JvbGxTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNjcm9sbERpc3BhdGNoZXIgPSBzY3JvbGxEaXNwYXRjaGVyO1xuICAgICAgICB0aGlzLnZpZXdwb3J0UnVsZXIgPSB2aWV3cG9ydFJ1bGVyO1xuICAgICAgICB0aGlzLm5nWm9uZSA9IG5nWm9uZTtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLmJsb2NrID0gKCkgPT4gbmV3IE5iQmxvY2tTY3JvbGxTdHJhdGVneUFkYXB0ZXIodGhpcy5kb2N1bWVudCwgdGhpcy52aWV3cG9ydFJ1bGVyLCB0aGlzLnNjcm9sbFNlcnZpY2UpO1xuICAgIH1cbn07XG5OYlNjcm9sbFN0cmF0ZWd5T3B0aW9ucyA9IF9fZGVjb3JhdGUkMjEoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtJDcoNCwgSW5qZWN0KE5CX0RPQ1VNRU5UKSksXG4gICAgX19tZXRhZGF0YSQxMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYkxheW91dFNjcm9sbFNlcnZpY2UsXG4gICAgICAgIFNjcm9sbERpc3BhdGNoZXIsXG4gICAgICAgIE5iVmlld3BvcnRSdWxlckFkYXB0ZXIsXG4gICAgICAgIE5nWm9uZSwgT2JqZWN0XSlcbl0sIE5iU2Nyb2xsU3RyYXRlZ3lPcHRpb25zKTtcblxudmFyIF9fZGVjb3JhdGUkMTkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIE5iQ2RrQWRhcHRlck1vZHVsZV8xO1xubGV0IE5iQ2RrQWRhcHRlck1vZHVsZSA9IE5iQ2RrQWRhcHRlck1vZHVsZV8xID0gY2xhc3MgTmJDZGtBZGFwdGVyTW9kdWxlIHtcbiAgICBzdGF0aWMgZm9yUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBOYkNka0FkYXB0ZXJNb2R1bGVfMSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE5iVmlld3BvcnRSdWxlckFkYXB0ZXIsXG4gICAgICAgICAgICAgICAgTmJPdmVybGF5Q29udGFpbmVyQWRhcHRlcixcbiAgICAgICAgICAgICAgICBOYkJsb2NrU2Nyb2xsU3RyYXRlZ3lBZGFwdGVyLFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogT3ZlcmxheUNvbnRhaW5lciwgdXNlRXhpc3Rpbmc6IE5iT3ZlcmxheUNvbnRhaW5lckFkYXB0ZXIgfSxcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5iT3ZlcmxheUNvbnRhaW5lciwgdXNlRXhpc3Rpbmc6IE5iT3ZlcmxheUNvbnRhaW5lckFkYXB0ZXIgfSxcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFNjcm9sbERpc3BhdGNoZXIsIHVzZUNsYXNzOiBOYlNjcm9sbERpc3BhdGNoZXJBZGFwdGVyIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBTY3JvbGxTdHJhdGVneU9wdGlvbnMsIHVzZUNsYXNzOiBOYlNjcm9sbFN0cmF0ZWd5T3B0aW9ucyB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuTmJDZGtBZGFwdGVyTW9kdWxlID0gTmJDZGtBZGFwdGVyTW9kdWxlXzEgPSBfX2RlY29yYXRlJDE5KFtcbiAgICBOZ01vZHVsZSh7fSlcbl0sIE5iQ2RrQWRhcHRlck1vZHVsZSk7XG5cbnZhciBfX2RlY29yYXRlJDIyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQ4ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xudmFyIE5iVHJpZ2dlcjtcbihmdW5jdGlvbiAoTmJUcmlnZ2VyKSB7XG4gICAgTmJUcmlnZ2VyW1wiTk9PUFwiXSA9IFwibm9vcFwiO1xuICAgIE5iVHJpZ2dlcltcIkNMSUNLXCJdID0gXCJjbGlja1wiO1xuICAgIE5iVHJpZ2dlcltcIkhPVkVSXCJdID0gXCJob3ZlclwiO1xuICAgIE5iVHJpZ2dlcltcIkhJTlRcIl0gPSBcImhpbnRcIjtcbiAgICBOYlRyaWdnZXJbXCJGT0NVU1wiXSA9IFwiZm9jdXNcIjtcbn0pKE5iVHJpZ2dlciB8fCAoTmJUcmlnZ2VyID0ge30pKTtcbi8qKlxuICogVE9ETyBtYXliZSB3ZSBoYXZlIHRvIHVzZSByZW5kZXJlci5saXN0ZW4gaW5zdGVhZCBvZiBvYnNlcnZhYmxlRnJvbUV2ZW50P1xuICogUmVuZGVyZXIgcHJvdmlkZXMgY2FwYWJpbGl0eSB1c2UgaXQgaW4gc2VydmljZSB3b3JrZXIsIHNzciBhbmQgc28gb24uXG4gKiAqL1xuY2xhc3MgTmJUcmlnZ2VyU3RyYXRlZ3lCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgaG9zdCwgY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkJC5uZXh0KCk7XG4gICAgfVxuICAgIGlzTm90T25Ib3N0T3JDb250YWluZXIoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzT25Ib3N0KGV2ZW50KSAmJiAhdGhpcy5pc09uQ29udGFpbmVyKGV2ZW50KTtcbiAgICB9XG4gICAgaXNPbkhvc3RPckNvbnRhaW5lcihldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc09uSG9zdChldmVudCkgfHwgdGhpcy5pc09uQ29udGFpbmVyKGV2ZW50KTtcbiAgICB9XG4gICAgaXNPbkhvc3QoeyB0YXJnZXQgfSkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgfVxuICAgIGlzT25Db250YWluZXIoeyB0YXJnZXQgfSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXIoKSAmJiB0aGlzLmNvbnRhaW5lcigpLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQuY29udGFpbnModGFyZ2V0KTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgc2hvdyBhbmQgaGlkZSBldmVudCBzdHJlYW1zLlxuICogRmlyZXMgdG9nZ2xlIGV2ZW50IHdoZW4gdGhlIGNsaWNrIHdhcyBwZXJmb3JtZWQgb24gdGhlIGhvc3QgZWxlbWVudC5cbiAqIEZpcmVzIGNsb3NlIGV2ZW50IHdoZW4gdGhlIGNsaWNrIHdhcyBwZXJmb3JtZWQgb24gdGhlIGRvY3VtZW50IGJ1dFxuICogbm90IG9uIHRoZSBob3N0IG9yIGNvbnRhaW5lci5cbiAqICovXG5jbGFzcyBOYkNsaWNrVHJpZ2dlclN0cmF0ZWd5IGV4dGVuZHMgTmJUcmlnZ2VyU3RyYXRlZ3lCYXNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gc2luY2Ugd2Ugc2hvdWxkIHRyYWNrIGNsaWNrIGZvciBib3RoIFNIT1cgYW5kIEhJREUgZXZlbnQgd2UgZmlyc3RseSBuZWVkIHRvIHRyYWNrIHRoZSBjbGljayBhbmQgdGhlIHN0YXRlXG4gICAgICAgIC8vIG9mIHRoZSBjb250YWluZXIgYW5kIHRoZW4gbGF0ZXIgb24gZGVjaWRlIHNob3VsZCB3ZSBoaWRlIGl0IG9yIHNob3dcbiAgICAgICAgLy8gaWYgd2UgdHJhY2sgdGhlIGNsaWNrICYgc3RhdGUgc2VwYXJhdGVseSB0aGlzIHdpbGwgY2FzZSBhIGJlaGF2aW9yIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBnZXR0aW5nIHNob3duXG4gICAgICAgIC8vIGFuZCB0aGVuIGhpZGRlbiByaWdodCBhd2F5XG4gICAgICAgIHRoaXMuY2xpY2skID0gZnJvbUV2ZW50KHRoaXMuZG9jdW1lbnQsICdjbGljaycpXG4gICAgICAgICAgICAucGlwZShtYXAoKGV2ZW50KSA9PiBbIXRoaXMuY29udGFpbmVyKCkgJiYgdGhpcy5pc09uSG9zdChldmVudCksIGV2ZW50XSksIHNoYXJlKCksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpKTtcbiAgICAgICAgdGhpcy5zaG93JCA9IHRoaXMuY2xpY2skXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKFtzaG91bGRTaG93XSkgPT4gc2hvdWxkU2hvdyksIG1hcCgoWywgZXZlbnRdKSA9PiBldmVudCksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpKTtcbiAgICAgICAgdGhpcy5oaWRlJCA9IHRoaXMuY2xpY2skXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKFtzaG91bGRTaG93LCBldmVudF0pID0+ICFzaG91bGRTaG93ICYmICF0aGlzLmlzT25Db250YWluZXIoZXZlbnQpKSwgbWFwKChbLCBldmVudF0pID0+IGV2ZW50KSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveWVkJCkpO1xuICAgIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBzaG93IGFuZCBoaWRlIGV2ZW50IHN0cmVhbXMuXG4gKiBGaXJlcyBvcGVuIGV2ZW50IHdoZW4gYSBtb3VzZSBob3ZlcnMgb3ZlciB0aGUgaG9zdCBlbGVtZW50IGFuZCBzdGF5IG92ZXIgYXQgbGVhc3QgMTAwIG1pbGxpc2Vjb25kcy5cbiAqIEZpcmVzIGNsb3NlIGV2ZW50IHdoZW4gdGhlIG1vdXNlIGxlYXZlcyB0aGUgaG9zdCBlbGVtZW50IGFuZCBzdG9wcyBvdXQgb2YgdGhlIGhvc3QgYW5kIHBvcG92ZXIgY29udGFpbmVyLlxuICogKi9cbmNsYXNzIE5iSG92ZXJUcmlnZ2VyU3RyYXRlZ3kgZXh0ZW5kcyBOYlRyaWdnZXJTdHJhdGVneUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNob3ckID0gZnJvbUV2ZW50KHRoaXMuaG9zdCwgJ21vdXNlZW50ZXInKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+ICF0aGlzLmNvbnRhaW5lcigpKSwgZGVsYXkoMTAwKSwgdGFrZVVudGlsKGZyb21FdmVudCh0aGlzLmhvc3QsICdtb3VzZWxlYXZlJykpLCByZXBlYXQoKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveWVkJCkpO1xuICAgICAgICB0aGlzLmhpZGUkID0gZnJvbUV2ZW50KHRoaXMuaG9zdCwgJ21vdXNlbGVhdmUnKVxuICAgICAgICAgICAgLnBpcGUoc3dpdGNoTWFwKCgpID0+IGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAnbW91c2Vtb3ZlJylcbiAgICAgICAgICAgIC5waXBlKGRlYm91bmNlVGltZSgxMDApLCB0YWtlV2hpbGUoKCkgPT4gISF0aGlzLmNvbnRhaW5lcigpKSwgZmlsdGVyKGV2ZW50ID0+IHRoaXMuaXNOb3RPbkhvc3RPckNvbnRhaW5lcihldmVudCkpKSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgc2hvdyBhbmQgaGlkZSBldmVudCBzdHJlYW1zLlxuICogRmlyZXMgb3BlbiBldmVudCB3aGVuIGEgbW91c2UgaG92ZXJzIG92ZXIgdGhlIGhvc3QgZWxlbWVudCBhbmQgc3RheSBvdmVyIGF0IGxlYXN0IDEwMCBtaWxsaXNlY29uZHMuXG4gKiBGaXJlcyBjbG9zZSBldmVudCB3aGVuIHRoZSBtb3VzZSBsZWF2ZXMgdGhlIGhvc3QgZWxlbWVudC5cbiAqICovXG5jbGFzcyBOYkhpbnRUcmlnZ2VyU3RyYXRlZ3kgZXh0ZW5kcyBOYlRyaWdnZXJTdHJhdGVneUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnNob3ckID0gZnJvbUV2ZW50KHRoaXMuaG9zdCwgJ21vdXNlZW50ZXInKVxuICAgICAgICAgICAgLnBpcGUoZGVsYXkoMTAwKSwgdGFrZVVudGlsKG1lcmdlKGZyb21FdmVudCh0aGlzLmhvc3QsICdtb3VzZWxlYXZlJyksIHRoaXMuZGVzdHJveWVkJCkpLCBcbiAgICAgICAgLy8gdGhpcyBgZGVsYXkgJiB0YWtlVW50aWwgJiByZXBlYXRgIG9wZXJhdG9ycyBjb21iaW5hdGlvbiBpcyBhIHN5bm9ueW0gZm9yIGBjb25kaXRpb25hbCBkZWJvdW5jZWBcbiAgICAgICAgLy8gbWVhbmluZyB0aGF0IGlmIG9uZSBldmVudCBvY2N1cnMgaW4gc29tZSB0aW1lIGFmdGVyIHRoZSBpbml0aWFsIG9uZSB3ZSB3b24ndCByZWFjdCB0byBpdFxuICAgICAgICByZXBlYXQoKSk7XG4gICAgICAgIHRoaXMuaGlkZSQgPSBmcm9tRXZlbnQodGhpcy5ob3N0LCAnbW91c2VsZWF2ZScpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQkKSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIHNob3cgYW5kIGhpZGUgZXZlbnQgc3RyZWFtcy5cbiAqIEZpcmVzIG9wZW4gZXZlbnQgd2hlbiBhIGZvY3VzIGlzIG9uIHRoZSBob3N0IGVsZW1lbnQgYW5kIHN0YXkgb3ZlciBhdCBsZWFzdCAxMDAgbWlsbGlzZWNvbmRzLlxuICogRmlyZXMgY2xvc2UgZXZlbnQgd2hlbiB0aGUgZm9jdXMgbGVhdmVzIHRoZSBob3N0IGVsZW1lbnQuXG4gKiAqL1xuY2xhc3MgTmJGb2N1c1RyaWdnZXJTdHJhdGVneSBleHRlbmRzIE5iVHJpZ2dlclN0cmF0ZWd5QmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuZm9jdXNPdXQkID0gZnJvbUV2ZW50KHRoaXMuaG9zdCwgJ2ZvY3Vzb3V0JylcbiAgICAgICAgICAgIC5waXBlKHN3aXRjaE1hcCgoKSA9PiBmcm9tRXZlbnQodGhpcy5kb2N1bWVudCwgJ2ZvY3VzaW4nKVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+ICEhdGhpcy5jb250YWluZXIoKSksIGZpbHRlcihldmVudCA9PiB0aGlzLmlzTm90T25Ib3N0T3JDb250YWluZXIoZXZlbnQpKSkpLCB0YWtlVW50aWwodGhpcy5kZXN0cm95ZWQkKSk7XG4gICAgICAgIHRoaXMuY2xpY2tJbiQgPSBmcm9tRXZlbnQodGhpcy5ob3N0LCAnY2xpY2snKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+ICF0aGlzLmNvbnRhaW5lcigpKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveWVkJCkpO1xuICAgICAgICB0aGlzLmNsaWNrT3V0JCA9IGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAnY2xpY2snKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+ICEhdGhpcy5jb250YWluZXIoKSksIGZpbHRlcihldmVudCA9PiB0aGlzLmlzTm90T25Ib3N0T3JDb250YWluZXIoZXZlbnQpKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveWVkJCkpO1xuICAgICAgICB0aGlzLnRhYktleVByZXNzJCA9IGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAna2V5ZG93bicpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKGV2ZW50KSA9PiBldmVudC5rZXlDb2RlID09PSA5KSwgZmlsdGVyKCgpID0+ICEhdGhpcy5jb250YWluZXIoKSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpKTtcbiAgICAgICAgdGhpcy5zaG93JCA9IG1lcmdlKGZyb21FdmVudCh0aGlzLmhvc3QsICdmb2N1c2luJyksIHRoaXMuY2xpY2tJbiQpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gIXRoaXMuY29udGFpbmVyKCkpLCBkZWJvdW5jZVRpbWUoMTAwKSwgdGFrZVVudGlsKG1lcmdlKGZyb21FdmVudCh0aGlzLmhvc3QsICdmb2N1c291dCcpLCB0aGlzLmRlc3Ryb3llZCQpKSwgcmVwZWF0KCkpO1xuICAgICAgICB0aGlzLmhpZGUkID0gbWVyZ2UodGhpcy5mb2N1c091dCQsIHRoaXMudGFiS2V5UHJlc3MkLCB0aGlzLmNsaWNrT3V0JClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3llZCQpKTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZXMgZW1wdHkgc2hvdyBhbmQgaGlkZSBldmVudCBzdHJlYW1zLlxuICogKi9cbmNsYXNzIE5iTm9vcFRyaWdnZXJTdHJhdGVneSBleHRlbmRzIE5iVHJpZ2dlclN0cmF0ZWd5QmFzZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc2hvdyQgPSBFTVBUWTtcbiAgICAgICAgdGhpcy5oaWRlJCA9IEVNUFRZO1xuICAgIH1cbn1cbmxldCBOYlRyaWdnZXJTdHJhdGVneUJ1aWxkZXJTZXJ2aWNlID0gY2xhc3MgTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoX2RvY3VtZW50KSB7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gX2RvY3VtZW50O1xuICAgIH1cbiAgICB0cmlnZ2VyKHRyaWdnZXIkJDEpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlciA9IHRyaWdnZXIkJDE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBob3N0KGhvc3QpIHtcbiAgICAgICAgdGhpcy5faG9zdCA9IGhvc3Q7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb250YWluZXIoY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGJ1aWxkKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3RyaWdnZXIpIHtcbiAgICAgICAgICAgIGNhc2UgTmJUcmlnZ2VyLkNMSUNLOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmJDbGlja1RyaWdnZXJTdHJhdGVneSh0aGlzLl9kb2N1bWVudCwgdGhpcy5faG9zdCwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNhc2UgTmJUcmlnZ2VyLkhJTlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOYkhpbnRUcmlnZ2VyU3RyYXRlZ3kodGhpcy5fZG9jdW1lbnQsIHRoaXMuX2hvc3QsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICBjYXNlIE5iVHJpZ2dlci5IT1ZFUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5iSG92ZXJUcmlnZ2VyU3RyYXRlZ3kodGhpcy5fZG9jdW1lbnQsIHRoaXMuX2hvc3QsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICBjYXNlIE5iVHJpZ2dlci5GT0NVUzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5iRm9jdXNUcmlnZ2VyU3RyYXRlZ3kodGhpcy5fZG9jdW1lbnQsIHRoaXMuX2hvc3QsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICBjYXNlIE5iVHJpZ2dlci5OT09QOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTmJOb29wVHJpZ2dlclN0cmF0ZWd5KHRoaXMuX2RvY3VtZW50LCB0aGlzLl9ob3N0LCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyaWdnZXIgaGF2ZSB0byBiZSBwcm92aWRlZCcpO1xuICAgICAgICB9XG4gICAgfVxufTtcbk5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2UgPSBfX2RlY29yYXRlJDIyKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSQ4KDAsIEluamVjdChOQl9ET0NVTUVOVCkpLFxuICAgIF9fbWV0YWRhdGEkMTMoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIE5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2UpO1xuXG52YXIgX19kZWNvcmF0ZSQ4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBOYk92ZXJsYXlNb2R1bGVfMTtcbmxldCBOYk92ZXJsYXlNb2R1bGUgPSBOYk92ZXJsYXlNb2R1bGVfMSA9IGNsYXNzIE5iT3ZlcmxheU1vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTmJPdmVybGF5TW9kdWxlXzEsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBOYlBvc2l0aW9uQnVpbGRlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSxcbiAgICAgICAgICAgICAgICBOYk92ZXJsYXlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIE5iUG9zaXRpb25IZWxwZXIsXG4gICAgICAgICAgICAgICAgLi4uTmJDZGtNYXBwaW5nTW9kdWxlLmZvclJvb3QoKS5wcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgLi4uTmJDZGtBZGFwdGVyTW9kdWxlLmZvclJvb3QoKS5wcm92aWRlcnMsXG4gICAgICAgICAgICAgICAgLi4uTmJBMTF5TW9kdWxlLmZvclJvb3QoKS5wcm92aWRlcnMsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5OYk92ZXJsYXlNb2R1bGUgPSBOYk92ZXJsYXlNb2R1bGVfMSA9IF9fZGVjb3JhdGUkOChbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBOYkNka01hcHBpbmdNb2R1bGUsXG4gICAgICAgICAgICBOYlNoYXJlZE1vZHVsZSxcbiAgICAgICAgXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBOYlBvc2l0aW9uZWRDb250YWluZXIsXG4gICAgICAgICAgICBOYk92ZXJsYXlDb250YWluZXJDb21wb25lbnQsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIE5iQ2RrTWFwcGluZ01vZHVsZSxcbiAgICAgICAgICAgIE5iQ2RrQWRhcHRlck1vZHVsZSxcbiAgICAgICAgICAgIE5iT3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJPdmVybGF5TW9kdWxlKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIE5iVGhlbWVNb2R1bGVfMTtcbmZ1bmN0aW9uIHdpbmRvd0ZhY3RvcnkocGxhdGZvcm1JZCkge1xuICAgIGlmIChpc1BsYXRmb3JtQnJvd3NlcihwbGF0Zm9ybUlkKSkge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICAvLyBQcm92aWRlIHVuZGVmaW5lZCB0byBnZXQgdGhlIGVycm9yIHdoZW4gdHJ5aW5nIHRvIGFjY2VzcyB0aGUgd2luZG93IGFzIGl0XG4gICAgLy8gc2hvdWxkbid0IGJlIHVzZWQgb3V0c2lkZSB0aGUgYnJvd3Nlci4gVGhvc2Ugd2hvIG5lZWQgdG8gcHJvdmlkZSBzb21ldGhpbmdcbiAgICAvLyBpbnN0ZWFkIG9mIHdpbmRvdyAoZS5nLiBkb21pbm8gd2luZG93IHdoZW4gcnVubmluZyBpbiBub2RlKSBjb3VsZCBvdmVycmlkZVxuICAgIC8vIE5CX1dJTkRPVyB0b2tlbi5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxubGV0IE5iVGhlbWVNb2R1bGUgPSBOYlRoZW1lTW9kdWxlXzEgPSBjbGFzcyBOYlRoZW1lTW9kdWxlIHtcbiAgICAvLyBUT0RPOiBjaGVjayB0aGUgb3B0aW9ucyAodGhyb3cgZXhjZXB0aW9uPylcbiAgICAvKipcbiAgICAgKiBNYWluIFRoZW1lIE1vZHVsZVxuICAgICAqXG4gICAgICogQHBhcmFtIG5iVGhlbWVPcHRpb25zIHtOYlRoZW1lT3B0aW9uc30gTWFpbiB0aGVtZSBvcHRpb25zXG4gICAgICogQHBhcmFtIG5iSlNUaGVtZXMge05iSlNUaGVtZU9wdGlvbnNbXX0gTGlzdCBvZiBKUyBUaGVtZXMsIHdpbGwgYmUgbWVyZ2VkIHdpdGggZGVmYXVsdCB0aGVtZXNcbiAgICAgKiBAcGFyYW0gbmJNZWRpYUJyZWFrcG9pbnRzIHtOYk1lZGlhQnJlYWtwb2ludH0gQXZhaWxhYmxlIG1lZGlhIGJyZWFrcG9pbnRzXG4gICAgICogQHBhcmFtIGxheW91dERpcmVjdGlvbiB7TmJMYXlvdXREaXJlY3Rpb259IExheW91dCBkaXJlY3Rpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtNb2R1bGVXaXRoUHJvdmlkZXJzfVxuICAgICAqL1xuICAgIHN0YXRpYyBmb3JSb290KG5iVGhlbWVPcHRpb25zID0geyBuYW1lOiAnZGVmYXVsdCcgfSwgbmJKU1RoZW1lcywgbmJNZWRpYUJyZWFrcG9pbnRzLCBsYXlvdXREaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBOYlRoZW1lTW9kdWxlXzEsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5CX1RIRU1FX09QVElPTlMsIHVzZVZhbHVlOiBuYlRoZW1lT3B0aW9ucyB8fCB7fSB9LFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTkJfQlVJTFRfSU5fSlNfVEhFTUVTLCB1c2VWYWx1ZTogQlVJTFRfSU5fVEhFTUVTIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9KU19USEVNRVMsIHVzZVZhbHVlOiBuYkpTVGhlbWVzIHx8IFtdIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9NRURJQV9CUkVBS1BPSU5UUywgdXNlVmFsdWU6IG5iTWVkaWFCcmVha3BvaW50cyB8fCBERUZBVUxUX01FRElBX0JSRUFLUE9JTlRTIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9ET0NVTUVOVCwgdXNlRXhpc3Rpbmc6IERPQ1VNRU5UIH0sXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9XSU5ET1csIHVzZUZhY3Rvcnk6IHdpbmRvd0ZhY3RvcnksIGRlcHM6IFtQTEFURk9STV9JRF0gfSxcbiAgICAgICAgICAgICAgICBOYkpTVGhlbWVzUmVnaXN0cnksXG4gICAgICAgICAgICAgICAgTmJUaGVtZVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgTmJNZWRpYUJyZWFrcG9pbnRzU2VydmljZSxcbiAgICAgICAgICAgICAgICBOYlNwaW5uZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTkJfTEFZT1VUX0RJUkVDVElPTiwgdXNlVmFsdWU6IGxheW91dERpcmVjdGlvbiB8fCBOYkxheW91dERpcmVjdGlvbi5MVFIgfSxcbiAgICAgICAgICAgICAgICBOYkxheW91dERpcmVjdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgTmJMYXlvdXRTY3JvbGxTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIE5iTGF5b3V0UnVsZXJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIC4uLk5iT3ZlcmxheU1vZHVsZS5mb3JSb290KCkucHJvdmlkZXJzLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuTmJUaGVtZU1vZHVsZSA9IE5iVGhlbWVNb2R1bGVfMSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBdLFxuICAgICAgICBleHBvcnRzOiBbXSxcbiAgICB9KVxuXSwgTmJUaGVtZU1vZHVsZSk7XG5cbmNsYXNzIE5iQ29sb3JIZWxwZXIge1xuICAgIHN0YXRpYyBzaGFkZShjb2xvciwgd2VpZ2h0KSB7XG4gICAgICAgIHJldHVybiBOYkNvbG9ySGVscGVyLm1peCgnIzAwMDAwMCcsIGNvbG9yLCB3ZWlnaHQpO1xuICAgIH1cbiAgICBzdGF0aWMgdGludChjb2xvciwgd2VpZ2h0KSB7XG4gICAgICAgIHJldHVybiBOYkNvbG9ySGVscGVyLm1peCgnI2ZmZmZmZicsIGNvbG9yLCB3ZWlnaHQpO1xuICAgIH1cbiAgICBzdGF0aWMgbWl4KGNvbG9yMSwgY29sb3IyLCB3ZWlnaHQpIHtcbiAgICAgICAgY29uc3QgZDJoID0gKGQpID0+IGQudG9TdHJpbmcoMTYpO1xuICAgICAgICBjb25zdCBoMmQgPSAoaCkgPT4gcGFyc2VJbnQoaCwgMTYpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyMnO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDc7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gaDJkKGNvbG9yMS5zdWJzdHIoaSwgMikpO1xuICAgICAgICAgICAgY29uc3Qgc2Vjb25kUGFydCA9IGgyZChjb2xvcjIuc3Vic3RyKGksIDIpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdFBhcnQgPSBkMmgoTWF0aC5mbG9vcihzZWNvbmRQYXJ0ICsgKGZpcnN0UGFydCAtIHNlY29uZFBhcnQpICogKHdlaWdodCAvIDEwMC4wKSkpO1xuICAgICAgICAgICAgcmVzdWx0ICs9ICgnMCcgKyByZXN1bHRQYXJ0KS5zbGljZSgtMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGhleFRvUmdiQShoZXgsIGFscGhhKSB7XG4gICAgICAgIGxldCBjO1xuICAgICAgICBpZiAoL14jKFtBLUZhLWYwLTldezN9KXsxLDJ9JC8udGVzdChoZXgpKSB7XG4gICAgICAgICAgICBjID0gaGV4LnN1YnN0cmluZygxKS5zcGxpdCgnJyk7XG4gICAgICAgICAgICBpZiAoYy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgICAgICAgICBjID0gW2NbMF0sIGNbMF0sIGNbMV0sIGNbMV0sIGNbMl0sIGNbMl1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYyA9ICcweCcgKyBjLmpvaW4oJycpO1xuICAgICAgICAgICAgcmV0dXJuICdyZ2JhKCcgKyBbKGMgPj4gMTYpICYgMjU1LCAoYyA+PiA4KSAmIDI1NSwgYyAmIDI1NV0uam9pbignLCcpICsgJywnICsgYWxwaGEgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYWQgSGV4Jyk7XG4gICAgfVxufVxuXG52YXIgTmJJY29uUGFja1R5cGU7XG4oZnVuY3Rpb24gKE5iSWNvblBhY2tUeXBlKSB7XG4gICAgTmJJY29uUGFja1R5cGVbXCJTVkdcIl0gPSBcInN2Z1wiO1xuICAgIE5iSWNvblBhY2tUeXBlW1wiRk9OVFwiXSA9IFwiZm9udFwiO1xufSkoTmJJY29uUGFja1R5cGUgfHwgKE5iSWNvblBhY2tUeXBlID0ge30pKTtcblxuY2xhc3MgTmJGb250SWNvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgY29udGVudCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfVxuICAgIGdldENsYXNzZXMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gW107XG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5wYWNrQ2xhc3MpIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCh0aGlzLnBhcmFtcy5wYWNrQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcmFtcy5pY29uQ2xhc3NQcmVmaXggPyBgJHt0aGlzLnBhcmFtcy5pY29uQ2xhc3NQcmVmaXh9LSR7dGhpcy5uYW1lfWAgOiB0aGlzLm5hbWU7XG4gICAgICAgIGNsYXNzZXMucHVzaChuYW1lKTtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXM7XG4gICAgfVxuICAgIGdldENvbnRlbnQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICAgIH1cbn1cbmNsYXNzIE5iU3ZnSWNvbiB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgY29udGVudCwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfVxuICAgIGdldENsYXNzZXMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gW107XG4gICAgICAgIGlmICh0aGlzLnBhcmFtcy5wYWNrQ2xhc3MpIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCh0aGlzLnBhcmFtcy5wYWNrQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgIH1cbiAgICBnZXRDb250ZW50KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICB9XG59XG5cbnZhciBfX2RlY29yYXRlJDI2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iSWNvbkRlZmluaXRpb24ge1xufVxuZnVuY3Rpb24gdGhyb3dQYWNrTm90Rm91bmRFcnJvcihuYW1lKSB7XG4gICAgdGhyb3cgRXJyb3IoYEljb24gUGFjayAnJHtuYW1lfScgaXMgbm90IHJlZ2lzdGVyZWRgKTtcbn1cbmZ1bmN0aW9uIHRocm93Tm9EZWZhdWx0UGFja0Vycm9yKCkge1xuICAgIHRocm93IEVycm9yKCdEZWZhdWx0IHBhY2sgaXMgbm90IHJlZ2lzdGVyZWQuJyk7XG59XG5mdW5jdGlvbiB0aHJvd0ljb25Ob3RGb3VuZEVycm9yKG5hbWUsIHBhY2spIHtcbiAgICB0aHJvdyBFcnJvcihgSWNvbiAnJHtuYW1lfScgaXMgbm90IHJlZ2lzdGVyZWQgaW4gcGFjayAnJHtwYWNrfScuIENoZWNrIGljb24gbmFtZSBvciBjb25zaWRlciBzd2l0Y2hpbmcgaWNvbiBwYWNrLmApO1xufVxuZnVuY3Rpb24gdGhyb3dXcm9uZ1BhY2tUeXBlRXJyb3IobmFtZSwgdHlwZSwgZGVzaXJlZFR5cGUpIHtcbiAgICB0aHJvdyBFcnJvcihgUGFjayAnJHtuYW1lfScgaXMgbm90IGFuICcke2Rlc2lyZWRUeXBlfScgUGFjayBhbmQgaXRzIHR5cGUgaXMgJyR7dHlwZX0nYCk7XG59XG4vKipcbiAqIFRoaXMgc2VydmljZSBhbGxvd3MgdG8gcmVnaXN0ZXIgbXVsdGlwbGUgaWNvbiBwYWNrcyB0byB1c2UgdGhlbSBsYXRlciB3aXRoaW4gYDxuYi1pY29uPjwvbmItaWNvbj5gIGNvbXBvbmVudC5cbiAqL1xubGV0IE5iSWNvbkxpYnJhcmllcyA9IGNsYXNzIE5iSWNvbkxpYnJhcmllcyB7XG4gICAgLyoqXG4gICAgICogVGhpcyBzZXJ2aWNlIGFsbG93cyB0byByZWdpc3RlciBtdWx0aXBsZSBpY29uIHBhY2tzIHRvIHVzZSB0aGVtIGxhdGVyIHdpdGhpbiBgPG5iLWljb24+PC9uYi1pY29uPmAgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhY2tzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgbmV3IFN2ZyBpY29uIHBhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7TmJJY29ufSBpY29uc1xuICAgICAqIEBwYXJhbSB7TmJJY29uUGFja1BhcmFtc30gcGFyYW1zXG4gICAgICovXG4gICAgcmVnaXN0ZXJTdmdQYWNrKG5hbWUsIGljb25zLCBwYXJhbXMgPSB7fSkge1xuICAgICAgICB0aGlzLnBhY2tzLnNldChuYW1lLCB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgaWNvbnM6IG5ldyBNYXAoT2JqZWN0LmVudHJpZXMoaWNvbnMpKSxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIHR5cGU6IE5iSWNvblBhY2tUeXBlLlNWRyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBuZXcgZm9udCBwYWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge05iSWNvblBhY2tQYXJhbXN9IHBhcmFtc1xuICAgICAqL1xuICAgIHJlZ2lzdGVyRm9udFBhY2sobmFtZSwgcGFyYW1zID0ge30pIHtcbiAgICAgICAgdGhpcy5wYWNrcy5zZXQobmFtZSwge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIGljb25zOiBuZXcgTWFwKCksXG4gICAgICAgICAgICB0eXBlOiBOYkljb25QYWNrVHlwZS5GT05ULFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBwYWNrIGJ5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqL1xuICAgIGdldFBhY2sobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWNrcy5nZXQobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgcGFjayBhcyBhIGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqL1xuICAgIHNldERlZmF1bHRQYWNrKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhY2tzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhyb3dQYWNrTm90Rm91bmRFcnJvcihuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZmF1bHRQYWNrID0gdGhpcy5wYWNrcy5nZXQobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgU3ZnIGljb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYWNrXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBOYkljb25EZWZpbml0aW9uXG4gICAgICovXG4gICAgZ2V0U3ZnSWNvbihuYW1lLCBwYWNrKSB7XG4gICAgICAgIGNvbnN0IGljb25zUGFjayA9IHBhY2sgPyB0aGlzLmdldFBhY2tPclRocm93KHBhY2spIDogdGhpcy5nZXREZWZhdWx0UGFja09yVGhyb3coKTtcbiAgICAgICAgaWYgKGljb25zUGFjay50eXBlICE9PSBOYkljb25QYWNrVHlwZS5TVkcpIHtcbiAgICAgICAgICAgIHRocm93V3JvbmdQYWNrVHlwZUVycm9yKGljb25zUGFjay5uYW1lLCBpY29uc1BhY2sudHlwZSwgJ1NWRycpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGljb24gPSB0aGlzLmdldEljb25Gcm9tUGFjayhuYW1lLCBpY29uc1BhY2spO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHBhY2s6IGljb25zUGFjay5uYW1lLFxuICAgICAgICAgICAgdHlwZTogTmJJY29uUGFja1R5cGUuU1ZHLFxuICAgICAgICAgICAgaWNvbjogdGhpcy5jcmVhdGVTdmdJY29uKG5hbWUsIGljb24sIGljb25zUGFjay5wYXJhbXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIEZvbnQgaWNvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhY2tcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIE5iSWNvbkRlZmluaXRpb25cbiAgICAgKi9cbiAgICBnZXRGb250SWNvbihuYW1lLCBwYWNrKSB7XG4gICAgICAgIGNvbnN0IGljb25zUGFjayA9IHBhY2sgPyB0aGlzLmdldFBhY2tPclRocm93KHBhY2spIDogdGhpcy5nZXREZWZhdWx0UGFja09yVGhyb3coKTtcbiAgICAgICAgaWYgKGljb25zUGFjay50eXBlICE9PSBOYkljb25QYWNrVHlwZS5GT05UKSB7XG4gICAgICAgICAgICB0aHJvd1dyb25nUGFja1R5cGVFcnJvcihpY29uc1BhY2submFtZSwgaWNvbnNQYWNrLnR5cGUsICdGb250Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMuZ2V0SWNvbkZyb21QYWNrKG5hbWUsIGljb25zUGFjaywgZmFsc2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHBhY2s6IGljb25zUGFjay5uYW1lLFxuICAgICAgICAgICAgdHlwZTogTmJJY29uUGFja1R5cGUuRk9OVCxcbiAgICAgICAgICAgIGljb246IHRoaXMuY3JlYXRlRm9udEljb24obmFtZSwgaWNvbiA/IGljb24gOiAnJywgaWNvbnNQYWNrLnBhcmFtcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaWNvblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhY2tcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIE5iSWNvbkRlZmluaXRpb25cbiAgICAgKi9cbiAgICBnZXRJY29uKG5hbWUsIHBhY2spIHtcbiAgICAgICAgY29uc3QgaWNvbnNQYWNrID0gcGFjayA/IHRoaXMuZ2V0UGFja09yVGhyb3cocGFjaykgOiB0aGlzLmdldERlZmF1bHRQYWNrT3JUaHJvdygpO1xuICAgICAgICBpZiAoaWNvbnNQYWNrLnR5cGUgPT09IE5iSWNvblBhY2tUeXBlLlNWRykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3ZnSWNvbihuYW1lLCBwYWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRGb250SWNvbihuYW1lLCBwYWNrKTtcbiAgICB9XG4gICAgY3JlYXRlU3ZnSWNvbihuYW1lLCBjb250ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQgaW5zdGFuY2VvZiBOYlN2Z0ljb24gPyBjb250ZW50IDogbmV3IE5iU3ZnSWNvbihuYW1lLCBjb250ZW50LCBwYXJhbXMpO1xuICAgIH1cbiAgICBjcmVhdGVGb250SWNvbihuYW1lLCBjb250ZW50LCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQgaW5zdGFuY2VvZiBOYkZvbnRJY29uID8gY29udGVudCA6IG5ldyBOYkZvbnRJY29uKG5hbWUsIGNvbnRlbnQsIHBhcmFtcyk7XG4gICAgfVxuICAgIGdldFBhY2tPclRocm93KG5hbWUpIHtcbiAgICAgICAgY29uc3QgcGFjayA9IHRoaXMucGFja3MuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIXBhY2spIHtcbiAgICAgICAgICAgIHRocm93UGFja05vdEZvdW5kRXJyb3IobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhY2s7XG4gICAgfVxuICAgIGdldERlZmF1bHRQYWNrT3JUaHJvdygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlZmF1bHRQYWNrKSB7XG4gICAgICAgICAgICB0aHJvd05vRGVmYXVsdFBhY2tFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRQYWNrO1xuICAgIH1cbiAgICBnZXRJY29uRnJvbVBhY2sobmFtZSwgcGFjaywgc2hvdWxkVGhyb3cgPSB0cnVlKSB7XG4gICAgICAgIGlmIChzaG91bGRUaHJvdyAmJiAhcGFjay5pY29ucy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93SWNvbk5vdEZvdW5kRXJyb3IobmFtZSwgcGFjay5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFjay5pY29ucy5nZXQobmFtZSk7XG4gICAgfVxufTtcbk5iSWNvbkxpYnJhcmllcy5uZ0luamVjdGFibGVEZWYgPSDJtcm1ZGVmaW5lSW5qZWN0YWJsZSh7IGZhY3Rvcnk6IGZ1bmN0aW9uIE5iSWNvbkxpYnJhcmllc19GYWN0b3J5KCkgeyByZXR1cm4gbmV3IE5iSWNvbkxpYnJhcmllcygpOyB9LCB0b2tlbjogTmJJY29uTGlicmFyaWVzLCBwcm92aWRlZEluOiBcInJvb3RcIiB9KTtcbk5iSWNvbkxpYnJhcmllcyA9IF9fZGVjb3JhdGUkMjYoW1xuICAgIEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbl0sIE5iSWNvbkxpYnJhcmllcyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDI1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDE1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIEljb24gY29tcG9uZW50LiBBbGxvd3MgdG8gcmVuZGVyIGJvdGggYHN2Z2AgYW5kIGBmb250YCBpY29ucy5cbiAqIFN0YXJ0aW5nIGZyb20gTmVidWxhciA0LjAgdXNlcyBbRXZhIEljb25zXShodHRwczovL2FrdmVvLmdpdGh1Yi5pby9ldmEtaWNvbnMvKSBwYWNrIGJ5IGRlZmF1bHQuXG4gKlxuICogQmFzaWMgaWNvbiBleGFtcGxlOlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgaWNvbi9pY29uLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBJY29uIGNvbmZpZ3VyYXRpb246XG4gKlxuICogYGBgaHRtbFxuICogPG5iLWljb24gaWNvbj1cInN0YXJcIj48L25iLWljb24+XG4gKiBgYGBcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBCeSBkZWZhdWx0IE5lYnVsYXIgY29tZXMgd2l0aG91dCBhbnkgcHJlLWluc3RhbGxlZCBpY29uIHBhY2suXG4gKiBTdGFydGluZyB3aXRoIE5lYnVsYXIgNC4wLjAgd2Ugc2hpcCBzZXBhcmF0ZSBwYWNrYWdlIGNhbGxlZCBgQG5lYnVsYXIvZXZhLWljb25zYFxuICogd2hpY2ggaW50ZWdyYXRlcyBTVkcgW0V2YSBJY29uc10oaHR0cHM6Ly9ha3Zlby5naXRodWIuaW8vZXZhLWljb25zLykgcGFjayB0byBOZWJ1bGFyLiBUbyBhZGQgaXQgdG8geW91clxuICogcHJvamVjdCBydW46XG4gKiBgYGBzaFxuICogbnBtIGkgQG5lYnVsYXIvZXZhLWljb25zXG4gKiBgYGBcbiAqIFRoaXMgY29tbWFuZCB3aWxsIGluc3RhbGwgRXZhIEljb25zIHBhY2suIFRoZW4gcmVnaXN0ZXIgYE5iRXZhSWNvbnNNb2R1bGVgIGludG8geW91ciBhcHAgbW9kdWxlOlxuICogYGBgdHNcbiAqIGltcG9ydCB7IE5iRXZhSWNvbnNNb2R1bGUgfSBmcm9tICdAbmVidWxhci9ldmEtaWNvbnMnO1xuICpcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkV2YUljb25zTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqIExhc3QgdGhpbmcsIGltcG9ydCBgTmJJY29uTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlIHdoZXJlIHlvdSBuZWVkIHRvIHNob3cgYW4gaWNvbjpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBOYkljb25Nb2R1bGUgfSBmcm9tICdAbmVidWxhci90aGVtZSc7XG4gKlxuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iSWNvbk1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogSWNvbiBjYW4gYmUgY29sb3JlZCB1c2luZyBgc3RhdHVzYCBpbnB1dDpcbiAqIGBgYGh0bWxcbiAqIDxuYi1pY29uIGljb249XCJzdGFyXCIgc3RhdHVzPVwid2FybmluZ1wiPjwvbmItaWNvbj5cbiAqIGBgYFxuICpcbiAqIENvbG9yZWQgaWNvbnM6XG4gKiBAc3RhY2tlZC1leGFtcGxlKENvbG9yZWQgSWNvbnMsIGljb24vaWNvbi1jb2xvcnMuY29tcG9uZW50KVxuICpcbiAqIEluIGNhc2UgeW91IG5lZWQgdG8gc3BlY2lmeSBhbiBpY29uIGZyb20gYSBzcGVjaWZpYyBpY29uIHBhY2ssIHRoaXMgY291bGQgYmUgZG9uZSB1c2luZyBgcGFja2AgaW5wdXQgcHJvcGVydHk6XG4gKiBgYGBodG1sXG4gKiA8bmItaWNvbiBpY29uPVwic3RhclwiIHBhY2s9XCJmb250LWF3ZXNvbWVcIj48L25iLWljb24+XG4gKiBgYGBcbiAqIEFkZGl0aW9uYWwgaWNvbiBzZXR0aW5ncyAoaWYgYXZhaWxhYmxlIGJ5IHRoZSBpY29uIHBhY2spIGNvdWxkIGJlIHBhc3NlZCB1c2luZyBgb3B0aW9uc2AgaW5wdXQ6XG4gKlxuICogYGBgaHRtbFxuICogPG5iLWljb24gaWNvbj1cInN0YXJcIiBbb3B0aW9uc109XCJ7IGFuaW1hdGlvbjogeyB0eXBlOiAnem9vbScgfSB9XCI+PC9uYi1pY29uPlxuICogYGBgXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGljb24tZm9udC1zaXplOlxuICogaWNvbi1saW5lLWhlaWdodDpcbiAqIGljb24td2lkdGg6XG4gKiBpY29uLWhlaWdodDpcbiAqIGljb24tc3ZnLXZlcnRpY2FsLWFsaWduOlxuICogaWNvbi1iYXNpYy1jb2xvcjpcbiAqIGljb24tcHJpbWFyeS1jb2xvcjpcbiAqIGljb24taW5mby1jb2xvcjpcbiAqIGljb24tc3VjY2Vzcy1jb2xvcjpcbiAqIGljb24td2FybmluZy1jb2xvcjpcbiAqIGljb24tZGFuZ2VyLWNvbG9yOlxuICogaWNvbi1jb250cm9sLWNvbG9yOlxuICovXG5sZXQgTmJJY29uQ29tcG9uZW50ID0gY2xhc3MgTmJJY29uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzYW5pdGl6ZXIsIGljb25MaWJyYXJ5LCBlbCwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5zYW5pdGl6ZXIgPSBzYW5pdGl6ZXI7XG4gICAgICAgIHRoaXMuaWNvbkxpYnJhcnkgPSBpY29uTGlicmFyeTtcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMucHJldkNsYXNzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5odG1sID0gJyc7XG4gICAgfVxuICAgIGdldCBwcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhbGwgaWNvbiBjb25maWd1cmFibGUgcHJvcGVydGllcyB2aWEgY29uZmlnIG9iamVjdC5cbiAgICAgKiBJZiBwYXNzZWQgdmFsdWUgaXMgYSBzdHJpbmcgc2V0IGljb24gbmFtZS5cbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICovXG4gICAgZ2V0IGNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9XG4gICAgc2V0IGNvbmZpZyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gdmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmljb24gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaWNvbiA9IHZhbHVlLmljb247XG4gICAgICAgICAgICB0aGlzLnBhY2sgPSB2YWx1ZS5wYWNrO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSB2YWx1ZS5zdGF0dXM7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB2YWx1ZS5vcHRpb25zO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmljb25EZWYgPSB0aGlzLnJlbmRlckljb24odGhpcy5pY29uLCB0aGlzLnBhY2ssIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5pY29uRGVmKSB7XG4gICAgICAgICAgICB0aGlzLmljb25EZWYgPSB0aGlzLnJlbmRlckljb24odGhpcy5pY29uLCB0aGlzLnBhY2ssIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVySWNvbihuYW1lLCBwYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGljb25EZWZpbml0aW9uID0gdGhpcy5pY29uTGlicmFyeS5nZXRJY29uKG5hbWUsIHBhY2spO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gaWNvbkRlZmluaXRpb24uaWNvbi5nZXRDb250ZW50KG9wdGlvbnMpO1xuICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5odG1sID0gdGhpcy5zYW5pdGl6ZXIuYnlwYXNzU2VjdXJpdHlUcnVzdEh0bWwoY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hc3NpZ25DbGFzc2VzKGljb25EZWZpbml0aW9uLmljb24uZ2V0Q2xhc3NlcyhvcHRpb25zKSk7XG4gICAgICAgIHJldHVybiBpY29uRGVmaW5pdGlvbjtcbiAgICB9XG4gICAgYXNzaWduQ2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgICAgIHRoaXMucHJldkNsYXNzZXMuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsYXNzZXMuZm9yRWFjaCgoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZWwubmF0aXZlRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJldkNsYXNzZXMgPSBjbGFzc2VzO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDI1KFtcbiAgICBIb3N0QmluZGluZygnaW5uZXJIdG1sJyksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iSWNvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiaHRtbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQyNShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJJY29uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmltYXJ5XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQyNShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1pbmZvJyksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJJY29uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmZvXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQyNShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1zdWNjZXNzJyksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJJY29uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdWNjZXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQyNShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy13YXJuaW5nJyksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJJY29uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3YXJuaW5nXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQyNShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1kYW5nZXInKSxcbiAgICBfX21ldGFkYXRhJDE1KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDE1KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkljb25Db21wb25lbnQucHJvdG90eXBlLCBcImRhbmdlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtYmFzaWMnKSxcbiAgICBfX21ldGFkYXRhJDE1KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDE1KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkljb25Db21wb25lbnQucHJvdG90eXBlLCBcImJhc2ljXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQyNShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1jb250cm9sJyksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJJY29uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250cm9sXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQyNShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDE1KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJJY29uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDI1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTUoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkljb25Db21wb25lbnQucHJvdG90eXBlLCBcInBhY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMjUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iSWNvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQyNShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDE1KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJJY29uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGF0dXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMjUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgTmJJY29uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb25maWdcIiwgbnVsbCk7XG5OYkljb25Db21wb25lbnQgPSBfX2RlY29yYXRlJDI1KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWljb24nLFxuICAgICAgICB0ZW1wbGF0ZTogJycsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6aW5saW5lLWJsb2NrfVxcblwiXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkMTUoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbRG9tU2FuaXRpemVyLFxuICAgICAgICBOYkljb25MaWJyYXJpZXMsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBOYkljb25Db21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQyNCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxNCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xubGV0IE5iSWNvbk1vZHVsZSA9IGNsYXNzIE5iSWNvbk1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoaWNvbnNMaWJyYXJ5KSB7XG4gICAgICAgIHRoaXMuaWNvbnNMaWJyYXJ5ID0gaWNvbnNMaWJyYXJ5O1xuICAgICAgICB0aGlzLmVzc2VudGlhbHNQYWNrTmFtZSA9ICduZWJ1bGFyLWVzc2VudGlhbHMnO1xuICAgICAgICAvLyBpbiBjYXNlIG9mIGNvbnNlcXVlbnQgY2FsbHMgd2UgZG9uJ3QgbmVlZCB0byBlbmFibGUgYG5lYnVsYXItZXNzZW50aWFsc2AgcGFjayBhZ2FpblxuICAgICAgICBpZiAodGhpcy5pY29uc0xpYnJhcnkuZ2V0UGFjayh0aGlzLmVzc2VudGlhbHNQYWNrTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgdGhpcy5pY29uc0xpYnJhcnkucmVnaXN0ZXJTdmdQYWNrKHRoaXMuZXNzZW50aWFsc1BhY2tOYW1lLCB7XG4gICAgICAgICAgICAnY2hldnJvbi1kb3duLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImNoZXZyb24tZG93blwiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMTIgMTUuNWExIDEgMCAwIDEtLjcxLS4yOWwtNC00YTEgMSAwIDEgMSAxLjQyLTEuNDJMMTIgMTMuMWwzLjMtMy4xOGExIDEgMCAxIDEgMS4zOCAxLjQ0bC00IDMuODZhMSAxIDAgMCAxLS42OC4yOHpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ2NoZXZyb24tdXAtb3V0bGluZSc6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwiY2hldnJvbi11cFwiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgxODAgMTIgMTIpXCIgb3BhY2l0eT1cIjBcIi8+PHBhdGggZD1cIk0xNiAxNC41YTEgMSAwIDAgMS0uNzEtLjI5TDEyIDEwLjlsLTMuMyAzLjE4YTEgMSAwIDAgMS0xLjQxIDAgMSAxIDAgMCAxIDAtMS40Mmw0LTMuODZhMSAxIDAgMCAxIDEuNCAwbDQgNGExIDEgMCAwIDEgMCAxLjQyIDEgMSAwIDAgMS0uNjkuMjh6XCIvPjwvZz48L2c+PC9zdmc+JyxcbiAgICAgICAgICAgICdjaGV2cm9uLWxlZnQtb3V0bGluZSc6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwiY2hldnJvbi1sZWZ0XCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdHJhbnNmb3JtPVwicm90YXRlKDkwIDEyIDEyKVwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMTMuMzYgMTdhMSAxIDAgMCAxLS43Mi0uMzFsLTMuODYtNGExIDEgMCAwIDEgMC0xLjRsNC00YTEgMSAwIDEgMSAxLjQyIDEuNDJMMTAuOSAxMmwzLjE4IDMuM2ExIDEgMCAwIDEgMCAxLjQxIDEgMSAwIDAgMS0uNzIuMjl6XCIvPjwvZz48L2c+PC9zdmc+JyxcbiAgICAgICAgICAgICdjaGV2cm9uLXJpZ2h0LW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImNoZXZyb24tcmlnaHRcIj48cmVjdCB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB0cmFuc2Zvcm09XCJyb3RhdGUoLTkwIDEyIDEyKVwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMTAuNSAxN2ExIDEgMCAwIDEtLjcxLS4yOSAxIDEgMCAwIDEgMC0xLjQyTDEzLjEgMTIgOS45MiA4LjY5YTEgMSAwIDAgMSAwLTEuNDEgMSAxIDAgMCAxIDEuNDIgMGwzLjg2IDRhMSAxIDAgMCAxIDAgMS40bC00IDRhMSAxIDAgMCAxLS43LjMyelwiLz48L2c+PC9nPjwvc3ZnPicsXG4gICAgICAgICAgICAnY2hlY2ttYXJrLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImNoZWNrbWFya1wiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNOS44NiAxOGExIDEgMCAwIDEtLjczLS4zMmwtNC44Ni01LjE3YTEgMSAwIDEgMSAxLjQ2LTEuMzdsNC4xMiA0LjM5IDguNDEtOS4yYTEgMSAwIDEgMSAxLjQ4IDEuMzRsLTkuMTQgMTBhMSAxIDAgMCAxLS43My4zM3pcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ3BhcGVyLXBsYW5lLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cInBhcGVyLXBsYW5lXCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgb3BhY2l0eT1cIjBcIi8+PHBhdGggZD1cIk0yMSA0YTEuMzEgMS4zMSAwIDAgMC0uMDYtLjI3di0uMDlhMSAxIDAgMCAwLS4yLS4zIDEgMSAwIDAgMC0uMjktLjE5aC0uMDlhLjg2Ljg2IDAgMCAwLS4zMS0uMTVIMjBhMSAxIDAgMCAwLS4zIDBsLTE4IDZhMSAxIDAgMCAwIDAgMS45bDguNTMgMi44NCAyLjg0IDguNTNhMSAxIDAgMCAwIDEuOSAwbDYtMThBMSAxIDAgMCAwIDIxIDR6bS00LjcgMi4yOWwtNS41NyA1LjU3TDUuMTYgMTB6TTE0IDE4Ljg0bC0xLjg2LTUuNTcgNS41Ny01LjU3elwiLz48L2c+PC9nPjwvc3ZnPicsXG4gICAgICAgICAgICAnZmlsZS10ZXh0LW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImZpbGUtdGV4dFwiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMTUgMTZIOWExIDEgMCAwIDAgMCAyaDZhMSAxIDAgMCAwIDAtMnpcIi8+PHBhdGggZD1cIk05IDE0aDNhMSAxIDAgMCAwIDAtMkg5YTEgMSAwIDAgMCAwIDJ6XCIvPjxwYXRoIGQ9XCJNMTkuNzQgOC4zM2wtNS40NC02YTEgMSAwIDAgMC0uNzQtLjMzaC03QTIuNTMgMi41MyAwIDAgMCA0IDQuNXYxNUEyLjUzIDIuNTMgMCAwIDAgNi41NiAyMmgxMC44OEEyLjUzIDIuNTMgMCAwIDAgMjAgMTkuNVY5YTEgMSAwIDAgMC0uMjYtLjY3ek0xNCA1bDIuNzQgM2gtMmEuNzkuNzkgMCAwIDEtLjc0LS44NXptMy40NCAxNUg2LjU2YS41My41MyAwIDAgMS0uNTYtLjV2LTE1YS41My41MyAwIDAgMSAuNTYtLjVIMTJ2My4xNUEyLjc5IDIuNzkgMCAwIDAgMTQuNzEgMTBIMTh2OS41YS41My41MyAwIDAgMS0uNTYuNXpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ2FsZXJ0LXRyaWFuZ2xlLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImFsZXJ0LXRyaWFuZ2xlXCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdHJhbnNmb3JtPVwicm90YXRlKDkwIDEyIDEyKVwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMjIuNTYgMTYuM0wxNC44OSAzLjU4YTMuNDMgMy40MyAwIDAgMC01Ljc4IDBMMS40NCAxNi4zYTMgMyAwIDAgMC0uMDUgM0EzLjM3IDMuMzcgMCAwIDAgNC4zMyAyMWgxNS4zNGEzLjM3IDMuMzcgMCAwIDAgMi45NC0xLjY2IDMgMyAwIDAgMC0uMDUtMy4wNHptLTEuNyAyLjA1YTEuMzEgMS4zMSAwIDAgMS0xLjE5LjY1SDQuMzNhMS4zMSAxLjMxIDAgMCAxLTEuMTktLjY1IDEgMSAwIDAgMSAwLTFsNy42OC0xMi43M2ExLjQ4IDEuNDggMCAwIDEgMi4zNiAwbDcuNjcgMTIuNzJhMSAxIDAgMCAxIC4wMSAxLjAxelwiLz48Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjE2XCIgcj1cIjFcIi8+PHBhdGggZD1cIk0xMiA4YTEgMSAwIDAgMC0xIDF2NGExIDEgMCAwIDAgMiAwVjlhMSAxIDAgMCAwLTEtMXpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ3F1ZXN0aW9uLW1hcmstb3V0bGluZSc6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwicXVlc3Rpb24tbWFya1wiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgxODAgMTIgMTIpXCIgb3BhY2l0eT1cIjBcIi8+PHBhdGggZD1cIk0xNyA5QTUgNSAwIDAgMCA3IDlhMSAxIDAgMCAwIDIgMCAzIDMgMCAxIDEgMyAzIDEgMSAwIDAgMC0xIDF2MmExIDEgMCAwIDAgMiAwdi0xLjFBNSA1IDAgMCAwIDE3IDl6XCIvPjxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTlcIiByPVwiMVwiLz48L2c+PC9nPjwvc3ZnPicsXG4gICAgICAgICAgICAnZW1haWwtb3V0bGluZSc6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwiZW1haWxcIj48cmVjdCB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTE5IDRINWEzIDMgMCAwIDAtMyAzdjEwYTMgMyAwIDAgMCAzIDNoMTRhMyAzIDAgMCAwIDMtM1Y3YTMgMyAwIDAgMC0zLTN6bS0uNjcgMkwxMiAxMC43NSA1LjY3IDZ6TTE5IDE4SDVhMSAxIDAgMCAxLTEtMVY3LjI1bDcuNCA1LjU1YTEgMSAwIDAgMCAuNi4yIDEgMSAwIDAgMCAuNi0uMkwyMCA3LjI1VjE3YTEgMSAwIDAgMS0xIDF6XCIvPjwvZz48L2c+PC9zdmc+JyxcbiAgICAgICAgICAgICdmbGFzaC1vdXRsaW5lJzogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxnIGRhdGEtbmFtZT1cIkxheWVyIDJcIj48ZyBkYXRhLW5hbWU9XCJmbGFzaFwiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIG9wYWNpdHk9XCIwXCIvPjxwYXRoIGQ9XCJNMTEuMTEgMjNhMSAxIDAgMCAxLS4zNC0uMDYgMSAxIDAgMCAxLS42NS0xLjA1bC43Ny03LjA5SDVhMSAxIDAgMCAxLS44My0xLjU2bDcuODktMTEuOGExIDEgMCAwIDEgMS4xNy0uMzggMSAxIDAgMCAxIC42NSAxbC0uNzcgNy4xNEgxOWExIDEgMCAwIDEgLjgzIDEuNTZsLTcuODkgMTEuOGExIDEgMCAwIDEtLjgzLjQ0ek02Ljg3IDEyLjhIMTJhMSAxIDAgMCAxIC43NC4zMyAxIDEgMCAwIDEgLjI1Ljc4bC0uNDUgNC4xNSA0LjU5LTYuODZIMTJhMSAxIDAgMCAxLTEtMS4xMWwuNDUtNC4xNXpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ3NlYXJjaC1vdXRsaW5lJzogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxnIGRhdGEtbmFtZT1cIkxheWVyIDJcIj48ZyBkYXRhLW5hbWU9XCJzZWFyY2hcIj48cmVjdCB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTIwLjcxIDE5LjI5bC0zLjQtMy4zOUE3LjkyIDcuOTIgMCAwIDAgMTkgMTFhOCA4IDAgMSAwLTggOCA3LjkyIDcuOTIgMCAwIDAgNC45LTEuNjlsMy4zOSAzLjRhMSAxIDAgMCAwIDEuNDIgMCAxIDEgMCAwIDAgMC0xLjQyek01IDExYTYgNiAwIDEgMSA2IDYgNiA2IDAgMCAxLTYtNnpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ2Nsb3NlLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImNsb3NlXCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdHJhbnNmb3JtPVwicm90YXRlKDE4MCAxMiAxMilcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTEzLjQxIDEybDQuMy00LjI5YTEgMSAwIDEgMC0xLjQyLTEuNDJMMTIgMTAuNTlsLTQuMjktNC4zYTEgMSAwIDAgMC0xLjQyIDEuNDJsNC4zIDQuMjktNC4zIDQuMjlhMSAxIDAgMCAwIDAgMS40MiAxIDEgMCAwIDAgMS40MiAwbDQuMjktNC4zIDQuMjkgNC4zYTEgMSAwIDAgMCAxLjQyIDAgMSAxIDAgMCAwIDAtMS40MnpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ2NvbGxhcHNlLW91dGxpbmUnOiAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+PGcgZGF0YS1uYW1lPVwiTGF5ZXIgMlwiPjxnIGRhdGEtbmFtZT1cImNvbGxhcHNlXCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdHJhbnNmb3JtPVwicm90YXRlKDE4MCAxMiAxMilcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTE5IDloLTIuNThsMy4yOS0zLjI5YTEgMSAwIDEgMC0xLjQyLTEuNDJMMTUgNy41N1Y1YTEgMSAwIDAgMC0xLTEgMSAxIDAgMCAwLTEgMXY1YTEgMSAwIDAgMCAxIDFoNWExIDEgMCAwIDAgMC0yelwiLz48cGF0aCBkPVwiTTEwIDEzSDVhMSAxIDAgMCAwIDAgMmgyLjU3bC0zLjI4IDMuMjlhMSAxIDAgMCAwIDAgMS40MiAxIDEgMCAwIDAgMS40MiAwTDkgMTYuNDJWMTlhMSAxIDAgMCAwIDEgMSAxIDEgMCAwIDAgMS0xdi01YTEgMSAwIDAgMC0xLTF6XCIvPjwvZz48L2c+PC9zdmc+JyxcbiAgICAgICAgICAgICdleHBhbmQtb3V0bGluZSc6ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwiZXhwYW5kXCI+PHJlY3Qgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdHJhbnNmb3JtPVwicm90YXRlKDE4MCAxMiAxMilcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTIwIDVhMSAxIDAgMCAwLTEtMWgtNWExIDEgMCAwIDAgMCAyaDIuNTdsLTMuMjggMy4yOWExIDEgMCAwIDAgMCAxLjQyIDEgMSAwIDAgMCAxLjQyIDBMMTggNy40MlYxMGExIDEgMCAwIDAgMSAxIDEgMSAwIDAgMCAxLTF6XCIvPjxwYXRoIGQ9XCJNMTAuNzEgMTMuMjlhMSAxIDAgMCAwLTEuNDIgMEw2IDE2LjU3VjE0YTEgMSAwIDAgMC0xLTEgMSAxIDAgMCAwLTEgMXY1YTEgMSAwIDAgMCAxIDFoNWExIDEgMCAwIDAgMC0ySDcuNDJsMy4yOS0zLjI5YTEgMSAwIDAgMCAwLTEuNDJ6XCIvPjwvZz48L2c+PC9zdmc+JyxcbiAgICAgICAgICAgICdtaW51cy1vdXRsaW5lJzogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPjxnIGRhdGEtbmFtZT1cIkxheWVyIDJcIj48ZyBkYXRhLW5hbWU9XCJtaW51c1wiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHRyYW5zZm9ybT1cInJvdGF0ZSgxODAgMTIgMTIpXCIgb3BhY2l0eT1cIjBcIi8+PHBhdGggZD1cIk0xOSAxM0g1YTEgMSAwIDAgMSAwLTJoMTRhMSAxIDAgMCAxIDAgMnpcIi8+PC9nPjwvZz48L3N2Zz4nLFxuICAgICAgICAgICAgJ21pbnVzLWJvbGQtb3V0bGluZSc6ICc8c3ZnIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDggMlwiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIj48ZGVmcz48cmVjdCBpZD1cIm5iLW1ib1wiIHk9XCIzXCIgd2lkdGg9XCI4XCIgaGVpZ2h0PVwiMlwiIHJ4PVwiMVwiLz48L2RlZnM+PHVzZSB4bGluazpocmVmPVwiI25iLW1ib1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwIC0zKVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgICAgICAgICAgICdjaGVja21hcmstYm9sZC1vdXRsaW5lJzogJzxzdmcgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgOCA3XCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiPjxkZWZzPjxwYXRoIGlkPVwibmItY2JvXCIgZD1cIk02LjAzOSAxLjQzYTEuMTEgMS4xMSAwIDAgMSAxLjUxNy0uMjI4Yy40ODMuMzQyLjU4OC45OTguMjM0IDEuNDY2TDQuNDMxIDcuMWExIDEgMCAwIDEtMS40OTIuMTE1TC4zMTcgNC42NzdhMS4wMjMgMS4wMjMgMCAwIDEgLjAwMi0xLjQ4MyAxLjExMyAxLjExMyAwIDAgMSAxLjUzNS4wMDJsMS42NDEgMS41OUw2LjA0IDEuNDI4elwiLz48L2RlZnM+PHVzZSB4bGluazpocmVmPVwiI25iLWNib1wiIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSgwIC0xKVwiIGZpbGwtcnVsZT1cImV2ZW5vZGRcIi8+PC9zdmc+JyxcbiAgICAgICAgICAgICdhcnJvdy1iYWNrJzogJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj48ZyBkYXRhLW5hbWU9XCJMYXllciAyXCI+PGcgZGF0YS1uYW1lPVwiYXJyb3ctYmFja1wiPjxyZWN0IHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHRyYW5zZm9ybT1cInJvdGF0ZSg5MCAxMiAxMilcIiBvcGFjaXR5PVwiMFwiLz48cGF0aCBkPVwiTTE5IDExSDcuMTRsMy42My00LjM2YTEgMSAwIDEgMC0xLjU0LTEuMjhsLTUgNmExLjE5IDEuMTkgMCAwIDAtLjA5LjE1YzAgLjA1IDAgLjA4LS4wNy4xM0ExIDEgMCAwIDAgNCAxMmExIDEgMCAwIDAgLjA3LjM2YzAgLjA1IDAgLjA4LjA3LjEzYTEuMTkgMS4xOSAwIDAgMCAuMDkuMTVsNSA2QTEgMSAwIDAgMCAxMCAxOWExIDEgMCAwIDAgLjY0LS4yMyAxIDEgMCAwIDAgLjEzLTEuNDFMNy4xNCAxM0gxOWExIDEgMCAwIDAgMC0yelwiLz48L2c+PC9nPjwvc3ZnPicsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aFxuICAgIH1cbn07XG5OYkljb25Nb2R1bGUgPSBfX2RlY29yYXRlJDI0KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBOYkljb25Db21wb25lbnQsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIE5iSWNvbkNvbXBvbmVudCxcbiAgICAgICAgXSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDE0KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iSWNvbkxpYnJhcmllc10pXG5dLCBOYkljb25Nb2R1bGUpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQyNyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxNiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBDb21wb25lbnQgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoaW4gdGhlIGA8bmItY2FyZD5gIGNvbXBvbmVudC5cbiAqIEl0IGFkZHMgc3R5bGVzIGZvciBhIHByZXNldCBoZWFkZXIgc2VjdGlvbi5cbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogY2FyZC1oZWFkZXItdGV4dC1jb2xvcjpcbiAqIGNhcmQtaGVhZGVyLXRleHQtZm9udC1mYW1pbHk6XG4gKiBjYXJkLWhlYWRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIGNhcmQtaGVhZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYXJkLWhlYWRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogY2FyZC1oZWFkZXItYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhcmQtaGVhZGVyLWJhc2ljLXRleHQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci1pbmZvLXRleHQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci13YXJuaW5nLXRleHQtY29sb3I6XG4gKiBjYXJkLWhlYWRlci1kYW5nZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhcmQtaGVhZGVyLWRhbmdlci10ZXh0LWNvbG9yOlxuICogY2FyZC1oZWFkZXItY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FyZC1oZWFkZXItY29udHJvbC10ZXh0LWNvbG9yOlxuICovXG5sZXQgTmJDYXJkSGVhZGVyQ29tcG9uZW50ID0gY2xhc3MgTmJDYXJkSGVhZGVyQ29tcG9uZW50IHtcbn07XG5OYkNhcmRIZWFkZXJDb21wb25lbnQgPSBfX2RlY29yYXRlJDI3KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWNhcmQtaGVhZGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YFxuICAgIH0pXG5dLCBOYkNhcmRIZWFkZXJDb21wb25lbnQpO1xuLyoqXG4gKiBDb21wb25lbnQgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoaW4gIHRoZSBgPG5iLWNhcmQ+YCBjb21wb25lbnQuXG4gKiBBZGRzIHN0eWxlcyBmb3IgYSBwcmVzZXQgYm9keSBzZWN0aW9uLlxuICovXG5sZXQgTmJDYXJkQm9keUNvbXBvbmVudCA9IGNsYXNzIE5iQ2FyZEJvZHlDb21wb25lbnQge1xufTtcbk5iQ2FyZEJvZHlDb21wb25lbnQgPSBfX2RlY29yYXRlJDI3KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWNhcmQtYm9keScsXG4gICAgICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PmBcbiAgICB9KVxuXSwgTmJDYXJkQm9keUNvbXBvbmVudCk7XG4vKipcbiAqIENvbXBvbmVudCBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGhpbiAgdGhlIGA8bmItY2FyZD5gIGNvbXBvbmVudC5cbiAqIEFkZHMgc3R5bGVzIGZvciBhIHByZXNldCBmb290ZXIgc2VjdGlvbi5cbiAqL1xubGV0IE5iQ2FyZEZvb3RlckNvbXBvbmVudCA9IGNsYXNzIE5iQ2FyZEZvb3RlckNvbXBvbmVudCB7XG59O1xuTmJDYXJkRm9vdGVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQyNyhbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jYXJkLWZvb3RlcicsXG4gICAgICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PmBcbiAgICB9KVxuXSwgTmJDYXJkRm9vdGVyQ29tcG9uZW50KTtcbi8qKlxuICogQmFzaWMgY29udGVudCBjb250YWluZXIgY29tcG9uZW50LlxuICpcbiAqIEJhc2ljIGNhcmQgZXhhbXBsZTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGNhcmQvY2FyZC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogQmFzaWMgY2FyZCBjb25maWd1cmF0aW9uOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1jYXJkPlxuICogICA8bmItY2FyZC1ib2R5PlxuICogICAgIENhcmRcbiAqICAgPC9uYi1jYXJkLWJvZHk+XG4gKiA8L25iLWNhcmQ+XG4gKiBgYGBcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkNhcmRNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iQ2FyZE1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogQ2FyZCB3aXRoIGhlYWRlciBhbmQgZm9vdGVyOlxuICogQHN0YWNrZWQtZXhhbXBsZShXaXRoIEhlYWRlciAmIEZvb3RlciwgY2FyZC9jYXJkLWZ1bGwuY29tcG9uZW50KVxuICpcbiAqIE1vc3Qgb2YgdGhlIHRpbWUgbWFpbiBjYXJkIGNvbnRlbnQgZ29lcyB0byBgbmItY2FyZC1ib2R5YCxcbiAqIHNvIGl0IGlzIHN0eWxlZCBhbmQgYWxpZ25lZCBpbiBhY2NvcmRhbmNlIHdpdGggdGhlIGhlYWRlciBhbmQgZm9vdGVyLlxuICogSW4gY2FzZSB5b3UgbmVlZCBhIGhpZ2hlciBsZXZlbCBvZiBjb250cm9sLCB5b3UgY2FuIHBhc3MgY29udGVuZCBkaXJlY3RseSB0byBgbmItY2FyZGAsXG4gKiBzbyBgbmItY2FyZC1ib2R5YCBzdHlsaW5nIHdpbGwgbm90IGJlIGFwcGxpZWQuXG4gKlxuICogQ29uc2lkZXIgYW4gZXhhbXBsZSB3aXRoIGBuYi1saXN0YCBjb21wb25lbnQ6XG4gKiBAc3RhY2tlZC1leGFtcGxlKENhcmQgd2l0aCBsaXN0LCBjYXJkL2NhcmQtd2l0aG91dC1ib2R5LmNvbXBvbmVudClcbiAqXG4gKiBDb2xvcmVkIGNhcmRzIGNvdWxkIGJlIHNpbXBseSBjb25maWd1cmVkIGJ5IHByb3ZpZGluZyBhIGBzdGF0dXNgIHByb3BlcnR5OlxuICogQHN0YWNrZWQtZXhhbXBsZShDb2xvcmVkIENhcmQsIGNhcmQvY2FyZC1jb2xvcnMuY29tcG9uZW50KVxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gYXNzaWduIGFuIGBhY2NlbnRgIHByb3BlcnR5IGZvciBhIHNsaWdodCBjYXJkIGhpZ2hsaWdodFxuICogYXMgd2VsbCBhcyBjb21iaW5lIGl0IHdpdGggYHN0YXR1c2A6XG4gKiBAc3RhY2tlZC1leGFtcGxlKEFjY2VudCBDYXJkLCBjYXJkL2NhcmQtYWNjZW50cy5jb21wb25lbnQpXG4gKlxuICogQ2FyZHMgb2Ygc21hbGxlciBzaXplcyBjb3VsZCBiZSBjb21iaW5lZCBhbmQgcHV0IG9uIHRoZSBzYW1lIHJvdyB3aXRoIGEgYmlnZ2VyIGNhcmQgc28gdGhleSBoYXZlIHRoZSBzYW1lIGhlaWdodHMuXG4gKiBAc3RhY2tlZC1leGFtcGxlKENhcmQgc2l6ZXMgY29tYmluYXRpb25zLCBjYXJkL2NhcmQtc2l6ZXMtY29tYmluYXRpb25zLmNvbXBvbmVudClcbiAqXG4gKiBAYWRkaXRpb25hbC1leGFtcGxlKE11bHRpcGxlIFNpemVzLCBjYXJkL2NhcmQtc2l6ZXMuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBjYXJkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYXJkLXRleHQtY29sb3I6XG4gKiBjYXJkLXRleHQtZm9udC1mYW1pbHk6XG4gKiBjYXJkLXRleHQtZm9udC1zaXplOlxuICogY2FyZC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogY2FyZC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogY2FyZC1ib3JkZXItd2lkdGg6XG4gKiBjYXJkLWJvcmRlci1zdHlsZTpcbiAqIGNhcmQtYm9yZGVyLWNvbG9yOlxuICogY2FyZC1ib3JkZXItcmFkaXVzOlxuICogY2FyZC1wYWRkaW5nOlxuICogY2FyZC1zaGFkb3c6XG4gKiBjYXJkLWRpdmlkZXItY29sb3I6XG4gKiBjYXJkLWRpdmlkZXItc3R5bGU6XG4gKiBjYXJkLWRpdmlkZXItd2lkdGg6XG4gKiBjYXJkLWhlaWdodC10aW55OlxuICogY2FyZC1oZWlnaHQtc21hbGw6XG4gKiBjYXJkLWhlaWdodC1tZWRpdW06XG4gKiBjYXJkLWhlaWdodC1sYXJnZTpcbiAqIGNhcmQtaGVpZ2h0LWdpYW50OlxuICogY2FyZC1tYXJnaW4tYm90dG9tOlxuICogY2FyZC1zY3JvbGxiYXItY29sb3I6XG4gKiBjYXJkLXNjcm9sbGJhci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FyZC1zY3JvbGxiYXItd2lkdGg6XG4gKi9cbmxldCBOYkNhcmRDb21wb25lbnQgPSBjbGFzcyBOYkNhcmRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEJhc2ljIGNvbnRlbnQgY29udGFpbmVyIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEJhc2ljIGNhcmQgZXhhbXBsZTpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBjYXJkL2NhcmQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogQmFzaWMgY2FyZCBjb25maWd1cmF0aW9uOlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuYi1jYXJkPlxuICAgICAqICAgPG5iLWNhcmQtYm9keT5cbiAgICAgKiAgICAgQ2FyZFxuICAgICAqICAgPC9uYi1jYXJkLWJvZHk+XG4gICAgICogPC9uYi1jYXJkPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEluc3RhbGxhdGlvblxuICAgICAqXG4gICAgICogSW1wb3J0IGBOYkNhcmRNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gICAgICogYGBgdHNcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgaW1wb3J0czogW1xuICAgICAqICAgICAvLyAuLi5cbiAgICAgKiAgICAgTmJDYXJkTW9kdWxlLFxuICAgICAqICAgXSxcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICAgICAqIGBgYFxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogQ2FyZCB3aXRoIGhlYWRlciBhbmQgZm9vdGVyOlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoV2l0aCBIZWFkZXIgJiBGb290ZXIsIGNhcmQvY2FyZC1mdWxsLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIE1vc3Qgb2YgdGhlIHRpbWUgbWFpbiBjYXJkIGNvbnRlbnQgZ29lcyB0byBgbmItY2FyZC1ib2R5YCxcbiAgICAgKiBzbyBpdCBpcyBzdHlsZWQgYW5kIGFsaWduZWQgaW4gYWNjb3JkYW5jZSB3aXRoIHRoZSBoZWFkZXIgYW5kIGZvb3Rlci5cbiAgICAgKiBJbiBjYXNlIHlvdSBuZWVkIGEgaGlnaGVyIGxldmVsIG9mIGNvbnRyb2wsIHlvdSBjYW4gcGFzcyBjb250ZW5kIGRpcmVjdGx5IHRvIGBuYi1jYXJkYCxcbiAgICAgKiBzbyBgbmItY2FyZC1ib2R5YCBzdHlsaW5nIHdpbGwgbm90IGJlIGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBDb25zaWRlciBhbiBleGFtcGxlIHdpdGggYG5iLWxpc3RgIGNvbXBvbmVudDpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKENhcmQgd2l0aCBsaXN0LCBjYXJkL2NhcmQtd2l0aG91dC1ib2R5LmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIENvbG9yZWQgY2FyZHMgY291bGQgYmUgc2ltcGx5IGNvbmZpZ3VyZWQgYnkgcHJvdmlkaW5nIGEgYHN0YXR1c2AgcHJvcGVydHk6XG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShDb2xvcmVkIENhcmQsIGNhcmQvY2FyZC1jb2xvcnMuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhc3NpZ24gYW4gYGFjY2VudGAgcHJvcGVydHkgZm9yIGEgc2xpZ2h0IGNhcmQgaGlnaGxpZ2h0XG4gICAgICogYXMgd2VsbCBhcyBjb21iaW5lIGl0IHdpdGggYHN0YXR1c2A6XG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShBY2NlbnQgQ2FyZCwgY2FyZC9jYXJkLWFjY2VudHMuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogQ2FyZHMgb2Ygc21hbGxlciBzaXplcyBjb3VsZCBiZSBjb21iaW5lZCBhbmQgcHV0IG9uIHRoZSBzYW1lIHJvdyB3aXRoIGEgYmlnZ2VyIGNhcmQgc28gdGhleSBoYXZlIHRoZSBzYW1lIGhlaWdodHMuXG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShDYXJkIHNpemVzIGNvbWJpbmF0aW9ucywgY2FyZC9jYXJkLXNpemVzLWNvbWJpbmF0aW9ucy5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBAYWRkaXRpb25hbC1leGFtcGxlKE11bHRpcGxlIFNpemVzLCBjYXJkL2NhcmQtc2l6ZXMuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogQHN0eWxlc1xuICAgICAqXG4gICAgICogY2FyZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGNhcmQtdGV4dC1jb2xvcjpcbiAgICAgKiBjYXJkLXRleHQtZm9udC1mYW1pbHk6XG4gICAgICogY2FyZC10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBjYXJkLXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogY2FyZC10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIGNhcmQtYm9yZGVyLXdpZHRoOlxuICAgICAqIGNhcmQtYm9yZGVyLXN0eWxlOlxuICAgICAqIGNhcmQtYm9yZGVyLWNvbG9yOlxuICAgICAqIGNhcmQtYm9yZGVyLXJhZGl1czpcbiAgICAgKiBjYXJkLXBhZGRpbmc6XG4gICAgICogY2FyZC1zaGFkb3c6XG4gICAgICogY2FyZC1kaXZpZGVyLWNvbG9yOlxuICAgICAqIGNhcmQtZGl2aWRlci1zdHlsZTpcbiAgICAgKiBjYXJkLWRpdmlkZXItd2lkdGg6XG4gICAgICogY2FyZC1oZWlnaHQtdGlueTpcbiAgICAgKiBjYXJkLWhlaWdodC1zbWFsbDpcbiAgICAgKiBjYXJkLWhlaWdodC1tZWRpdW06XG4gICAgICogY2FyZC1oZWlnaHQtbGFyZ2U6XG4gICAgICogY2FyZC1oZWlnaHQtZ2lhbnQ6XG4gICAgICogY2FyZC1tYXJnaW4tYm90dG9tOlxuICAgICAqIGNhcmQtc2Nyb2xsYmFyLWNvbG9yOlxuICAgICAqIGNhcmQtc2Nyb2xsYmFyLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogY2FyZC1zY3JvbGxiYXItd2lkdGg6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhcmQgc3RhdHVzOlxuICAgICAgICAgKiBgYmFzaWNgLCBgcHJpbWFyeWAsIGBpbmZvYCwgYHN1Y2Nlc3NgLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgY29udHJvbGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdHVzID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYXJkIGFjY2VudCAoY29sb3Igb2YgdGhlIHRvcCBib3JkZXIpOlxuICAgICAgICAgKiBgYmFzaWNgLCBgcHJpbWFyeWAsIGBpbmZvYCwgYHN1Y2Nlc3NgLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgY29udHJvbGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWNjZW50ID0gJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhcmQgc2l6ZSwgYXZhaWxhYmxlIHNpemVzOlxuICAgICAqIHRpbnksIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCBnaWFudFxuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgc2V0IHNpemUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdGlueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3RpbnknO1xuICAgIH1cbiAgICBnZXQgc21hbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdzbWFsbCc7XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdtZWRpdW0nO1xuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdsYXJnZSc7XG4gICAgfVxuICAgIGdldCBnaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2dpYW50JztcbiAgICB9XG4gICAgZ2V0IHByaW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgYmFzaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2NvbnRyb2wnO1xuICAgIH1cbiAgICBnZXQgaGFzQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQ7XG4gICAgfVxuICAgIGdldCBwcmltYXJ5QWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IGluZm9BY2NlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY2VudCA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgc3VjY2Vzc0FjY2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZW50ID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlckFjY2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZW50ID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICdjb250cm9sJztcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQyNyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDE2KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhJDE2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBOYkNhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDI3KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXR1c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQyNyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDE2KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhY2NlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLXRpbnknKSxcbiAgICBfX21ldGFkYXRhJDE2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDE2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInRpbnlcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDI3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1zbWFsbCcpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwic21hbGxcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDI3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1tZWRpdW0nKSxcbiAgICBfX21ldGFkYXRhJDE2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDE2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhcmRDb21wb25lbnQucHJvdG90eXBlLCBcIm1lZGl1bVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLWxhcmdlJyksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYXJnZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLWdpYW50JyksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJnaWFudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtcHJpbWFyeScpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwicHJpbWFyeVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtaW5mbycpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5mb1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtc3VjY2VzcycpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwic3VjY2Vzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtd2FybmluZycpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwid2FybmluZ1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtZGFuZ2VyJyksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYW5nZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDI3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWJhc2ljJyksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXNpY1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtY29udHJvbCcpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NlbnQnKSxcbiAgICBfX21ldGFkYXRhJDE2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDE2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhcmRDb21wb25lbnQucHJvdG90eXBlLCBcImhhc0FjY2VudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NlbnQtcHJpbWFyeScpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwicHJpbWFyeUFjY2VudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NlbnQtaW5mbycpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5mb0FjY2VudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NlbnQtc3VjY2VzcycpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwic3VjY2Vzc0FjY2VudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NlbnQtd2FybmluZycpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwid2FybmluZ0FjY2VudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NlbnQtZGFuZ2VyJyksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYW5nZXJBY2NlbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDI3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MuYWNjZW50LWJhc2ljJyksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxNihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYXJkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXNpY0FjY2VudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NlbnQtY29udHJvbCcpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udHJvbEFjY2VudFwiLCBudWxsKTtcbk5iQ2FyZENvbXBvbmVudCA9IF9fZGVjb3JhdGUkMjcoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItY2FyZCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItY2FyZC1oZWFkZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItY2FyZC1ib2R5XCI+PC9uZy1jb250ZW50PlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1jYXJkLWZvb3RlclwiPjwvbmctY29udGVudD5cbiAgYCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufVxcblwiXVxuICAgIH0pXG5dLCBOYkNhcmRDb21wb25lbnQpO1xuXG52YXIgX19kZWNvcmF0ZSQyOCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxNyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKlxuICogUmV2ZWFsIGNhcmQgZXhhbXBsZTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoTXkgZXhhbXBsZSwgcmV2ZWFsLWNhcmQvcmV2ZWFsLWNhcmQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIEFzIGEgY29udGVudCBSZXZlYWwgY2FyZCBhY2NlcHRzIHR3byBpbnN0YW5jZXMgb2YgYG5iLWNhcmRgIC0gZm9yIGZyb250IGFuZCBiYWNrIHNpZGVzLlxuICpcbiAqIEJhc2ljIHJldmVhbCBjYXJkIGNvbmZpZ3VyYXRpb246XG4gKlxuICogYGBgaHRtbFxuICogPG5iLXJldmVhbC1jYXJkPlxuICogICA8bmItY2FyZC1mcm9udD5cbiAqICAgICA8bmItY2FyZD5cbiAqICAgICAgIDxuYi1jYXJkLWJvZHk+XG4gKiAgICAgICAgIEZyb250XG4gKiAgICAgICA8L25iLWNhcmQtYm9keT5cbiAqICAgICA8L25iLWNhcmQ+XG4gKiAgIDwvbmItY2FyZC1mcm9udD5cbiAqICAgPG5iLWNhcmQtYmFjaz5cbiAqICAgICA8bmItY2FyZD5cbiAqICAgICAgIDxuYi1jYXJkLWJvZHk+XG4gKiAgICAgICAgIEJhY2tcbiAqICAgICAgIDwvbmItY2FyZC1ib2R5PlxuICogICAgIDwvbmItY2FyZD5cbiAqICAgPC9uYi1jYXJkLWJhY2s+XG4gKiA8L25iLXJldmVhbC1jYXJkPlxuICogYGBgXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJDYXJkTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkNhcmRNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIFJldmVhbCBDYXJkIHdpdGggaGVhZGVyIGFuZCBmb290ZXI6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFdpdGggSGVhZGVyICYgRm9vdGVyLCByZXZlYWwtY2FyZC9yZXZlYWwtY2FyZC1mdWxsLmNvbXBvbmVudClcbiAqXG4gKiBDb2xvcmVkIHJldmVhbC1jYXJkcyBjb3VsZCBiZSBzaW1wbHkgY29uZmlndXJlZCBieSBwcm92aWRpbmcgYSBgc3RhdHVzYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ29sb3JlZCBDYXJkLCByZXZlYWwtY2FyZC9yZXZlYWwtY2FyZC1jb2xvcnMuY29tcG9uZW50KVxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gYXNzaWduIGFuIGBhY2NlbnRgIHByb3BlcnR5IGZvciBhIHNsaWdodCBjYXJkIGhpZ2hsaWdodFxuICogYXMgd2VsbCBhcyBjb21iaW5lIGl0IHdpdGggYHN0YXR1c2A6XG4gKiBAc3RhY2tlZC1leGFtcGxlKEFjY2VudCBDYXJkLCByZXZlYWwtY2FyZC9yZXZlYWwtY2FyZC1hY2NlbnRzLmNvbXBvbmVudClcbiAqXG4gKiBAYWRkaXRpb25hbC1leGFtcGxlKE11bHRpcGxlIFNpemVzLCByZXZlYWwtY2FyZC9yZXZlYWwtY2FyZC1zaXplcy5jb21wb25lbnQpXG4gKi9cbmxldCBOYlJldmVhbENhcmRDb21wb25lbnQgPSBjbGFzcyBOYlJldmVhbENhcmRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogUmV2ZWFsIGNhcmQgZXhhbXBsZTpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKE15IGV4YW1wbGUsIHJldmVhbC1jYXJkL3JldmVhbC1jYXJkLXNob3djYXNlLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEFzIGEgY29udGVudCBSZXZlYWwgY2FyZCBhY2NlcHRzIHR3byBpbnN0YW5jZXMgb2YgYG5iLWNhcmRgIC0gZm9yIGZyb250IGFuZCBiYWNrIHNpZGVzLlxuICAgICAqXG4gICAgICogQmFzaWMgcmV2ZWFsIGNhcmQgY29uZmlndXJhdGlvbjpcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmItcmV2ZWFsLWNhcmQ+XG4gICAgICogICA8bmItY2FyZC1mcm9udD5cbiAgICAgKiAgICAgPG5iLWNhcmQ+XG4gICAgICogICAgICAgPG5iLWNhcmQtYm9keT5cbiAgICAgKiAgICAgICAgIEZyb250XG4gICAgICogICAgICAgPC9uYi1jYXJkLWJvZHk+XG4gICAgICogICAgIDwvbmItY2FyZD5cbiAgICAgKiAgIDwvbmItY2FyZC1mcm9udD5cbiAgICAgKiAgIDxuYi1jYXJkLWJhY2s+XG4gICAgICogICAgIDxuYi1jYXJkPlxuICAgICAqICAgICAgIDxuYi1jYXJkLWJvZHk+XG4gICAgICogICAgICAgICBCYWNrXG4gICAgICogICAgICAgPC9uYi1jYXJkLWJvZHk+XG4gICAgICogICAgIDwvbmItY2FyZD5cbiAgICAgKiAgIDwvbmItY2FyZC1iYWNrPlxuICAgICAqIDwvbmItcmV2ZWFsLWNhcmQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgSW5zdGFsbGF0aW9uXG4gICAgICpcbiAgICAgKiBJbXBvcnQgYE5iQ2FyZE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAgICAgKiBgYGB0c1xuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBpbXBvcnRzOiBbXG4gICAgICogICAgIC8vIC4uLlxuICAgICAqICAgICBOYkNhcmRNb2R1bGUsXG4gICAgICogICBdLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gICAgICogYGBgXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBSZXZlYWwgQ2FyZCB3aXRoIGhlYWRlciBhbmQgZm9vdGVyOlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoV2l0aCBIZWFkZXIgJiBGb290ZXIsIHJldmVhbC1jYXJkL3JldmVhbC1jYXJkLWZ1bGwuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogQ29sb3JlZCByZXZlYWwtY2FyZHMgY291bGQgYmUgc2ltcGx5IGNvbmZpZ3VyZWQgYnkgcHJvdmlkaW5nIGEgYHN0YXR1c2AgcHJvcGVydHk6XG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShDb2xvcmVkIENhcmQsIHJldmVhbC1jYXJkL3JldmVhbC1jYXJkLWNvbG9ycy5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFzc2lnbiBhbiBgYWNjZW50YCBwcm9wZXJ0eSBmb3IgYSBzbGlnaHQgY2FyZCBoaWdobGlnaHRcbiAgICAgKiBhcyB3ZWxsIGFzIGNvbWJpbmUgaXQgd2l0aCBgc3RhdHVzYDpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKEFjY2VudCBDYXJkLCByZXZlYWwtY2FyZC9yZXZlYWwtY2FyZC1hY2NlbnRzLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoTXVsdGlwbGUgU2l6ZXMsIHJldmVhbC1jYXJkL3JldmVhbC1jYXJkLXNpemVzLmNvbXBvbmVudClcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldmVhbCBzdGF0ZVxuICAgICAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJldmVhbGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93L2hpZGUgdG9nZ2xlIGJ1dHRvbiB0byBiZSBhYmxlIHRvIGNvbnRyb2wgdG9nZ2xlIGZyb20geW91ciBjb2RlXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93VG9nZ2xlQnV0dG9uID0gdHJ1ZTtcbiAgICB9XG4gICAgdG9nZ2xlKCkge1xuICAgICAgICB0aGlzLnJldmVhbGVkID0gIXRoaXMucmV2ZWFsZWQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMjgoW1xuICAgIElucHV0KCksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnJldmVhbGVkJyksXG4gICAgX19tZXRhZGF0YSQxNyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYlJldmVhbENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInJldmVhbGVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDI4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTcoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYlJldmVhbENhcmRDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dUb2dnbGVCdXR0b25cIiwgdm9pZCAwKTtcbk5iUmV2ZWFsQ2FyZENvbXBvbmVudCA9IF9fZGVjb3JhdGUkMjgoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItcmV2ZWFsLWNhcmQnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWNhcmQtZnJvbnRcIj48L25nLWNvbnRlbnQ+XG4gICAgPGRpdiBjbGFzcz1cInNlY29uZC1jYXJkLWNvbnRhaW5lclwiPlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItY2FyZC1iYWNrXCI+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuICAgIDxhICpuZ0lmPVwic2hvd1RvZ2dsZUJ1dHRvblwiIGNsYXNzPVwicmV2ZWFsLWJ1dHRvblwiIChjbGljayk9XCJ0b2dnbGUoKVwiPlxuICAgICAgPG5iLWljb24gaWNvbj1cImNoZXZyb24tZG93bi1vdXRsaW5lXCIgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvbmItaWNvbj5cbiAgICA8L2E+XG4gIGAsXG4gICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpibG9jaztwb3NpdGlvbjpyZWxhdGl2ZTtvdmVyZmxvdzpoaWRkZW59Omhvc3QgLnNlY29uZC1jYXJkLWNvbnRhaW5lcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTAwJTtyaWdodDowO2xlZnQ6MDtvdmVyZmxvdzpoaWRkZW47dHJhbnNpdGlvbjp0b3AgMHMgMC41c306aG9zdCA6Om5nLWRlZXAgbmItY2FyZC1mcm9udCBuYi1jYXJkLDpob3N0IDo6bmctZGVlcCBuYi1jYXJkLWJhY2sgbmItY2FyZHtib3gtc2hhZG93Om5vbmU7bWFyZ2luOjB9Omhvc3QgOjpuZy1kZWVwIG5iLWNhcmQtZnJvbnR7ZGlzcGxheTpibG9jaztoZWlnaHQ6MTAwJX06aG9zdCA6Om5nLWRlZXAgbmItY2FyZC1iYWNre3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MTAwJTt3aWR0aDoxMDAlO3RyYW5zaXRpb246dG9wIDAuNXN9Omhvc3QgLnJldmVhbC1idXR0b257Y3Vyc29yOnBvaW50ZXI7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDtib3R0b206MDt0cmFuc2Zvcm06cm90YXRlKDE4MGRlZyk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC4zc306aG9zdCgucmV2ZWFsZWQpIC5zZWNvbmQtY2FyZC1jb250YWluZXJ7dG9wOjA7dHJhbnNpdGlvbjpub25lfTpob3N0KC5yZXZlYWxlZCkgLnNlY29uZC1jYXJkLWNvbnRhaW5lciA6Om5nLWRlZXAgbmItY2FyZC1iYWNre3RvcDowfTpob3N0KC5yZXZlYWxlZCkgLnJldmVhbC1idXR0b257dHJhbnNmb3JtOm5vbmV9XFxuXCJdXG4gICAgfSlcbl0sIE5iUmV2ZWFsQ2FyZENvbXBvbmVudCk7XG5cbnZhciBfX2RlY29yYXRlJDI5ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDE4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqXG4gKiBGbGlwIGNhcmQgZXhhbXBsZTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGZsaXAtY2FyZC9mbGlwLWNhcmQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIEFzIGEgY29udGVudCBGbGlwIGNhcmQgYWNjZXB0cyB0d28gaW5zdGFuY2VzIG9mIGBuYi1jYXJkYCAtIGZvciBmcm9udCBhbmQgYmFjayBzaWRlcy5cbiAqXG4gKiBCYXNpYyBmbGlwIGNhcmQgY29uZmlndXJhdGlvbjpcbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItZmxpcC1jYXJkPlxuICogICA8bmItY2FyZC1mcm9udD5cbiAqICAgICA8bmItY2FyZD5cbiAqICAgICAgIDxuYi1jYXJkLWJvZHk+XG4gKiAgICAgICAgIEZyb250XG4gKiAgICAgICA8L25iLWNhcmQtYm9keT5cbiAqICAgICA8L25iLWNhcmQ+XG4gKiAgIDwvbmItY2FyZC1mcm9udD5cbiAqICAgPG5iLWNhcmQtYmFjaz5cbiAqICAgICA8bmItY2FyZD5cbiAqICAgICAgIDxuYi1jYXJkLWJvZHk+XG4gKiAgICAgICAgIEJhY2tcbiAqICAgICAgIDwvbmItY2FyZC1ib2R5PlxuICogICAgIDwvbmItY2FyZD5cbiAqICAgPC9uYi1jYXJkLWJhY2s+XG4gKiA8L25iLWZsaXAtY2FyZD5cbiAqIGBgYFxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iQ2FyZE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJDYXJkTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBGbGlwIENhcmQgd2l0aCBoZWFkZXIgYW5kIGZvb3RlcjpcbiAqIEBzdGFja2VkLWV4YW1wbGUoV2l0aCBIZWFkZXIgJiBGb290ZXIsIGZsaXAtY2FyZC9mbGlwLWNhcmQtZnVsbC5jb21wb25lbnQudHMpXG4gKlxuICogQ29sb3JlZCBmbGlwLWNhcmRzIGNvdWxkIGJlIHNpbXBseSBjb25maWd1cmVkIGJ5IHByb3ZpZGluZyBhIGBzdGF0dXNgIHByb3BlcnR5OlxuICogQHN0YWNrZWQtZXhhbXBsZShDb2xvcmVkIENhcmQsIGZsaXAtY2FyZC9mbGlwLWNhcmQtY29sb3JzLmNvbXBvbmVudClcbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGFzc2lnbiBhbiBgYWNjZW50YCBwcm9wZXJ0eSBmb3IgYSBzbGlnaHQgY2FyZCBoaWdobGlnaHRcbiAqIGFzIHdlbGwgYXMgY29tYmluZSBpdCB3aXRoIGBzdGF0dXNgOlxuICogQHN0YWNrZWQtZXhhbXBsZShBY2NlbnQgQ2FyZCwgZmxpcC1jYXJkL2ZsaXAtY2FyZC1hY2NlbnRzLmNvbXBvbmVudClcbiAqXG4gKiBAYWRkaXRpb25hbC1leGFtcGxlKE11bHRpcGxlIFNpemVzLCBmbGlwLWNhcmQvZmxpcC1jYXJkLXNpemVzLmNvbXBvbmVudClcbiAqXG4gKi9cbmxldCBOYkZsaXBDYXJkQ29tcG9uZW50ID0gY2xhc3MgTmJGbGlwQ2FyZENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBGbGlwIGNhcmQgZXhhbXBsZTpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBmbGlwLWNhcmQvZmxpcC1jYXJkLXNob3djYXNlLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEFzIGEgY29udGVudCBGbGlwIGNhcmQgYWNjZXB0cyB0d28gaW5zdGFuY2VzIG9mIGBuYi1jYXJkYCAtIGZvciBmcm9udCBhbmQgYmFjayBzaWRlcy5cbiAgICAgKlxuICAgICAqIEJhc2ljIGZsaXAgY2FyZCBjb25maWd1cmF0aW9uOlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuYi1mbGlwLWNhcmQ+XG4gICAgICogICA8bmItY2FyZC1mcm9udD5cbiAgICAgKiAgICAgPG5iLWNhcmQ+XG4gICAgICogICAgICAgPG5iLWNhcmQtYm9keT5cbiAgICAgKiAgICAgICAgIEZyb250XG4gICAgICogICAgICAgPC9uYi1jYXJkLWJvZHk+XG4gICAgICogICAgIDwvbmItY2FyZD5cbiAgICAgKiAgIDwvbmItY2FyZC1mcm9udD5cbiAgICAgKiAgIDxuYi1jYXJkLWJhY2s+XG4gICAgICogICAgIDxuYi1jYXJkPlxuICAgICAqICAgICAgIDxuYi1jYXJkLWJvZHk+XG4gICAgICogICAgICAgICBCYWNrXG4gICAgICogICAgICAgPC9uYi1jYXJkLWJvZHk+XG4gICAgICogICAgIDwvbmItY2FyZD5cbiAgICAgKiAgIDwvbmItY2FyZC1iYWNrPlxuICAgICAqIDwvbmItZmxpcC1jYXJkPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEluc3RhbGxhdGlvblxuICAgICAqXG4gICAgICogSW1wb3J0IGBOYkNhcmRNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gICAgICogYGBgdHNcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgaW1wb3J0czogW1xuICAgICAqICAgICAvLyAuLi5cbiAgICAgKiAgICAgTmJDYXJkTW9kdWxlLFxuICAgICAqICAgXSxcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICAgICAqIGBgYFxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogRmxpcCBDYXJkIHdpdGggaGVhZGVyIGFuZCBmb290ZXI6XG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShXaXRoIEhlYWRlciAmIEZvb3RlciwgZmxpcC1jYXJkL2ZsaXAtY2FyZC1mdWxsLmNvbXBvbmVudC50cylcbiAgICAgKlxuICAgICAqIENvbG9yZWQgZmxpcC1jYXJkcyBjb3VsZCBiZSBzaW1wbHkgY29uZmlndXJlZCBieSBwcm92aWRpbmcgYSBgc3RhdHVzYCBwcm9wZXJ0eTpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKENvbG9yZWQgQ2FyZCwgZmxpcC1jYXJkL2ZsaXAtY2FyZC1jb2xvcnMuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhc3NpZ24gYW4gYGFjY2VudGAgcHJvcGVydHkgZm9yIGEgc2xpZ2h0IGNhcmQgaGlnaGxpZ2h0XG4gICAgICogYXMgd2VsbCBhcyBjb21iaW5lIGl0IHdpdGggYHN0YXR1c2A6XG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShBY2NlbnQgQ2FyZCwgZmxpcC1jYXJkL2ZsaXAtY2FyZC1hY2NlbnRzLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoTXVsdGlwbGUgU2l6ZXMsIGZsaXAtY2FyZC9mbGlwLWNhcmQtc2l6ZXMuY29tcG9uZW50KVxuICAgICAqXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGlwIHN0YXRlXG4gICAgICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmxpcHBlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdy9oaWRlIHRvZ2dsZSBidXR0b24gdG8gYmUgYWJsZSB0byBjb250cm9sIHRvZ2dsZSBmcm9tIHlvdXIgY29kZVxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvd1RvZ2dsZUJ1dHRvbiA9IHRydWU7XG4gICAgfVxuICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgdGhpcy5mbGlwcGVkID0gIXRoaXMuZmxpcHBlZDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQyOShbXG4gICAgSW5wdXQoKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3MuZmxpcHBlZCcpLFxuICAgIF9fbWV0YWRhdGEkMTgoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJGbGlwQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmxpcHBlZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQyOShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDE4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJGbGlwQ2FyZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1RvZ2dsZUJ1dHRvblwiLCB2b2lkIDApO1xuTmJGbGlwQ2FyZENvbXBvbmVudCA9IF9fZGVjb3JhdGUkMjkoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItZmxpcC1jYXJkJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiZmxpcGNhcmQtYm9keVwiPlxuICAgICAgPGRpdiBjbGFzcz1cImZyb250LWNvbnRhaW5lclwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1jYXJkLWZyb250XCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8YSAqbmdJZj1cInNob3dUb2dnbGVCdXR0b25cIiBjbGFzcz1cImZsaXAtYnV0dG9uXCIgKGNsaWNrKT1cInRvZ2dsZSgpXCI+XG4gICAgICAgICAgPG5iLWljb24gaWNvbj1cImNoZXZyb24tbGVmdC1vdXRsaW5lXCIgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvbmItaWNvbj5cbiAgICAgICAgPC9hPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiYmFjay1jb250YWluZXJcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItY2FyZC1iYWNrXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8YSAqbmdJZj1cInNob3dUb2dnbGVCdXR0b25cIiBjbGFzcz1cImZsaXAtYnV0dG9uXCIgKGNsaWNrKT1cInRvZ2dsZSgpXCI+XG4gICAgICAgICAgPG5iLWljb24gaWNvbj1cImNoZXZyb24tbGVmdC1vdXRsaW5lXCIgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvbmItaWNvbj5cbiAgICAgICAgPC9hPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGAsXG4gICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpibG9jaztwZXJzcGVjdGl2ZToxMjAwcHg7cG9zaXRpb246cmVsYXRpdmV9Omhvc3QtY29udGV4dCguZmxpcHBlZCkgLmZsaXBjYXJkLWJvZHl7dHJhbnNmb3JtOnJvdGF0ZVkoLTE4MGRlZyl9Omhvc3QtY29udGV4dCguZmxpcHBlZCkgLmZsaXBjYXJkLWJvZHkgLmZyb250LWNvbnRhaW5lcntvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IDBzIDAuMjVzO2JhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW59Omhvc3QtY29udGV4dCguZmxpcHBlZCkgLmZsaXBjYXJkLWJvZHkgLmZyb250LWNvbnRhaW5lciAuZmxpcC1idXR0b257b3BhY2l0eTowO3otaW5kZXg6LTF9Omhvc3QtY29udGV4dCguZmxpcHBlZCkgLmZsaXBjYXJkLWJvZHkgLmJhY2stY29udGFpbmVye2JhY2tmYWNlLXZpc2liaWxpdHk6dmlzaWJsZTstd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6dmlzaWJsZX0uZmxpcGNhcmQtYm9keXtkaXNwbGF5OmZsZXg7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC41czt0cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2R9LmZsaXBjYXJkLWJvZHkgLmZyb250LWNvbnRhaW5lciwuZmxpcGNhcmQtYm9keSAuYmFjay1jb250YWluZXJ7ZmxleDoxfS5mbGlwY2FyZC1ib2R5IC5mcm9udC1jb250YWluZXIgLmZsaXAtYnV0dG9uLC5mbGlwY2FyZC1ib2R5IC5iYWNrLWNvbnRhaW5lciAuZmxpcC1idXR0b257Y3Vyc29yOnBvaW50ZXI7cG9zaXRpb246YWJzb2x1dGU7cmlnaHQ6MDtib3R0b206MDtvcGFjaXR5OjE7dHJhbnNpdGlvbjpvcGFjaXR5IDBzIDAuMTVzfS5mbGlwY2FyZC1ib2R5IC5mcm9udC1jb250YWluZXJ7YmFja2ZhY2UtdmlzaWJpbGl0eTp2aXNpYmxlOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTp2aXNpYmxlO3RyYW5zaXRpb246b3BhY2l0eSAwcyAwLjJzfS5mbGlwY2FyZC1ib2R5IC5iYWNrLWNvbnRhaW5lcntiYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjstd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6aGlkZGVuO3RyYW5zZm9ybTpyb3RhdGVZKDE4MGRlZyl9XFxuXCJdXG4gICAgfSlcbl0sIE5iRmxpcENhcmRDb21wb25lbnQpO1xuXG52YXIgX19kZWNvcmF0ZSQzMCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG4vKipcbiAqIENvbXBvbmVudCBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGhpbiB0aGUgYDxuYi1mbGlwLWNhcmQ+YCBhbmQgYDxuYi1yZXZlYWwtY2FyZD5gIGNvbXBvbmVudHMuXG4gKlxuICogVXNlIGl0IGFzIGEgY29udGFpbmVyIGZvciB0aGUgZnJvbnQgY2FyZC5cbiAqL1xubGV0IE5iQ2FyZEZyb250Q29tcG9uZW50ID0gY2xhc3MgTmJDYXJkRnJvbnRDb21wb25lbnQge1xufTtcbk5iQ2FyZEZyb250Q29tcG9uZW50ID0gX19kZWNvcmF0ZSQzMChbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jYXJkLWZyb250JyxcbiAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudCBzZWxlY3Q9XCJuYi1jYXJkXCI+PC9uZy1jb250ZW50PidcbiAgICB9KVxuXSwgTmJDYXJkRnJvbnRDb21wb25lbnQpO1xuLyoqXG4gKiBDb21wb25lbnQgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoaW4gdGhlIGA8bmItZmxpcC1jYXJkPmAgYW5kIGA8bmItcmV2ZWFsLWNhcmQ+YCBjb21wb25lbnRzLlxuICpcbiAqIFVzZSBpdCBhcyBhIGNvbnRhaW5lciBmb3IgdGhlIGJhY2sgY2FyZC5cbiAqL1xubGV0IE5iQ2FyZEJhY2tDb21wb25lbnQgPSBjbGFzcyBOYkNhcmRCYWNrQ29tcG9uZW50IHtcbn07XG5OYkNhcmRCYWNrQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQzMChbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jYXJkLWJhY2snLFxuICAgICAgICB0ZW1wbGF0ZTogJzxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWNhcmRcIj48L25nLWNvbnRlbnQ+J1xuICAgIH0pXG5dLCBOYkNhcmRCYWNrQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMjMgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuY29uc3QgTkJfQ0FSRF9DT01QT05FTlRTID0gW1xuICAgIE5iQ2FyZENvbXBvbmVudCxcbiAgICBOYkNhcmRCb2R5Q29tcG9uZW50LFxuICAgIE5iQ2FyZEZvb3RlckNvbXBvbmVudCxcbiAgICBOYkNhcmRIZWFkZXJDb21wb25lbnQsXG4gICAgTmJSZXZlYWxDYXJkQ29tcG9uZW50LFxuICAgIE5iRmxpcENhcmRDb21wb25lbnQsXG4gICAgTmJDYXJkRnJvbnRDb21wb25lbnQsXG4gICAgTmJDYXJkQmFja0NvbXBvbmVudCxcbl07XG5sZXQgTmJDYXJkTW9kdWxlID0gY2xhc3MgTmJDYXJkTW9kdWxlIHtcbn07XG5OYkNhcmRNb2R1bGUgPSBfX2RlY29yYXRlJDIzKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgTmJJY29uTW9kdWxlLFxuICAgICAgICBdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIC4uLk5CX0NBUkRfQ09NUE9ORU5UUyxcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgLi4uTkJfQ0FSRF9DT01QT05FTlRTLFxuICAgICAgICBdLFxuICAgIH0pXG5dLCBOYkNhcmRNb2R1bGUpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgTmJDYWxlbmRhclZpZXdNb2RlO1xuKGZ1bmN0aW9uIChOYkNhbGVuZGFyVmlld01vZGUpIHtcbiAgICBOYkNhbGVuZGFyVmlld01vZGVbXCJZRUFSXCJdID0gXCJ5ZWFyXCI7XG4gICAgTmJDYWxlbmRhclZpZXdNb2RlW1wiTU9OVEhcIl0gPSBcIm1vbnRoXCI7XG4gICAgTmJDYWxlbmRhclZpZXdNb2RlW1wiREFURVwiXSA9IFwiZGF0ZVwiO1xufSkoTmJDYWxlbmRhclZpZXdNb2RlIHx8IChOYkNhbGVuZGFyVmlld01vZGUgPSB7fSkpO1xudmFyIE5iQ2FsZW5kYXJTaXplO1xuKGZ1bmN0aW9uIChOYkNhbGVuZGFyU2l6ZSkge1xuICAgIE5iQ2FsZW5kYXJTaXplW1wiTUVESVVNXCJdID0gXCJtZWRpdW1cIjtcbiAgICBOYkNhbGVuZGFyU2l6ZVtcIkxBUkdFXCJdID0gXCJsYXJnZVwiO1xufSkoTmJDYWxlbmRhclNpemUgfHwgKE5iQ2FsZW5kYXJTaXplID0ge30pKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWwgPSB2YWwudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIHJldHVybiAodmFsID09PSAndHJ1ZScgfHwgdmFsID09PSAnJyk7XG4gICAgfVxuICAgIHJldHVybiAhIXZhbDtcbn1cblxuZnVuY3Rpb24gZmlyc3RDaGlsZE5vdENvbW1lbnQobm9kZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gQXJyYXlcbiAgICAgICAgLmZyb20obm9kZS5jaGlsZE5vZGVzKVxuICAgICAgICAuZmlsdGVyKChjaGlsZCkgPT4gY2hpbGQubm9kZVR5cGUgIT09IE5vZGUuQ09NTUVOVF9OT0RFKTtcbiAgICByZXR1cm4gY2hpbGRyZW5bMF07XG59XG5mdW5jdGlvbiBsYXN0Q2hpbGROb3RDb21tZW50KG5vZGUpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IEFycmF5XG4gICAgICAgIC5mcm9tKG5vZGUuY2hpbGROb2RlcylcbiAgICAgICAgLmZpbHRlcigoY2hpbGQpID0+IGNoaWxkLm5vZGVUeXBlICE9PSBOb2RlLkNPTU1FTlRfTk9ERSk7XG4gICAgcmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xufVxuLypcbiAqIEBicmVha2luZy1jaGFuZ2UgUmVtb3ZlIEA1LjAuMFxuICovXG5mdW5jdGlvbiBlbXB0eVN0YXR1c1dhcm5pbmcoc291cmNlKSB7XG4gICAgY29uc29sZS53YXJuKGAke3NvdXJjZX06IFVzaW5nIGVtcHR5IHN0cmluZyBhcyBhIHN0YXR1cyBpcyBkZXByZWNhdGVkLiBVc2UgXFxgYmFzaWNcXGAgaW5zdGVhZC5gKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMzIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogQ2FsZW5kYXIgY29tcG9uZW50IHByb3ZpZGVzIGEgY2FwYWJpbGl0eSB0byBjaG9vc2UgYSBkYXRlLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1jYWxlbmRhciBbKGRhdGUpXT1cImRhdGVcIj48L25iLWNhbGVuZGFyPlxuICogPG5iLWNhbGVuZGFyIFtkYXRlXT1cImRhdGVcIiAoZGF0ZUNoYW5nZSk9XCJoYW5kbGVEYXRlQ2hhbmdlKCRldmVudClcIj48L25iLWNhbGVuZGFyPlxuICogYGBgXG4gKlxuICogQmFzaWMgdXNhZ2UgZXhhbXBsZVxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgY2FsZW5kYXIvY2FsZW5kYXItc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iQ2FsZW5kYXJNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iQ2FsZW5kYXJNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIElmIHlvdSB3YW50IHRvIHNlbGVjdCByYW5nZXMgeW91IGNhbiB1c2UgYE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudGAuXG4gKlxuICogYGBgaHRtbFxuICogPG5iLWNhbGVuZGFyLXJhbmdlIFsocmFuZ2UpXT1cInJhbmdlXCI+PC9uYi1jYWxlbmRhci1yYW5nZT5cbiAqIDxuYi1jYWxlbmRhci1yYW5nZSBbcmFuZ2VdPVwicmFuZ2VcIiAocmFuZ2VDaGFuZ2UpPVwiaGFuZGxlUmFuZ2VDaGFuZ2UoJGV2ZW50KVwiPjwvbmItY2FsZW5kYXItcmFuZ2U+XG4gKiBgYGBcbiAqXG4gKiBJbiBvcmRlciB0byB1c2UgaXQsIHlvdSBoYXZlIHRvIGltcG9ydCBgTmJDYWxlbmRhclJhbmdlTW9kdWxlYC5cbiAqIEBzdGFja2VkLWV4YW1wbGUoUmFuZ2UsIGNhbGVuZGFyL2NhbGVuZGFyLXJhbmdlLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBUaGUgY2FsZW5kYXIgY29tcG9uZW50IGlzIHN1cHBsaWVkIHdpdGggYSBjYWxlbmRhciBoZWFkZXIgdGhhdCBjb250YWlucyBuYXZpZ2F0ZSB0b2RheSBidXR0b24uXG4gKiBJZiB5b3UgZG8gbm90IHdhbnQgdG8gdXNlIGl0IHlvdSBjYW4gaGlkZSBjYWxlbmRhciBoZWFkZXIgdXNpbmcgYHNob3dIZWFkZXJgIHByb3BlcnR5LlxuICogQHN0YWNrZWQtZXhhbXBsZShIZWFkZXIsIGNhbGVuZGFyL2NhbGVuZGFyLXdpdGhvdXQtaGVhZGVyLmNvbXBvbmVudClcbiAqXG4gKiBBcyB5b3UgY2FuIHNlZSBpbiB0aGUgYmFzaWMgdXNhZ2UgZXhhbXBsZSBjYWxlbmRhciBjb250YWlucyBwcmV2aW91cyBhbmQgbmV4dCBtb250aCBkYXlzXG4gKiB3aGljaCBjYW4gYmUgZGlzYWJsZWQgdXNpbmcgYGJvdW5kaW5nTW9udGhgIHByb3BlcnR5LlxuICogQHN0YWNrZWQtZXhhbXBsZShCb3VuZGluZyBtb250aHMsIGNhbGVuZGFyL2NhbGVuZGFyLWJvdW5kaW5nLW1vbnRoLmNvbXBvbmVudClcbiAqXG4gKiBZb3UgY2FuIGRlZmluZSBzdGFydGluZyB2aWV3IG9mIHRoZSBjYWxlbmRhciBieSBzZXR0aW5nIGBzdGFydFZpZXdgIHByb3BlcnR5LlxuICogQXZhaWxhYmxlIHZhbHVlczogeWVhciwgbW9udGggYW5kIGRhdGUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFN0YXJ0IHZpZXcsIGNhbGVuZGFyL2NhbGVuZGFyLXN0YXJ0LXZpZXcuY29tcG9uZW50KVxuICpcbiAqIFlvdSBjYW4gdXNlIGEgbGFyZ2VyIHZlcnNpb24gb2YgdGhlIGNhbGVuZGFyIGJ5IGRlZmluaW5nIHNpemUgcHJvcGVydHkuXG4gKiBBdmFpbGFibGUgdmFsdWVzOiBtZWRpdW0od2hpY2ggaXMgZGVmYXVsdCkgYW5kIGxhcmdlLlxuICogQHN0YWNrZWQtZXhhbXBsZShTaXplLCBjYWxlbmRhci9jYWxlbmRhci1zaXplLmNvbXBvbmVudClcbiAqXG4gKiBDYWxlbmRhciBzdXBwb3J0cyBtaW4gYW5kIG1heCBkYXRlcyB3aGljaCBkaXNhYmxlcyB2YWx1ZXMgb3V0IG9mIG1pbi1tYXggcmFuZ2UuXG4gKiBAc3RhY2tlZC1leGFtcGxlKEJvcmRlcnMsIGNhbGVuZGFyL2NhbGVuZGFyLW1pbi1tYXguY29tcG9uZW50KVxuICpcbiAqIEFsc28sIHlvdSBjYW4gZGVmaW5lIGN1c3RvbSBmaWx0ZXIgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgcHJlZGljYXRlIHdoaWNoIHJlY2VpdmVzXG4gKiBkYXRlIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoaXMgZGF0ZSBoYXMgdG8gYmUgZGlzYWJsZWQuIEluIHRoaXMgZXhhbXBsZSwgd2UgcHJvdmlkZSB0aGUgZmlsdGVyXG4gKiB3aGljaCBkaXNhYmxlcyB3ZWVrZGF5cy5cbiAqIEBzdGFja2VkLWV4YW1wbGUoRmlsdGVyLCBjYWxlbmRhci9jYWxlbmRhci1maWx0ZXIuY29tcG9uZW50KVxuICpcbiAqIFdlZWsgbnVtYmVycyBjb2x1bW4gY291bGQgYmUgZW5hYmxlZCB2aWEgYHNob3dXZWVrTnVtYmVyYCBiaW5kaW5nOlxuICogQHN0YWNrZWQtZXhhbXBsZShXZWVrIG51bWJlciwgY2FsZW5kYXIvY2FsZW5kYXItd2Vlay1udW1iZXIuY29tcG9uZW50KVxuICpcbiAqIElmIHlvdSBuZWVkIGNyZWF0ZSBjdXN0b20gY2VsbHMgeW91IGNhbiBlYXNpbHkgcHJvdmlkZSBjdXN0b20gY29tcG9uZW50cyBmb3JcbiAqIGNhbGVuZGFyLiBGb3IgZXhhbXBsZXMgaWYgeW91IHdhbnQgdG8gc2hvdyBhbnkgYXZlcmFnZSBwcmljZSB1bmRlciBlYWNoIGRhdGUgeW91IGNhblxuICoganVzdCBwcm92aWRlIGN1c3RvbSBgZGF5Q2VsbENvbXBvbmVudGAuIEN1c3RvbSBjZWxscyBmb3IgbW9udGggYW5kIHllYXIgY2FuIGJlIHByb3ZpZGVkXG4gKiB0aGUgc2FtZSB3YXksIGNoZWNrIEFQSSByZWZlcmVuY2UuXG4gKiBAc3RhY2tlZC1leGFtcGxlKEN1c3RvbSBkYXkgY2VsbCwgY2FsZW5kYXIvY2FsZW5kYXItY3VzdG9tLWRheS1jZWxsLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogY2FsZW5kYXItd2lkdGg6XG4gKiBjYWxlbmRhci1ib2R5LWhlaWdodDpcbiAqIGNhbGVuZGFyLWJvcmRlci1yYWRpdXM6XG4gKiBjYWxlbmRhci10ZXh0LWNvbG9yOlxuICogY2FsZW5kYXItdGV4dC1mb250LWZhbWlseTpcbiAqIGNhbGVuZGFyLXRleHQtZm9udC1zaXplOlxuICogY2FsZW5kYXItdGV4dC1mb250LXdlaWdodDpcbiAqIGNhbGVuZGFyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1oZWFkZXItdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWhlYWRlci10ZXh0LWZvbnQtZmFtaWx5OlxuICogY2FsZW5kYXItaGVhZGVyLXRpdGxlLXRleHQtZm9udC1zaXplOlxuICogY2FsZW5kYXItaGVhZGVyLXRpdGxlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1oZWFkZXItdGl0bGUtdGV4dC1saW5lLWhlaWdodDpcbiAqIGNhbGVuZGFyLWhlYWRlci1zdWItdGl0bGUtdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci1oZWFkZXItc3ViLXRpdGxlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1oZWFkZXItc3ViLXRpdGxlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1uYXZpZ2F0aW9uLWJ1dHRvbi13aWR0aDpcbiAqIGNhbGVuZGFyLWNlbGwtaW5hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtaW4tcmFuZ2UtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLWhvdmVyLXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLWhvdmVyLXRleHQtZm9udC1zaXplOlxuICogY2FsZW5kYXItY2VsbC1ob3Zlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogY2FsZW5kYXItY2VsbC1ob3Zlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogY2FsZW5kYXItY2VsbC1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtYWN0aXZlLXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLWFjdGl2ZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIGNhbGVuZGFyLWNlbGwtYWN0aXZlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLWFjdGl2ZS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogY2FsZW5kYXItY2VsbC10b2RheS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS10ZXh0LWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS10ZXh0LWZvbnQtc2l6ZTpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktdGV4dC1mb250LXdlaWdodDpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktdGV4dC1saW5lLWhlaWdodDpcbiAqIGNhbGVuZGFyLWRheS1jZWxsLXdpZHRoOlxuICogY2FsZW5kYXItZGF5LWNlbGwtaGVpZ2h0OlxuICogY2FsZW5kYXItbW9udGgtY2VsbC13aWR0aDpcbiAqIGNhbGVuZGFyLW1vbnRoLWNlbGwtaGVpZ2h0OlxuICogY2FsZW5kYXIteWVhci1jZWxsLXdpZHRoOlxuICogY2FsZW5kYXIteWVhci1jZWxsLWhlaWdodDpcbiAqIGNhbGVuZGFyLXdlZWtkYXktYmFja2dyb3VuZDpcbiAqIGNhbGVuZGFyLXdlZWtkYXktZGl2aWRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtkYXktdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtkYXktdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci13ZWVrZGF5LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrZGF5LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrZGF5LWhvbGlkYXktdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtkYXktaGVpZ2h0OlxuICogY2FsZW5kYXItd2Vla2RheS13aWR0aDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItYmFja2dyb3VuZDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItZGl2aWRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItZGl2aWRlci13aWR0aDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLWhlaWdodDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItd2lkdGg6XG4gKiBjYWxlbmRhci1sYXJnZS13aWR0aDpcbiAqIGNhbGVuZGFyLWxhcmdlLWJvZHktaGVpZ2h0OlxuICogY2FsZW5kYXItZGF5LWNlbGwtbGFyZ2Utd2lkdGg6XG4gKiBjYWxlbmRhci1kYXktY2VsbC1sYXJnZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrZGF5LWxhcmdlLWhlaWdodDpcbiAqIGNhbGVuZGFyLXdlZWtkYXktbGFyZ2Utd2lkdGg6XG4gKiBjYWxlbmRhci1tb250aC1jZWxsLWxhcmdlLXdpZHRoOlxuICogY2FsZW5kYXItbW9udGgtY2VsbC1sYXJnZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci15ZWFyLWNlbGwtbGFyZ2Utd2lkdGg6XG4gKiBjYWxlbmRhci15ZWFyLWNlbGwtbGFyZ2UtaGVpZ2h0OlxuICogKi9cbmxldCBOYkNhbGVuZGFyQ29tcG9uZW50ID0gY2xhc3MgTmJDYWxlbmRhckNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogQ2FsZW5kYXIgY29tcG9uZW50IHByb3ZpZGVzIGEgY2FwYWJpbGl0eSB0byBjaG9vc2UgYSBkYXRlLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuYi1jYWxlbmRhciBbKGRhdGUpXT1cImRhdGVcIj48L25iLWNhbGVuZGFyPlxuICAgICAqIDxuYi1jYWxlbmRhciBbZGF0ZV09XCJkYXRlXCIgKGRhdGVDaGFuZ2UpPVwiaGFuZGxlRGF0ZUNoYW5nZSgkZXZlbnQpXCI+PC9uYi1jYWxlbmRhcj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEJhc2ljIHVzYWdlIGV4YW1wbGVcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBjYWxlbmRhci9jYWxlbmRhci1zaG93Y2FzZS5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiAjIyMgSW5zdGFsbGF0aW9uXG4gICAgICpcbiAgICAgKiBJbXBvcnQgYE5iQ2FsZW5kYXJNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gICAgICogYGBgdHNcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgaW1wb3J0czogW1xuICAgICAqICAgICAvLyAuLi5cbiAgICAgKiAgICAgTmJDYWxlbmRhck1vZHVsZSxcbiAgICAgKiAgIF0sXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAgICAgKiBgYGBcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIElmIHlvdSB3YW50IHRvIHNlbGVjdCByYW5nZXMgeW91IGNhbiB1c2UgYE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudGAuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5iLWNhbGVuZGFyLXJhbmdlIFsocmFuZ2UpXT1cInJhbmdlXCI+PC9uYi1jYWxlbmRhci1yYW5nZT5cbiAgICAgKiA8bmItY2FsZW5kYXItcmFuZ2UgW3JhbmdlXT1cInJhbmdlXCIgKHJhbmdlQ2hhbmdlKT1cImhhbmRsZVJhbmdlQ2hhbmdlKCRldmVudClcIj48L25iLWNhbGVuZGFyLXJhbmdlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSW4gb3JkZXIgdG8gdXNlIGl0LCB5b3UgaGF2ZSB0byBpbXBvcnQgYE5iQ2FsZW5kYXJSYW5nZU1vZHVsZWAuXG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShSYW5nZSwgY2FsZW5kYXIvY2FsZW5kYXItcmFuZ2Utc2hvd2Nhc2UuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogVGhlIGNhbGVuZGFyIGNvbXBvbmVudCBpcyBzdXBwbGllZCB3aXRoIGEgY2FsZW5kYXIgaGVhZGVyIHRoYXQgY29udGFpbnMgbmF2aWdhdGUgdG9kYXkgYnV0dG9uLlxuICAgICAqIElmIHlvdSBkbyBub3Qgd2FudCB0byB1c2UgaXQgeW91IGNhbiBoaWRlIGNhbGVuZGFyIGhlYWRlciB1c2luZyBgc2hvd0hlYWRlcmAgcHJvcGVydHkuXG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShIZWFkZXIsIGNhbGVuZGFyL2NhbGVuZGFyLXdpdGhvdXQtaGVhZGVyLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEFzIHlvdSBjYW4gc2VlIGluIHRoZSBiYXNpYyB1c2FnZSBleGFtcGxlIGNhbGVuZGFyIGNvbnRhaW5zIHByZXZpb3VzIGFuZCBuZXh0IG1vbnRoIGRheXNcbiAgICAgKiB3aGljaCBjYW4gYmUgZGlzYWJsZWQgdXNpbmcgYGJvdW5kaW5nTW9udGhgIHByb3BlcnR5LlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoQm91bmRpbmcgbW9udGhzLCBjYWxlbmRhci9jYWxlbmRhci1ib3VuZGluZy1tb250aC5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGRlZmluZSBzdGFydGluZyB2aWV3IG9mIHRoZSBjYWxlbmRhciBieSBzZXR0aW5nIGBzdGFydFZpZXdgIHByb3BlcnR5LlxuICAgICAqIEF2YWlsYWJsZSB2YWx1ZXM6IHllYXIsIG1vbnRoIGFuZCBkYXRlLlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoU3RhcnQgdmlldywgY2FsZW5kYXIvY2FsZW5kYXItc3RhcnQtdmlldy5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIHVzZSBhIGxhcmdlciB2ZXJzaW9uIG9mIHRoZSBjYWxlbmRhciBieSBkZWZpbmluZyBzaXplIHByb3BlcnR5LlxuICAgICAqIEF2YWlsYWJsZSB2YWx1ZXM6IG1lZGl1bSh3aGljaCBpcyBkZWZhdWx0KSBhbmQgbGFyZ2UuXG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShTaXplLCBjYWxlbmRhci9jYWxlbmRhci1zaXplLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIENhbGVuZGFyIHN1cHBvcnRzIG1pbiBhbmQgbWF4IGRhdGVzIHdoaWNoIGRpc2FibGVzIHZhbHVlcyBvdXQgb2YgbWluLW1heCByYW5nZS5cbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKEJvcmRlcnMsIGNhbGVuZGFyL2NhbGVuZGFyLW1pbi1tYXguY29tcG9uZW50KVxuICAgICAqXG4gICAgICogQWxzbywgeW91IGNhbiBkZWZpbmUgY3VzdG9tIGZpbHRlciBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBwcmVkaWNhdGUgd2hpY2ggcmVjZWl2ZXNcbiAgICAgKiBkYXRlIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoaXMgZGF0ZSBoYXMgdG8gYmUgZGlzYWJsZWQuIEluIHRoaXMgZXhhbXBsZSwgd2UgcHJvdmlkZSB0aGUgZmlsdGVyXG4gICAgICogd2hpY2ggZGlzYWJsZXMgd2Vla2RheXMuXG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShGaWx0ZXIsIGNhbGVuZGFyL2NhbGVuZGFyLWZpbHRlci5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBXZWVrIG51bWJlcnMgY29sdW1uIGNvdWxkIGJlIGVuYWJsZWQgdmlhIGBzaG93V2Vla051bWJlcmAgYmluZGluZzpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFdlZWsgbnVtYmVyLCBjYWxlbmRhci9jYWxlbmRhci13ZWVrLW51bWJlci5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBJZiB5b3UgbmVlZCBjcmVhdGUgY3VzdG9tIGNlbGxzIHlvdSBjYW4gZWFzaWx5IHByb3ZpZGUgY3VzdG9tIGNvbXBvbmVudHMgZm9yXG4gICAgICogY2FsZW5kYXIuIEZvciBleGFtcGxlcyBpZiB5b3Ugd2FudCB0byBzaG93IGFueSBhdmVyYWdlIHByaWNlIHVuZGVyIGVhY2ggZGF0ZSB5b3UgY2FuXG4gICAgICoganVzdCBwcm92aWRlIGN1c3RvbSBgZGF5Q2VsbENvbXBvbmVudGAuIEN1c3RvbSBjZWxscyBmb3IgbW9udGggYW5kIHllYXIgY2FuIGJlIHByb3ZpZGVkXG4gICAgICogdGhlIHNhbWUgd2F5LCBjaGVjayBBUEkgcmVmZXJlbmNlLlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoQ3VzdG9tIGRheSBjZWxsLCBjYWxlbmRhci9jYWxlbmRhci1jdXN0b20tZGF5LWNlbGwtc2hvd2Nhc2UuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogQHN0eWxlc1xuICAgICAqXG4gICAgICogY2FsZW5kYXItd2lkdGg6XG4gICAgICogY2FsZW5kYXItYm9keS1oZWlnaHQ6XG4gICAgICogY2FsZW5kYXItYm9yZGVyLXJhZGl1czpcbiAgICAgKiBjYWxlbmRhci10ZXh0LWNvbG9yOlxuICAgICAqIGNhbGVuZGFyLXRleHQtZm9udC1mYW1pbHk6XG4gICAgICogY2FsZW5kYXItdGV4dC1mb250LXNpemU6XG4gICAgICogY2FsZW5kYXItdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBjYWxlbmRhci10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIGNhbGVuZGFyLWhlYWRlci10ZXh0LWNvbG9yOlxuICAgICAqIGNhbGVuZGFyLWhlYWRlci10ZXh0LWZvbnQtZmFtaWx5OlxuICAgICAqIGNhbGVuZGFyLWhlYWRlci10aXRsZS10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBjYWxlbmRhci1oZWFkZXItdGl0bGUtdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBjYWxlbmRhci1oZWFkZXItdGl0bGUtdGV4dC1saW5lLWhlaWdodDpcbiAgICAgKiBjYWxlbmRhci1oZWFkZXItc3ViLXRpdGxlLXRleHQtZm9udC1zaXplOlxuICAgICAqIGNhbGVuZGFyLWhlYWRlci1zdWItdGl0bGUtdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBjYWxlbmRhci1oZWFkZXItc3ViLXRpdGxlLXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogY2FsZW5kYXItbmF2aWdhdGlvbi1idXR0b24td2lkdGg6XG4gICAgICogY2FsZW5kYXItY2VsbC1pbmFjdGl2ZS10ZXh0LWNvbG9yOlxuICAgICAqIGNhbGVuZGFyLWNlbGwtaW4tcmFuZ2UtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBjYWxlbmRhci1jZWxsLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogY2FsZW5kYXItY2VsbC1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICAgICAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLXRleHQtY29sb3I6XG4gICAgICogY2FsZW5kYXItY2VsbC1zZWxlY3RlZC10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogY2FsZW5kYXItY2VsbC1zZWxlY3RlZC10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIGNhbGVuZGFyLWNlbGwtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBjYWxlbmRhci1jZWxsLWhvdmVyLXRleHQtY29sb3I6XG4gICAgICogY2FsZW5kYXItY2VsbC1ob3Zlci10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBjYWxlbmRhci1jZWxsLWhvdmVyLXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogY2FsZW5kYXItY2VsbC1ob3Zlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIGNhbGVuZGFyLWNlbGwtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogY2FsZW5kYXItY2VsbC1hY3RpdmUtdGV4dC1jb2xvcjpcbiAgICAgKiBjYWxlbmRhci1jZWxsLWFjdGl2ZS10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBjYWxlbmRhci1jZWxsLWFjdGl2ZS10ZXh0LWZvbnQtd2VpZ2h0OlxuICAgICAqIGNhbGVuZGFyLWNlbGwtYWN0aXZlLXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogY2FsZW5kYXItY2VsbC10b2RheS1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGNhbGVuZGFyLWNlbGwtdG9kYXktdGV4dC1jb2xvcjpcbiAgICAgKiBjYWxlbmRhci1jZWxsLXRvZGF5LXRleHQtZm9udC1zaXplOlxuICAgICAqIGNhbGVuZGFyLWNlbGwtdG9kYXktdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBjYWxlbmRhci1jZWxsLXRvZGF5LXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogY2FsZW5kYXItZGF5LWNlbGwtd2lkdGg6XG4gICAgICogY2FsZW5kYXItZGF5LWNlbGwtaGVpZ2h0OlxuICAgICAqIGNhbGVuZGFyLW1vbnRoLWNlbGwtd2lkdGg6XG4gICAgICogY2FsZW5kYXItbW9udGgtY2VsbC1oZWlnaHQ6XG4gICAgICogY2FsZW5kYXIteWVhci1jZWxsLXdpZHRoOlxuICAgICAqIGNhbGVuZGFyLXllYXItY2VsbC1oZWlnaHQ6XG4gICAgICogY2FsZW5kYXItd2Vla2RheS1iYWNrZ3JvdW5kOlxuICAgICAqIGNhbGVuZGFyLXdlZWtkYXktZGl2aWRlci1jb2xvcjpcbiAgICAgKiBjYWxlbmRhci13ZWVrZGF5LXRleHQtY29sb3I6XG4gICAgICogY2FsZW5kYXItd2Vla2RheS10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBjYWxlbmRhci13ZWVrZGF5LXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogY2FsZW5kYXItd2Vla2RheS10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIGNhbGVuZGFyLXdlZWtkYXktaG9saWRheS10ZXh0LWNvbG9yOlxuICAgICAqIGNhbGVuZGFyLXdlZWtkYXktaGVpZ2h0OlxuICAgICAqIGNhbGVuZGFyLXdlZWtkYXktd2lkdGg6XG4gICAgICogY2FsZW5kYXItd2Vla251bWJlci1iYWNrZ3JvdW5kOlxuICAgICAqIGNhbGVuZGFyLXdlZWtudW1iZXItZGl2aWRlci1jb2xvcjpcbiAgICAgKiBjYWxlbmRhci13ZWVrbnVtYmVyLWRpdmlkZXItd2lkdGg6XG4gICAgICogY2FsZW5kYXItd2Vla251bWJlci10ZXh0LWNvbG9yOlxuICAgICAqIGNhbGVuZGFyLXdlZWtudW1iZXItdGV4dC1mb250LXNpemU6XG4gICAgICogY2FsZW5kYXItd2Vla251bWJlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICAgICAqIGNhbGVuZGFyLXdlZWtudW1iZXItdGV4dC1saW5lLWhlaWdodDpcbiAgICAgKiBjYWxlbmRhci13ZWVrbnVtYmVyLWhlaWdodDpcbiAgICAgKiBjYWxlbmRhci13ZWVrbnVtYmVyLXdpZHRoOlxuICAgICAqIGNhbGVuZGFyLWxhcmdlLXdpZHRoOlxuICAgICAqIGNhbGVuZGFyLWxhcmdlLWJvZHktaGVpZ2h0OlxuICAgICAqIGNhbGVuZGFyLWRheS1jZWxsLWxhcmdlLXdpZHRoOlxuICAgICAqIGNhbGVuZGFyLWRheS1jZWxsLWxhcmdlLWhlaWdodDpcbiAgICAgKiBjYWxlbmRhci13ZWVrZGF5LWxhcmdlLWhlaWdodDpcbiAgICAgKiBjYWxlbmRhci13ZWVrZGF5LWxhcmdlLXdpZHRoOlxuICAgICAqIGNhbGVuZGFyLW1vbnRoLWNlbGwtbGFyZ2Utd2lkdGg6XG4gICAgICogY2FsZW5kYXItbW9udGgtY2VsbC1sYXJnZS1oZWlnaHQ6XG4gICAgICogY2FsZW5kYXIteWVhci1jZWxsLWxhcmdlLXdpZHRoOlxuICAgICAqIGNhbGVuZGFyLXllYXItY2VsbC1sYXJnZS1oZWlnaHQ6XG4gICAgICogKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgaWYgd2Ugc2hvdWxkIHJlbmRlciBwcmV2aW91cyBhbmQgbmV4dCBtb250aHNcbiAgICAgICAgICogaW4gdGhlIGN1cnJlbnQgbW9udGggdmlldy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5ib3VuZGluZ01vbnRoID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgc3RhcnRpbmcgdmlldyBmb3IgY2FsZW5kYXIuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc3RhcnRWaWV3ID0gTmJDYWxlbmRhclZpZXdNb2RlLkRBVEU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaXplIG9mIHRoZSBjYWxlbmRhciBhbmQgZW50aXJlIGNvbXBvbmVudHMuXG4gICAgICAgICAqIENhbiBiZSAnbWVkaXVtJyB3aGljaCBpcyBkZWZhdWx0IG9yICdsYXJnZScuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgY2FsZW5kYXJzIGhlYWRlciBvciBub3QuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2hvd0hlYWRlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Nob3dXZWVrTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHN5bWJvbCB1c2VkIGFzIGEgaGVhZGVyIGZvciB3ZWVrIG51bWJlcnMgY29sdW1uXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMud2Vla051bWJlclN5bWJvbCA9ICcjJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIGRhdGUgd2hlbiBzZWxlY3RlZC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5kYXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHNob3VsZCB3ZSBzaG93IHdlZWsgbnVtYmVycyBjb2x1bW4uXG4gICAgICogRmFsc2UgYnkgZGVmYXVsdC5cbiAgICAgKiAqL1xuICAgIGdldCBzaG93V2Vla051bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3dXZWVrTnVtYmVyO1xuICAgIH1cbiAgICBzZXQgc2hvd1dlZWtOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2hvd1dlZWtOdW1iZXIgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDMyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm91bmRpbmdNb250aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQzMihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDE5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRWaWV3XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDMyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTkoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMzIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxOShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQzMihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDE5KFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBOYkNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMzIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxOShcImRlc2lnbjp0eXBlXCIsIFR5cGUpXG5dLCBOYkNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXlDZWxsQ29tcG9uZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDMyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTkoXCJkZXNpZ246dHlwZVwiLCBUeXBlKVxuXSwgTmJDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwibW9udGhDZWxsQ29tcG9uZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDMyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTkoXCJkZXNpZ246dHlwZVwiLCBUeXBlKVxuXSwgTmJDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwieWVhckNlbGxDb21wb25lbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMzIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxOShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMzIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxOShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInZpc2libGVEYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDMyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0hlYWRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQzMihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDE5KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQzMihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDE5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQxOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dXZWVrTnVtYmVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzMihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDE5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclN5bWJvbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQzMihbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQxOShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE5iQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGVDaGFuZ2VcIiwgdm9pZCAwKTtcbk5iQ2FsZW5kYXJDb21wb25lbnQgPSBfX2RlY29yYXRlJDMyKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWNhbGVuZGFyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmItYmFzZS1jYWxlbmRhclxuICAgICAgW2JvdW5kaW5nTW9udGhdPVwiYm91bmRpbmdNb250aFwiXG4gICAgICBbc3RhcnRWaWV3XT1cInN0YXJ0Vmlld1wiXG4gICAgICBbZGF0ZV09XCJkYXRlXCJcbiAgICAgIFttaW5dPVwibWluXCJcbiAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgIFtkYXlDZWxsQ29tcG9uZW50XT1cImRheUNlbGxDb21wb25lbnRcIlxuICAgICAgW21vbnRoQ2VsbENvbXBvbmVudF09XCJtb250aENlbGxDb21wb25lbnRcIlxuICAgICAgW3llYXJDZWxsQ29tcG9uZW50XT1cInllYXJDZWxsQ29tcG9uZW50XCJcbiAgICAgIFtzaXplXT1cInNpemVcIlxuICAgICAgW3Zpc2libGVEYXRlXT1cInZpc2libGVEYXRlXCJcbiAgICAgIFtzaG93SGVhZGVyXT1cInNob3dIZWFkZXJcIlxuICAgICAgW3Nob3dXZWVrTnVtYmVyXT1cInNob3dXZWVrTnVtYmVyXCJcbiAgICAgIFt3ZWVrTnVtYmVyU3ltYm9sXT1cIndlZWtOdW1iZXJTeW1ib2xcIlxuICAgICAgKGRhdGVDaGFuZ2UpPVwiZGF0ZUNoYW5nZS5lbWl0KCRldmVudClcIlxuICAgID48L25iLWJhc2UtY2FsZW5kYXI+XG4gIGBcbiAgICB9KVxuXSwgTmJDYWxlbmRhckNvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDM2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDIwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIEJhc2ljIGJ1dHRvbiBjb21wb25lbnQuXG4gKlxuICogRGVmYXVsdCBidXR0b24gc2l6ZSBpcyBgbWVkaXVtYCBhbmQgc3RhdHVzIGNvbG9yIGlzIGBwcmltYXJ5YDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQnV0dG9uIFNob3djYXNlLCBidXR0b24vYnV0dG9uLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBgYGBodG1sXG4gKiA8YnV0dG9uIG5iQnV0dG9uPjwvYnV0dG9uPlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkJ1dHRvbk1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJCdXR0b25Nb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIEJ1dHRvbnMgYXJlIGF2YWlsYWJsZSBpbiBtdWx0aXBsZSBjb2xvcnMgdXNpbmcgYHN0YXR1c2AgcHJvcGVydHk6XG4gKiBAc3RhY2tlZC1leGFtcGxlKEJ1dHRvbiBDb2xvcnMsIGJ1dHRvbi9idXR0b24tY29sb3JzLmNvbXBvbmVudC5odG1sKVxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBidXR0b24gc2l6ZXM6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShCdXR0b24gU2l6ZXMsIGJ1dHRvbi9idXR0b24tc2l6ZXMuY29tcG9uZW50Lmh0bWwpXG4gKlxuICogQW5kIHR3byBhZGRpdGlvbmFsIHN0eWxlIHR5cGVzIC0gYG91dGxpbmVgOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoT3V0bGluZSBCdXR0b25zLCBidXR0b24vYnV0dG9uLW91dGxpbmUuY29tcG9uZW50Lmh0bWwpXG4gKlxuICogYW5kIGBoZXJvYDpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEJ1dHRvbiBIZXJvLCBidXR0b24vYnV0dG9uLWhlcm8uY29tcG9uZW50Lmh0bWwpXG4gKlxuICogQnV0dG9ucyBhdmFpbGFibGUgaW4gZGlmZmVyZW50IHNoYXBlcywgd2hpY2ggY291bGQgYmUgY29tYmluZWQgd2l0aCB0aGUgb3RoZXIgcHJvcGVydGllczpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQnV0dG9uIFNoYXBlcywgYnV0dG9uL2J1dHRvbi1zaGFwZXMuY29tcG9uZW50KVxuICpcbiAqIGBuYkJ1dHRvbmAgY291bGQgYmUgYXBwbGllZCB0byB0aGUgZm9sbG93aW5nIHNlbGVjdG9ycyAtIGBidXR0b25gLCBgaW5wdXRbdHlwZT1cImJ1dHRvblwiXWAsIGBpbnB1dFt0eXBlPVwic3VibWl0XCJdYFxuICogYW5kIGBhYDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQnV0dG9uIEVsZW1lbnRzLCBidXR0b24vYnV0dG9uLXR5cGVzLmNvbXBvbmVudC5odG1sKVxuICpcbiAqIEJ1dHRvbiBjYW4gYmUgbWFkZSBgZnVsbFdpZHRoYDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRnVsbCBXaWR0aCBCdXR0b24sIGJ1dHRvbi9idXR0b24tZnVsbC13aWR0aC5jb21wb25lbnQuaHRtbClcbiAqXG4gKiBJY29uIGNhbiBiZSBwbGFjZWQgaW5zaWRlIG9mIGEgYnV0dG9uIGFzIGEgY2hpbGQgZWxlbWVudDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoSWNvbiBCdXR0b24sIGJ1dHRvbi9idXR0b24taWNvbi5jb21wb25lbnQuaHRtbClcbiAqXG4gKiBAYWRkaXRpb25hbC1leGFtcGxlKEludGVyYWN0aXZlIGV4YW1wbGUsIGJ1dHRvbi9idXR0b24taW50ZXJhY3RpdmUuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBidXR0b24tY3Vyc29yOlxuICogYnV0dG9uLW91dGxpbmUtd2lkdGg6XG4gKiBidXR0b24tb3V0bGluZS1jb2xvcjpcbiAqIGJ1dHRvbi10ZXh0LWZvbnQtZmFtaWx5OlxuICogYnV0dG9uLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBidXR0b24tZGlzYWJsZWQtY3Vyc29yOlxuICogYnV0dG9uLXRpbnktdGV4dC1mb250LXNpemU6XG4gKiBidXR0b24tdGlueS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogYnV0dG9uLXNtYWxsLXRleHQtZm9udC1zaXplOlxuICogYnV0dG9uLXNtYWxsLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBidXR0b24tbWVkaXVtLXRleHQtZm9udC1zaXplOlxuICogYnV0dG9uLW1lZGl1bS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogYnV0dG9uLWxhcmdlLXRleHQtZm9udC1zaXplOlxuICogYnV0dG9uLWxhcmdlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBidXR0b24tZ2lhbnQtdGV4dC1mb250LXNpemU6XG4gKiBidXR0b24tZ2lhbnQtdGV4dC1saW5lLWhlaWdodDpcbiAqIGJ1dHRvbi1yZWN0YW5nbGUtYm9yZGVyLXJhZGl1czpcbiAqIGJ1dHRvbi1zZW1pLXJvdW5kLWJvcmRlci1yYWRpdXM6XG4gKiBidXR0b24tcm91bmQtYm9yZGVyLXJhZGl1czpcbiAqIGJ1dHRvbi1maWxsZWQtYm9yZGVyLXN0eWxlOlxuICogYnV0dG9uLWZpbGxlZC1ib3JkZXItd2lkdGg6XG4gKiBidXR0b24tZmlsbGVkLXRleHQtdHJhbnNmb3JtOlxuICogYnV0dG9uLWZpbGxlZC10aW55LXBhZGRpbmc6XG4gKiBidXR0b24tZmlsbGVkLXNtYWxsLXBhZGRpbmc6XG4gKiBidXR0b24tZmlsbGVkLW1lZGl1bS1wYWRkaW5nOlxuICogYnV0dG9uLWZpbGxlZC1sYXJnZS1wYWRkaW5nOlxuICogYnV0dG9uLWZpbGxlZC1naWFudC1wYWRkaW5nOlxuICogYnV0dG9uLWZpbGxlZC1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1iYXNpYy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWJhc2ljLXRleHQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWJhc2ljLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWJhc2ljLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtYmFzaWMtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtYmFzaWMtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1iYXNpYy1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtYmFzaWMtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtYmFzaWMtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtYmFzaWMtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1iYXNpYy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXByaW1hcnktYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXByaW1hcnktZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtcHJpbWFyeS1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXByaW1hcnktaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtcHJpbWFyeS1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXByaW1hcnktYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXByaW1hcnktYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtcHJpbWFyeS1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1wcmltYXJ5LWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtcHJpbWFyeS1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXN1Y2Nlc3MtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtc3VjY2Vzcy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXN1Y2Nlc3MtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtc3VjY2Vzcy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXN1Y2Nlc3MtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXN1Y2Nlc3MtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtc3VjY2Vzcy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1zdWNjZXNzLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtc3VjY2Vzcy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWluZm8tYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1pbmZvLXRleHQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWluZm8tZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtaW5mby1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWluZm8taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtaW5mby1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWluZm8tYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWluZm8tYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtaW5mby1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1pbmZvLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtaW5mby1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXdhcm5pbmctYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC13YXJuaW5nLXRleHQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXdhcm5pbmctZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtd2FybmluZy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXdhcm5pbmctaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtd2FybmluZy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXdhcm5pbmctYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLXdhcm5pbmctYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtd2FybmluZy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC13YXJuaW5nLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtd2FybmluZy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1kYW5nZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtZGFuZ2VyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtZGFuZ2VyLXRleHQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWRhbmdlci1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1kYW5nZXItZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1kYW5nZXItaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtZGFuZ2VyLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtZGFuZ2VyLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1kYW5nZXItYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtZGFuZ2VyLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWRhbmdlci1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWRhbmdlci1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1jb250cm9sLXRleHQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWNvbnRyb2wtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtY29udHJvbC1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWNvbnRyb2wtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtY29udHJvbC1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWNvbnRyb2wtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZmlsbGVkLWNvbnRyb2wtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtY29udHJvbC1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWZpbGxlZC1jb250cm9sLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1maWxsZWQtY29udHJvbC1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYm9yZGVyLXN0eWxlOlxuICogYnV0dG9uLW91dGxpbmUtYm9yZGVyLXdpZHRoOlxuICogYnV0dG9uLW91dGxpbmUtdGV4dC10cmFuc2Zvcm06XG4gKiBidXR0b24tb3V0bGluZS10aW55LXBhZGRpbmc6XG4gKiBidXR0b24tb3V0bGluZS1zbWFsbC1wYWRkaW5nOlxuICogYnV0dG9uLW91dGxpbmUtbWVkaXVtLXBhZGRpbmc6XG4gKiBidXR0b24tb3V0bGluZS1sYXJnZS1wYWRkaW5nOlxuICogYnV0dG9uLW91dGxpbmUtZ2lhbnQtcGFkZGluZzpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1iYXNpYy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1iYXNpYy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJhc2ljLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJhc2ljLWZvY3VzLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1iYXNpYy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtaG92ZXItdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJhc2ljLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJhc2ljLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtYmFzaWMtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJhc2ljLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWJhc2ljLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1wcmltYXJ5LWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXByaW1hcnktZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXByaW1hcnktZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtcHJpbWFyeS1mb2N1cy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtcHJpbWFyeS1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtcHJpbWFyeS1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1wcmltYXJ5LWhvdmVyLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1wcmltYXJ5LWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtcHJpbWFyeS1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtcHJpbWFyeS1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXByaW1hcnktZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXByaW1hcnktZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtcHJpbWFyeS1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtc3VjY2Vzcy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1zdWNjZXNzLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1zdWNjZXNzLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXN1Y2Nlc3MtZm9jdXMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXN1Y2Nlc3MtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXN1Y2Nlc3MtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtc3VjY2Vzcy1ob3Zlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtc3VjY2Vzcy1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXN1Y2Nlc3MtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXN1Y2Nlc3MtYWN0aXZlLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1zdWNjZXNzLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1zdWNjZXNzLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXN1Y2Nlc3MtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWluZm8tYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtaW5mby10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtaW5mby1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtaW5mby1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1pbmZvLWZvY3VzLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1pbmZvLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1pbmZvLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWluZm8taG92ZXItdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWluZm8tYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1pbmZvLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1pbmZvLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtaW5mby1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtaW5mby1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1pbmZvLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS13YXJuaW5nLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXdhcm5pbmctZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXdhcm5pbmctZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtd2FybmluZy1mb2N1cy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtd2FybmluZy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtd2FybmluZy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS13YXJuaW5nLWhvdmVyLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS13YXJuaW5nLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtd2FybmluZy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtd2FybmluZy1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXdhcm5pbmctZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLXdhcm5pbmctZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtd2FybmluZy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1kYW5nZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtZGFuZ2VyLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1kYW5nZXItZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWRhbmdlci1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1kYW5nZXItZm9jdXMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWRhbmdlci1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtZGFuZ2VyLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWRhbmdlci1ob3Zlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtZGFuZ2VyLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtZGFuZ2VyLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1kYW5nZXItYWN0aXZlLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1kYW5nZXItZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWRhbmdlci1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1kYW5nZXItZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtY29udHJvbC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtY29udHJvbC1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtY29udHJvbC1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1jb250cm9sLWZvY3VzLXRleHQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1jb250cm9sLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1jb250cm9sLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWNvbnRyb2wtaG92ZXItdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1vdXRsaW5lLWNvbnRyb2wtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1jb250cm9sLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1jb250cm9sLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtY29udHJvbC1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLW91dGxpbmUtY29udHJvbC1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tb3V0bGluZS1jb250cm9sLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtYm9yZGVyLXN0eWxlOlxuICogYnV0dG9uLWdob3N0LWJvcmRlci13aWR0aDpcbiAqIGJ1dHRvbi1naG9zdC10ZXh0LXRyYW5zZm9ybTpcbiAqIGJ1dHRvbi1naG9zdC10aW55LXBhZGRpbmc6XG4gKiBidXR0b24tZ2hvc3Qtc21hbGwtcGFkZGluZzpcbiAqIGJ1dHRvbi1naG9zdC1tZWRpdW0tcGFkZGluZzpcbiAqIGJ1dHRvbi1naG9zdC1sYXJnZS1wYWRkaW5nOlxuICogYnV0dG9uLWdob3N0LWdpYW50LXBhZGRpbmc6XG4gKiBidXR0b24tZ2hvc3QtYmFzaWMtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1iYXNpYy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWJhc2ljLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1iYXNpYy1mb2N1cy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWJhc2ljLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtYmFzaWMtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWJhc2ljLWhvdmVyLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtYmFzaWMtYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtYmFzaWMtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1iYXNpYy1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1iYXNpYy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWJhc2ljLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1iYXNpYy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1wcmltYXJ5LWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtcHJpbWFyeS1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtcHJpbWFyeS1mb2N1cy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXByaW1hcnktaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1wcmltYXJ5LWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1wcmltYXJ5LWhvdmVyLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtcHJpbWFyeS1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1wcmltYXJ5LWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtcHJpbWFyeS1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1wcmltYXJ5LWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtcHJpbWFyeS1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtcHJpbWFyeS1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1zdWNjZXNzLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtc3VjY2Vzcy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtc3VjY2Vzcy1mb2N1cy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXN1Y2Nlc3MtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1zdWNjZXNzLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1zdWNjZXNzLWhvdmVyLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtc3VjY2Vzcy1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1zdWNjZXNzLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtc3VjY2Vzcy1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1zdWNjZXNzLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtc3VjY2Vzcy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtc3VjY2Vzcy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWluZm8tdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1pbmZvLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtaW5mby1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtaW5mby1mb2N1cy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWluZm8taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1pbmZvLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1pbmZvLWhvdmVyLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtaW5mby1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1pbmZvLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtaW5mby1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1pbmZvLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtaW5mby1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtaW5mby1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC13YXJuaW5nLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtd2FybmluZy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtd2FybmluZy1mb2N1cy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LXdhcm5pbmctaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC13YXJuaW5nLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC13YXJuaW5nLWhvdmVyLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtd2FybmluZy1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC13YXJuaW5nLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtd2FybmluZy1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC13YXJuaW5nLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtd2FybmluZy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3Qtd2FybmluZy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWRhbmdlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWRhbmdlci1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWRhbmdlci1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtZGFuZ2VyLWZvY3VzLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtZGFuZ2VyLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtZGFuZ2VyLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1kYW5nZXItaG92ZXItdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1kYW5nZXItYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtZGFuZ2VyLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtZGFuZ2VyLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWRhbmdlci1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtZGFuZ2VyLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtY29udHJvbC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWNvbnRyb2wtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1jb250cm9sLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1jb250cm9sLWZvY3VzLXRleHQtY29sb3I6XG4gKiBidXR0b24tZ2hvc3QtY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWNvbnRyb2wtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWNvbnRyb2wtaG92ZXItdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1jb250cm9sLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWNvbnRyb2wtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1jb250cm9sLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWdob3N0LWNvbnRyb2wtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1jb250cm9sLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGJ1dHRvbi1naG9zdC1jb250cm9sLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24taGVyby1ib3JkZXItY29sb3I6XG4gKiBidXR0b24taGVyby1ib3JkZXItc3R5bGU6XG4gKiBidXR0b24taGVyby1ib3JkZXItd2lkdGg6XG4gKiBidXR0b24taGVyby10ZXh0LXRyYW5zZm9ybTpcbiAqIGJ1dHRvbi1oZXJvLXRpbnktcGFkZGluZzpcbiAqIGJ1dHRvbi1oZXJvLXNtYWxsLXBhZGRpbmc6XG4gKiBidXR0b24taGVyby1tZWRpdW0tcGFkZGluZzpcbiAqIGJ1dHRvbi1oZXJvLWxhcmdlLXBhZGRpbmc6XG4gKiBidXR0b24taGVyby1naWFudC1wYWRkaW5nOlxuICogYnV0dG9uLWhlcm8tc2hhZG93OlxuICogYnV0dG9uLWhlcm8tdGV4dC1zaGFkb3c6XG4gKiBidXR0b24taGVyby1iZXZlbC1zaXplOlxuICogYnV0dG9uLWhlcm8tZ2xvdy1zaXplOlxuICogYnV0dG9uLWhlcm8tb3V0bGluZS1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLW91dGxpbmUtd2lkdGg6XG4gKiBidXR0b24taGVyby1iYXNpYy10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tYmFzaWMtYmV2ZWwtY29sb3I6XG4gKiBidXR0b24taGVyby1iYXNpYy1nbG93LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tYmFzaWMtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tYmFzaWMtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWJhc2ljLWZvY3VzLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWJhc2ljLWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1iYXNpYy1ob3Zlci1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1iYXNpYy1ob3Zlci1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tYmFzaWMtYWN0aXZlLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWJhc2ljLWFjdGl2ZS1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tYmFzaWMtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWJhc2ljLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24taGVyby1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiBidXR0b24taGVyby1wcmltYXJ5LWJldmVsLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tcHJpbWFyeS1nbG93LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tcHJpbWFyeS1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1wcmltYXJ5LXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1wcmltYXJ5LWZvY3VzLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXByaW1hcnktZm9jdXMtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXByaW1hcnktaG92ZXItbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tcHJpbWFyeS1ob3Zlci1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tcHJpbWFyeS1hY3RpdmUtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tcHJpbWFyeS1hY3RpdmUtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXByaW1hcnktZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXByaW1hcnktZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXN1Y2Nlc3MtYmV2ZWwtY29sb3I6XG4gKiBidXR0b24taGVyby1zdWNjZXNzLWdsb3ctY29sb3I6XG4gKiBidXR0b24taGVyby1zdWNjZXNzLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXN1Y2Nlc3MtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXN1Y2Nlc3MtZm9jdXMtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tc3VjY2Vzcy1mb2N1cy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tc3VjY2Vzcy1ob3Zlci1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1zdWNjZXNzLWhvdmVyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1zdWNjZXNzLWFjdGl2ZS1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1zdWNjZXNzLWFjdGl2ZS1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tc3VjY2Vzcy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tc3VjY2Vzcy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWhlcm8taW5mby10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWhlcm8taW5mby1iZXZlbC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWluZm8tZ2xvdy1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWluZm8tbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8taW5mby1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8taW5mby1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1pbmZvLWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1pbmZvLWhvdmVyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWluZm8taG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWluZm8tYWN0aXZlLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWluZm8tYWN0aXZlLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1pbmZvLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1pbmZvLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24taGVyby13YXJuaW5nLXRleHQtY29sb3I6XG4gKiBidXR0b24taGVyby13YXJuaW5nLWJldmVsLWNvbG9yOlxuICogYnV0dG9uLWhlcm8td2FybmluZy1nbG93LWNvbG9yOlxuICogYnV0dG9uLWhlcm8td2FybmluZy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby13YXJuaW5nLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby13YXJuaW5nLWZvY3VzLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXdhcm5pbmctZm9jdXMtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXdhcm5pbmctaG92ZXItbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8td2FybmluZy1ob3Zlci1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8td2FybmluZy1hY3RpdmUtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8td2FybmluZy1hY3RpdmUtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXdhcm5pbmctZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLXdhcm5pbmctZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWRhbmdlci10ZXh0LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tZGFuZ2VyLWJldmVsLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tZGFuZ2VyLWdsb3ctY29sb3I6XG4gKiBidXR0b24taGVyby1kYW5nZXItbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tZGFuZ2VyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1kYW5nZXItZm9jdXMtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tZGFuZ2VyLWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1kYW5nZXItaG92ZXItbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tZGFuZ2VyLWhvdmVyLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1kYW5nZXItYWN0aXZlLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWRhbmdlci1hY3RpdmUtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tZGFuZ2VyLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBidXR0b24taGVyby1jb250cm9sLXRleHQtY29sb3I6XG4gKiBidXR0b24taGVyby1jb250cm9sLWJldmVsLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tY29udHJvbC1nbG93LWNvbG9yOlxuICogYnV0dG9uLWhlcm8tY29udHJvbC1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1jb250cm9sLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBidXR0b24taGVyby1jb250cm9sLWZvY3VzLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWNvbnRyb2wtZm9jdXMtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWNvbnRyb2wtaG92ZXItbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tY29udHJvbC1ob3Zlci1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tY29udHJvbC1hY3RpdmUtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYnV0dG9uLWhlcm8tY29udHJvbC1hY3RpdmUtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWNvbnRyb2wtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJ1dHRvbi1oZXJvLWNvbnRyb2wtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqL1xubGV0IE5iQnV0dG9uQ29tcG9uZW50ID0gY2xhc3MgTmJCdXR0b25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyLCBob3N0RWxlbWVudCwgY2QpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdXR0b24gc2l6ZSwgYXZhaWxhYmxlIHNpemVzOlxuICAgICAgICAgKiBgdGlueWAsIGBzbWFsbGAsIGBtZWRpdW1gLCBgbGFyZ2VgLCBgZ2lhbnRgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpemUgPSAnbWVkaXVtJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1dHRvbiBzdGF0dXMgKGFkZHMgc3BlY2lmaWMgc3R5bGVzKTpcbiAgICAgICAgICogYGJhc2ljYCwgYHByaW1hcnlgLCBgaW5mb2AsIGBzdWNjZXNzYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCwgYGNvbnRyb2xgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAncHJpbWFyeSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdXR0b24gc2hhcGVzOiBgcmVjdGFuZ2xlYCwgYHJvdW5kYCwgYHNlbWktcm91bmRgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYXBlID0gJ3JlY3RhbmdsZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdXR0b24gYXBwZWFyYW5jZTogYGZpbGxlZGAsIGBvdXRsaW5lYCwgYGdob3N0YCwgYGhlcm9gXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFwcGVhcmFuY2UgPSAnZmlsbGVkJztcbiAgICAgICAgdGhpcy5fZnVsbFdpZHRoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYGZpbGxlZGAgYXBwZWFyYW5jZVxuICAgICAqL1xuICAgIGdldCBmaWxsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVhcmFuY2UgPT09ICdmaWxsZWQnO1xuICAgIH1cbiAgICBzZXQgZmlsbGVkKHZhbHVlKSB7XG4gICAgICAgIGlmIChjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVhcmFuY2UgPSAnZmlsbGVkJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGBvdXRsaW5lYCBhcHBlYXJhbmNlXG4gICAgICovXG4gICAgZ2V0IG91dGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVhcmFuY2UgPT09ICdvdXRsaW5lJztcbiAgICB9XG4gICAgc2V0IG91dGxpbmUodmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZWFyYW5jZSA9ICdvdXRsaW5lJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGBnaG9zdGAgYXBwZWFyYW5jZVxuICAgICAqL1xuICAgIGdldCBnaG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZWFyYW5jZSA9PT0gJ2dob3N0JztcbiAgICB9XG4gICAgc2V0IGdob3N0KHZhbHVlKSB7XG4gICAgICAgIGlmIChjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVhcmFuY2UgPSAnZ2hvc3QnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYGhlcm9gIGFwcGVhcmFuY2VcbiAgICAgKi9cbiAgICBnZXQgaGVybygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZWFyYW5jZSA9PT0gJ2hlcm8nO1xuICAgIH1cbiAgICBzZXQgaGVybyh2YWx1ZSkge1xuICAgICAgICBpZiAoY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlYXJhbmNlID0gJ2hlcm8nO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHNldCBlbGVtZW50IHdpbGwgZmlsbCBpdHMgY29udGFpbmVyXG4gICAgICovXG4gICAgZ2V0IGZ1bGxXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bGxXaWR0aDtcbiAgICB9XG4gICAgc2V0IGZ1bGxXaWR0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mdWxsV2lkdGggPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB0aGUgYnV0dG9uXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCB0aGlzLmRpc2FibGVkKTtcbiAgICB9XG4gICAgLy8gaXNzdWUgIzc5NFxuICAgIGdldCB0YWJiYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyAnLTEnIDogJzAnO1xuICAgIH1cbiAgICBnZXQgdGlueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3RpbnknO1xuICAgIH1cbiAgICBnZXQgc21hbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdzbWFsbCc7XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdtZWRpdW0nO1xuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdsYXJnZSc7XG4gICAgfVxuICAgIGdldCBnaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2dpYW50JztcbiAgICB9XG4gICAgZ2V0IHByaW1hcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3ByaW1hcnknO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgYmFzaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2NvbnRyb2wnO1xuICAgIH1cbiAgICBnZXQgcmVjdGFuZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFwZSA9PT0gJ3JlY3RhbmdsZSc7XG4gICAgfVxuICAgIGdldCByb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUgPT09ICdyb3VuZCc7XG4gICAgfVxuICAgIGdldCBzZW1pUm91bmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXBlID09PSAnc2VtaS1yb3VuZCc7XG4gICAgfVxuICAgIGdldCBpY29uTGVmdCgpIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGljb24gPSB0aGlzLmljb25FbGVtZW50O1xuICAgICAgICByZXR1cm4gISEoaWNvbiAmJiBmaXJzdENoaWxkTm90Q29tbWVudChlbCkgPT09IGljb24pO1xuICAgIH1cbiAgICBnZXQgaWNvblJpZ2h0KCkge1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuaG9zdEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgaWNvbiA9IHRoaXMuaWNvbkVsZW1lbnQ7XG4gICAgICAgIHJldHVybiAhIShpY29uICYmIGxhc3RDaGlsZE5vdENvbW1lbnQoZWwpID09PSBpY29uKTtcbiAgICB9XG4gICAgZ2V0IHRyYW5zaXRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0luaXRpYWxpemVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEtlZXAgdGhpcyBoYW5kbGVyIHRvIHBhcnRpYWxseSBzdXBwb3J0IGFuY2hvciBkaXNhYmxpbmcuXG4gICAgICogVW5saWtlIGJ1dHRvbiwgYW5jaG9yIGRvZXNuJ3QgaGF2ZSAnZGlzYWJsZWQnIERPTSBwcm9wZXJ0eSxcbiAgICAgKiBzbyBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkIGFueXdheS4gV2UgcHJldmVudGluZyBuYXZpZ2F0aW9uIGFuZCBidWJibGluZy5cbiAgICAgKiBEaXNhYmxpbmcgaXMgcGFydGlhbCBkdWUgdG8gY2xpY2sgaGFuZGxlcnMgcHJlY2VkZW5jZS4gQ29uc2lkZXIgZXhhbXBsZTpcbiAgICAgKiA8YSBuYkJ1dHRvbiBbZGlzYWJsZWRdPVwidHJ1ZVwiIChjbGljayk9XCJjbGlja0hhbmRsZXIoKVwiPi4uLjwvYT5cbiAgICAgKiAnY2xpY2tIYW5kbGVyJyB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgb3VyIGhvc3QgbGlzdGVuZXIgYmVsb3cuIFdlIGNhbid0IHByZXZlbnRcbiAgICAgKiBzdWNoIGhhbmRsZXJzIGNhbGwuXG4gICAgICovXG4gICAgb25DbGljayhldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpY29uRWxlbWVudCgpIHtcbiAgICAgICAgY29uc3QgZWwgPSB0aGlzLmhvc3RFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yKCduYi1pY29uJyk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMzYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyMChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwic2hhcGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMzYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyMChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhcHBlYXJhbmNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBJbnB1dCgpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hcHBlYXJhbmNlLWZpbGxlZCcpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJCdXR0b25Db21wb25lbnQucHJvdG90eXBlLCBcImZpbGxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMzYoW1xuICAgIElucHV0KCksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmFwcGVhcmFuY2Utb3V0bGluZScpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJCdXR0b25Db21wb25lbnQucHJvdG90eXBlLCBcIm91dGxpbmVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBJbnB1dCgpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hcHBlYXJhbmNlLWdob3N0JyksXG4gICAgX19tZXRhZGF0YSQyMChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2hvc3RcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBJbnB1dCgpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hcHBlYXJhbmNlLWhlcm8nKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQyMChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJoZXJvXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzNihbXG4gICAgSW5wdXQoKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3MuZnVsbC13aWR0aCcpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJCdXR0b25Db21wb25lbnQucHJvdG90eXBlLCBcImZ1bGxXaWR0aFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMzYoW1xuICAgIElucHV0KCksXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1kaXNhYmxlZCcpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5idG4tZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQyMChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMzYoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JyksXG4gICAgX19tZXRhZGF0YSQyMChcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YSQyMChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJCdXR0b25Db21wb25lbnQucHJvdG90eXBlLCBcInRhYmJhYmxlXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzNihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtdGlueScpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aW55XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzNihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtc21hbGwnKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwic21hbGxcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1tZWRpdW0nKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwibWVkaXVtXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzNihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtbGFyZ2UnKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwibGFyZ2VcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1naWFudCcpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJnaWFudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMzYoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtcHJpbWFyeScpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmltYXJ5XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzNihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1pbmZvJyksXG4gICAgX19tZXRhZGF0YSQyMChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQyMChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJCdXR0b25Db21wb25lbnQucHJvdG90eXBlLCBcImluZm9cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwic3VjY2Vzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMzYoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtd2FybmluZycpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3YXJuaW5nXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzNihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1kYW5nZXInKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGFuZ2VyXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzNihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1iYXNpYycpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXNpY1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMzYoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtY29udHJvbCcpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250cm9sXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzNihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNoYXBlLXJlY3RhbmdsZScpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWN0YW5nbGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2hhcGUtcm91bmQnKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2hhcGUtc2VtaS1yb3VuZCcpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQnV0dG9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZW1pUm91bmRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MuaWNvbi1zdGFydCcpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiaWNvbkxlZnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MuaWNvbi1lbmQnKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQyMChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJCdXR0b25Db21wb25lbnQucHJvdG90eXBlLCBcImljb25SaWdodFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMzYoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy50cmFuc2l0aW9ucycpLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwidHJhbnNpdGlvbnNcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDM2KFtcbiAgICBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YSQyMChcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEkMjAoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBOYkJ1dHRvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwib25DbGlja1wiLCBudWxsKTtcbk5iQnV0dG9uQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQzNihbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbmJCdXR0b25dLGFbbmJCdXR0b25dLGlucHV0W3R5cGU9XCJidXR0b25cIl1bbmJCdXR0b25dLGlucHV0W3R5cGU9XCJzdWJtaXRcIl1bbmJCdXR0b25dJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gIGAsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2FwcGVhcmFuY2U6bm9uZTt0ZXh0LWFsaWduOmNlbnRlcjt0ZXh0LWRlY29yYXRpb246bm9uZTtkaXNwbGF5OmlubGluZS1mbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO3doaXRlLXNwYWNlOm5vd3JhcDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7dXNlci1zZWxlY3Q6bm9uZX06aG9zdDpob3Zlciw6aG9zdDpmb2N1c3t0ZXh0LWRlY29yYXRpb246bm9uZX06aG9zdC5mdWxsLXdpZHRoe3dpZHRoOjEwMCV9Omhvc3QgOjpuZy1kZWVwIG5iLWljb257dmVydGljYWwtYWxpZ246dG9wfVtkaXI9bHRyXSA6aG9zdC5pY29uLXN0YXJ0Om5vdCguaWNvbi1lbmQpIDo6bmctZGVlcCBuYi1pY29ue21hcmdpbi1yaWdodDouNzVyZW19W2Rpcj1ydGxdIDpob3N0Lmljb24tc3RhcnQ6bm90KC5pY29uLWVuZCkgOjpuZy1kZWVwIG5iLWljb257bWFyZ2luLWxlZnQ6Ljc1cmVtfVtkaXI9bHRyXSA6aG9zdC5pY29uLWVuZDpub3QoLmljb24tc3RhcnQpIDo6bmctZGVlcCBuYi1pY29ue21hcmdpbi1sZWZ0Oi43NXJlbX1bZGlyPXJ0bF0gOmhvc3QuaWNvbi1lbmQ6bm90KC5pY29uLXN0YXJ0KSA6Om5nLWRlZXAgbmItaWNvbnttYXJnaW4tcmlnaHQ6Ljc1cmVtfTpob3N0KC50cmFuc2l0aW9ucyl7dHJhbnNpdGlvbi1kdXJhdGlvbjowLjE1czt0cmFuc2l0aW9uLXByb3BlcnR5OmJhY2tncm91bmQtY29sb3IsYm9yZGVyLWNvbG9yLGJveC1zaGFkb3csY29sb3I7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1pbn1cXG5cIl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDIwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1JlbmRlcmVyMixcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgTmJCdXR0b25Db21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQzNSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5jb25zdCBOQl9CVVRUT05fQ09NUE9ORU5UUyA9IFtcbiAgICBOYkJ1dHRvbkNvbXBvbmVudCxcbl07XG5sZXQgTmJCdXR0b25Nb2R1bGUgPSBjbGFzcyBOYkJ1dHRvbk1vZHVsZSB7XG59O1xuTmJCdXR0b25Nb2R1bGUgPSBfX2RlY29yYXRlJDM1KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICBdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIC4uLk5CX0JVVFRPTl9DT01QT05FTlRTLFxuICAgICAgICBdLFxuICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAuLi5OQl9CVVRUT05fQ09NUE9ORU5UUyxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJCdXR0b25Nb2R1bGUpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iRGF0ZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLkRBWVNfSU5fV0VFSyA9IDc7XG4gICAgfVxuICAgIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZGF0ZSBpcyBiZXR3ZWVuIHRoZSBzdGFydCBkYXRlIGFuZCB0aGUgZW5kIGRhdGUuXG4gICAgICogKi9cbiAgICBpc0JldHdlZW4oZGF0ZSwgc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlRGF0ZXMoZGF0ZSwgc3RhcnQpID4gMCAmJiB0aGlzLmNvbXBhcmVEYXRlcyhkYXRlLCBlbmQpIDwgMDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpcyB0d28gZGF0ZXMgaGF2ZSB0aGUgc2FtZSBkYXkuXG4gICAgICogKi9cbiAgICBpc1NhbWVEYXlTYWZlKGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gZGF0ZTEgJiYgZGF0ZTIgJiYgdGhpcy5pc1NhbWVEYXkoZGF0ZTEsIGRhdGUyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpcyB0d28gZGF0ZXMgaGF2ZSB0aGUgc2FtZSBtb250aC5cbiAgICAgKiAqL1xuICAgIGlzU2FtZU1vbnRoU2FmZShkYXRlMSwgZGF0ZTIpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUxICYmIGRhdGUyICYmIHRoaXMuaXNTYW1lTW9udGgoZGF0ZTEsIGRhdGUyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlzIHR3byBkYXRlcyBoYXZlIHRoZSBzYW1lIHllYXIuXG4gICAgICogKi9cbiAgICBpc1NhbWVZZWFyU2FmZShkYXRlMSwgZGF0ZTIpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUxICYmIGRhdGUyICYmIHRoaXMuaXNTYW1lWWVhcihkYXRlMSwgZGF0ZTIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgYmF0Y2ggPSAodGFyZ2V0LCBiYXRjaFNpemUsIG9mZnNldCA9IDApID0+IHtcbiAgICByZXR1cm4gdGFyZ2V0LnJlZHVjZSgocmVzLCBpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBjaHVua0luZGV4ID0gTWF0aC5mbG9vcigoaW5kZXggKyBvZmZzZXQpIC8gYmF0Y2hTaXplKTtcbiAgICAgICAgaWYgKCFyZXNbY2h1bmtJbmRleF0pIHtcbiAgICAgICAgICAgIHJlc1tjaHVua0luZGV4XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJlc1tjaHVua0luZGV4XS5wdXNoKGl0ZW0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sIFtdKTtcbn07XG4vKipcbiAqIHJldHVybnMgYXJyYXkgd2l0aCBudW1iZXJzIGZyb20gemVybyB0byBib3VuZC5cbiAqICovXG5jb25zdCByYW5nZSA9IChib3VuZCwgcHJvZHVjZXIgPSBpID0+IGkpID0+IHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kOyBpKyspIHtcbiAgICAgICAgYXJyLnB1c2gocHJvZHVjZXIoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMzcgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYkNhbGVuZGFyTW9udGhNb2RlbFNlcnZpY2UgPSBjbGFzcyBOYkNhbGVuZGFyTW9udGhNb2RlbFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICB9XG4gICAgY3JlYXRlRGF5c0dyaWQoYWN0aXZlTW9udGgsIGJvdW5kaW5nTW9udGggPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHdlZWtzID0gdGhpcy5jcmVhdGVEYXRlcyhhY3RpdmVNb250aCk7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhCb3VuZGluZ01vbnRocyh3ZWVrcywgYWN0aXZlTW9udGgsIGJvdW5kaW5nTW9udGgpO1xuICAgIH1cbiAgICBjcmVhdGVEYXRlcyhhY3RpdmVNb250aCkge1xuICAgICAgICBjb25zdCBkYXlzID0gdGhpcy5jcmVhdGVEYXRlUmFuZ2VGb3JNb250aChhY3RpdmVNb250aCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZXZWVrRGF5RGlmZiA9IHRoaXMuZ2V0U3RhcnRPZldlZWtEYXlEaWZmKGFjdGl2ZU1vbnRoKTtcbiAgICAgICAgcmV0dXJuIGJhdGNoKGRheXMsIHRoaXMuZGF0ZVNlcnZpY2UuREFZU19JTl9XRUVLLCBzdGFydE9mV2Vla0RheURpZmYpO1xuICAgIH1cbiAgICB3aXRoQm91bmRpbmdNb250aHMod2Vla3MsIGFjdGl2ZU1vbnRoLCBib3VuZGluZ01vbnRoKSB7XG4gICAgICAgIGxldCB3aXRoQm91bmRpbmdNb250aHMgPSB3ZWVrcztcbiAgICAgICAgaWYgKHRoaXMuaXNTaG91bGRBZGRQcmV2Qm91bmRpbmdNb250aCh3aXRoQm91bmRpbmdNb250aHMpKSB7XG4gICAgICAgICAgICB3aXRoQm91bmRpbmdNb250aHMgPSB0aGlzLmFkZFByZXZCb3VuZGluZ01vbnRoKHdpdGhCb3VuZGluZ01vbnRocywgYWN0aXZlTW9udGgsIGJvdW5kaW5nTW9udGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU2hvdWxkQWRkTmV4dEJvdW5kaW5nTW9udGgod2l0aEJvdW5kaW5nTW9udGhzKSkge1xuICAgICAgICAgICAgd2l0aEJvdW5kaW5nTW9udGhzID0gdGhpcy5hZGROZXh0Qm91bmRpbmdNb250aCh3aXRoQm91bmRpbmdNb250aHMsIGFjdGl2ZU1vbnRoLCBib3VuZGluZ01vbnRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2l0aEJvdW5kaW5nTW9udGhzO1xuICAgIH1cbiAgICBhZGRQcmV2Qm91bmRpbmdNb250aCh3ZWVrcywgYWN0aXZlTW9udGgsIGJvdW5kaW5nTW9udGgpIHtcbiAgICAgICAgY29uc3QgZmlyc3RXZWVrID0gd2Vla3Muc2hpZnQoKTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWRJdGVtcyA9IHRoaXMuZGF0ZVNlcnZpY2UuREFZU19JTl9XRUVLIC0gZmlyc3RXZWVrLmxlbmd0aDtcbiAgICAgICAgZmlyc3RXZWVrLnVuc2hpZnQoLi4udGhpcy5jcmVhdGVQcmV2Qm91bmRpbmdEYXlzKGFjdGl2ZU1vbnRoLCBib3VuZGluZ01vbnRoLCByZXF1aXJlZEl0ZW1zKSk7XG4gICAgICAgIHJldHVybiBbZmlyc3RXZWVrLCAuLi53ZWVrc107XG4gICAgfVxuICAgIGFkZE5leHRCb3VuZGluZ01vbnRoKHdlZWtzLCBhY3RpdmVNb250aCwgYm91bmRpbmdNb250aCkge1xuICAgICAgICBjb25zdCBsYXN0V2VlayA9IHdlZWtzLnBvcCgpO1xuICAgICAgICBjb25zdCByZXF1aXJlZEl0ZW1zID0gdGhpcy5kYXRlU2VydmljZS5EQVlTX0lOX1dFRUsgLSBsYXN0V2Vlay5sZW5ndGg7XG4gICAgICAgIGxhc3RXZWVrLnB1c2goLi4udGhpcy5jcmVhdGVOZXh0Qm91bmRpbmdEYXlzKGFjdGl2ZU1vbnRoLCBib3VuZGluZ01vbnRoLCByZXF1aXJlZEl0ZW1zKSk7XG4gICAgICAgIHJldHVybiBbLi4ud2Vla3MsIGxhc3RXZWVrXTtcbiAgICB9XG4gICAgY3JlYXRlUHJldkJvdW5kaW5nRGF5cyhhY3RpdmVNb250aCwgYm91bmRpbmdNb250aCwgcmVxdWlyZWRJdGVtcykge1xuICAgICAgICBjb25zdCBtb250aCA9IHRoaXMuZGF0ZVNlcnZpY2UuYWRkTW9udGgoYWN0aXZlTW9udGgsIC0xKTtcbiAgICAgICAgY29uc3QgZGF5c0luTW9udGggPSB0aGlzLmRhdGVTZXJ2aWNlLmdldE51bWJlck9mRGF5c0luTW9udGgobW9udGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEYXRlUmFuZ2VGb3JNb250aChtb250aClcbiAgICAgICAgICAgIC5zbGljZShkYXlzSW5Nb250aCAtIHJlcXVpcmVkSXRlbXMpXG4gICAgICAgICAgICAubWFwKGRhdGUgPT4gYm91bmRpbmdNb250aCA/IGRhdGUgOiBudWxsKTtcbiAgICB9XG4gICAgY3JlYXRlTmV4dEJvdW5kaW5nRGF5cyhhY3RpdmVNb250aCwgYm91bmRpbmdNb250aCwgcmVxdWlyZWRJdGVtcykge1xuICAgICAgICBjb25zdCBtb250aCA9IHRoaXMuZGF0ZVNlcnZpY2UuYWRkTW9udGgoYWN0aXZlTW9udGgsIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEYXRlUmFuZ2VGb3JNb250aChtb250aClcbiAgICAgICAgICAgIC5zbGljZSgwLCByZXF1aXJlZEl0ZW1zKVxuICAgICAgICAgICAgLm1hcChkYXRlID0+IGJvdW5kaW5nTW9udGggPyBkYXRlIDogbnVsbCk7XG4gICAgfVxuICAgIGdldFN0YXJ0T2ZXZWVrRGF5RGlmZihkYXRlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZNb250aCA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TW9udGhTdGFydChkYXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2Vla1N0YXJ0RGlmZihzdGFydE9mTW9udGgpO1xuICAgIH1cbiAgICBnZXRXZWVrU3RhcnREaWZmKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuICg3IC0gdGhpcy5kYXRlU2VydmljZS5nZXRGaXJzdERheU9mV2VlaygpICsgdGhpcy5kYXRlU2VydmljZS5nZXREYXlPZldlZWsoZGF0ZSkpICUgNztcbiAgICB9XG4gICAgaXNTaG91bGRBZGRQcmV2Qm91bmRpbmdNb250aCh3ZWVrcykge1xuICAgICAgICByZXR1cm4gd2Vla3NbMF0ubGVuZ3RoIDwgdGhpcy5kYXRlU2VydmljZS5EQVlTX0lOX1dFRUs7XG4gICAgfVxuICAgIGlzU2hvdWxkQWRkTmV4dEJvdW5kaW5nTW9udGgod2Vla3MpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzW3dlZWtzLmxlbmd0aCAtIDFdLmxlbmd0aCA8IHRoaXMuZGF0ZVNlcnZpY2UuREFZU19JTl9XRUVLO1xuICAgIH1cbiAgICBjcmVhdGVEYXRlUmFuZ2VGb3JNb250aChkYXRlKSB7XG4gICAgICAgIGNvbnN0IGRheXNJbk1vbnRoID0gdGhpcy5kYXRlU2VydmljZS5nZXROdW1iZXJPZkRheXNJbk1vbnRoKGRhdGUpO1xuICAgICAgICByZXR1cm4gcmFuZ2UoZGF5c0luTW9udGgsIGkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeWVhciA9IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0WWVhcihkYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IG1vbnRoID0gdGhpcy5kYXRlU2VydmljZS5nZXRNb250aChkYXRlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmNyZWF0ZURhdGUoeWVhciwgbW9udGgsIGkgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbk5iQ2FsZW5kYXJNb250aE1vZGVsU2VydmljZSA9IF9fZGVjb3JhdGUkMzcoW1xuICAgIEluamVjdGFibGUoKSxcbiAgICBfX21ldGFkYXRhJDIxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iRGF0ZVNlcnZpY2VdKVxuXSwgTmJDYWxlbmRhck1vbnRoTW9kZWxTZXJ2aWNlKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMzggPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudCA9IGNsYXNzIE5iQ2FsZW5kYXJEYXlDZWxsQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcih0cnVlKTtcbiAgICB9XG4gICAgZ2V0IHRvZGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1NhbWVEYXlTYWZlKHRoaXMuZGF0ZSwgdGhpcy5kYXRlU2VydmljZS50b2RheSgpKTtcbiAgICB9XG4gICAgZ2V0IGJvdW5kaW5nTW9udGgoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5kYXRlU2VydmljZS5pc1NhbWVNb250aFNhZmUodGhpcy5kYXRlLCB0aGlzLnZpc2libGVEYXRlKTtcbiAgICB9XG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1NhbWVEYXlTYWZlKHRoaXMuZGF0ZSwgdGhpcy5zZWxlY3RlZFZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGVtcHR5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGF0ZTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbWFsbGVyVGhhbk1pbigpIHx8IHRoaXMuZ3JlYXRlclRoYW5NYXgoKSB8fCB0aGlzLmRvbnRGaXRGaWx0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IGRheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLmRhdGVTZXJ2aWNlLmdldERhdGUodGhpcy5kYXRlKTtcbiAgICB9XG4gICAgb25DbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5lbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQodGhpcy5kYXRlKTtcbiAgICB9XG4gICAgc21hbGxlclRoYW5NaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5taW4gJiYgdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXModGhpcy5kYXRlLCB0aGlzLm1pbikgPCAwO1xuICAgIH1cbiAgICBncmVhdGVyVGhhbk1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLm1heCAmJiB0aGlzLmRhdGVTZXJ2aWNlLmNvbXBhcmVEYXRlcyh0aGlzLmRhdGUsIHRoaXMubWF4KSA+IDA7XG4gICAgfVxuICAgIGRvbnRGaXRGaWx0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5maWx0ZXIgJiYgIXRoaXMuZmlsdGVyKHRoaXMuZGF0ZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMzgoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyMihcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJEYXlDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDM4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjIoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQzOChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDIyKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhckRheUNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInZpc2libGVEYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDM4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjIoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDM4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjIoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDM4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjIoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIE5iQ2FsZW5kYXJEYXlDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMzgoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjIoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDM4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MudG9kYXknKSxcbiAgICBfX21ldGFkYXRhJDIyKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQyMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYWxlbmRhckRheUNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInRvZGF5XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzOChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmJvdW5kaW5nLW1vbnRoJyksXG4gICAgX19tZXRhZGF0YSQyMihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkMjIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FsZW5kYXJEYXlDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJib3VuZGluZ01vbnRoXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzOChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNlbGVjdGVkJyksXG4gICAgX19tZXRhZGF0YSQyMihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkMjIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FsZW5kYXJEYXlDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMzgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5lbXB0eScpLFxuICAgIF9fbWV0YWRhdGEkMjIoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDIyKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZW1wdHlcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDM4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MuZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhJDIyKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQyMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYWxlbmRhckRheUNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzOChbXG4gICAgSG9zdExpc3RlbmVyKCdjbGljaycpLFxuICAgIF9fbWV0YWRhdGEkMjIoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YSQyMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhJDIyKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTmJDYWxlbmRhckRheUNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcIm9uQ2xpY2tcIiwgbnVsbCk7XG5OYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudCA9IF9fZGVjb3JhdGUkMzgoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItZGF5LWNlbGwnLFxuICAgICAgICB0ZW1wbGF0ZTogJ3t7IGRheSB9fScsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdkYXktY2VsbCcgfVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkMjIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJEYXRlU2VydmljZV0pXG5dLCBOYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDM5ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDIzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFByb3ZpZGVzIGNhcGFiaWxpdHkgcGljayBkYXlzLlxuICogKi9cbmxldCBOYkNhbGVuZGFyRGF5UGlja2VyQ29tcG9uZW50ID0gY2xhc3MgTmJDYWxlbmRhckRheVBpY2tlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobW9udGhNb2RlbCkge1xuICAgICAgICB0aGlzLm1vbnRoTW9kZWwgPSBtb250aE1vZGVsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBpZiB3ZSBzaG91bGQgcmVuZGVyIHByZXZpb3VzIGFuZCBuZXh0IG1vbnRoc1xuICAgICAgICAgKiBpbiB0aGUgY3VycmVudCBtb250aCB2aWV3LlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmJvdW5kaW5nTW9udGhzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jZWxsQ29tcG9uZW50ID0gTmJDYWxlbmRhckRheUNlbGxDb21wb25lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaXplIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqIENhbiBiZSAnbWVkaXVtJyB3aGljaCBpcyBkZWZhdWx0IG9yICdsYXJnZScuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICAgICAgdGhpcy5fc2hvd1dlZWtOdW1iZXIgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIG5ld2x5IHNlbGVjdGVkIGRhdGUuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuZGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3VzdG9tIGRheSBjZWxsIGNvbXBvbmVudC4gSGF2ZSB0byBpbXBsZW1lbnQgYE5iQ2FsZW5kYXJDZWxsYCBpbnRlcmZhY2UuXG4gICAgICogKi9cbiAgICBzZXQgc2V0Q2VsbENvbXBvbmVudChjZWxsQ29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjZWxsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxDb21wb25lbnQgPSBjZWxsQ29tcG9uZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgd2VlayBudW1iZXJzIGNvbHVtbi5cbiAgICAgKiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqICovXG4gICAgZ2V0IHNob3dXZWVrTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvd1dlZWtOdW1iZXI7XG4gICAgfVxuICAgIHNldCBzaG93V2Vla051bWJlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zaG93V2Vla051bWJlciA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICB9XG4gICAgZ2V0IGxhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSBOYkNhbGVuZGFyU2l6ZS5MQVJHRTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoeyB2aXNpYmxlRGF0ZSB9KSB7XG4gICAgICAgIGlmICh2aXNpYmxlRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy53ZWVrcyA9IHRoaXMubW9udGhNb2RlbC5jcmVhdGVEYXlzR3JpZCh0aGlzLnZpc2libGVEYXRlLCB0aGlzLmJvdW5kaW5nTW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvblNlbGVjdChkYXkpIHtcbiAgICAgICAgdGhpcy5kYXRlQ2hhbmdlLmVtaXQoZGF5KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQzOShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDIzKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhckRheVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzaWJsZURhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMzkoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyMyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYkNhbGVuZGFyRGF5UGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJib3VuZGluZ01vbnRoc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQzOShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDIzKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhckRheVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDM5KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjMoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyRGF5UGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMzkoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyMyhcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgTmJDYWxlbmRhckRheVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDM5KFtcbiAgICBJbnB1dCgnY2VsbENvbXBvbmVudCcpLFxuICAgIF9fbWV0YWRhdGEkMjMoXCJkZXNpZ246dHlwZVwiLCBUeXBlKSxcbiAgICBfX21ldGFkYXRhJDIzKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1R5cGVdKVxuXSwgTmJDYWxlbmRhckRheVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2V0Q2VsbENvbXBvbmVudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMzkoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyMyhcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2FsZW5kYXJEYXlQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMzkoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyMyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJEYXlQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMzkoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyMyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkMjMoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYkNhbGVuZGFyRGF5UGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93V2Vla051bWJlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMzkoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyMyhcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2FsZW5kYXJEYXlQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJTeW1ib2xcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMzkoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjMoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyRGF5UGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDM5KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubWVkaXVtJyksXG4gICAgX19tZXRhZGF0YSQyMyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQyMyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYWxlbmRhckRheVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWVkaXVtXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQzOShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmxhcmdlJyksXG4gICAgX19tZXRhZGF0YSQyMyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQyMyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYWxlbmRhckRheVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibGFyZ2VcIiwgbnVsbCk7XG5OYkNhbGVuZGFyRGF5UGlja2VyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQzOShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jYWxlbmRhci1kYXktcGlja2VyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmItY2FsZW5kYXItd2Vlay1udW1iZXJzICpuZ0lmPVwic2hvd1dlZWtOdW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3dlZWtzXT1cIndlZWtzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzaXplXT1cInNpemVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3dlZWtOdW1iZXJTeW1ib2xdPVwid2Vla051bWJlclN5bWJvbFwiPlxuICAgIDwvbmItY2FsZW5kYXItd2Vlay1udW1iZXJzPlxuICAgIDxkaXYgY2xhc3M9XCJkYXlzLWNvbnRhaW5lclwiPlxuICAgICAgPG5iLWNhbGVuZGFyLWRheXMtbmFtZXM+PC9uYi1jYWxlbmRhci1kYXlzLW5hbWVzPlxuICAgICAgPG5iLWNhbGVuZGFyLXBpY2tlclxuICAgICAgICAgIFtkYXRhXT1cIndlZWtzXCJcbiAgICAgICAgICBbdmlzaWJsZURhdGVdPVwidmlzaWJsZURhdGVcIlxuICAgICAgICAgIFtzZWxlY3RlZFZhbHVlXT1cImRhdGVcIlxuICAgICAgICAgIFtjZWxsQ29tcG9uZW50XT1cImNlbGxDb21wb25lbnRcIlxuICAgICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgICAgIChzZWxlY3QpPVwib25TZWxlY3QoJGV2ZW50KVwiPlxuICAgICAgPC9uYi1jYWxlbmRhci1waWNrZXI+XG4gICAgPC9kaXY+XG4gIGAsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6ZmxleH0uZGF5cy1jb250YWluZXJ7d2lkdGg6MTAwJX1cXG5cIl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDIzKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iQ2FsZW5kYXJNb250aE1vZGVsU2VydmljZV0pXG5dLCBOYkNhbGVuZGFyRGF5UGlja2VyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkNDAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYkNhbGVuZGFyRGF5c05hbWVzQ29tcG9uZW50ID0gY2xhc3MgTmJDYWxlbmRhckRheXNOYW1lc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgY29uc3QgZGF5cyA9IHRoaXMuY3JlYXRlRGF5c05hbWVzKCk7XG4gICAgICAgIHRoaXMuZGF5cyA9IHRoaXMuc2hpZnRTdGFydE9mV2VlayhkYXlzKTtcbiAgICB9XG4gICAgY3JlYXRlRGF5c05hbWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXREYXlPZldlZWtOYW1lcygpXG4gICAgICAgICAgICAubWFwKHRoaXMubWFya0lmSG9saWRheSk7XG4gICAgfVxuICAgIHNoaWZ0U3RhcnRPZldlZWsoZGF5cykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGF0ZVNlcnZpY2UuZ2V0Rmlyc3REYXlPZldlZWsoKTsgaSsrKSB7XG4gICAgICAgICAgICBkYXlzLnB1c2goZGF5cy5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF5cztcbiAgICB9XG4gICAgbWFya0lmSG9saWRheShuYW1lLCBpKSB7XG4gICAgICAgIHJldHVybiB7IG5hbWUsIGlzSG9saWRheTogaSAlIDYgPT09IDAgfTtcbiAgICB9XG59O1xuTmJDYWxlbmRhckRheXNOYW1lc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUkNDAoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItZGF5cy1uYW1lcycsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImRheVwiICpuZ0Zvcj1cImxldCBkYXkgb2YgZGF5c1wiIFtjbGFzcy5ob2xpZGF5XT1cImRheS5pc0hvbGlkYXlcIj57eyBkYXkubmFtZSB9fTwvZGl2PlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59Omhvc3QgLmRheXtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpjZW50ZXJ9XFxuXCJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQyNChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYkRhdGVTZXJ2aWNlXSlcbl0sIE5iQ2FsZW5kYXJEYXlzTmFtZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ0MSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyNSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xubGV0IE5iQ2FsZW5kYXJIZWFkZXJDb21wb25lbnQgPSBjbGFzcyBOYkNhbGVuZGFySGVhZGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkaXJlY3Rpb25TZXJ2aWNlLCBkYXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLmRpcmVjdGlvblNlcnZpY2UgPSBkaXJlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMubmF2aWdhdGVUb2RheSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5kYXRlID0gdGhpcy5kYXRlU2VydmljZS50b2RheSgpO1xuICAgIH1cbiAgICBnZXQgaXNSdGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvblNlcnZpY2UuaXNSdGwoKTtcbiAgICB9XG4gICAgZ2V0IGlzTHRyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb25TZXJ2aWNlLmlzTHRyKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkNDEoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyNShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDEoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjUoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOYkNhbGVuZGFySGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0ZVRvZGF5XCIsIHZvaWQgMCk7XG5OYkNhbGVuZGFySGVhZGVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQ0MShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jYWxlbmRhci1oZWFkZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJoZWFkZXJcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwidGl0bGVcIiAoY2xpY2spPVwibmF2aWdhdGVUb2RheS5lbWl0KClcIj5cbiAgICAgICAge3sgZGF0ZSB8IGRhdGU6ICdtZWRpdW1EYXRlJyB9fVxuICAgICAgICA8aSBbbmdDbGFzc109XCJ7ICduYi1hcnJvdy1kcm9wcmlnaHQnOiBpc0x0ciwgJ25iLWFycm93LWRyb3BsZWZ0JzogaXNSdGwgfVwiPjwvaT5cbiAgICAgIDwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwic3ViLXRpdGxlXCI+VG9kYXk8L3NwYW4+XG4gICAgPC9kaXY+XG4gIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDI1KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iTGF5b3V0RGlyZWN0aW9uU2VydmljZSwgTmJEYXRlU2VydmljZV0pXG5dLCBOYkNhbGVuZGFySGVhZGVyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkNDIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjYgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYkNhbGVuZGFyTW9udGhDZWxsQ29tcG9uZW50ID0gY2xhc3MgTmJDYWxlbmRhck1vbnRoQ2VsbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuaXNTYW1lTW9udGhTYWZlKHRoaXMuZGF0ZSwgdGhpcy5zZWxlY3RlZFZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHRvZGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1NhbWVNb250aFNhZmUodGhpcy5kYXRlLCB0aGlzLmRhdGVTZXJ2aWNlLnRvZGF5KCkpO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNtYWxsZXJUaGFuTWluKCkgfHwgdGhpcy5ncmVhdGVyVGhhbk1heCgpO1xuICAgIH1cbiAgICBnZXQgbW9udGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmdldE1vbnRoTmFtZSh0aGlzLmRhdGUpO1xuICAgIH1cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0LmVtaXQodGhpcy5kYXRlKTtcbiAgICB9XG4gICAgc21hbGxlclRoYW5NaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5taW4gJiYgdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXModGhpcy5tb250aEVuZCgpLCB0aGlzLm1pbikgPCAwO1xuICAgIH1cbiAgICBncmVhdGVyVGhhbk1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLm1heCAmJiB0aGlzLmRhdGVTZXJ2aWNlLmNvbXBhcmVEYXRlcyh0aGlzLm1vbnRoU3RhcnQoKSwgdGhpcy5tYXgpID4gMDtcbiAgICB9XG4gICAgbW9udGhTdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TW9udGhTdGFydCh0aGlzLmRhdGUpO1xuICAgIH1cbiAgICBtb250aEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0TW9udGhFbmQodGhpcy5kYXRlKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ0MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDI2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhck1vbnRoQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDI2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhck1vbnRoQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDI2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhck1vbnRoQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDQyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyTW9udGhDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDIoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjYoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOYkNhbGVuZGFyTW9udGhDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zZWxlY3RlZCcpLFxuICAgIF9fbWV0YWRhdGEkMjYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDI2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhbGVuZGFyTW9udGhDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNDIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy50b2RheScpLFxuICAgIF9fbWV0YWRhdGEkMjYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDI2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhbGVuZGFyTW9udGhDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b2RheVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNDIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEkMjYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDI2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhbGVuZGFyTW9udGhDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNDIoW1xuICAgIEhvc3RMaXN0ZW5lcignY2xpY2snKSxcbiAgICBfX21ldGFkYXRhJDI2KFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEkMjYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YSQyNihcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE5iQ2FsZW5kYXJNb250aENlbGxDb21wb25lbnQucHJvdG90eXBlLCBcIm9uQ2xpY2tcIiwgbnVsbCk7XG5OYkNhbGVuZGFyTW9udGhDZWxsQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQ0MihbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jYWxlbmRhci1tb250aC1jZWxsJyxcbiAgICAgICAgdGVtcGxhdGU6IGB7eyBtb250aCB9fWAsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICdtb250aC1jZWxsJyB9XG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQyNihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYkRhdGVTZXJ2aWNlXSlcbl0sIE5iQ2FsZW5kYXJNb250aENlbGxDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ0MyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQyNyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuY29uc3QgTU9OVEhTX0lOX1ZJRVcgPSAxMjtcbmNvbnN0IE1PTlRIU19JTl9DT0xVTU4gPSA0O1xubGV0IE5iQ2FsZW5kYXJNb250aFBpY2tlckNvbXBvbmVudCA9IGNsYXNzIE5iQ2FsZW5kYXJNb250aFBpY2tlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNpemUgPSBOYkNhbGVuZGFyU2l6ZS5NRURJVU07XG4gICAgICAgIHRoaXMubW9udGhDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuY2VsbENvbXBvbmVudCA9IE5iQ2FsZW5kYXJNb250aENlbGxDb21wb25lbnQ7XG4gICAgfVxuICAgIHNldCBfY2VsbENvbXBvbmVudChjZWxsQ29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjZWxsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxDb21wb25lbnQgPSBjZWxsQ29tcG9uZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICB9XG4gICAgZ2V0IGxhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSBOYkNhbGVuZGFyU2l6ZS5MQVJHRTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuaW5pdE1vbnRocygpO1xuICAgIH1cbiAgICBpbml0TW9udGhzKCkge1xuICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5kYXRlU2VydmljZS5nZXREYXRlKHRoaXMubW9udGgpO1xuICAgICAgICBjb25zdCB5ZWFyID0gdGhpcy5kYXRlU2VydmljZS5nZXRZZWFyKHRoaXMubW9udGgpO1xuICAgICAgICBjb25zdCBmaXJzdE1vbnRoID0gdGhpcy5kYXRlU2VydmljZS5jcmVhdGVEYXRlKHllYXIsIDAsIGRhdGUpO1xuICAgICAgICBjb25zdCBtb250aHMgPSBbZmlyc3RNb250aF07XG4gICAgICAgIGZvciAobGV0IG1vbnRoSW5kZXggPSAxOyBtb250aEluZGV4IDwgTU9OVEhTX0lOX1ZJRVc7IG1vbnRoSW5kZXgrKykge1xuICAgICAgICAgICAgbW9udGhzLnB1c2godGhpcy5kYXRlU2VydmljZS5hZGRNb250aChmaXJzdE1vbnRoLCBtb250aEluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb250aHMgPSBiYXRjaChtb250aHMsIE1PTlRIU19JTl9DT0xVTU4pO1xuICAgIH1cbiAgICBvblNlbGVjdChtb250aCkge1xuICAgICAgICB0aGlzLm1vbnRoQ2hhbmdlLmVtaXQobW9udGgpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDQzKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjcoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyTW9udGhQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0MyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDI3KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhck1vbnRoUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDMoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyNyhcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgTmJDYWxlbmRhck1vbnRoUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDMoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyNyhcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2FsZW5kYXJNb250aFBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0MyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDI3KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhck1vbnRoUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtb250aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0MyhbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQyNyhcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE5iQ2FsZW5kYXJNb250aFBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibW9udGhDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDMoW1xuICAgIElucHV0KCdjZWxsQ29tcG9uZW50JyksXG4gICAgX19tZXRhZGF0YSQyNyhcImRlc2lnbjp0eXBlXCIsIFR5cGUpLFxuICAgIF9fbWV0YWRhdGEkMjcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVHlwZV0pXG5dLCBOYkNhbGVuZGFyTW9udGhQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIl9jZWxsQ29tcG9uZW50XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ0MyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLm1lZGl1bScpLFxuICAgIF9fbWV0YWRhdGEkMjcoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMjcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FsZW5kYXJNb250aFBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWVkaXVtXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ0MyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmxhcmdlJyksXG4gICAgX19tZXRhZGF0YSQyNyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQyNyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYWxlbmRhck1vbnRoUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYXJnZVwiLCBudWxsKTtcbk5iQ2FsZW5kYXJNb250aFBpY2tlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUkNDMoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItbW9udGgtcGlja2VyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmItY2FsZW5kYXItcGlja2VyXG4gICAgICBbZGF0YV09XCJtb250aHNcIlxuICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgW21heF09XCJtYXhcIlxuICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgW3NlbGVjdGVkVmFsdWVdPVwibW9udGhcIlxuICAgICAgW2NlbGxDb21wb25lbnRdPVwiY2VsbENvbXBvbmVudFwiXG4gICAgICAoc2VsZWN0KT1cIm9uU2VsZWN0KCRldmVudClcIj5cbiAgICA8L25iLWNhbGVuZGFyLXBpY2tlcj5cbiAgYCxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDI3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iRGF0ZVNlcnZpY2VdKVxuXSwgTmJDYWxlbmRhck1vbnRoUGlja2VyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkNDQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjggPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYkNhbGVuZGFyTmF2aWdhdGlvbkNvbXBvbmVudCA9IGNsYXNzIE5iQ2FsZW5kYXJOYXZpZ2F0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VNb2RlID0gbmV3IEV2ZW50RW1pdHRlcih0cnVlKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ0NChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDI4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhck5hdmlnYXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcImRhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDQoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyTmF2aWdhdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hhbmdlTW9kZVwiLCB2b2lkIDApO1xuTmJDYWxlbmRhck5hdmlnYXRpb25Db21wb25lbnQgPSBfX2RlY29yYXRlJDQ0KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWNhbGVuZGFyLW5hdmlnYXRpb24nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxidXR0b24gbmJCdXR0b24gKGNsaWNrKT1cImNoYW5nZU1vZGUuZW1pdCgpXCI+XG4gICAgICB7eyBkYXRlIHwgZGF0ZTogJ01NTSB5eXl5JyB9fVxuICAgIDwvYnV0dG9uPlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc3R5bGVzOiBbYFxuICAgIDpob3N0IHtcbiAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICB9XG5cbiAgICA6aG9zdCBidXR0b24ge1xuICAgICAgaGVpZ2h0OiAzLjEyNXJlbTtcbiAgICB9XG4gIGBdXG4gICAgfSlcbl0sIE5iQ2FsZW5kYXJOYXZpZ2F0aW9uQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkNDUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMjkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYkNhbGVuZGFyUGFnZWFibGVOYXZpZ2F0aW9uQ29tcG9uZW50ID0gY2xhc3MgTmJDYWxlbmRhclBhZ2VhYmxlTmF2aWdhdGlvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZGlyZWN0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLmRpcmVjdGlvblNlcnZpY2UgPSBkaXJlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNoYW5nZU1vZGUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMubmV4dCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5wcmV2ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBnZXQgaXNSdGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvblNlcnZpY2UuaXNSdGwoKTtcbiAgICB9XG4gICAgZ2V0IGlzTHRyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb25TZXJ2aWNlLmlzTHRyKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkNDUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQyOShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJQYWdlYWJsZU5hdmlnYXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcImRhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMjkoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyUGFnZWFibGVOYXZpZ2F0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjaGFuZ2VNb2RlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDQ1KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDI5KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhclBhZ2VhYmxlTmF2aWdhdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwibmV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0NShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQyOShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJQYWdlYWJsZU5hdmlnYXRpb25Db21wb25lbnQucHJvdG90eXBlLCBcInByZXZcIiwgdm9pZCAwKTtcbk5iQ2FsZW5kYXJQYWdlYWJsZU5hdmlnYXRpb25Db21wb25lbnQgPSBfX2RlY29yYXRlJDQ1KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWNhbGVuZGFyLXBhZ2VhYmxlLW5hdmlnYXRpb24nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxidXR0b24gbmJCdXR0b24gKGNsaWNrKT1cInByZXYuZW1pdCgpXCIgZ2hvc3Qgc2l6ZT1cInNtYWxsXCIgY2xhc3M9XCJwcmV2LW1vbnRoXCI+XG4gICAgICA8bmItaWNvbiBbaWNvbl09XCJpc0x0ciA/ICdjaGV2cm9uLWxlZnQtb3V0bGluZScgOiAnY2hldnJvbi1yaWdodC1vdXRsaW5lJ1wiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIj48L25iLWljb24+XG4gICAgPC9idXR0b24+XG4gICAgPG5iLWNhbGVuZGFyLW5hdmlnYXRpb24gW2RhdGVdPVwiZGF0ZVwiIChjaGFuZ2VNb2RlKT1cImNoYW5nZU1vZGUuZW1pdCgpXCI+PC9uYi1jYWxlbmRhci1uYXZpZ2F0aW9uPlxuICAgIDxidXR0b24gbmJCdXR0b24gKGNsaWNrKT1cIm5leHQuZW1pdCgpXCIgZ2hvc3Qgc2l6ZT1cInNtYWxsXCIgY2xhc3M9XCJuZXh0LW1vbnRoXCI+XG4gICAgICA8bmItaWNvbiBbaWNvbl09XCJpc0x0ciA/ICdjaGV2cm9uLXJpZ2h0LW91dGxpbmUnIDogJ2NoZXZyb24tbGVmdC1vdXRsaW5lJ1wiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIj48L25iLWljb24+XG4gICAgPC9idXR0b24+XG4gIGAsXG4gICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn1bZGlyPWx0cl0gOmhvc3QgLnByZXYtbW9udGh7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6MC40cmVtfVtkaXI9cnRsXSA6aG9zdCAucHJldi1tb250aHttYXJnaW4tbGVmdDowLjRyZW07bWFyZ2luLXJpZ2h0OmF1dG99W2Rpcj1sdHJdIDpob3N0IC5uZXh0LW1vbnRoe21hcmdpbi1sZWZ0OjAuNHJlbTttYXJnaW4tcmlnaHQ6YXV0b31bZGlyPXJ0bF0gOmhvc3QgLm5leHQtbW9udGh7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6MC40cmVtfW5iLWNhbGVuZGFyLW5hdmlnYXRpb257bWFyZ2luOjAgMC41cmVtfVxcblwiXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkMjkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlXSlcbl0sIE5iQ2FsZW5kYXJQYWdlYWJsZU5hdmlnYXRpb25Db21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ0NiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzMCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xubGV0IE5iQ2FsZW5kYXJQaWNrZXJDb21wb25lbnQgPSBjbGFzcyBOYkNhbGVuZGFyUGlja2VyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkNDYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzMChcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgTmJDYWxlbmRhclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0NihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDMwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzaWJsZURhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzMChcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGVkVmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzMChcImRlc2lnbjp0eXBlXCIsIFR5cGUpXG5dLCBOYkNhbGVuZGFyUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjZWxsQ29tcG9uZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDQ2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzMChcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0NihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDMwKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBOYkNhbGVuZGFyUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDYoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzAoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOYkNhbGVuZGFyUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbk5iQ2FsZW5kYXJQaWNrZXJDb21wb25lbnQgPSBfX2RlY29yYXRlJDQ2KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWNhbGVuZGFyLXBpY2tlcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLWNhbGVuZGFyLXBpY2tlci1yb3dcbiAgICAgICpuZ0Zvcj1cImxldCByb3cgb2YgZGF0YVwiXG4gICAgICBbcm93XT1cInJvd1wiXG4gICAgICBbdmlzaWJsZURhdGVdPVwidmlzaWJsZURhdGVcIlxuICAgICAgW3NlbGVjdGVkVmFsdWVdPVwic2VsZWN0ZWRWYWx1ZVwiXG4gICAgICBbY29tcG9uZW50XT1cImNlbGxDb21wb25lbnRcIlxuICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgW21heF09XCJtYXhcIlxuICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgKHNlbGVjdCk9XCJzZWxlY3QuZW1pdCgkZXZlbnQpXCI+XG4gICAgPC9uYi1jYWxlbmRhci1waWNrZXItcm93PlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgIH0pXG5dLCBOYkNhbGVuZGFyUGlja2VyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkNDcgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMzEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYkNhbGVuZGFyUGlja2VyUm93Q29tcG9uZW50ID0gY2xhc3MgTmJDYWxlbmRhclBpY2tlclJvd0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY2ZyKSB7XG4gICAgICAgIHRoaXMuY2ZyID0gY2ZyO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLmNmci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeSh0aGlzLmNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyUmVmLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucm93LmZvckVhY2goKGRhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuY29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChmYWN0b3J5KTtcbiAgICAgICAgICAgIHRoaXMucGF0Y2hXaXRoQ29udGV4dChjb21wb25lbnQuaW5zdGFuY2UsIGRhdGUpO1xuICAgICAgICAgICAgY29tcG9uZW50LmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhdGNoV2l0aENvbnRleHQoY29tcG9uZW50LCBkYXRlKSB7XG4gICAgICAgIGNvbXBvbmVudC52aXNpYmxlRGF0ZSA9IHRoaXMudmlzaWJsZURhdGU7XG4gICAgICAgIGNvbXBvbmVudC5zZWxlY3RlZFZhbHVlID0gdGhpcy5zZWxlY3RlZFZhbHVlO1xuICAgICAgICBjb21wb25lbnQuZGF0ZSA9IGRhdGU7XG4gICAgICAgIGNvbXBvbmVudC5taW4gPSB0aGlzLm1pbjtcbiAgICAgICAgY29tcG9uZW50Lm1heCA9IHRoaXMubWF4O1xuICAgICAgICBjb21wb25lbnQuZmlsdGVyID0gdGhpcy5maWx0ZXI7XG4gICAgICAgIGNvbXBvbmVudC5zZWxlY3Quc3Vic2NyaWJlKHRoaXMuc2VsZWN0LmVtaXQuYmluZCh0aGlzLnNlbGVjdCkpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDQ3KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIE5iQ2FsZW5kYXJQaWNrZXJSb3dDb21wb25lbnQucHJvdG90eXBlLCBcInJvd1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0NyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDMxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhclBpY2tlclJvd0NvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0NyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDMxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhclBpY2tlclJvd0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzaWJsZURhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDcoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzMShcImRlc2lnbjp0eXBlXCIsIFR5cGUpXG5dLCBOYkNhbGVuZGFyUGlja2VyUm93Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb21wb25lbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDcoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzMShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJQaWNrZXJSb3dDb21wb25lbnQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0NyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDMxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhclBpY2tlclJvd0NvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDQ3KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIE5iQ2FsZW5kYXJQaWNrZXJSb3dDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0NyhbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQzMShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE5iQ2FsZW5kYXJQaWNrZXJSb3dDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0NyhbXG4gICAgVmlld0NoaWxkKFRlbXBsYXRlUmVmLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYsIHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhJDMxKFwiZGVzaWduOnR5cGVcIiwgVmlld0NvbnRhaW5lclJlZilcbl0sIE5iQ2FsZW5kYXJQaWNrZXJSb3dDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRhaW5lclJlZlwiLCB2b2lkIDApO1xuTmJDYWxlbmRhclBpY2tlclJvd0NvbXBvbmVudCA9IF9fZGVjb3JhdGUkNDcoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItcGlja2VyLXJvdycsXG4gICAgICAgIHRlbXBsYXRlOiAnPG5nLXRlbXBsYXRlPjwvbmctdGVtcGxhdGU+JyxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHN0eWxlczogW2BcbiAgICA6aG9zdCB7XG4gICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIH1cbiAgYF1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDMxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcl0pXG5dLCBOYkNhbGVuZGFyUGlja2VyUm93Q29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkNDggPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMzIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYkNhbGVuZGFyWWVhckNlbGxDb21wb25lbnQgPSBjbGFzcyBOYkNhbGVuZGFyWWVhckNlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKHRydWUpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmlzU2FtZVllYXJTYWZlKHRoaXMuZGF0ZSwgdGhpcy5zZWxlY3RlZFZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHRvZGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1NhbWVZZWFyU2FmZSh0aGlzLmRhdGUsIHRoaXMuZGF0ZVNlcnZpY2UudG9kYXkoKSk7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc21hbGxlclRoYW5NaW4oKSB8fCB0aGlzLmdyZWF0ZXJUaGFuTWF4KCk7XG4gICAgfVxuICAgIGdldCB5ZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXRZZWFyKHRoaXMuZGF0ZSk7XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3QuZW1pdCh0aGlzLmRhdGUpO1xuICAgIH1cbiAgICBzbWFsbGVyVGhhbk1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLm1pbiAmJiB0aGlzLmRhdGVTZXJ2aWNlLmNvbXBhcmVEYXRlcyh0aGlzLnllYXJFbmQoKSwgdGhpcy5taW4pIDwgMDtcbiAgICB9XG4gICAgZ3JlYXRlclRoYW5NYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5tYXggJiYgdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXModGhpcy55ZWFyU3RhcnQoKSwgdGhpcy5tYXgpID4gMDtcbiAgICB9XG4gICAgeWVhclN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXRZZWFyU3RhcnQodGhpcy5kYXRlKTtcbiAgICB9XG4gICAgeWVhckVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVNlcnZpY2UuZ2V0WWVhckVuZCh0aGlzLmRhdGUpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDQ4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzIoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyWWVhckNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDgoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzMihcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJZZWFyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDQ4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzIoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyWWVhckNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0OChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDMyKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhclllYXJDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZFZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDQ4KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDMyKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTmJDYWxlbmRhclllYXJDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zZWxlY3RlZCcpLFxuICAgIF9fbWV0YWRhdGEkMzIoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDMyKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhbGVuZGFyWWVhckNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ0OChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnRvZGF5JyksXG4gICAgX19tZXRhZGF0YSQzMihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkMzIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FsZW5kYXJZZWFyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9kYXlcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDQ4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MuZGlzYWJsZWQnKSxcbiAgICBfX21ldGFkYXRhJDMyKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQzMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYWxlbmRhclllYXJDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNDgoW1xuICAgIEhvc3RMaXN0ZW5lcignY2xpY2snKSxcbiAgICBfX21ldGFkYXRhJDMyKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEkMzIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YSQzMihcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE5iQ2FsZW5kYXJZZWFyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwib25DbGlja1wiLCBudWxsKTtcbk5iQ2FsZW5kYXJZZWFyQ2VsbENvbXBvbmVudCA9IF9fZGVjb3JhdGUkNDgoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXIteWVhci1jZWxsJyxcbiAgICAgICAgdGVtcGxhdGU6IGB7eyB5ZWFyIH19YCxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIGhvc3Q6IHsgJ2NsYXNzJzogJ3llYXItY2VsbCcgfVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkMzIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJEYXRlU2VydmljZV0pXG5dLCBOYkNhbGVuZGFyWWVhckNlbGxDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ0OSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzMyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuY29uc3QgWUVBUlNfSU5fVklFVyA9IDIwO1xuY29uc3QgWUVBUlNfSU5fQ09MVU1OID0gNDtcbmxldCBOYkNhbGVuZGFyWWVhclBpY2tlckNvbXBvbmVudCA9IGNsYXNzIE5iQ2FsZW5kYXJZZWFyUGlja2VyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2VsbENvbXBvbmVudCA9IE5iQ2FsZW5kYXJZZWFyQ2VsbENvbXBvbmVudDtcbiAgICAgICAgdGhpcy5zaXplID0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgICAgICB0aGlzLnllYXJDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIHNldCBfY2VsbENvbXBvbmVudChjZWxsQ29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjZWxsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNlbGxDb21wb25lbnQgPSBjZWxsQ29tcG9uZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICB9XG4gICAgZ2V0IGxhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSBOYkNhbGVuZGFyU2l6ZS5MQVJHRTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMuaW5pdFllYXJzKCk7XG4gICAgfVxuICAgIGluaXRZZWFycygpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRZZWFyID0gdGhpcy5kYXRlU2VydmljZS5nZXRZZWFyKHRoaXMueWVhcik7XG4gICAgICAgIGNvbnN0IHN0YXJ0WWVhciA9IE1hdGguY2VpbChzZWxlY3RlZFllYXIgLSBZRUFSU19JTl9WSUVXIC8gMik7XG4gICAgICAgIGNvbnN0IHllYXJzID0gcmFuZ2UoWUVBUlNfSU5fVklFVykubWFwKGkgPT4gdGhpcy5jcmVhdGVZZWFyRGF0ZUJ5SW5kZXgoaSArIHN0YXJ0WWVhcikpO1xuICAgICAgICB0aGlzLnllYXJzID0gYmF0Y2goeWVhcnMsIFlFQVJTX0lOX0NPTFVNTik7XG4gICAgfVxuICAgIG9uU2VsZWN0KHllYXIpIHtcbiAgICAgICAgdGhpcy55ZWFyQ2hhbmdlLmVtaXQoeWVhcik7XG4gICAgfVxuICAgIGNyZWF0ZVllYXJEYXRlQnlJbmRleChpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmNyZWF0ZURhdGUoaSwgdGhpcy5kYXRlU2VydmljZS5nZXRNb250aCh0aGlzLnllYXIpLCB0aGlzLmRhdGVTZXJ2aWNlLmdldERhdGUodGhpcy55ZWFyKSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkNDkoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzMyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJZZWFyUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDQ5KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzMoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyWWVhclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDQ5KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzMoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyWWVhclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDQ5KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzMoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIE5iQ2FsZW5kYXJZZWFyUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWx0ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDkoW1xuICAgIElucHV0KCdjZWxsQ29tcG9uZW50JyksXG4gICAgX19tZXRhZGF0YSQzMyhcImRlc2lnbjp0eXBlXCIsIFR5cGUpLFxuICAgIF9fbWV0YWRhdGEkMzMoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVHlwZV0pXG5dLCBOYkNhbGVuZGFyWWVhclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiX2NlbGxDb21wb25lbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDQ5KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzMoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNhbGVuZGFyWWVhclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0OShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDMzKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhclllYXJQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInllYXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNDkoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzMoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyWWVhclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwieWVhckNoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ0OShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLm1lZGl1bScpLFxuICAgIF9fbWV0YWRhdGEkMzMoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMzMoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FsZW5kYXJZZWFyUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtZWRpdW1cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDQ5KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubGFyZ2UnKSxcbiAgICBfX21ldGFkYXRhJDMzKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDMzKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhbGVuZGFyWWVhclBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibGFyZ2VcIiwgbnVsbCk7XG5OYkNhbGVuZGFyWWVhclBpY2tlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUkNDkoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXIteWVhci1waWNrZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuYi1jYWxlbmRhci1waWNrZXJcbiAgICAgIFtkYXRhXT1cInllYXJzXCJcbiAgICAgIFttaW5dPVwibWluXCJcbiAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgIFtmaWx0ZXJdPVwiZmlsdGVyXCJcbiAgICAgIFtzZWxlY3RlZFZhbHVlXT1cImRhdGVcIlxuICAgICAgW3Zpc2libGVEYXRlXT1cInllYXJcIlxuICAgICAgW2NlbGxDb21wb25lbnRdPVwiY2VsbENvbXBvbmVudFwiXG4gICAgICAoc2VsZWN0KT1cIm9uU2VsZWN0KCRldmVudClcIj5cbiAgICA8L25iLWNhbGVuZGFyLXBpY2tlcj5cbiAgYCxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDMzKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iRGF0ZVNlcnZpY2VdKVxuXSwgTmJDYWxlbmRhclllYXJQaWNrZXJDb21wb25lbnQpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDUwID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDM0ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5sZXQgTmJDYWxlbmRhcldlZWtOdW1iZXJDb21wb25lbnQgPSBjbGFzcyBOYkNhbGVuZGFyV2Vla051bWJlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgIH1cbiAgICBnZXQgaXNNZWRpdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICB9XG4gICAgZ2V0IGlzTGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLkxBUkdFO1xuICAgIH1cbiAgICBnZXRXZWVrcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla3MubWFwKCh3ZWVrKSA9PiB7XG4gICAgICAgICAgICAvLyBGaW5kIGxhc3QgZGVmaW5lZCBkYXkgYXMgd2VlayBjb3VsZCBjb250YWluIG51bGwgZGF5cyBpbiBjYXNlXG4gICAgICAgICAgICAvLyBib3VuZGluZ01vbnRoIHNldCB0byBmYWxzZVxuICAgICAgICAgICAgY29uc3QgbGFzdERheSA9IFsuLi53ZWVrXS5yZXZlcnNlKCkuZmluZCgoZGF5KSA9PiAhIWRheSk7XG4gICAgICAgICAgICAvLyBVc2UgbGFzdCBkYXkgb2YgdGhlIHdlZWsgdG8gZGV0ZXJtaW5lIHdlZWsgbnVtYmVyLlxuICAgICAgICAgICAgLy8gVGhpcyB3YXkgd2Vla3Mgd2hpY2ggc3BhbiBiZXR3ZWVuIHNpYmxpbmcgeWVhcnMgaXMgbWFya2VkIGZpcnN0XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXRXZWVrTnVtYmVyKGxhc3REYXkpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ1MChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM0KFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBOYkNhbGVuZGFyV2Vla051bWJlckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTAoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzNChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2FsZW5kYXJXZWVrTnVtYmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDUwKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzQoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNhbGVuZGFyV2Vla051bWJlckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclN5bWJvbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtbWVkaXVtJyksXG4gICAgX19tZXRhZGF0YSQzNChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQzNChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYWxlbmRhcldlZWtOdW1iZXJDb21wb25lbnQucHJvdG90eXBlLCBcImlzTWVkaXVtXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ1MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtbGFyZ2UnKSxcbiAgICBfX21ldGFkYXRhJDM0KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDM0KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhbGVuZGFyV2Vla051bWJlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNMYXJnZVwiLCBudWxsKTtcbk5iQ2FsZW5kYXJXZWVrTnVtYmVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQ1MChbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jYWxlbmRhci13ZWVrLW51bWJlcnMnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJzaWduXCI+e3sgd2Vla051bWJlclN5bWJvbCB9fTwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJ3ZWVrLWNlbGxcIiAqbmdGb3I9XCJsZXQgd2VlayBvZiBnZXRXZWVrcygpXCI+e3sgd2VlayB9fTwvZGl2PlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufVxcblwiXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkMzQoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJEYXRlU2VydmljZV0pXG5dLCBOYkNhbGVuZGFyV2Vla051bWJlckNvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDUxID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDM1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQ5ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBUaGUgYE5iTmF0aXZlRGF0ZVNlcnZpY2VgIGlzIGJhc2ljIGltcGxlbWVudGF0aW9uIG9mIGBOYkRhdGVTZXJ2aWNlYCB1c2luZ1xuICogbmF0aXZlIGpzIGRhdGUgb2JqZWN0cyBhbmQgYW5ndWxhciBsb2NhbGl6YXRpb24gc2VydmljZXMuXG4gKiAqL1xubGV0IE5iTmF0aXZlRGF0ZVNlcnZpY2UgPSBjbGFzcyBOYk5hdGl2ZURhdGVTZXJ2aWNlIGV4dGVuZHMgTmJEYXRlU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IobG9jYWxlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2V0TG9jYWxlKGxvY2FsZSk7XG4gICAgfVxuICAgIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgc3VwZXIuc2V0TG9jYWxlKGxvY2FsZSk7XG4gICAgICAgIHRoaXMuZGF0ZVBpcGUgPSBuZXcgRGF0ZVBpcGUobG9jYWxlKTtcbiAgICB9XG4gICAgaXNWYWxpZERhdGVTdHJpbmcoZGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiAhaXNOYU4odGhpcy5wYXJzZShkYXRlLCBmb3JtYXQpLmdldFRpbWUoKSk7XG4gICAgfVxuICAgIHRvZGF5KCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgZ2V0RGF0ZShkYXRlKSB7XG4gICAgICAgIHJldHVybiBkYXRlLmdldERhdGUoKTtcbiAgICB9XG4gICAgZ2V0TW9udGgoZGF0ZSkge1xuICAgICAgICByZXR1cm4gZGF0ZS5nZXRNb250aCgpO1xuICAgIH1cbiAgICBnZXRZZWFyKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICB9XG4gICAgZ2V0RGF5T2ZXZWVrKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUuZ2V0RGF5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHJldHVybnMgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLCBpdCBjYW4gYmUgMSBpZiB3ZWVrIHN0YXJ0cyBmcm9tIG1vbmRheVxuICAgICAqIGFuZCAwIGlmIGZyb20gc3VuZGF5IGFuZCBzbyBvbi5cbiAgICAgKiAqL1xuICAgIGdldEZpcnN0RGF5T2ZXZWVrKCkge1xuICAgICAgICByZXR1cm4gZ2V0TG9jYWxlRmlyc3REYXlPZldlZWsodGhpcy5sb2NhbGUpO1xuICAgIH1cbiAgICBnZXRNb250aE5hbWUoZGF0ZSwgc3R5bGUkJDEgPSBUcmFuc2xhdGlvbldpZHRoLkFiYnJldmlhdGVkKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZGF0ZS5nZXRNb250aCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNb250aE5hbWVCeUluZGV4KGluZGV4LCBzdHlsZSQkMSk7XG4gICAgfVxuICAgIGdldE1vbnRoTmFtZUJ5SW5kZXgoaW5kZXgsIHN0eWxlJCQxID0gVHJhbnNsYXRpb25XaWR0aC5BYmJyZXZpYXRlZCkge1xuICAgICAgICByZXR1cm4gZ2V0TG9jYWxlTW9udGhOYW1lcyh0aGlzLmxvY2FsZSwgRm9ybVN0eWxlLkZvcm1hdCwgc3R5bGUkJDEpW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0RGF5T2ZXZWVrTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBnZXRMb2NhbGVEYXlOYW1lcyh0aGlzLmxvY2FsZSwgRm9ybVN0eWxlLkZvcm1hdCwgVHJhbnNsYXRpb25XaWR0aC5TaG9ydCk7XG4gICAgfVxuICAgIGZvcm1hdChkYXRlLCBmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVBpcGUudHJhbnNmb3JtKGRhdGUsIGZvcm1hdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdlIGhhdmVuJ3QgZ290IGNhcGFiaWxpdHkgdG8gcGFyc2UgZGF0ZSB1c2luZyBmb3JtYXR0aW5nIHdpdGhvdXQgdGhpcmQgcGFydHkgbGlicmFyaWVzLlxuICAgICAqICovXG4gICAgcGFyc2UoZGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLnBhcnNlKGRhdGUpKTtcbiAgICB9XG4gICAgYWRkRGF5KGRhdGUsIG51bSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSArIG51bSk7XG4gICAgfVxuICAgIGFkZE1vbnRoKGRhdGUsIG51bSkge1xuICAgICAgICBjb25zdCBtb250aCA9IHRoaXMuY3JlYXRlRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIG51bSwgMSk7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZGF0ZSBoYXMgbW9yZSBkYXlzIHRoYW4gY2FsY3VsYXRlZCBtb250aCBqcyBEYXRlIHdpbGwgY2hhbmdlIHRoYXQgbW9udGggdG8gdGhlIG5leHQgb25lXG4gICAgICAgIC8vIGJlY2F1c2Ugb2YgdGhlIGRhdGUgb3ZlcmZsb3cuXG4gICAgICAgIG1vbnRoLnNldERhdGUoTWF0aC5taW4oZGF0ZS5nZXREYXRlKCksIHRoaXMuZ2V0TW9udGhFbmQobW9udGgpLmdldERhdGUoKSkpO1xuICAgICAgICByZXR1cm4gbW9udGg7XG4gICAgfVxuICAgIGFkZFllYXIoZGF0ZSwgbnVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURhdGUoZGF0ZS5nZXRGdWxsWWVhcigpICsgbnVtLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcbiAgICB9XG4gICAgY2xvbmUoZGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZS5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICBjb21wYXJlRGF0ZXMoZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiBkYXRlMS5nZXRUaW1lKCkgLSBkYXRlMi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGNyZWF0ZURhdGUoeWVhciwgbW9udGgsIGRhdGUpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IERhdGUoeWVhciwgbW9udGgsIGRhdGUpO1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGNvcnJlY3QgZm9yIHRoZSBmYWN0IHRoYXQgSlMgbmF0aXZlIERhdGUgdHJlYXRzIHllYXJzIGluIHJhbmdlIFswLCA5OV0gYXNcbiAgICAgICAgLy8gYWJicmV2aWF0aW9ucyBmb3IgMTl4eC5cbiAgICAgICAgaWYgKHllYXIgPj0gMCAmJiB5ZWFyIDwgMTAwKSB7XG4gICAgICAgICAgICByZXN1bHQuc2V0RnVsbFllYXIocmVzdWx0LmdldEZ1bGxZZWFyKCkgLSAxOTAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZXRNb250aEVuZChkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCkgKyAxLCAwKTtcbiAgICB9XG4gICAgZ2V0TW9udGhTdGFydChkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIDEpO1xuICAgIH1cbiAgICBnZXROdW1iZXJPZkRheXNJbk1vbnRoKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TW9udGhFbmQoZGF0ZSkuZ2V0RGF0ZSgpO1xuICAgIH1cbiAgICBnZXRZZWFyRW5kKGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDExLCAzMSk7XG4gICAgfVxuICAgIGdldFllYXJTdGFydChkYXRlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZURhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgICB9XG4gICAgaXNTYW1lRGF5KGRhdGUxLCBkYXRlMikge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWVNb250aChkYXRlMSwgZGF0ZTIpICYmXG4gICAgICAgICAgICBkYXRlMS5nZXREYXRlKCkgPT09IGRhdGUyLmdldERhdGUoKTtcbiAgICB9XG4gICAgaXNTYW1lTW9udGgoZGF0ZTEsIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZVllYXIoZGF0ZTEsIGRhdGUyKSAmJlxuICAgICAgICAgICAgZGF0ZTEuZ2V0TW9udGgoKSA9PT0gZGF0ZTIuZ2V0TW9udGgoKTtcbiAgICB9XG4gICAgaXNTYW1lWWVhcihkYXRlMSwgZGF0ZTIpIHtcbiAgICAgICAgcmV0dXJuIGRhdGUxLmdldEZ1bGxZZWFyKCkgPT09IGRhdGUyLmdldEZ1bGxZZWFyKCk7XG4gICAgfVxuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gJ25hdGl2ZSc7XG4gICAgfVxuICAgIGdldFdlZWtOdW1iZXIoZGF0ZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5kYXRlUGlwZS50cmFuc2Zvcm0oZGF0ZSwgJ3cnKSwgMTApO1xuICAgIH1cbn07XG5OYk5hdGl2ZURhdGVTZXJ2aWNlID0gX19kZWNvcmF0ZSQ1MShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fcGFyYW0kOSgwLCBJbmplY3QoTE9DQUxFX0lEKSksXG4gICAgX19tZXRhZGF0YSQzNShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgTmJOYXRpdmVEYXRlU2VydmljZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDM0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmNvbnN0IFNFUlZJQ0VTID0gW1xuICAgIHsgcHJvdmlkZTogTmJEYXRlU2VydmljZSwgdXNlQ2xhc3M6IE5iTmF0aXZlRGF0ZVNlcnZpY2UgfSxcbiAgICBEYXRlUGlwZSxcbiAgICBOYkNhbGVuZGFyTW9udGhNb2RlbFNlcnZpY2UsXG5dO1xuY29uc3QgQ09NUE9ORU5UUyA9IFtcbiAgICBOYkNhbGVuZGFySGVhZGVyQ29tcG9uZW50LFxuICAgIE5iQ2FsZW5kYXJOYXZpZ2F0aW9uQ29tcG9uZW50LFxuICAgIE5iQ2FsZW5kYXJQYWdlYWJsZU5hdmlnYXRpb25Db21wb25lbnQsXG4gICAgTmJDYWxlbmRhckRheXNOYW1lc0NvbXBvbmVudCxcbiAgICBOYkNhbGVuZGFyWWVhclBpY2tlckNvbXBvbmVudCxcbiAgICBOYkNhbGVuZGFyTW9udGhQaWNrZXJDb21wb25lbnQsXG4gICAgTmJDYWxlbmRhckRheVBpY2tlckNvbXBvbmVudCxcbiAgICBOYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudCxcbiAgICBOYkNhbGVuZGFyTW9udGhDZWxsQ29tcG9uZW50LFxuICAgIE5iQ2FsZW5kYXJZZWFyQ2VsbENvbXBvbmVudCxcbiAgICBOYkNhbGVuZGFyUGlja2VyUm93Q29tcG9uZW50LFxuICAgIE5iQ2FsZW5kYXJQaWNrZXJDb21wb25lbnQsXG4gICAgTmJDYWxlbmRhcldlZWtOdW1iZXJDb21wb25lbnQsXG5dO1xuLyoqXG4gKiBgTmJDYWxlbmRhcktpdE1vZHVsZWAgaXMgYSBtb2R1bGUgdGhhdCBjb250YWlucyBtdWx0aXBsZSB1c2VmdWwgY29tcG9uZW50cyBmb3IgYnVpbGRpbmcgY3VzdG9tIGNhbGVuZGFycy5cbiAqIFNvIGlmIHlvdSB0aGluayBvdXIgY2FsZW5kYXJzIGlzIG5vdCBlbm91Z2ggcG93ZXJmdWwgZm9yIHlvdSBqdXN0IHVzZSBjYWxlbmRhci1raXQgYW5kIGJ1aWxkIHlvdXIgb3duIGNhbGVuZGFyIVxuICpcbiAqIEF2YWlsYWJsZSBjb21wb25lbnRzOlxuICogLSBgTmJDYWxlbmRhckRheVBpY2tlcmBcbiAqIC0gYE5iQ2FsZW5kYXJEYXlDZWxsYFxuICogLSBgTmJDYWxlbmRhck1vbnRoUGlja2VyYFxuICogLSBgTmJDYWxlbmRhck1vbnRoQ2VsbGBcbiAqIC0gYE5iQ2FsZW5kYXJZZWFyUGlja2VyYFxuICogLSBgTmJDYWxlbmRhclllYXJDZWxsYFxuICogLSBgTmJDYWxlbmRhckhlYWRlcmBcbiAqIC0gYE5iQ2FsZW5kYXJOYXZpZ2F0aW9uYFxuICogLSBgTmJDYWxlbmRhclBhZ2VhYmxlTmF2aWdhdGlvbmBcbiAqXG4gKiBGb3IgZXhhbXBsZSB5b3UgY2FuIGVhc2lseSBidWlsZCBmdWxsIGNhbGVuZGFyOlxuICogQHN0YWNrZWQtZXhhbXBsZShGdWxsIGNhbGVuZGFyLCBjYWxlbmRhci1raXQvY2FsZW5kYXIta2l0LWZ1bGwtY2FsZW5kYXIuY29tcG9uZW50KVxuICogKi9cbmxldCBOYkNhbGVuZGFyS2l0TW9kdWxlID0gY2xhc3MgTmJDYWxlbmRhcktpdE1vZHVsZSB7XG59O1xuTmJDYWxlbmRhcktpdE1vZHVsZSA9IF9fZGVjb3JhdGUkMzQoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW05iU2hhcmVkTW9kdWxlLCBOYkJ1dHRvbk1vZHVsZSwgTmJJY29uTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogWy4uLkNPTVBPTkVOVFNdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFsuLi5DT01QT05FTlRTXSxcbiAgICAgICAgcHJvdmlkZXJzOiBbLi4uU0VSVklDRVNdLFxuICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgIE5iQ2FsZW5kYXJEYXlDZWxsQ29tcG9uZW50LFxuICAgICAgICAgICAgTmJDYWxlbmRhck1vbnRoQ2VsbENvbXBvbmVudCxcbiAgICAgICAgICAgIE5iQ2FsZW5kYXJZZWFyQ2VsbENvbXBvbmVudCxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJDYWxlbmRhcktpdE1vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDUyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDM2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFRoZSBiYXNpcyBmb3IgY2FsZW5kYXIgYW5kIHJhbmdlIGNhbGVuZGFyIGNvbXBvbmVudHMuXG4gKiBFbmNhcHN1bGF0ZXMgY29tbW9uIGJlaGF2aW9yIC0gc3RvcmUgY2FsZW5kYXIgc3RhdGUgYW5kIHBlcmZvcm0gbmF2aWdhdGlvblxuICogYmV0d2VlbiBwaWNrZXJzLlxuICogKi9cbmxldCBOYkJhc2VDYWxlbmRhckNvbXBvbmVudCA9IGNsYXNzIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIGlmIHdlIHNob3VsZCByZW5kZXIgcHJldmlvdXMgYW5kIG5leHQgbW9udGhzXG4gICAgICAgICAqIGluIHRoZSBjdXJyZW50IG1vbnRoIHZpZXcuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuYm91bmRpbmdNb250aCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIGFjdGl2ZSB2aWV3IGZvciBjYWxlbmRhci5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3TW9kZSA9IE5iQ2FsZW5kYXJWaWV3TW9kZS5EQVRFO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2l6ZSBvZiB0aGUgY2FsZW5kYXIgYW5kIGVudGlyZSBjb21wb25lbnRzLlxuICAgICAgICAgKiBDYW4gYmUgJ21lZGl1bScgd2hpY2ggaXMgZGVmYXVsdCBvciAnbGFyZ2UnLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnNpemUgPSBOYkNhbGVuZGFyU2l6ZS5NRURJVU07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHNob3VsZCB3ZSBzaG93IGNhbGVuZGFycyBoZWFkZXIgb3Igbm90LlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnNob3dIZWFkZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zaG93V2Vla051bWJlciA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgZGF0ZSB3aGVuIHNlbGVjdGVkLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmRhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuVmlld01vZGUgPSBOYkNhbGVuZGFyVmlld01vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgd2VlayBudW1iZXJzIGNvbHVtbi5cbiAgICAgKiBGYWxzZSBieSBkZWZhdWx0LlxuICAgICAqICovXG4gICAgZ2V0IHNob3dXZWVrTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvd1dlZWtOdW1iZXI7XG4gICAgfVxuICAgIHNldCBzaG93V2Vla051bWJlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zaG93V2Vla051bWJlciA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZURhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZURhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLnRvZGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG1lZGl1bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09IE5iQ2FsZW5kYXJTaXplLkxBUkdFO1xuICAgIH1cbiAgICBzZXRWaWV3TW9kZSh2aWV3TW9kZSkge1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXdNb2RlID0gdmlld01vZGU7XG4gICAgfVxuICAgIHNldFZpc2libGVEYXRlKHZpc2libGVEYXRlKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZURhdGUgPSB2aXNpYmxlRGF0ZTtcbiAgICB9XG4gICAgcHJldk1vbnRoKCkge1xuICAgICAgICB0aGlzLmNoYW5nZVZpc2libGVNb250aCgtMSk7XG4gICAgfVxuICAgIG5leHRNb250aCgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWaXNpYmxlTW9udGgoMSk7XG4gICAgfVxuICAgIHByZXZZZWFycygpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWaXNpYmxlWWVhcigtMSk7XG4gICAgfVxuICAgIG5leHRZZWFycygpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VWaXNpYmxlWWVhcigxKTtcbiAgICB9XG4gICAgbmF2aWdhdGVUb2RheSgpIHtcbiAgICAgICAgdGhpcy5zZXRWaWV3TW9kZShOYkNhbGVuZGFyVmlld01vZGUuREFURSk7XG4gICAgICAgIHRoaXMudmlzaWJsZURhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLnRvZGF5KCk7XG4gICAgfVxuICAgIGNoYW5nZVZpc2libGVNb250aChkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy52aXNpYmxlRGF0ZSA9IHRoaXMuZGF0ZVNlcnZpY2UuYWRkTW9udGgodGhpcy52aXNpYmxlRGF0ZSwgZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgY2hhbmdlVmlzaWJsZVllYXIoZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMudmlzaWJsZURhdGUgPSB0aGlzLmRhdGVTZXJ2aWNlLmFkZFllYXIodGhpcy52aXNpYmxlRGF0ZSwgZGlyZWN0aW9uICogWUVBUlNfSU5fVklFVyk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkNTIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzNihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYkJhc2VDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm91bmRpbmdNb250aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1MihbXG4gICAgSW5wdXQoJ3N0YXJ0VmlldycpLFxuICAgIF9fbWV0YWRhdGEkMzYoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkJhc2VDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlVmlld01vZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzNihcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzNihcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzNihcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgTmJCYXNlQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM2KFwiZGVzaWduOnR5cGVcIiwgVHlwZSlcbl0sIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXlDZWxsQ29tcG9uZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDUyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzYoXCJkZXNpZ246dHlwZVwiLCBUeXBlKVxuXSwgTmJCYXNlQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1vbnRoQ2VsbENvbXBvbmVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM2KFwiZGVzaWduOnR5cGVcIiwgVHlwZSlcbl0sIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ5ZWFyQ2VsbENvbXBvbmVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM2KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJCYXNlQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzNihcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aXNpYmxlRGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM2KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93SGVhZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDUyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkJhc2VDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1MihbXG4gICAgSW5wdXQoKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3MuaGFzLXdlZWstbnVtYmVyJyksXG4gICAgX19tZXRhZGF0YSQzNihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkMzYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYkJhc2VDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1dlZWtOdW1iZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDUyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzYoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkJhc2VDYWxlbmRhckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2Vla051bWJlclN5bWJvbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1MihbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQzNihcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDUyKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubWVkaXVtJyksXG4gICAgX19tZXRhZGF0YSQzNihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQzNihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJCYXNlQ2FsZW5kYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1lZGl1bVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNTIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5sYXJnZScpLFxuICAgIF9fbWV0YWRhdGEkMzYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMzYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYXJnZVwiLCBudWxsKTtcbk5iQmFzZUNhbGVuZGFyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQ1MihbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1iYXNlLWNhbGVuZGFyJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiPG5iLWNhcmQ+XFxuICA8bmItY2FyZC1oZWFkZXIgKm5nSWY9XFxcInNob3dIZWFkZXJcXFwiPlxcbiAgICA8bmItY2FsZW5kYXItaGVhZGVyIChuYXZpZ2F0ZVRvZGF5KT1cXFwibmF2aWdhdGVUb2RheSgpXFxcIj48L25iLWNhbGVuZGFyLWhlYWRlcj5cXG4gIDwvbmItY2FyZC1oZWFkZXI+XFxuXFxuICA8bmItY2FyZC1ib2R5IFtuZ1N3aXRjaF09XFxcImFjdGl2ZVZpZXdNb2RlXFxcIj5cXG5cXG4gICAgPG5nLWNvbnRhaW5lciAqbmdTd2l0Y2hDYXNlPVxcXCJWaWV3TW9kZS5EQVRFXFxcIj5cXG5cXG4gICAgICA8bmItY2FsZW5kYXItcGFnZWFibGUtbmF2aWdhdGlvblxcbiAgICAgICAgKm5nU3dpdGNoQ2FzZT1cXFwiVmlld01vZGUuREFURVxcXCJcXG4gICAgICAgIFtkYXRlXT1cXFwidmlzaWJsZURhdGVcXFwiXFxuICAgICAgICAobmV4dCk9XFxcIm5leHRNb250aCgpXFxcIlxcbiAgICAgICAgKHByZXYpPVxcXCJwcmV2TW9udGgoKVxcXCJcXG4gICAgICAgIChjaGFuZ2VNb2RlKT1cXFwic2V0Vmlld01vZGUoVmlld01vZGUuWUVBUilcXFwiPlxcbiAgICAgIDwvbmItY2FsZW5kYXItcGFnZWFibGUtbmF2aWdhdGlvbj5cXG5cXG4gICAgICA8bmItY2FsZW5kYXItZGF5LXBpY2tlclxcbiAgICAgICAgW2JvdW5kaW5nTW9udGhzXT1cXFwiYm91bmRpbmdNb250aFxcXCJcXG4gICAgICAgIFtjZWxsQ29tcG9uZW50XT1cXFwiZGF5Q2VsbENvbXBvbmVudFxcXCJcXG4gICAgICAgIFttaW5dPVxcXCJtaW5cXFwiXFxuICAgICAgICBbbWF4XT1cXFwibWF4XFxcIlxcbiAgICAgICAgW2ZpbHRlcl09XFxcImZpbHRlclxcXCJcXG4gICAgICAgIFt2aXNpYmxlRGF0ZV09XFxcInZpc2libGVEYXRlXFxcIlxcbiAgICAgICAgW3NpemVdPVxcXCJzaXplXFxcIlxcbiAgICAgICAgW2RhdGVdPVxcXCJkYXRlXFxcIlxcbiAgICAgICAgW3Nob3dXZWVrTnVtYmVyXT1cXFwic2hvd1dlZWtOdW1iZXJcXFwiXFxuICAgICAgICAoZGF0ZUNoYW5nZSk9XFxcImRhdGVDaGFuZ2UuZW1pdCgkZXZlbnQpXFxcIlxcbiAgICAgICAgW3dlZWtOdW1iZXJTeW1ib2xdPVxcXCJ3ZWVrTnVtYmVyU3ltYm9sXFxcIj5cXG4gICAgICA8L25iLWNhbGVuZGFyLWRheS1waWNrZXI+XFxuXFxuICAgIDwvbmctY29udGFpbmVyPlxcblxcbiAgICA8bmctY29udGFpbmVyICpuZ1N3aXRjaENhc2U9XFxcIlZpZXdNb2RlLllFQVJcXFwiPlxcblxcbiAgICAgIDxuYi1jYWxlbmRhci1wYWdlYWJsZS1uYXZpZ2F0aW9uXFxuICAgICAgICBbZGF0ZV09XFxcInZpc2libGVEYXRlXFxcIlxcbiAgICAgICAgKG5leHQpPVxcXCJuZXh0WWVhcnMoKVxcXCJcXG4gICAgICAgIChwcmV2KT1cXFwicHJldlllYXJzKClcXFwiXFxuICAgICAgICAoY2hhbmdlTW9kZSk9XFxcInNldFZpZXdNb2RlKFZpZXdNb2RlLkRBVEUpXFxcIj5cXG4gICAgICA8L25iLWNhbGVuZGFyLXBhZ2VhYmxlLW5hdmlnYXRpb24+XFxuXFxuICAgICAgPG5iLWNhbGVuZGFyLXllYXItcGlja2VyXFxuICAgICAgICBbY2VsbENvbXBvbmVudF09XFxcInllYXJDZWxsQ29tcG9uZW50XFxcIlxcbiAgICAgICAgW2RhdGVdPVxcXCJkYXRlXFxcIlxcbiAgICAgICAgW21pbl09XFxcIm1pblxcXCJcXG4gICAgICAgIFttYXhdPVxcXCJtYXhcXFwiXFxuICAgICAgICBbZmlsdGVyXT1cXFwiZmlsdGVyXFxcIlxcbiAgICAgICAgW3NpemVdPVxcXCJzaXplXFxcIlxcbiAgICAgICAgW3llYXJdPVxcXCJ2aXNpYmxlRGF0ZVxcXCJcXG4gICAgICAgICh5ZWFyQ2hhbmdlKT1cXFwic2V0VmlzaWJsZURhdGUoJGV2ZW50KTsgc2V0Vmlld01vZGUoVmlld01vZGUuTU9OVEgpXFxcIj5cXG4gICAgICA8L25iLWNhbGVuZGFyLXllYXItcGlja2VyPlxcblxcbiAgICA8L25nLWNvbnRhaW5lcj5cXG5cXG4gICAgPG5nLWNvbnRhaW5lciAqbmdTd2l0Y2hDYXNlPVxcXCJWaWV3TW9kZS5NT05USFxcXCI+XFxuXFxuICAgICAgPG5iLWNhbGVuZGFyLW5hdmlnYXRpb25cXG4gICAgICAgIFtkYXRlXT1cXFwidmlzaWJsZURhdGVcXFwiXFxuICAgICAgICAoY2hhbmdlTW9kZSk9XFxcInNldFZpZXdNb2RlKFZpZXdNb2RlLkRBVEUpXFxcIj5cXG4gICAgICA8L25iLWNhbGVuZGFyLW5hdmlnYXRpb24+XFxuXFxuICAgICAgPG5iLWNhbGVuZGFyLW1vbnRoLXBpY2tlclxcbiAgICAgICAgW2NlbGxDb21wb25lbnRdPVxcXCJtb250aENlbGxDb21wb25lbnRcXFwiXFxuICAgICAgICBbbWluXT1cXFwibWluXFxcIlxcbiAgICAgICAgW21heF09XFxcIm1heFxcXCJcXG4gICAgICAgIFtmaWx0ZXJdPVxcXCJmaWx0ZXJcXFwiXFxuICAgICAgICBbc2l6ZV09XFxcInNpemVcXFwiXFxuICAgICAgICBbbW9udGhdPVxcXCJ2aXNpYmxlRGF0ZVxcXCJcXG4gICAgICAgIChtb250aENoYW5nZSk9XFxcInNldFZpc2libGVEYXRlKCRldmVudCk7IHNldFZpZXdNb2RlKFZpZXdNb2RlLkRBVEUpXFxcIj5cXG4gICAgICA8L25iLWNhbGVuZGFyLW1vbnRoLXBpY2tlcj5cXG5cXG4gICAgPC9uZy1jb250YWluZXI+XFxuXFxuICA8L25iLWNhcmQtYm9keT5cXG5cXG48L25iLWNhcmQ+XFxuXCJcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDM2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iRGF0ZVNlcnZpY2VdKVxuXSwgTmJCYXNlQ2FsZW5kYXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQzMyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5sZXQgTmJCYXNlQ2FsZW5kYXJNb2R1bGUgPSBjbGFzcyBOYkJhc2VDYWxlbmRhck1vZHVsZSB7XG59O1xuTmJCYXNlQ2FsZW5kYXJNb2R1bGUgPSBfX2RlY29yYXRlJDMzKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtOYkNhbGVuZGFyS2l0TW9kdWxlLCBOYlNoYXJlZE1vZHVsZSwgTmJDYXJkTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW05iQmFzZUNhbGVuZGFyQ29tcG9uZW50XSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbTmJCYXNlQ2FsZW5kYXJDb21wb25lbnRdLFxuICAgIH0pXG5dLCBOYkJhc2VDYWxlbmRhck1vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDMxID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmxldCBOYkNhbGVuZGFyTW9kdWxlID0gY2xhc3MgTmJDYWxlbmRhck1vZHVsZSB7XG59O1xuTmJDYWxlbmRhck1vZHVsZSA9IF9fZGVjb3JhdGUkMzEoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW05iQmFzZUNhbGVuZGFyTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW05iQ2FsZW5kYXJDb21wb25lbnRdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYkNhbGVuZGFyQ29tcG9uZW50XSxcbiAgICB9KVxuXSwgTmJDYWxlbmRhck1vZHVsZSk7XG5cbnZhciBfX2RlY29yYXRlJDU1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDM4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5sZXQgTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudCA9IGNsYXNzIE5iQ2FsZW5kYXJSYW5nZURheUNlbGxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy5zZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyKHRydWUpO1xuICAgIH1cbiAgICBnZXQgaW5SYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLnNlbGVjdGVkVmFsdWVcbiAgICAgICAgICAgICYmICh0aGlzLnNlbGVjdGVkVmFsdWUuc3RhcnQgJiYgdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXModGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUuc3RhcnQpID49IDApXG4gICAgICAgICAgICAmJiAodGhpcy5zZWxlY3RlZFZhbHVlLmVuZCAmJiB0aGlzLmRhdGVTZXJ2aWNlLmNvbXBhcmVEYXRlcyh0aGlzLmRhdGUsIHRoaXMuc2VsZWN0ZWRWYWx1ZS5lbmQpIDw9IDApO1xuICAgIH1cbiAgICBnZXQgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5zZWxlY3RlZFZhbHVlICYmIHRoaXMuc2VsZWN0ZWRWYWx1ZS5lbmRcbiAgICAgICAgICAgICYmICh0aGlzLnNlbGVjdGVkVmFsdWUuc3RhcnQgJiYgdGhpcy5kYXRlU2VydmljZS5pc1NhbWVEYXkodGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUuc3RhcnQpKTtcbiAgICB9XG4gICAgZ2V0IGVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLnNlbGVjdGVkVmFsdWUgJiZcbiAgICAgICAgICAgICh0aGlzLnNlbGVjdGVkVmFsdWUuZW5kICYmIHRoaXMuZGF0ZVNlcnZpY2UuaXNTYW1lRGF5KHRoaXMuZGF0ZSwgdGhpcy5zZWxlY3RlZFZhbHVlLmVuZCkpO1xuICAgIH1cbiAgICBnZXQgdG9kYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5kYXRlU2VydmljZS5pc1NhbWVEYXkodGhpcy5kYXRlLCB0aGlzLmRhdGVTZXJ2aWNlLnRvZGF5KCkpO1xuICAgIH1cbiAgICBnZXQgYm91bmRpbmdNb250aCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRhdGVTZXJ2aWNlLmlzU2FtZU1vbnRoU2FmZSh0aGlzLmRhdGUsIHRoaXMudmlzaWJsZURhdGUpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5zZWxlY3RlZFZhbHVlXG4gICAgICAgICAgICAmJiAodGhpcy5zZWxlY3RlZFZhbHVlLnN0YXJ0ICYmIHRoaXMuZGF0ZVNlcnZpY2UuaXNTYW1lRGF5KHRoaXMuZGF0ZSwgdGhpcy5zZWxlY3RlZFZhbHVlLnN0YXJ0KSkgfHwgdGhpcy5lbmQ7XG4gICAgfVxuICAgIGdldCBlbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmRhdGU7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc21hbGxlclRoYW5NaW4oKSB8fCB0aGlzLmdyZWF0ZXJUaGFuTWF4KCkgfHwgdGhpcy5kb250Rml0RmlsdGVyKCk7XG4gICAgfVxuICAgIGdldCBkYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5kYXRlU2VydmljZS5nZXREYXRlKHRoaXMuZGF0ZSk7XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IHRoaXMuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuZGF0ZSk7XG4gICAgfVxuICAgIHNtYWxsZXJUaGFuTWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMubWluICYmIHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKHRoaXMuZGF0ZSwgdGhpcy5taW4pIDwgMDtcbiAgICB9XG4gICAgZ3JlYXRlclRoYW5NYXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5tYXggJiYgdGhpcy5kYXRlU2VydmljZS5jb21wYXJlRGF0ZXModGhpcy5kYXRlLCB0aGlzLm1heCkgPiAwO1xuICAgIH1cbiAgICBkb250Rml0RmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMuZmlsdGVyICYmICF0aGlzLmZpbHRlcih0aGlzLmRhdGUpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDU1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyUmFuZ2VEYXlDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyUmFuZ2VEYXlDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZFZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyUmFuZ2VEYXlDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aXNpYmxlRGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyUmFuZ2VEYXlDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzOChcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU1KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDM4KFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MuaW4tcmFuZ2UnKSxcbiAgICBfX21ldGFkYXRhJDM4KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQzOChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5SYW5nZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNTUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGFydCcpLFxuICAgIF9fbWV0YWRhdGEkMzgoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDM4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhbGVuZGFyUmFuZ2VEYXlDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNTUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5lbmQnKSxcbiAgICBfX21ldGFkYXRhJDM4KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQzOChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwiZW5kXCIsIG51bGwpO1xuTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudCA9IF9fZGVjb3JhdGUkNTUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItY2FsZW5kYXItcmFuZ2UtZGF5LWNlbGwnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXZcbiAgICAgIGNsYXNzPVwiZGF5LWNlbGxcIlxuICAgICAgW2NsYXNzLnRvZGF5XT1cInRvZGF5XCJcbiAgICAgIFtjbGFzcy5zZWxlY3RlZF09XCJzZWxlY3RlZFwiXG4gICAgICBbY2xhc3MuYm91bmRpbmctbW9udGhdPVwiYm91bmRpbmdNb250aFwiXG4gICAgICBbY2xhc3Muc3RhcnRdPVwic3RhcnRcIlxuICAgICAgW2NsYXNzLmVuZF09XCJlbmRcIlxuICAgICAgW2NsYXNzLmluLXJhbmdlXT1cImluUmFuZ2VcIlxuICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkXCI+XG4gICAgICB7eyBkYXkgfX1cbiAgICA8L2Rpdj5cbiAgYCxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIGhvc3Q6IHsgJyhjbGljayknOiAnb25DbGljaygpJywgJ2NsYXNzJzogJ3JhbmdlLWNlbGwnIH1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDM4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iRGF0ZVNlcnZpY2VdKVxuXSwgTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudCk7XG5sZXQgTmJDYWxlbmRhclJhbmdlWWVhckNlbGxDb21wb25lbnQgPSBjbGFzcyBOYkNhbGVuZGFyUmFuZ2VZZWFyQ2VsbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZGF0ZVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNlbGVjdCA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG4gICAgfVxuICAgIGdldCBzZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRWYWx1ZSAmJiB0aGlzLmRhdGVTZXJ2aWNlLmlzU2FtZVllYXIodGhpcy5kYXRlLCB0aGlzLnNlbGVjdGVkVmFsdWUuc3RhcnQpO1xuICAgIH1cbiAgICBnZXQgdG9kYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGUgJiYgdGhpcy5kYXRlU2VydmljZS5pc1NhbWVZZWFyKHRoaXMuZGF0ZSwgdGhpcy5kYXRlU2VydmljZS50b2RheSgpKTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zbWFsbGVyVGhhbk1pbigpIHx8IHRoaXMuZ3JlYXRlclRoYW5NYXgoKTtcbiAgICB9XG4gICAgZ2V0IHllYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmdldFllYXIodGhpcy5kYXRlKTtcbiAgICB9XG4gICAgb25DbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHRoaXMuZGF0ZSk7XG4gICAgfVxuICAgIHNtYWxsZXJUaGFuTWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlICYmIHRoaXMubWluICYmIHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKHRoaXMueWVhckVuZCgpLCB0aGlzLm1pbikgPCAwO1xuICAgIH1cbiAgICBncmVhdGVyVGhhbk1heCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZSAmJiB0aGlzLm1heCAmJiB0aGlzLmRhdGVTZXJ2aWNlLmNvbXBhcmVEYXRlcyh0aGlzLnllYXJTdGFydCgpLCB0aGlzLm1heCkgPiAwO1xuICAgIH1cbiAgICB5ZWFyU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmdldFllYXJTdGFydCh0aGlzLmRhdGUpO1xuICAgIH1cbiAgICB5ZWFyRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5nZXRZZWFyRW5kKHRoaXMuZGF0ZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkNTUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzOChcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJSYW5nZVllYXJDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyUmFuZ2VZZWFyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyUmFuZ2VZZWFyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyUmFuZ2VZZWFyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1NShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQzOChcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE5iQ2FsZW5kYXJSYW5nZVllYXJDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zZWxlY3RlZCcpLFxuICAgIF9fbWV0YWRhdGEkMzgoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDM4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNhbGVuZGFyUmFuZ2VZZWFyQ2VsbENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDU1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MudG9kYXknKSxcbiAgICBfX21ldGFkYXRhJDM4KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQzOChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDYWxlbmRhclJhbmdlWWVhckNlbGxDb21wb25lbnQucHJvdG90eXBlLCBcInRvZGF5XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ1NShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YSQzOChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkMzgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2FsZW5kYXJSYW5nZVllYXJDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNTUoW1xuICAgIEhvc3RMaXN0ZW5lcignY2xpY2snKSxcbiAgICBfX21ldGFkYXRhJDM4KFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEkMzgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YSQzOChcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE5iQ2FsZW5kYXJSYW5nZVllYXJDZWxsQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkNsaWNrXCIsIG51bGwpO1xuTmJDYWxlbmRhclJhbmdlWWVhckNlbGxDb21wb25lbnQgPSBfX2RlY29yYXRlJDU1KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWNhbGVuZGFyLXJhbmdlLXllYXItY2VsbCcsXG4gICAgICAgIHRlbXBsYXRlOiBge3sgeWVhciB9fWAsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBob3N0OiB7ICdjbGFzcyc6ICd5ZWFyLWNlbGwnIH1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDM4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iRGF0ZVNlcnZpY2VdKVxuXSwgTmJDYWxlbmRhclJhbmdlWWVhckNlbGxDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ1NCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQzNyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBDYWxlbmRhclJhbmdlIGNvbXBvbmVudCBwcm92aWRlcyBhIGNhcGFiaWxpdHkgdG8gY2hvb3NlIGEgZGF0ZSByYW5nZS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItY2FsZW5kYXIgWyhkYXRlKV09XCJkYXRlXCI+PC9uYi1jYWxlbmRhcj5cbiAqIDxuYi1jYWxlbmRhciBbZGF0ZV09XCJkYXRlXCIgKGRhdGVDaGFuZ2UpPVwiaGFuZGxlRGF0ZUNoYW5nZSgkZXZlbnQpXCI+PC9uYi1jYWxlbmRhcj5cbiAqIGBgYFxuICpcbiAqIEJhc2ljIHVzYWdlIGV4YW1wbGVcbiAqIEBzdGFja2VkLWV4YW1wbGUoUmFuZ2UsIGNhbGVuZGFyL2NhbGVuZGFyLXJhbmdlLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkNhbGVuZGFyUmFuZ2VNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iQ2FsZW5kYXJSYW5nZU1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIENhbGVuZGFyUmFuZ2UgY29tcG9uZW50IHN1cHBvcnRzIGFsbCBvZiB0aGUgQ2FsZW5kYXIgY29tcG9uZW50IGN1c3RvbWl6YXRpb24gcHJvcGVydGllcy4gTW9yZSBkZWZhaWxzIGNhbiBiZSBmb3VuZFxuICogaW4gdGhlIFtDYWxlbmRhciBjb21wb25lbnQgZG9jc10oZG9jcy9jb21wb25lbnRzL2NhbGVuZGFyKS5cbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogY2FsZW5kYXItd2lkdGg6XG4gKiBjYWxlbmRhci1ib2R5LWhlaWdodDpcbiAqIGNhbGVuZGFyLWJvcmRlci1yYWRpdXM6XG4gKiBjYWxlbmRhci10ZXh0LWNvbG9yOlxuICogY2FsZW5kYXItdGV4dC1mb250LWZhbWlseTpcbiAqIGNhbGVuZGFyLXRleHQtZm9udC1zaXplOlxuICogY2FsZW5kYXItdGV4dC1mb250LXdlaWdodDpcbiAqIGNhbGVuZGFyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1oZWFkZXItdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWhlYWRlci10ZXh0LWZvbnQtZmFtaWx5OlxuICogY2FsZW5kYXItaGVhZGVyLXRpdGxlLXRleHQtZm9udC1zaXplOlxuICogY2FsZW5kYXItaGVhZGVyLXRpdGxlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1oZWFkZXItdGl0bGUtdGV4dC1saW5lLWhlaWdodDpcbiAqIGNhbGVuZGFyLWhlYWRlci1zdWItdGl0bGUtdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci1oZWFkZXItc3ViLXRpdGxlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1oZWFkZXItc3ViLXRpdGxlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1uYXZpZ2F0aW9uLWJ1dHRvbi13aWR0aDpcbiAqIGNhbGVuZGFyLWNlbGwtaW5hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtaW4tcmFuZ2UtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtc2VsZWN0ZWQtdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLXNlbGVjdGVkLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLWhvdmVyLXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLWhvdmVyLXRleHQtZm9udC1zaXplOlxuICogY2FsZW5kYXItY2VsbC1ob3Zlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogY2FsZW5kYXItY2VsbC1ob3Zlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogY2FsZW5kYXItY2VsbC1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNhbGVuZGFyLWNlbGwtYWN0aXZlLXRleHQtY29sb3I6XG4gKiBjYWxlbmRhci1jZWxsLWFjdGl2ZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIGNhbGVuZGFyLWNlbGwtYWN0aXZlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci1jZWxsLWFjdGl2ZS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogY2FsZW5kYXItY2VsbC10b2RheS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS10ZXh0LWNvbG9yOlxuICogY2FsZW5kYXItY2VsbC10b2RheS10ZXh0LWZvbnQtc2l6ZTpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktdGV4dC1mb250LXdlaWdodDpcbiAqIGNhbGVuZGFyLWNlbGwtdG9kYXktdGV4dC1saW5lLWhlaWdodDpcbiAqIGNhbGVuZGFyLWRheS1jZWxsLXdpZHRoOlxuICogY2FsZW5kYXItZGF5LWNlbGwtaGVpZ2h0OlxuICogY2FsZW5kYXItbW9udGgtY2VsbC13aWR0aDpcbiAqIGNhbGVuZGFyLW1vbnRoLWNlbGwtaGVpZ2h0OlxuICogY2FsZW5kYXIteWVhci1jZWxsLXdpZHRoOlxuICogY2FsZW5kYXIteWVhci1jZWxsLWhlaWdodDpcbiAqIGNhbGVuZGFyLXdlZWtkYXktYmFja2dyb3VuZDpcbiAqIGNhbGVuZGFyLXdlZWtkYXktZGl2aWRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtkYXktdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtkYXktdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci13ZWVrZGF5LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrZGF5LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrZGF5LWhvbGlkYXktdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtkYXktaGVpZ2h0OlxuICogY2FsZW5kYXItd2Vla2RheS13aWR0aDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItYmFja2dyb3VuZDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItZGl2aWRlci1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItZGl2aWRlci13aWR0aDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItdGV4dC1jb2xvcjpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItdGV4dC1mb250LXNpemU6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrbnVtYmVyLWhlaWdodDpcbiAqIGNhbGVuZGFyLXdlZWtudW1iZXItd2lkdGg6XG4gKiBjYWxlbmRhci1sYXJnZS13aWR0aDpcbiAqIGNhbGVuZGFyLWxhcmdlLWJvZHktaGVpZ2h0OlxuICogY2FsZW5kYXItZGF5LWNlbGwtbGFyZ2Utd2lkdGg6XG4gKiBjYWxlbmRhci1kYXktY2VsbC1sYXJnZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci13ZWVrZGF5LWxhcmdlLWhlaWdodDpcbiAqIGNhbGVuZGFyLXdlZWtkYXktbGFyZ2Utd2lkdGg6XG4gKiBjYWxlbmRhci1tb250aC1jZWxsLWxhcmdlLXdpZHRoOlxuICogY2FsZW5kYXItbW9udGgtY2VsbC1sYXJnZS1oZWlnaHQ6XG4gKiBjYWxlbmRhci15ZWFyLWNlbGwtbGFyZ2Utd2lkdGg6XG4gKiBjYWxlbmRhci15ZWFyLWNlbGwtbGFyZ2UtaGVpZ2h0OlxuICogKi9cbmxldCBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQgPSBjbGFzcyBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgaWYgd2Ugc2hvdWxkIHJlbmRlciBwcmV2aW91cyBhbmQgbmV4dCBtb250aHNcbiAgICAgICAgICogaW4gdGhlIGN1cnJlbnQgbW9udGggdmlldy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5ib3VuZGluZ01vbnRoID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgc3RhcnRpbmcgdmlldyBmb3IgdGhlIGNhbGVuZGFyLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnN0YXJ0VmlldyA9IE5iQ2FsZW5kYXJWaWV3TW9kZS5EQVRFO1xuICAgICAgICB0aGlzLmRheUNlbGxDb21wb25lbnQgPSBOYkNhbGVuZGFyUmFuZ2VEYXlDZWxsQ29tcG9uZW50O1xuICAgICAgICB0aGlzLnllYXJDZWxsQ29tcG9uZW50ID0gTmJDYWxlbmRhclJhbmdlWWVhckNlbGxDb21wb25lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaXplIG9mIHRoZSBjYWxlbmRhciBhbmQgZW50aXJlIGNvbXBvbmVudHMuXG4gICAgICAgICAqIENhbiBiZSAnbWVkaXVtJyB3aGljaCBpcyBkZWZhdWx0IG9yICdsYXJnZScuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IE5iQ2FsZW5kYXJTaXplLk1FRElVTTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgY2FsZW5kYXJzIGhlYWRlciBvciBub3QuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2hvd0hlYWRlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Nob3dXZWVrTnVtYmVyID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHN5bWJvbCB1c2VkIGFzIGEgaGVhZGVyIGZvciB3ZWVrIG51bWJlcnMgY29sdW1uXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMud2Vla051bWJlclN5bWJvbCA9ICcjJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHJhbmdlIHdoZW4gc3RhcnQgc2VsZWN0ZWQgYW5kIGVtaXRzIGFnYWluIHdoZW4gZW5kIHNlbGVjdGVkLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnJhbmdlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDdXN0b20gZGF5IGNlbGwgY29tcG9uZW50LiBIYXZlIHRvIGltcGxlbWVudCBgTmJDYWxlbmRhckNlbGxgIGludGVyZmFjZS5cbiAgICAgKiAqL1xuICAgIHNldCBfY2VsbENvbXBvbmVudChjZWxsQ29tcG9uZW50KSB7XG4gICAgICAgIGlmIChjZWxsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLmRheUNlbGxDb21wb25lbnQgPSBjZWxsQ29tcG9uZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1c3RvbSB5ZWFyIGNlbGwgY29tcG9uZW50LiBIYXZlIHRvIGltcGxlbWVudCBgTmJDYWxlbmRhckNlbGxgIGludGVyZmFjZS5cbiAgICAgKiAqL1xuICAgIHNldCBfeWVhckNlbGxDb21wb25lbnQoY2VsbENvbXBvbmVudCkge1xuICAgICAgICBpZiAoY2VsbENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy55ZWFyQ2VsbENvbXBvbmVudCA9IGNlbGxDb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBzaG91bGQgd2Ugc2hvdyB3ZWVrIG51bWJlcnMgY29sdW1uLlxuICAgICAqIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICogKi9cbiAgICBnZXQgc2hvd1dlZWtOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93V2Vla051bWJlcjtcbiAgICB9XG4gICAgc2V0IHNob3dXZWVrTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3Nob3dXZWVrTnVtYmVyID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgb25DaGFuZ2UoZGF0ZSkge1xuICAgICAgICB0aGlzLmluaXREYXRlSWZOdWxsKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0ZWQoZGF0ZSk7XG4gICAgfVxuICAgIGluaXREYXRlSWZOdWxsKCkge1xuICAgICAgICBpZiAoIXRoaXMucmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB7IHN0YXJ0OiBudWxsLCBlbmQ6IG51bGwgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVTZWxlY3RlZChkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RFbmQoZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdFN0YXJ0KGRhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdGlvblN0YXJ0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gdGhpcy5yYW5nZTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICYmICFlbmQ7XG4gICAgfVxuICAgIHNlbGVjdFN0YXJ0KHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc2VsZWN0UmFuZ2UoeyBzdGFydCB9KTtcbiAgICB9XG4gICAgc2VsZWN0RW5kKGRhdGUpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCB9ID0gdGhpcy5yYW5nZTtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKGRhdGUsIHN0YXJ0KSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0UmFuZ2UoeyBzdGFydCwgZW5kOiBkYXRlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RSYW5nZSh7IHN0YXJ0OiBkYXRlLCBlbmQ6IHN0YXJ0IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy5yYW5nZUNoYW5nZS5lbWl0KHJhbmdlKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ1NChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM3KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm91bmRpbmdNb250aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1NChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM3KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJDYWxlbmRhclJhbmdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydFZpZXdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTQoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzNyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU0KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzcoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1NChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM3KFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImZpbHRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1NChbXG4gICAgSW5wdXQoJ2RheUNlbGxDb21wb25lbnQnKSxcbiAgICBfX21ldGFkYXRhJDM3KFwiZGVzaWduOnR5cGVcIiwgVHlwZSksXG4gICAgX19tZXRhZGF0YSQzNyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUeXBlXSlcbl0sIE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiX2NlbGxDb21wb25lbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDU0KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzcoXCJkZXNpZ246dHlwZVwiLCBUeXBlKVxuXSwgTmJDYWxlbmRhclJhbmdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtb250aENlbGxDb21wb25lbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTQoW1xuICAgIElucHV0KCd5ZWFyQ2VsbENvbXBvbmVudCcpLFxuICAgIF9fbWV0YWRhdGEkMzcoXCJkZXNpZ246dHlwZVwiLCBUeXBlKSxcbiAgICBfX21ldGFkYXRhJDM3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1R5cGVdKVxuXSwgTmJDYWxlbmRhclJhbmdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJfeWVhckNlbGxDb21wb25lbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDU0KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTQoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzNyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzaWJsZURhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTQoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzNyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dIZWFkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTQoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzNyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTQoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzNyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkMzcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dXZWVrTnVtYmVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ1NChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM3KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJDYWxlbmRhclJhbmdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3ZWVrTnVtYmVyU3ltYm9sXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU0KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDM3KFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTmJDYWxlbmRhclJhbmdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZUNoYW5nZVwiLCB2b2lkIDApO1xuTmJDYWxlbmRhclJhbmdlQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQ1NChbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jYWxlbmRhci1yYW5nZScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLWJhc2UtY2FsZW5kYXJcbiAgICAgIFtkYXRlXT1cInJhbmdlXCJcbiAgICAgIChkYXRlQ2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgW21heF09XCJtYXhcIlxuICAgICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgICAgW3N0YXJ0Vmlld109XCJzdGFydFZpZXdcIlxuICAgICAgW2JvdW5kaW5nTW9udGhdPVwiYm91bmRpbmdNb250aFwiXG4gICAgICBbZGF5Q2VsbENvbXBvbmVudF09XCJkYXlDZWxsQ29tcG9uZW50XCJcbiAgICAgIFttb250aENlbGxDb21wb25lbnRdPVwibW9udGhDZWxsQ29tcG9uZW50XCJcbiAgICAgIFt5ZWFyQ2VsbENvbXBvbmVudF09XCJ5ZWFyQ2VsbENvbXBvbmVudFwiXG4gICAgICBbdmlzaWJsZURhdGVdPVwidmlzaWJsZURhdGVcIlxuICAgICAgW3Nob3dIZWFkZXJdPVwic2hvd0hlYWRlclwiXG4gICAgICBbc2l6ZV09XCJzaXplXCJcbiAgICAgIFtzaG93V2Vla051bWJlcl09XCJzaG93V2Vla051bWJlclwiXG4gICAgICBbd2Vla051bWJlclN5bWJvbF09XCJ3ZWVrTnVtYmVyU3ltYm9sXCJcbiAgICA+PC9uYi1iYXNlLWNhbGVuZGFyPlxuICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQzNyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYkRhdGVTZXJ2aWNlXSlcbl0sIE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDUzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmxldCBOYkNhbGVuZGFyUmFuZ2VNb2R1bGUgPSBjbGFzcyBOYkNhbGVuZGFyUmFuZ2VNb2R1bGUge1xufTtcbk5iQ2FsZW5kYXJSYW5nZU1vZHVsZSA9IF9fZGVjb3JhdGUkNTMoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW05iQmFzZUNhbGVuZGFyTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW05iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudF0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgTmJDYWxlbmRhclJhbmdlQ29tcG9uZW50LFxuICAgICAgICAgICAgTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudCxcbiAgICAgICAgICAgIE5iQ2FsZW5kYXJSYW5nZVllYXJDZWxsQ29tcG9uZW50LFxuICAgICAgICBdLFxuICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtOYkNhbGVuZGFyUmFuZ2VEYXlDZWxsQ29tcG9uZW50LCBOYkNhbGVuZGFyUmFuZ2VZZWFyQ2VsbENvbXBvbmVudF0sXG4gICAgfSlcbl0sIE5iQ2FsZW5kYXJSYW5nZU1vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGlzVXJsUGF0aEVxdWFsKHBhdGgsIGxpbmspIHtcbiAgICBjb25zdCBsb2NhdGlvblBhdGggPSBnZXRQYXRoUGFydE9mVXJsKHBhdGgpO1xuICAgIHJldHVybiBsaW5rID09PSBsb2NhdGlvblBhdGg7XG59XG5mdW5jdGlvbiBpc1VybFBhdGhDb250YWluKHBhdGgsIGxpbmspIHtcbiAgICBjb25zdCBsb2NhdGlvblBhdGggPSBnZXRQYXRoUGFydE9mVXJsKHBhdGgpO1xuICAgIGNvbnN0IGVuZE9mVXJsU2VnbWVudFJlZ0V4cCA9IC9cXC98XiQvO1xuICAgIHJldHVybiBsb2NhdGlvblBhdGguc3RhcnRzV2l0aChsaW5rKSAmJlxuICAgICAgICBsb2NhdGlvblBhdGguc2xpY2UobGluay5sZW5ndGgpLmNoYXJBdCgwKS5zZWFyY2goZW5kT2ZVcmxTZWdtZW50UmVnRXhwKSAhPT0gLTE7XG59XG5mdW5jdGlvbiBnZXRQYXRoUGFydE9mVXJsKHVybCkge1xuICAgIHJldHVybiB1cmwubWF0Y2goLy4qPyg/PVs/OyNdfCQpLylbMF07XG59XG5mdW5jdGlvbiBnZXRGcmFnbWVudFBhcnRPZlVybCh1cmwpIHtcbiAgICBjb25zdCBtYXRjaGVkID0gdXJsLm1hdGNoKC8jKC4rKS8pO1xuICAgIHJldHVybiBtYXRjaGVkID8gbWF0Y2hlZFsxXSA6ICcnO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudEVxdWFsKHBhdGgsIGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGdldEZyYWdtZW50UGFydE9mVXJsKHBhdGgpID09PSBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnRDb250YWluKHBhdGgsIGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGdldEZyYWdtZW50UGFydE9mVXJsKHBhdGgpLmluY2x1ZGVzKGZyYWdtZW50KTtcbn1cblxudmFyIF9fZGVjb3JhdGUkNTggPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNDAgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogVGhpcyBzZXJ2aWNlIGRldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgc2Nyb2xsIHRoZSBsYXlvdXQgYmFjayB0byB0b3AuXG4gKiBUaGlzIG9jY3VycyB3aGVuIHRoZSBwYWdlIGlzIGNoYW5nZWQsIHNvIHdoZW4gY3VycmVudCB1cmwgUEFUSCBpcyBub3QgZXF1YWwgdG8gdGhlIHByZXZpb3VzIG9uZS5cbiAqXG4gKiAgVE9ETzogdGhpcyBpcyBtb3N0IGxpa2VseSBhIHRlbXBvcmFyeSBzb2x1dGlvbnMgYXMgcmVjZW50bHkgQW5ndWxhciBpbnRyb2R1Y2VzIFZpZXdwb3J0U2Nyb2xsXG4gKiAgYW5kIHNjcm9sbCByZXN0b3JhdGlvbiBwcm9jZXNzXG4gKi9cbmxldCBOYlJlc3RvcmVTY3JvbGxUb3BIZWxwZXIgPSBjbGFzcyBOYlJlc3RvcmVTY3JvbGxUb3BIZWxwZXIge1xuICAgIGNvbnN0cnVjdG9yKHJvdXRlcikge1xuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICB9XG4gICAgc2hvdWxkUmVzdG9yZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91dGVyLmV2ZW50c1xuICAgICAgICAgICAgLnBpcGUoc3RhcnRXaXRoKG51bGwpLCBmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSwgcGFpcndpc2UoKSwgbWFwKChbcHJldiwgY3VycmVudF0pID0+IHRoaXMucGFnZUNoYW5nZWQocHJldiwgY3VycmVudCkpLCBmaWx0ZXIocmVzID0+ICEhcmVzKSk7XG4gICAgfVxuICAgIHBhZ2VDaGFuZ2VkKHByZXYsIGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuICFwcmV2IHx8IGdldFBhdGhQYXJ0T2ZVcmwocHJldi51cmwpICE9PSBnZXRQYXRoUGFydE9mVXJsKGN1cnJlbnQudXJsKTtcbiAgICB9XG59O1xuTmJSZXN0b3JlU2Nyb2xsVG9wSGVscGVyID0gX19kZWNvcmF0ZSQ1OChbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEkNDAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUm91dGVyXSlcbl0sIE5iUmVzdG9yZVNjcm9sbFRvcEhlbHBlcik7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDU3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDM5ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxMCA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogTGF5b3V0IGNvbnRhaW5lciBjb21wb25lbnQuXG4gKiBXaGVuIHVzaW5nIHdpdGggTmVidWxhciBUaGVtZSBTeXN0ZW0gaXQgaXMgcmVxdWlyZWQgdGhhdCBhbGwgY2hpbGQgY29tcG9uZW50cyBzaG91bGQgYmUgcGxhY2VkIGluc2lkZS5cbiAqXG4gKiBCYXNpYyBleGFtcGxlIG9mIHR3byBjb2x1bW4gbGF5b3V0IHdpdGggaGVhZGVyOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGxheW91dC9sYXlvdXQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIENhbiBjb250YWluIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50cyBpbnNpZGU6XG4gKlxuICogYGBgaHRtbFxuICogPG5iLWxheW91dD5cbiAqICA8bmItbGF5b3V0LWhlYWRlcj48L25iLWxheW91dC1oZWFkZXI+XG4gKiAgPG5iLWxheW91dC1mb290ZXI+PC9uYi1sYXlvdXQtZm9vdGVyPlxuICogIDxuYi1sYXlvdXQtY29sdW1uPjwvbmItbGF5b3V0LWNvbHVtbj5cbiAqICA8bmItc2lkZWJhcj48L25iLXNpZGViYXI+XG4gKiA8L25iLWxheW91dD5cbiAqIGBgYFxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJMYXlvdXRNb2R1bGVgIHRvIHlvdXIgYXBwIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJMYXlvdXRNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKiBCeSBkZWZhdWx0IHRoZSBsYXlvdXQgZmlsbHMgdXAgdGhlIHdob2xlIHZpZXctcG9ydC5cbiAqIFRoZSB3aW5kb3cgc2Nyb2xsYmFycyBhcmUgZGlzYWJsZWQgb24gdGhlIGJvZHkgYW5kIG1vdmVkIGluc2lkZSBvZiB0aGUgbmItbGF5b3V0LCBzbyB0aGF0IHRoZSBzY3JvbGxiYXJzXG4gKiB3b24ndCBtZXNzIHdpdGggdGhlIGZpeGVkIG5iLWhlYWRlci5cbiAqXG4gKiBUaGUgY2hpbGQgY29tcG9uZW50cyBhcmUgcHJvamVjdGVkIGludG8gYSBmbGV4aWJsZSBsYXlvdXQgc3RydWN0dXJlIGFsbG93aW5nIHRvIGFkanVzdCB0aGUgbGF5b3V0IGJlaGF2aW9yXG4gKiBiYXNlZCBvbiB0aGUgc2V0dGluZ3MgcHJvdmlkZWQuXG4gKlxuICogVGhlIGxheW91dCBjb250ZW50IChjb2x1bW5zKSBiZWNvbWVzIGNlbnRlcmVkIHdoZW4gdGhlIHdpbmRvdyB3aWR0aCBpcyBtb3JlIHRoYW5cbiAqIHRoZSB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhlIHRoZW1lIHZhcmlhYmxlIGBsYXlvdXQtY29udGVudC13aWR0aGAuXG4gKlxuICogVGhlIGxheW91dCBhbHNvIGNvbnRhaW5zIHRoZSBhcmVhIG9uIHRoZSB2ZXJ5IHRvcCAodGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBuYi1sYXlvdXQpLCB3aGljaCBjb3VsZCBiZSB1c2VkXG4gKiB0byBkeW5hbWljYWxseSBhcHBlbmQgc29tZSBjb21wb25lbnRzIGxpa2UgbW9kYWxzIG9yIHNwaW5uZXJzL2xvYWRlcnNcbiAqIHNvIHRoYXQgdGhleSBhcmUgbG9jYXRlZCBvbiB0b3Agb2YgdGhlIGVsZW1lbnRzIGhpZXJhcmNoeS5cbiAqIE1vcmUgZGV0YWlscyBhcmUgdW5kZXIgdGhlIGBUaGVtZVNlcnZpY2VgIHNlY3Rpb24uXG4gKlxuICogVGhlIGxheW91dCBjb21wb25lbnQgaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgY2hhbmdpbmcgYXBwbGljYXRpb24gdGhlbWVzLlxuICogSXQgbGlzdGVucyB0byB0aGUgYHRoZW1lQ2hhbmdlYCBldmVudCBhbmQgY2hhbmdlIGEgdGhlbWUgQ1NTIGNsYXNzIGFwcGVuZGVkIHRvIGJvZHkuXG4gKiBCYXNlZCBvbiB0aGUgY2xhc3MgYXBwZW5kZWQsIHNwZWNpZmljIENTUy10aGVtZSBpcyBhcHBsaWVkIHRvIHRoZSBhcHBsaWNhdGlvbi5cbiAqIE1vcmUgZGV0YWlscyBvZiB0aGUgVGhlbWUgU3lzdGVtIGNvdWxkIGJlIGZvdW5kIGhlcmUgW0VuYWJsaW5nIFRoZW1lIFN5c3RlbV0oIy9kb2NzL2NvbmNlcHRzL3RoZW1lLXN5c3RlbSlcbiAqXG4gKiBBIHNpbXBsZSBsYXlvdXQgd2l0aCBmb290ZXI6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShMYXlvdXQgV2l0aCBGb290ZXIsIGxheW91dC9sYXlvdXQtdy1mb290ZXIuY29tcG9uZW50KVxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGFzayB0aGUgbGF5b3V0IHRvIGNlbnRlciB0aGUgY29sdW1ucyAobm90aWNlOiB3ZSBhZGRlZCBhIGBjZW50ZXJgIGF0dHJpYnV0ZVxuICogdG8gdGhlIGxheW91dDpcbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItbGF5b3V0IGNlbnRlcj5cbiAqICAgPG5iLWxheW91dC1oZWFkZXI+QXdlc29tZSBDb21wYW55PC9uYi1sYXlvdXQtaGVhZGVyPlxuICpcbiAqICAgPG5iLWxheW91dC1jb2x1bW4+XG4gKiAgICAgSGVsbG8gV29ybGQhXG4gKiAgIDwvbmItbGF5b3V0LWNvbHVtbj5cbiAqXG4gKiAgIDxuYi1sYXlvdXQtZm9vdGVyPkNvbnRhY3QgdXM8L25iLWxheW91dC1mb290ZXI+XG4gKiA8L25iLWxheW91dD5cbiAqIGBgYFxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBsYXlvdXQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGxheW91dC10ZXh0LWNvbG9yOlxuICogbGF5b3V0LXRleHQtZm9udC1mYW1pbHk6XG4gKiBsYXlvdXQtdGV4dC1mb250LXNpemU6XG4gKiBsYXlvdXQtdGV4dC1mb250LXdlaWdodDpcbiAqIGxheW91dC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogbGF5b3V0LW1pbi1oZWlnaHQ6XG4gKiBsYXlvdXQtY29udGVudC13aWR0aDpcbiAqIGxheW91dC13aW5kb3ctbW9kZS1taW4td2lkdGg6XG4gKiBsYXlvdXQtd2luZG93LW1vZGUtbWF4LXdpZHRoOlxuICogbGF5b3V0LXdpbmRvdy1tb2RlLWJhY2tncm91bmQtY29sb3I6XG4gKiBsYXlvdXQtd2luZG93LW1vZGUtcGFkZGluZy10b3A6XG4gKiBsYXlvdXQtd2luZG93LXNoYWRvdzpcbiAqIGxheW91dC1wYWRkaW5nOlxuICogbGF5b3V0LW1lZGl1bS1wYWRkaW5nOlxuICogbGF5b3V0LXNtYWxsLXBhZGRpbmc6XG4gKiBsYXlvdXQtc2Nyb2xsYmFyLWJhY2tncm91bmQtY29sb3I6XG4gKiBsYXlvdXQtc2Nyb2xsYmFyLWNvbG9yOlxuICogbGF5b3V0LXNjcm9sbGJhci13aWR0aDpcbiAqL1xubGV0IE5iTGF5b3V0Q29tcG9uZW50ID0gY2xhc3MgTmJMYXlvdXRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHRoZW1lU2VydmljZSwgc3Bpbm5lclNlcnZpY2UsIGVsZW1lbnRSZWYsIHJlbmRlcmVyLCB3aW5kb3csIGRvY3VtZW50LCBwbGF0Zm9ybUlkLCBsYXlvdXREaXJlY3Rpb25TZXJ2aWNlLCBzY3JvbGxTZXJ2aWNlLCBydWxlclNlcnZpY2UsIHNjcm9sbFRvcCwgb3ZlcmxheUNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnRoZW1lU2VydmljZSA9IHRoZW1lU2VydmljZTtcbiAgICAgICAgdGhpcy5zcGlubmVyU2VydmljZSA9IHNwaW5uZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMucGxhdGZvcm1JZCA9IHBsYXRmb3JtSWQ7XG4gICAgICAgIHRoaXMubGF5b3V0RGlyZWN0aW9uU2VydmljZSA9IGxheW91dERpcmVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZSA9IHNjcm9sbFNlcnZpY2U7XG4gICAgICAgIHRoaXMucnVsZXJTZXJ2aWNlID0gcnVsZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgdGhpcy5vdmVybGF5Q29udGFpbmVyID0gb3ZlcmxheUNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5zY3JvbGxCbG9ja0NsYXNzID0gJ25iLWdsb2JhbC1zY3JvbGxibG9jayc7XG4gICAgICAgIHRoaXMuaXNTY3JvbGxCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2VudGVyVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXN0b3JlU2Nyb2xsVG9wVmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLndpbmRvd01vZGVWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLndpdGhTY3JvbGxWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLndpdGhTdWJoZWFkZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hZnRlclZpZXdJbml0JCA9IG5ldyBCZWhhdmlvclN1YmplY3QobnVsbCk7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyQXNPdmVybGF5Q29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMudGhlbWVTZXJ2aWNlLm9uVGhlbWVDaGFuZ2UoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgodGhlbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB0aGlzLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XG4gICAgICAgICAgICBpZiAodGhlbWUucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGJvZHksIGBuYi10aGVtZS0ke3RoZW1lLnByZXZpb3VzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhib2R5LCBgbmItdGhlbWUtJHt0aGVtZS5uYW1lfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50aGVtZVNlcnZpY2Uub25BcHBlbmRMYXlvdXRDbGFzcygpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRoZW1lU2VydmljZS5vblJlbW92ZUxheW91dENsYXNzKClcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3Bpbm5lclNlcnZpY2UucmVnaXN0ZXJMb2FkZXIobmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZnRlclZpZXdJbml0JFxuICAgICAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChfKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuc3Bpbm5lclNlcnZpY2UubG9hZCgpO1xuICAgICAgICB0aGlzLnJ1bGVyU2VydmljZS5vbkdldERpbWVuc2lvbnMoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoeyBsaXN0ZW5lciB9KSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lci5uZXh0KHRoaXMuZ2V0RGltZW5zaW9ucygpKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjcm9sbFNlcnZpY2Uub25HZXRQb3NpdGlvbigpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh7IGxpc3RlbmVyIH0pID0+IHtcbiAgICAgICAgICAgIGxpc3RlbmVyLm5leHQodGhpcy5nZXRTY3JvbGxQb3NpdGlvbigpKTtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjcm9sbFRvcFxuICAgICAgICAgICAgLnNob3VsZFJlc3RvcmUoKVxuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKCgpID0+IHRoaXMucmVzdG9yZVNjcm9sbFRvcFZhbHVlKSwgdGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbCgwLCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZVxuICAgICAgICAgICAgLm9uU2Nyb2xsYWJsZUNoYW5nZSgpXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy53aXRoU2Nyb2xsVmFsdWUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoc2Nyb2xsYWJsZSkgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbiBjYXNlIHdoZW4gTmVidWxhciBMYXlvdXQgY3VzdG9tIHNjcm9sbCBgd2l0aFNjcm9sbGAgbW9kZSBpcyBlbmFibGVkXG4gICAgICAgICAgICAgKiB3ZSBuZWVkIHRvIGRpc2FibGUgZGVmYXVsdCBDREsgc2Nyb2xsIGJsb2NrZXIgKEBsaW5rIE5iQmxvY2tTY3JvbGxTdHJhdGVneUFkYXB0ZXIpIG9uIEhUTUwgZWxlbWVudFxuICAgICAgICAgICAgICogc28gdGhhdCBpdCB3b24ndCBhZGQgYWRkaXRpb25hbCBwb3NpdGlvbmluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHNjcm9sbGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZVNjcm9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja1Njcm9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgICAgICAgIC8vIHRyaWdnZXIgZmlyc3QgdGltZSBzbyB0aGF0IGFmdGVyIHRoZSBjaGFuZ2Ugd2UgaGF2ZSB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgdGhpcy50aGVtZVNlcnZpY2UuY2hhbmdlV2luZG93V2lkdGgodGhpcy53aW5kb3cuaW5uZXJXaWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBsYXlvdXQgY29sdW1ucyB3aWxsIGJlIGNlbnRlcmVkIGFmdGVyIHNvbWUgd2lkdGhcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICAgICAqL1xuICAgIHNldCBjZW50ZXIodmFsKSB7XG4gICAgICAgIHRoaXMuY2VudGVyVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRoZSBsYXlvdXQgZW50ZXJzIGEgJ3dpbmRvdycgbW9kZSwgd2hlbiB0aGUgbGF5b3V0IGNvbnRlbnQgKGluY2x1ZGluZyBzaWRlYmFycyBhbmQgZml4ZWQgaGVhZGVyKVxuICAgICAqIGJlY29tZXMgY2VudGVyZWQgYnkgd2lkdGggd2l0aCBhIG1hcmdpbiBmcm9tIHRoZSB0b3Agb2YgdGhlIHNjcmVlbiwgbGlrZSBhIGZsb2F0aW5nIHdpbmRvdy5cbiAgICAgKiBBdXRvbWF0aWNhbGx5IGVuYWJsZXMgYHdpdGhTY3JvbGxgIG1vZGUsIGFzIGluIHRoZSB3aW5kb3cgbW9kZSBzY3JvbGwgbXVzdCBiZSBpbnNpZGUgdGhlIGxheW91dCBhbmQgY2Fubm90IGJlIG9uXG4gICAgICogd2luZG93LiAoVE9ETzogY2hlY2sgdGhpcylcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICAgICAqL1xuICAgIHNldCB3aW5kb3dNb2RlKHZhbCkge1xuICAgICAgICB0aGlzLndpbmRvd01vZGVWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgICAgICB0aGlzLndpdGhTY3JvbGwgPSB0aGlzLndpbmRvd01vZGVWYWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGV0aGVyIHRvIG1vdmUgdGhlIHNjcm9sbGJhcnMgdG8gbGF5b3V0IG9yIGxlYXZlIGl0IGF0IHRoZSBib2R5IGxldmVsLlxuICAgICAqIEF1dG9tYXRpY2FsbHkgc2V0IHRvIHRydWUgd2hlbiBgd2luZG93TW9kZWAgaXMgZW5hYmxlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICAgICAqL1xuICAgIHNldCB3aXRoU2Nyb2xsKHZhbCkge1xuICAgICAgICB0aGlzLndpdGhTY3JvbGxWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgICAgICAvLyBUT0RPOiBpcyB0aGlzIHRoZSBiZXN0IHdheSBvZiBkb2luZyBpdD8gYXMgd2UgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gYm9keSBmcm9tIHRoZW1lIHN0eWxlc1xuICAgICAgICAvLyBUT0RPOiBhZGQgZTJlIHRlc3RcbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgICAgICAgaWYgKHRoaXMud2l0aFNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKGJvZHksICdvdmVyZmxvdycsICdoaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoYm9keSwgJ292ZXJmbG93JywgJ2luaXRpYWwnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZSBhZnRlciBuYXZpZ2F0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgcmVzdG9yZVNjcm9sbFRvcCh2YWwpIHtcbiAgICAgICAgdGhpcy5yZXN0b3JlU2Nyb2xsVG9wVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmxheW91dERpcmVjdGlvblNlcnZpY2Uub25EaXJlY3Rpb25DaGFuZ2UoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShkaXJlY3Rpb24gPT4gdGhpcy5kb2N1bWVudC5kaXIgPSBkaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLnNjcm9sbFNlcnZpY2Uub25NYW51YWxTY3JvbGwoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoeyB4LCB5IH0pID0+IHRoaXMuc2Nyb2xsKHgsIHkpKTtcbiAgICAgICAgdGhpcy5hZnRlclZpZXdJbml0JC5uZXh0KHRydWUpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXJBc092ZXJsYXlDb250YWluZXIoKTtcbiAgICB9XG4gICAgb25TY3JvbGwoJGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZS5maXJlU2Nyb2xsQ2hhbmdlKCRldmVudCk7XG4gICAgfVxuICAgIG9uUmVzaXplKGV2ZW50KSB7XG4gICAgICAgIHRoaXMudGhlbWVTZXJ2aWNlLmNoYW5nZVdpbmRvd1dpZHRoKGV2ZW50LnRhcmdldC5pbm5lcldpZHRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzY3JvbGwgYW5kIGNsaWVudCBoZWlnaHQvd2lkdGhcbiAgICAgKlxuICAgICAqIERlcGVuZGluZyBvbiB0aGUgY3VycmVudCBzY3JvbGwgbW9kZSAoYHdpdGhTY3JvbGw9dHJ1ZWApIHJldHVybnMgc2l6ZXMgZnJvbSB0aGUgYm9keSBlbGVtZW50XG4gICAgICogb3IgZnJvbSB0aGUgYC5zY3JvbGxhYmxlLWNvbnRhaW5lcmBcbiAgICAgKiBAcmV0dXJucyB7TmJMYXlvdXREaW1lbnNpb25zfVxuICAgICAqL1xuICAgIGdldERpbWVuc2lvbnMoKSB7XG4gICAgICAgIGxldCBjbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0LCBzY3JvbGxXaWR0aCwgc2Nyb2xsSGVpZ2h0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMud2l0aFNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLnNjcm9sbGFibGVDb250YWluZXJSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGNsaWVudFdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgY2xpZW50SGVpZ2h0ID0gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIHNjcm9sbFdpZHRoID0gY29udGFpbmVyLnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gY29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9jdW1lbnRFbGVtZW50LCBib2R5IH0gPSB0aGlzLmRvY3VtZW50O1xuICAgICAgICAgICAgY2xpZW50V2lkdGggPSBkb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgYm9keS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgIGNsaWVudEhlaWdodCA9IGRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgYm9keS5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICBzY3JvbGxXaWR0aCA9IGRvY3VtZW50RWxlbWVudC5zY3JvbGxXaWR0aCB8fCBib2R5LnNjcm9sbFdpZHRoO1xuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBib2R5LnNjcm9sbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBjbGllbnRIZWlnaHQsXG4gICAgICAgICAgICBzY3JvbGxXaWR0aCxcbiAgICAgICAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBzY3JvbGwgcG9zaXRpb24gb2YgY3VycmVudCBzY3JvbGwgY29udGFpbmVyLlxuICAgICAqXG4gICAgICogSWYgYHdpdGhTY3JvbGxgID0gdHJ1ZSwgcmV0dXJucyBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIGAuc2Nyb2xsYWJsZS1jb250YWluZXJgIGVsZW1lbnQsXG4gICAgICogb3RoZXJ3aXNlIC0gb2YgdGhlIHNjcm9sbGFibGUgZWxlbWVudCBvZiB0aGUgd2luZG93ICh3aGljaCBtYXkgYmUgZGlmZmVyZW50IGRlcGVuZGluZyBvZiBhIGJyb3dzZXIpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TmJTY3JvbGxQb3NpdGlvbn1cbiAgICAgKi9cbiAgICBnZXRTY3JvbGxQb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKCFpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2l0aFNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLnNjcm9sbGFibGVDb250YWluZXJSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGNvbnRhaW5lci5zY3JvbGxMZWZ0LCB5OiBjb250YWluZXIuc2Nyb2xsVG9wIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jdW1lbnRSZWN0ID0gdGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHggPSAtZG9jdW1lbnRSZWN0LmxlZnQgfHwgdGhpcy5kb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgfHwgdGhpcy53aW5kb3cuc2Nyb2xsWCB8fFxuICAgICAgICAgICAgdGhpcy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICBjb25zdCB5ID0gLWRvY3VtZW50UmVjdC50b3AgfHwgdGhpcy5kb2N1bWVudC5ib2R5LnNjcm9sbFRvcCB8fCB0aGlzLndpbmRvdy5zY3JvbGxZIHx8XG4gICAgICAgICAgICB0aGlzLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgMDtcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH1cbiAgICByZWdpc3RlckFzT3ZlcmxheUNvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheUNvbnRhaW5lci5zZXRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lci5zZXRDb250YWluZXIodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVucmVnaXN0ZXJBc092ZXJsYXlDb250YWluZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXlDb250YWluZXIuY2xlYXJDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheUNvbnRhaW5lci5jbGVhckNvbnRhaW5lcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjcm9sbCh4ID0gbnVsbCwgeSA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyB4OiBjdXJyZW50WCwgeTogY3VycmVudFkgfSA9IHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgeCA9IHggPT0gbnVsbCA/IGN1cnJlbnRYIDogeDtcbiAgICAgICAgeSA9IHkgPT0gbnVsbCA/IGN1cnJlbnRZIDogeTtcbiAgICAgICAgaWYgKCFpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLnBsYXRmb3JtSWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2l0aFNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxhYmxlID0gdGhpcy5zY3JvbGxhYmxlQ29udGFpbmVyUmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsYWJsZS5zY3JvbGxUbykge1xuICAgICAgICAgICAgICAgIHNjcm9sbGFibGUuc2Nyb2xsVG8oeCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxhYmxlLnNjcm9sbExlZnQgPSB4O1xuICAgICAgICAgICAgICAgIHNjcm9sbGFibGUuc2Nyb2xsVG9wID0geTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93LnNjcm9sbFRvKHgsIHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE86IEV4dHJhY3QgaW50byBibG9jayBzY3JvbGwgc3RyYXRlZ3lcbiAgICBibG9ja1Njcm9sbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTY3JvbGxCbG9ja2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1Njcm9sbEJsb2NrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLnNjcm9sbEJsb2NrQ2xhc3MpO1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlQ29udGFpbmVyRWxlbWVudCA9IHRoaXMuc2Nyb2xsYWJsZUNvbnRhaW5lclJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICBjb25zdCBsYXlvdXRFbGVtZW50ID0gdGhpcy5sYXlvdXRDb250YWluZXJSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgbGF5b3V0V2l0aFNjcm9sbFdpZHRoID0gbGF5b3V0RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlQ29udGFpbmVyT3ZlcmZsb3dPbGRWYWx1ZSA9IHNjcm9sbGFibGVDb250YWluZXJFbGVtZW50LnN0eWxlLm92ZXJmbG93O1xuICAgICAgICBzY3JvbGxhYmxlQ29udGFpbmVyRWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICBjb25zdCBsYXlvdXRXaXRob3V0U2Nyb2xsV2lkdGggPSBsYXlvdXRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICBjb25zdCBzY3JvbGxXaWR0aCA9IGxheW91dFdpdGhvdXRTY3JvbGxXaWR0aCAtIGxheW91dFdpdGhTY3JvbGxXaWR0aDtcbiAgICAgICAgaWYgKCFzY3JvbGxXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5b3V0UGFkZGluZ09sZFZhbHVlID0ge1xuICAgICAgICAgICAgbGVmdDogbGF5b3V0RWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCxcbiAgICAgICAgICAgIHJpZ2h0OiBsYXlvdXRFbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0RGlyZWN0aW9uU2VydmljZS5pc0x0cigpKSB7XG4gICAgICAgICAgICBsYXlvdXRFbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke3Njcm9sbFdpZHRofXB4YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxheW91dEVsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBgJHtzY3JvbGxXaWR0aH1weGA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5hYmxlU2Nyb2xsKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Njcm9sbEJsb2NrZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTY3JvbGxCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLnNjcm9sbEJsb2NrQ2xhc3MpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxhYmxlQ29udGFpbmVyUmVmLm5hdGl2ZUVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSB0aGlzLnNjcm9sbGFibGVDb250YWluZXJPdmVyZmxvd09sZFZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubGF5b3V0UGFkZGluZ09sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF5b3V0RWxlbWVudCA9IHRoaXMubGF5b3V0Q29udGFpbmVyUmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgbGF5b3V0RWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IHRoaXMubGF5b3V0UGFkZGluZ09sZFZhbHVlLmxlZnQ7XG4gICAgICAgICAgICAgICAgbGF5b3V0RWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSB0aGlzLmxheW91dFBhZGRpbmdPbGRWYWx1ZS5yaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dFBhZGRpbmdPbGRWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLndpbmRvdy1tb2RlJyksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYkxheW91dENvbXBvbmVudC5wcm90b3R5cGUsIFwid2luZG93TW9kZVZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Mud2l0aC1zY3JvbGwnKSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE5iTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aXRoU2Nyb2xsVmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy53aXRoLXN1YmhlYWRlcicpLFxuICAgIF9fbWV0YWRhdGEkMzkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcIndpdGhTdWJoZWFkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTcoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkMzkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYkxheW91dENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2VudGVyXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aW5kb3dNb2RlXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3aXRoU2Nyb2xsXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZXN0b3JlU2Nyb2xsVG9wXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgVmlld0NoaWxkKCdsYXlvdXRUb3BEeW5hbWljQXJlYScsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnR5cGVcIiwgVmlld0NvbnRhaW5lclJlZilcbl0sIE5iTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2ZXJ5VG9wUmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU3KFtcbiAgICBWaWV3Q2hpbGQoJ3Njcm9sbGFibGVDb250YWluZXInLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBOYkxheW91dENvbXBvbmVudC5wcm90b3R5cGUsIFwic2Nyb2xsYWJsZUNvbnRhaW5lclJlZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgVmlld0NoaWxkKCdsYXlvdXRDb250YWluZXInLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBOYkxheW91dENvbXBvbmVudC5wcm90b3R5cGUsIFwibGF5b3V0Q29udGFpbmVyUmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU3KFtcbiAgICBIb3N0TGlzdGVuZXIoJ3dpbmRvdzpzY3JvbGwnLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEkMzkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE5iTGF5b3V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvblNjcm9sbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNTcoW1xuICAgIEhvc3RMaXN0ZW5lcignd2luZG93OnJlc2l6ZScsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEkMzkoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTmJMYXlvdXRDb21wb25lbnQucHJvdG90eXBlLCBcIm9uUmVzaXplXCIsIG51bGwpO1xuTmJMYXlvdXRDb21wb25lbnQgPSBfX2RlY29yYXRlJDU3KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWxheW91dCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cInNjcm9sbGFibGUtY29udGFpbmVyXCIgI3Njcm9sbGFibGVDb250YWluZXIgKHNjcm9sbCk9XCJvblNjcm9sbCgkZXZlbnQpXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibGF5b3V0XCIgI2xheW91dENvbnRhaW5lcj5cbiAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItbGF5b3V0LWhlYWRlcjpub3QoW3N1YmhlYWRlcl0pXCI+PC9uZy1jb250ZW50PlxuICAgICAgICA8ZGl2IGNsYXNzPVwibGF5b3V0LWNvbnRhaW5lclwiPlxuICAgICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLXNpZGViYXJcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIiBbY2xhc3MuY2VudGVyXT1cImNlbnRlclZhbHVlXCI+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1sYXlvdXQtaGVhZGVyW3N1YmhlYWRlcl1cIj48L25nLWNvbnRlbnQ+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29sdW1uc1wiPlxuICAgICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1sYXlvdXQtY29sdW1uXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1sYXlvdXQtZm9vdGVyXCI+PC9uZy1jb250ZW50PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0ey13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWR9W2Rpcj1sdHJdIDpob3N0e3RleHQtYWxpZ246bGVmdH1bZGlyPXJ0bF0gOmhvc3R7dGV4dC1hbGlnbjpyaWdodH06aG9zdCAubGF5b3V0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Omhvc3QgOjpuZy1kZWVwIG5iLWxheW91dC1oZWFkZXJ7ZGlzcGxheTpibG9ja306aG9zdCA6Om5nLWRlZXAgbmItbGF5b3V0LWhlYWRlciBuYXZ7YWxpZ24taXRlbXM6Y2VudGVyO2p1c3RpZnktY29udGVudDpmbGV4LXN0YXJ0O2Rpc3BsYXk6ZmxleH06aG9zdCA6Om5nLWRlZXAgbmItbGF5b3V0LWhlYWRlci5maXhlZHtwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7cmlnaHQ6MDt6LWluZGV4OjEwNDB9Omhvc3QgLmxheW91dC1jb250YWluZXJ7ZGlzcGxheTpmbGV4O2ZsZXg6MTstbXMtZmxleDoxIDEgYXV0bztmbGV4LWRpcmVjdGlvbjpyb3d9W2Rpcj1sdHJdIDpob3N0IC5sYXlvdXQtY29udGFpbmVyIDo6bmctZGVlcCBuYi1zaWRlYmFyLmxlZnR7b3JkZXI6MH1bZGlyPXJ0bF0gOmhvc3QgLmxheW91dC1jb250YWluZXIgOjpuZy1kZWVwIG5iLXNpZGViYXIubGVmdHtvcmRlcjoyfVtkaXI9bHRyXSA6aG9zdCAubGF5b3V0LWNvbnRhaW5lciA6Om5nLWRlZXAgbmItc2lkZWJhci5yaWdodHtvcmRlcjoyfVtkaXI9cnRsXSA6aG9zdCAubGF5b3V0LWNvbnRhaW5lciA6Om5nLWRlZXAgbmItc2lkZWJhci5yaWdodHtvcmRlcjowfTpob3N0IC5sYXlvdXQtY29udGFpbmVyIDo6bmctZGVlcCBuYi1zaWRlYmFyLmVuZHtvcmRlcjoyfTpob3N0IC5sYXlvdXQtY29udGFpbmVyIDo6bmctZGVlcCBuYi1zaWRlYmFyIC5maXhlZHtwb3NpdGlvbjpmaXhlZDt3aWR0aDoxMDAlO292ZXJmbG93LXk6YXV0bztoZWlnaHQ6MTAwJX06aG9zdCAubGF5b3V0LWNvbnRhaW5lciAuY29udGVudHtkaXNwbGF5OmZsZXg7ZmxleDoxOy1tcy1mbGV4OjEgMSBhdXRvO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjttaW4td2lkdGg6MH06aG9zdCAubGF5b3V0LWNvbnRhaW5lciAuY29udGVudC5jZW50ZXJ7bWF4LXdpZHRoOjEwMCU7cG9zaXRpb246cmVsYXRpdmU7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0b306aG9zdCAubGF5b3V0LWNvbnRhaW5lciAuY29udGVudCAuY29sdW1uc3tkaXNwbGF5OmZsZXg7ZmxleDoxOy1tcy1mbGV4OjEgMSBhdXRvO2ZsZXgtZGlyZWN0aW9uOnJvdzt3aWR0aDoxMDAlfTpob3N0IC5sYXlvdXQtY29udGFpbmVyIC5jb250ZW50IC5jb2x1bW5zIDo6bmctZGVlcCBuYi1sYXlvdXQtY29sdW1ue29yZGVyOjE7ZmxleDoxIDA7bWluLXdpZHRoOjB9W2Rpcj1sdHJdIDpob3N0IC5sYXlvdXQtY29udGFpbmVyIC5jb250ZW50IC5jb2x1bW5zIDo6bmctZGVlcCBuYi1sYXlvdXQtY29sdW1uLmxlZnR7b3JkZXI6MH1bZGlyPXJ0bF0gOmhvc3QgLmxheW91dC1jb250YWluZXIgLmNvbnRlbnQgLmNvbHVtbnMgOjpuZy1kZWVwIG5iLWxheW91dC1jb2x1bW4ubGVmdHtvcmRlcjoyfTpob3N0IC5sYXlvdXQtY29udGFpbmVyIC5jb250ZW50IC5jb2x1bW5zIDo6bmctZGVlcCBuYi1sYXlvdXQtY29sdW1uLnN0YXJ0e29yZGVyOjB9Omhvc3QgLmxheW91dC1jb250YWluZXIgLmNvbnRlbnQgOjpuZy1kZWVwIG5iLWxheW91dC1mb290ZXJ7ZGlzcGxheTpibG9jazttYXJnaW4tdG9wOmF1dG99Omhvc3QgLmxheW91dC1jb250YWluZXIgLmNvbnRlbnQgOjpuZy1kZWVwIG5iLWxheW91dC1mb290ZXIgbmF2e2p1c3RpZnktY29udGVudDpjZW50ZXI7ZGlzcGxheTpmbGV4fVxcblwiXVxuICAgIH0pLFxuICAgIF9fcGFyYW0kMTAoNCwgSW5qZWN0KE5CX1dJTkRPVykpLFxuICAgIF9fcGFyYW0kMTAoNSwgSW5qZWN0KE5CX0RPQ1VNRU5UKSksXG4gICAgX19wYXJhbSQxMCg2LCBJbmplY3QoUExBVEZPUk1fSUQpKSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iVGhlbWVTZXJ2aWNlLFxuICAgICAgICBOYlNwaW5uZXJTZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBSZW5kZXJlcjIsIE9iamVjdCwgT2JqZWN0LCBPYmplY3QsXG4gICAgICAgIE5iTGF5b3V0RGlyZWN0aW9uU2VydmljZSxcbiAgICAgICAgTmJMYXlvdXRTY3JvbGxTZXJ2aWNlLFxuICAgICAgICBOYkxheW91dFJ1bGVyU2VydmljZSxcbiAgICAgICAgTmJSZXN0b3JlU2Nyb2xsVG9wSGVscGVyLFxuICAgICAgICBOYk92ZXJsYXlDb250YWluZXJBZGFwdGVyXSlcbl0sIE5iTGF5b3V0Q29tcG9uZW50KTtcbi8qKlxuICogQSBjb250YWluZXIgY29tcG9uZW50IHdoaWNoIGRldGVybWluZXMgYSBjb250ZW50IHBvc2l0aW9uIGluc2lkZSBvZiB0aGUgbGF5b3V0LlxuICogVGhlIGxheW91dCBjb3VsZCBjb250YWluIHVubGltaXRlZCBjb2x1bW5zIChub3QgaW5jbHVkaW5nIHRoZSBzaWRlYmFycykuXG4gKlxuICogQnkgZGVmYXVsdCB0aGUgY29sdW1ucyBhcmUgb3JkZXJlZCBmcm9tIHRoZSBsZWZ0IHRvIHRoZSByaWdodCxcbiAqIGJ1dCBpdCdzIGFsc28gcG9zc2libGUgdG8gb3ZlcndyaXRlIHRoaXMgYmVoYXZpb3IgYnkgc2V0dGluZyBhIGBsZWZ0YCBhdHRyaWJ1dGUgdG8gdGhlIGNvbHVtbixcbiAqIG1vdmluZyBpdCB0byB0aGUgdmVyeSBmaXJzdCBwb3NpdGlvbjpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKENvbHVtbiBMZWZ0LCBsYXlvdXQvbGF5b3V0LWNvbHVtbi1sZWZ0LmNvbXBvbmVudClcbiAqL1xubGV0IE5iTGF5b3V0Q29sdW1uQ29tcG9uZW50ID0gY2xhc3MgTmJMYXlvdXRDb2x1bW5Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIE1vdmUgdGhlIGNvbHVtbiB0byB0aGUgdmVyeSBsZWZ0IHBvc2l0aW9uIGluIHRoZSBsYXlvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgbGVmdCh2YWwpIHtcbiAgICAgICAgdGhpcy5sZWZ0VmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgY29sdW1uIGZpcnN0IGluIHRoZSBsYXlvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgc3RhcnQodmFsKSB7XG4gICAgICAgIHRoaXMuc3RhcnRWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgICAgICB0aGlzLmxlZnRWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDU3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubGVmdCcpLFxuICAgIF9fbWV0YWRhdGEkMzkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJMYXlvdXRDb2x1bW5Db21wb25lbnQucHJvdG90eXBlLCBcImxlZnRWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXJ0JyksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYkxheW91dENvbHVtbkNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iTGF5b3V0Q29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWZ0XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iTGF5b3V0Q29sdW1uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGFydFwiLCBudWxsKTtcbk5iTGF5b3V0Q29sdW1uQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQ1NyhbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1sYXlvdXQtY29sdW1uJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gIGBcbiAgICB9KVxuXSwgTmJMYXlvdXRDb2x1bW5Db21wb25lbnQpO1xuLyoqXG4gKiBQYWdlIGhlYWRlciBjb21wb25lbnQuXG4gKiBMb2NhdGVkIG9uIHRvcCBvZiB0aGUgcGFnZSBhYm92ZSB0aGUgbGF5b3V0IGNvbHVtbnMgYW5kIHNpZGViYXJzLlxuICogQ291bGQgYmUgbWFkZSBgZml4ZWRgIGJ5IHNldHRpbmcgdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkuIEluIHRoZSBmaXhlZCBtb2RlIHRoZSBoZWFkZXIgYmVjb21lc1xuICogc3RpY2t5IHRvIHRoZSB0b3Agb2YgdGhlIG5iLWxheW91dCAodG8gb2YgdGhlIHBhZ2UpLiBIZXJlJ3MgYW4gZXhhbXBsZTpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEZpeGVkIEhlYWRlciwgbGF5b3V0L2xheW91dC1maXhlZC1oZWFkZXIuY29tcG9uZW50KVxuICpcbiAqIEluIGEgcGFpciB3aXRoIHNpZGViYXIgaXQgaXMgcG9zc2libGUgdG8gc2V0dXAgYSBjb25maWd1cmF0aW9uIHdoZW4gaGVhZGVyIGlzIHBsYWNlZCBvbiBhIHNpZGUgb2YgdGhlIHNpZGViYXJcbiAqIGFuZCBub3Qgb24gdG9wIG9mIGl0LiBUbyBhY2hpZXZlIHRoaXMgc2ltcGx5IHB1dCBhIGBzdWJoZWFkZXJgIHByb3BlcnR5IHRvIHRoZSBoZWFkZXIgbGlrZSB0aGlzOlxuICogYGBgaHRtbFxuICogPG5iLWxheW91dC1oZWFkZXIgc3ViaGVhZGVyPjwvbmItbGF5b3V0LWhlYWRlcj5cbiAqIGBgYFxuICogQHN0YWNrZWQtZXhhbXBsZShTdWJoZWFkZXIsIGxheW91dC9sYXlvdXQtc2lkZWJhci1zdWJoZWFkZXIuY29tcG9uZW50KVxuICogTm90ZSB0aGF0IGluIHN1Y2ggY29uZmlndXJhdGlvbiBzaWRlYmFyIHNoYWRvdyBpcyByZW1vdmVkIGFuZCBoZWFkZXIgY2Fubm90IGJlIG1ha2UgYGZpeGVkYC5cbiAqXG4gKiBTYW1lIHdheSB5b3UgY2FuIHB1dCBib3RoIGBmaXhlZGAgYW5kIGBjbGlwcGVkYCBoZWFkZXJzIGFkZGluZyBjcmVhdGluZyBhIHN1Yi1oZWFkZXIgZm9yIHlvdXIgYXBwOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU3ViaGVhZGVyLCBsYXlvdXQvbGF5b3V0LXN1YmhlYWRlci5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGhlYWRlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaGVhZGVyLXRleHQtY29sb3I6XG4gKiBoZWFkZXItdGV4dC1mb250LWZhbWlseTpcbiAqIGhlYWRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIGhlYWRlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogaGVhZGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBoZWFkZXItaGVpZ2h0OlxuICogaGVhZGVyLXBhZGRpbmc6XG4gKiBoZWFkZXItc2hhZG93OlxuICovXG5sZXQgTmJMYXlvdXRIZWFkZXJDb21wb25lbnQgPSBjbGFzcyBOYkxheW91dEhlYWRlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0KSB7XG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgaGVhZGVyIHN0aWNreSB0byB0aGUgdG9wIG9mIHRoZSBuYi1sYXlvdXQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgZml4ZWQodmFsKSB7XG4gICAgICAgIHRoaXMuZml4ZWRWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGFjZXMgaGVhZGVyIG9uIGEgc2lkZSBvZiB0aGUgc2lkZWJhciwgYW5kIG5vdCBhYm92ZS5cbiAgICAgKiBEaXNhYmxlcyBmaXhlZCBtb2RlIGZvciB0aGlzIGhlYWRlciBhbmQgcmVtb3ZlIGEgc2hhZG93IGZyb20gdGhlIHNpZGViYXIuXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgc3ViaGVhZGVyKHZhbCkge1xuICAgICAgICB0aGlzLnN1YmhlYWRlclZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgICAgIHRoaXMuZml4ZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxheW91dC53aXRoU3ViaGVhZGVyID0gdGhpcy5zdWJoZWFkZXJWYWx1ZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmZpeGVkJyksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYkxheW91dEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZml4ZWRWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN1YmhlYWRlcicpLFxuICAgIF9fbWV0YWRhdGEkMzkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJMYXlvdXRIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInN1YmhlYWRlclZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDU3KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMzkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJMYXlvdXRIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZpeGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ1NyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDM5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iTGF5b3V0SGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdWJoZWFkZXJcIiwgbnVsbCk7XG5OYkxheW91dEhlYWRlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUkNTcoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItbGF5b3V0LWhlYWRlcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5hdiBbY2xhc3MuZml4ZWRdPVwiZml4ZWRWYWx1ZVwiPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvbmF2PlxuICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYkxheW91dENvbXBvbmVudF0pXG5dLCBOYkxheW91dEhlYWRlckNvbXBvbmVudCk7XG4vKipcbiAqIFBhZ2UgZm9vdGVyLlxuICogTG9jYXRlZCB1bmRlciB0aGUgbmItbGF5b3V0IGNvbnRlbnQgKHNwZWNpZmljYWxseSwgdW5kZXIgdGhlIGNvbHVtbnMpLlxuICogQ291bGQgYmUgbWFkZSBgZml4ZWRgLCBiZWNvbWluZyBzdGlja3kgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdmlldyBwb3J0ICh3aW5kb3cpLlxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBmb290ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGZvb3Rlci10ZXh0LWNvbG9yOlxuICogZm9vdGVyLXRleHQtZm9udC1mYW1pbHk6XG4gKiBmb290ZXItdGV4dC1mb250LXNpemU6XG4gKiBmb290ZXItdGV4dC1mb250LXdlaWdodDpcbiAqIGZvb3Rlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogZm9vdGVyLXRleHQtaGlnaGxpZ2h0LWNvbG9yOlxuICogZm9vdGVyLWhlaWdodDpcbiAqIGZvb3Rlci1wYWRkaW5nOlxuICogZm9vdGVyLWRpdmlkZXItY29sb3I6XG4gKiBmb290ZXItZGl2aWRlci1zdHlsZTpcbiAqIGZvb3Rlci1kaXZpZGVyLXdpZHRoOlxuICogZm9vdGVyLXNoYWRvdzpcbiAqL1xubGV0IE5iTGF5b3V0Rm9vdGVyQ29tcG9uZW50ID0gY2xhc3MgTmJMYXlvdXRGb290ZXJDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBmb290ZXIgc3RpY2t5IHRvIHRoZSBib3R0b20gb2YgdGhlIHdpbmRvdy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICAgICAqL1xuICAgIHNldCBmaXhlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5maXhlZFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkNTcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5maXhlZCcpLFxuICAgIF9fbWV0YWRhdGEkMzkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJMYXlvdXRGb290ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZpeGVkVmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNTcoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQzOShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkMzkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYkxheW91dEZvb3RlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZml4ZWRcIiwgbnVsbCk7XG5OYkxheW91dEZvb3RlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUkNTcoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItbGF5b3V0LWZvb3RlcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5hdiBbY2xhc3MuZml4ZWRdPVwiZml4ZWRWYWx1ZVwiPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvbmF2PlxuICBgXG4gICAgfSlcbl0sIE5iTGF5b3V0Rm9vdGVyQ29tcG9uZW50KTtcblxudmFyIF9fZGVjb3JhdGUkNTYgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgTkJfTEFZT1VUX0NPTVBPTkVOVFMgPSBbXG4gICAgTmJMYXlvdXRDb21wb25lbnQsXG4gICAgTmJMYXlvdXRDb2x1bW5Db21wb25lbnQsXG4gICAgTmJMYXlvdXRGb290ZXJDb21wb25lbnQsXG4gICAgTmJMYXlvdXRIZWFkZXJDb21wb25lbnQsXG5dO1xubGV0IE5iTGF5b3V0TW9kdWxlID0gY2xhc3MgTmJMYXlvdXRNb2R1bGUge1xufTtcbk5iTGF5b3V0TW9kdWxlID0gX19kZWNvcmF0ZSQ1NihbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBOYlNoYXJlZE1vZHVsZSxcbiAgICAgICAgXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAuLi5OQl9MQVlPVVRfQ09NUE9ORU5UUyxcbiAgICAgICAgXSxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICBOYlJlc3RvcmVTY3JvbGxUb3BIZWxwZXIsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIC4uLk5CX0xBWU9VVF9DT01QT05FTlRTLFxuICAgICAgICBdLFxuICAgIH0pXG5dLCBOYkxheW91dE1vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDYxID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5jb25zdCBpdGVtQ2xpY2skID0gbmV3IFN1YmplY3QoKTtcbmNvbnN0IGFkZEl0ZW1zJCA9IG5ldyBSZXBsYXlTdWJqZWN0KDEpO1xuY29uc3QgbmF2aWdhdGVIb21lJCA9IG5ldyBSZXBsYXlTdWJqZWN0KDEpO1xuY29uc3QgZ2V0U2VsZWN0ZWRJdGVtJCA9IG5ldyBSZXBsYXlTdWJqZWN0KDEpO1xuY29uc3QgaXRlbVNlbGVjdCQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcbmNvbnN0IGl0ZW1Ib3ZlciQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcbmNvbnN0IHN1Ym1lbnVUb2dnbGUkID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG5jb25zdCBjb2xsYXBzZUFsbCQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcbi8vIFRPRE86IGNoZWNrIGlmIHdlIG5lZWQgYm90aCBVUkwgYW5kIExJTktcbi8qKlxuICpcbiAqXG4gKiBNZW51IEl0ZW0gb3B0aW9ucyBleGFtcGxlXG4gKiBAc3RhY2tlZC1leGFtcGxlKE1lbnUgTGluayBQYXJhbWV0ZXJzLCBtZW51L21lbnUtbGluay1wYXJhbXMuY29tcG9uZW50KVxuICpcbiAqXG4gKi9cbmNsYXNzIE5iTWVudUl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSXRlbSBpcyBzZWxlY3RlZCB3aGVuIHBhcnRseSBvciBmdWxseSBlcXVhbCB0byB0aGUgY3VycmVudCB1cmxcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGF0aE1hdGNoID0gJ2Z1bGwnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyBpdGVtIHBhcmVudHMgaW4gdG9wLWRvd24gb3JkZXJcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0UGFyZW50cyhpdGVtKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgICAgbGV0IHBhcmVudCA9IGl0ZW0ucGFyZW50O1xuICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnRzLnVuc2hpZnQocGFyZW50KTtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuICAgIHN0YXRpYyBpc1BhcmVudChpdGVtLCBwb3NzaWJsZUNoaWxkKSB7XG4gICAgICAgIHJldHVybiBwb3NzaWJsZUNoaWxkLnBhcmVudFxuICAgICAgICAgICAgPyBwb3NzaWJsZUNoaWxkLnBhcmVudCA9PT0gaXRlbSB8fCB0aGlzLmlzUGFyZW50KGl0ZW0sIHBvc3NpYmxlQ2hpbGQucGFyZW50KVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG59XG4vLyBUT0RPOiBtYXAgc2VsZWN0IGV2ZW50cyB0byByb3V0ZXIgY2hhbmdlIGV2ZW50c1xuLy8gVE9ETzogcmV2aWV3IHRoZSBpbnRlcmZhY2Vcbi8qKlxuICpcbiAqXG4gKiBNZW51IFNlcnZpY2UuIEFsbG93cyB5b3UgdG8gbGlzdGVuIHRvIG1lbnUgZXZlbnRzLCBvciB0byBpbnRlcmFjdCB3aXRoIGEgbWVudS5cbiAqIEBzdGFja2VkLWV4YW1wbGUoTWVudSBTZXJ2aWNlLCBtZW51L21lbnUtc2VydmljZS5jb21wb25lbnQpXG4gKlxuICpcbiAqL1xubGV0IE5iTWVudVNlcnZpY2UgPSBjbGFzcyBOYk1lbnVTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBBZGQgaXRlbXMgdG8gdGhlIGVuZCBvZiB0aGUgbWVudSBpdGVtcyBsaXN0XG4gICAgICogQHBhcmFtIHtMaXN0PE5iTWVudUl0ZW0+fSBpdGVtc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAgICAgKi9cbiAgICBhZGRJdGVtcyhpdGVtcywgdGFnKSB7XG4gICAgICAgIGFkZEl0ZW1zJC5uZXh0KHsgdGFnLCBpdGVtcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGFsbCBtZW51IGl0ZW1zXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgICAqL1xuICAgIGNvbGxhcHNlQWxsKHRhZykge1xuICAgICAgICBjb2xsYXBzZUFsbCQubmV4dCh7IHRhZyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGUgdG8gdGhlIGhvbWUgbWVudSBpdGVtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgICAqL1xuICAgIG5hdmlnYXRlSG9tZSh0YWcpIHtcbiAgICAgICAgbmF2aWdhdGVIb21lJC5uZXh0KHsgdGFnIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtLiBXb24ndCBzdWJzY3JpYmUgdG8gdGhlIGZ1dHVyZSBldmVudHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPHt0YWc6IHN0cmluZzsgaXRlbTogTmJNZW51SXRlbX0+fVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkSXRlbSh0YWcpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KG51bGwpO1xuICAgICAgICBnZXRTZWxlY3RlZEl0ZW0kLm5leHQoeyB0YWcsIGxpc3RlbmVyIH0pO1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIG9uSXRlbUNsaWNrKCkge1xuICAgICAgICByZXR1cm4gaXRlbUNsaWNrJC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbiAgICBvbkl0ZW1TZWxlY3QoKSB7XG4gICAgICAgIHJldHVybiBpdGVtU2VsZWN0JC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbiAgICBvbkl0ZW1Ib3ZlcigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1Ib3ZlciQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgb25TdWJtZW51VG9nZ2xlKCkge1xuICAgICAgICByZXR1cm4gc3VibWVudVRvZ2dsZSQucGlwZShzaGFyZSgpKTtcbiAgICB9XG59O1xuTmJNZW51U2VydmljZSA9IF9fZGVjb3JhdGUkNjEoW1xuICAgIEluamVjdGFibGUoKVxuXSwgTmJNZW51U2VydmljZSk7XG5sZXQgTmJNZW51SW50ZXJuYWxTZXJ2aWNlID0gY2xhc3MgTmJNZW51SW50ZXJuYWxTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhdGlvbikge1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gbG9jYXRpb247XG4gICAgfVxuICAgIHByZXBhcmVJdGVtcyhpdGVtcykge1xuICAgICAgICBjb25zdCBkZWZhdWx0SXRlbSA9IG5ldyBOYk1lbnVJdGVtKCk7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVmYXVsdHMoaSwgZGVmYXVsdEl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJlbnQoaSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZWxlY3RGcm9tVXJsKGl0ZW1zLCB0YWcsIGNvbGxhcHNlT3RoZXIgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RlZEl0ZW0gPSB0aGlzLmZpbmRJdGVtQnlVcmwoaXRlbXMpO1xuICAgICAgICBpZiAoc2VsZWN0ZWRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEl0ZW0oc2VsZWN0ZWRJdGVtLCBpdGVtcywgY29sbGFwc2VPdGhlciwgdGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3RJdGVtKGl0ZW0sIGl0ZW1zLCBjb2xsYXBzZU90aGVyID0gZmFsc2UsIHRhZykge1xuICAgICAgICBjb25zdCB1bnNlbGVjdGVkSXRlbXMgPSB0aGlzLnJlc2V0U2VsZWN0aW9uKGl0ZW1zKTtcbiAgICAgICAgY29uc3QgY29sbGFwc2VkSXRlbXMgPSBjb2xsYXBzZU90aGVyID8gdGhpcy5jb2xsYXBzZUl0ZW1zKGl0ZW1zKSA6IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiBOYk1lbnVJdGVtLmdldFBhcmVudHMoaXRlbSkpIHtcbiAgICAgICAgICAgIHBhcmVudC5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBlbWl0IGV2ZW50IG9ubHkgZm9yIGl0ZW1zIHRoYXQgd2VyZW4ndCBzZWxlY3RlZCBiZWZvcmUgKCd1bnNlbGVjdGVkSXRlbXMnIGNvbnRhaW5zIGl0ZW1zIHRoYXQgd2VyZSBzZWxlY3RlZClcbiAgICAgICAgICAgIGlmICghdW5zZWxlY3RlZEl0ZW1zLmluY2x1ZGVzKHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1TZWxlY3QocGFyZW50LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2FzTm90RXhwYW5kZWQgPSAhcGFyZW50LmV4cGFuZGVkO1xuICAgICAgICAgICAgcGFyZW50LmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBjb2xsYXBzZWRJdGVtcy5pbmRleE9mKHBhcmVudCk7XG4gICAgICAgICAgICAvLyBlbWl0IGV2ZW50IG9ubHkgZm9yIGl0ZW1zIHRoYXQgd2VyZW4ndCBleHBhbmRlZCBiZWZvcmUuXG4gICAgICAgICAgICAvLyAnY29sbGFwc2VkSXRlbXMnIGNvbnRhaW5zIGl0ZW1zIHRoYXQgd2VyZSBleHBhbmRlZCwgc28gbm8gbmVlZCB0byBlbWl0IGV2ZW50LlxuICAgICAgICAgICAgLy8gaW4gY2FzZSAnY29sbGFwc2VPdGhlcicgaXMgZmFsc2UsICdjb2xsYXBzZWRJdGVtcycgd2lsbCBiZSBlbXB0eSxcbiAgICAgICAgICAgIC8vIHNvIGFsc28gY2hlY2sgaWYgaXRlbSBpc24ndCBleHBhbmRlZCBhbHJlYWR5ICgnd2FzTm90RXhwYW5kZWQnKS5cbiAgICAgICAgICAgIGlmIChpID09PSAtMSAmJiB3YXNOb3RFeHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VibWVudVRvZ2dsZShwYXJlbnQsIHRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xsYXBzZWRJdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIC8vIGVtaXQgZXZlbnQgb25seSBmb3IgaXRlbXMgdGhhdCB3ZXJlbid0IHNlbGVjdGVkIGJlZm9yZSAoJ3Vuc2VsZWN0ZWRJdGVtcycgY29udGFpbnMgaXRlbXMgdGhhdCB3ZXJlIHNlbGVjdGVkKVxuICAgICAgICBpZiAoIXVuc2VsZWN0ZWRJdGVtcy5pbmNsdWRlcyhpdGVtKSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtU2VsZWN0KGl0ZW0sIHRhZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtYWluaW5nIGl0ZW1zIHdoaWNoIHdhc24ndCBleHBhbmRlZCBiYWNrIGFmdGVyIGV4cGFuZGluZyBhbGwgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zXG4gICAgICAgIGZvciAoY29uc3QgY29sbGFwc2VkSXRlbSBvZiBjb2xsYXBzZWRJdGVtcykge1xuICAgICAgICAgICAgdGhpcy5zdWJtZW51VG9nZ2xlKGNvbGxhcHNlZEl0ZW0sIHRhZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29sbGFwc2VBbGwoaXRlbXMsIHRhZywgZXhjZXB0KSB7XG4gICAgICAgIGNvbnN0IGNvbGxhcHNlZEl0ZW1zID0gdGhpcy5jb2xsYXBzZUl0ZW1zKGl0ZW1zLCBleGNlcHQpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY29sbGFwc2VkSXRlbXMpIHtcbiAgICAgICAgICAgIHRoaXMuc3VibWVudVRvZ2dsZShpdGVtLCB0YWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uQWRkSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIGFkZEl0ZW1zJC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbiAgICBvbk5hdmlnYXRlSG9tZSgpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRlSG9tZSQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgb25Db2xsYXBzZUFsbCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxhcHNlQWxsJC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbiAgICBvbkdldFNlbGVjdGVkSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIGdldFNlbGVjdGVkSXRlbSQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgaXRlbUhvdmVyKGl0ZW0sIHRhZykge1xuICAgICAgICBpdGVtSG92ZXIkLm5leHQoeyB0YWcsIGl0ZW0gfSk7XG4gICAgfVxuICAgIHN1Ym1lbnVUb2dnbGUoaXRlbSwgdGFnKSB7XG4gICAgICAgIHN1Ym1lbnVUb2dnbGUkLm5leHQoeyB0YWcsIGl0ZW0gfSk7XG4gICAgfVxuICAgIGl0ZW1TZWxlY3QoaXRlbSwgdGFnKSB7XG4gICAgICAgIGl0ZW1TZWxlY3QkLm5leHQoeyB0YWcsIGl0ZW0gfSk7XG4gICAgfVxuICAgIGl0ZW1DbGljayhpdGVtLCB0YWcpIHtcbiAgICAgICAgaXRlbUNsaWNrJC5uZXh0KHsgdGFnLCBpdGVtIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnNlbGVjdCBhbGwgZ2l2ZW4gaXRlbXMgZGVlcGx5LlxuICAgICAqIEBwYXJhbSBpdGVtcyBhcnJheSBvZiBpdGVtcyB0byB1bnNlbGVjdC5cbiAgICAgKiBAcmV0dXJucyBpdGVtcyB3aGljaCBzZWxlY3RlZCB2YWx1ZSB3YXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICByZXNldFNlbGVjdGlvbihpdGVtcykge1xuICAgICAgICBjb25zdCB1bnNlbGVjdGVkSXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHVuc2VsZWN0ZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICB1bnNlbGVjdGVkSXRlbXMucHVzaCguLi50aGlzLnJlc2V0U2VsZWN0aW9uKGl0ZW0uY2hpbGRyZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5zZWxlY3RlZEl0ZW1zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZSBhbGwgZ2l2ZW4gaXRlbXMgZGVlcGx5LlxuICAgICAqIEBwYXJhbSBpdGVtcyBhcnJheSBvZiBpdGVtcyB0byBjb2xsYXBzZS5cbiAgICAgKiBAcGFyYW0gZXhjZXB0IG1lbnUgaXRlbSB3aGljaCBzaG91bGRuJ3QgYmUgY29sbGFwc2VkLCBhbHNvIGRpc2FibGVzIGNvbGxhcHNpbmcgZm9yIHBhcmVudHMgb2YgdGhpcyBpdGVtLlxuICAgICAqIEByZXR1cm5zIGl0ZW1zIHdoaWNoIGV4cGFuZGVkIHZhbHVlIHdhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIGNvbGxhcHNlSXRlbXMoaXRlbXMsIGV4Y2VwdCkge1xuICAgICAgICBjb25zdCBjb2xsYXBzZWRJdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChleGNlcHQgJiYgKGl0ZW0gPT09IGV4Y2VwdCB8fCBOYk1lbnVJdGVtLmlzUGFyZW50KGl0ZW0sIGV4Y2VwdCkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS5leHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIGNvbGxhcHNlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGNvbGxhcHNlZEl0ZW1zLnB1c2goLi4udGhpcy5jb2xsYXBzZUl0ZW1zKGl0ZW0uY2hpbGRyZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sbGFwc2VkSXRlbXM7XG4gICAgfVxuICAgIGFwcGx5RGVmYXVsdHMoaXRlbSwgZGVmYXVsdEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWVudUl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBpdGVtKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihpdGVtLCBkZWZhdWx0SXRlbSwgbWVudUl0ZW0pO1xuICAgICAgICBpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5RGVmYXVsdHMoY2hpbGQsIGRlZmF1bHRJdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldFBhcmVudChpdGVtKSB7XG4gICAgICAgIGl0ZW0uY2hpbGRyZW4gJiYgaXRlbS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IGl0ZW07XG4gICAgICAgICAgICB0aGlzLnNldFBhcmVudChjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGRlZXBlc3QgaXRlbSB3aGljaCBsaW5rIG1hdGNoZXMgY3VycmVudCBVUkwgcGF0aC5cbiAgICAgKiBAcGFyYW0gaXRlbXMgYXJyYXkgb2YgaXRlbXMgdG8gc2VhcmNoIGluLlxuICAgICAqIEByZXR1cm5zIGZvdW5kIGl0ZW0gb2YgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGZpbmRJdGVtQnlVcmwoaXRlbXMpIHtcbiAgICAgICAgbGV0IHNlbGVjdGVkSXRlbTtcbiAgICAgICAgaXRlbXMuc29tZShpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRJdGVtID0gdGhpcy5maW5kSXRlbUJ5VXJsKGl0ZW0uY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZEl0ZW0gJiYgdGhpcy5pc1NlbGVjdGVkSW5VcmwoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkSXRlbTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZEl0ZW07XG4gICAgfVxuICAgIGlzU2VsZWN0ZWRJblVybChpdGVtKSB7XG4gICAgICAgIGNvbnN0IGV4YWN0ID0gaXRlbS5wYXRoTWF0Y2ggPT09ICdmdWxsJztcbiAgICAgICAgY29uc3QgbGluayA9IGl0ZW0ubGluaztcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZEluUGF0aCA9IGV4YWN0XG4gICAgICAgICAgICA/IGlzVXJsUGF0aEVxdWFsKHRoaXMubG9jYXRpb24ucGF0aCgpLCBsaW5rKVxuICAgICAgICAgICAgOiBpc1VybFBhdGhDb250YWluKHRoaXMubG9jYXRpb24ucGF0aCgpLCBsaW5rKTtcbiAgICAgICAgaWYgKGlzU2VsZWN0ZWRJblBhdGggJiYgaXRlbS5mcmFnbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhhY3RcbiAgICAgICAgICAgICAgICA/IGlzRnJhZ21lbnRFcXVhbCh0aGlzLmxvY2F0aW9uLnBhdGgodHJ1ZSksIGl0ZW0uZnJhZ21lbnQpXG4gICAgICAgICAgICAgICAgOiBpc0ZyYWdtZW50Q29udGFpbih0aGlzLmxvY2F0aW9uLnBhdGgodHJ1ZSksIGl0ZW0uZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1NlbGVjdGVkSW5QYXRoO1xuICAgIH1cbn07XG5OYk1lbnVJbnRlcm5hbFNlcnZpY2UgPSBfX2RlY29yYXRlJDYxKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YSQ0MihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtMb2NhdGlvbl0pXG5dLCBOYk1lbnVJbnRlcm5hbFNlcnZpY2UpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ2MCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0MSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMTEgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG52YXIgTmJUb2dnbGVTdGF0ZXM7XG4oZnVuY3Rpb24gKE5iVG9nZ2xlU3RhdGVzKSB7XG4gICAgTmJUb2dnbGVTdGF0ZXNbXCJFeHBhbmRlZFwiXSA9IFwiZXhwYW5kZWRcIjtcbiAgICBOYlRvZ2dsZVN0YXRlc1tcIkNvbGxhcHNlZFwiXSA9IFwiY29sbGFwc2VkXCI7XG59KShOYlRvZ2dsZVN0YXRlcyB8fCAoTmJUb2dnbGVTdGF0ZXMgPSB7fSkpO1xubGV0IE5iTWVudUl0ZW1Db21wb25lbnQgPSBjbGFzcyBOYk1lbnVJdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihtZW51U2VydmljZSwgZGlyZWN0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLm1lbnVTZXJ2aWNlID0gbWVudVNlcnZpY2U7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uU2VydmljZSA9IGRpcmVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWVudUl0ZW0gPSBudWxsO1xuICAgICAgICB0aGlzLmhvdmVySXRlbSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy50b2dnbGVTdWJNZW51ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNlbGVjdEl0ZW0gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuaXRlbUNsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZVN0YXRlID0gdGhpcy5tZW51SXRlbS5leHBhbmRlZCA/IE5iVG9nZ2xlU3RhdGVzLkV4cGFuZGVkIDogTmJUb2dnbGVTdGF0ZXMuQ29sbGFwc2VkO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMubWVudVNlcnZpY2Uub25TdWJtZW51VG9nZ2xlKClcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSwgZmlsdGVyKCh7IGl0ZW0gfSkgPT4gaXRlbSA9PT0gdGhpcy5tZW51SXRlbSksIG1hcCgoeyBpdGVtIH0pID0+IGl0ZW0uZXhwYW5kZWQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShpc0V4cGFuZGVkID0+IHRoaXMudG9nZ2xlU3RhdGUgPSBpc0V4cGFuZGVkID8gTmJUb2dnbGVTdGF0ZXMuRXhwYW5kZWQgOiBOYlRvZ2dsZVN0YXRlcy5Db2xsYXBzZWQpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBvblRvZ2dsZVN1Yk1lbnUoaXRlbSkge1xuICAgICAgICB0aGlzLnRvZ2dsZVN1Yk1lbnUuZW1pdChpdGVtKTtcbiAgICB9XG4gICAgb25Ib3Zlckl0ZW0oaXRlbSkge1xuICAgICAgICB0aGlzLmhvdmVySXRlbS5lbWl0KGl0ZW0pO1xuICAgIH1cbiAgICBvblNlbGVjdEl0ZW0oaXRlbSkge1xuICAgICAgICB0aGlzLnNlbGVjdEl0ZW0uZW1pdChpdGVtKTtcbiAgICB9XG4gICAgb25JdGVtQ2xpY2soaXRlbSkge1xuICAgICAgICB0aGlzLml0ZW1DbGljay5lbWl0KGl0ZW0pO1xuICAgIH1cbiAgICBnZXRFeHBhbmRTdGF0ZUljb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1lbnVJdGVtLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NoZXZyb24tZG93bi1vdXRsaW5lJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb25TZXJ2aWNlLmlzTHRyKClcbiAgICAgICAgICAgID8gJ2NoZXZyb24tbGVmdC1vdXRsaW5lJ1xuICAgICAgICAgICAgOiAnY2hldnJvbi1yaWdodC1vdXRsaW5lJztcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ2MChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJNZW51SXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWVudUl0ZW1cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNjAoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYk1lbnVJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJob3Zlckl0ZW1cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNjAoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYk1lbnVJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b2dnbGVTdWJNZW51XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDYwKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDQxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJNZW51SXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0SXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ2MChbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQ0MShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iTWVudUl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1DbGlja1wiLCB2b2lkIDApO1xuTmJNZW51SXRlbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUkNjAoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnW25iTWVudUl0ZW1dJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiPHNwYW4gKm5nSWY9XFxcIm1lbnVJdGVtLmdyb3VwXFxcIj5cXG4gIDxuYi1pY29uIGNsYXNzPVxcXCJtZW51LWljb25cXFwiIFtjb25maWddPVxcXCJtZW51SXRlbS5pY29uXFxcIiAqbmdJZj1cXFwibWVudUl0ZW0uaWNvblxcXCI+PC9uYi1pY29uPlxcbiAge3sgbWVudUl0ZW0udGl0bGUgfX1cXG48L3NwYW4+XFxuPGEgKm5nSWY9XFxcIm1lbnVJdGVtLmxpbmsgJiYgIW1lbnVJdGVtLnVybCAmJiAhbWVudUl0ZW0uY2hpbGRyZW4gJiYgIW1lbnVJdGVtLmdyb3VwXFxcIlxcbiAgIFtyb3V0ZXJMaW5rXT1cXFwibWVudUl0ZW0ubGlua1xcXCJcXG4gICBbcXVlcnlQYXJhbXNdPVxcXCJtZW51SXRlbS5xdWVyeVBhcmFtc1xcXCJcXG4gICBbZnJhZ21lbnRdPVxcXCJtZW51SXRlbS5mcmFnbWVudFxcXCJcXG4gICBbc2tpcExvY2F0aW9uQ2hhbmdlXT1cXFwibWVudUl0ZW0uc2tpcExvY2F0aW9uQ2hhbmdlXFxcIlxcbiAgIFthdHRyLnRhcmdldF09XFxcIm1lbnVJdGVtLnRhcmdldFxcXCJcXG4gICBbYXR0ci50aXRsZV09XFxcIm1lbnVJdGVtLnRpdGxlXFxcIlxcbiAgIFtjbGFzcy5hY3RpdmVdPVxcXCJtZW51SXRlbS5zZWxlY3RlZFxcXCJcXG4gICAobW91c2VlbnRlcik9XFxcIm9uSG92ZXJJdGVtKG1lbnVJdGVtKVxcXCJcXG4gICAoY2xpY2spPVxcXCJvbkl0ZW1DbGljayhtZW51SXRlbSk7XFxcIj5cXG4gIDxuYi1pY29uIGNsYXNzPVxcXCJtZW51LWljb25cXFwiIFtjb25maWddPVxcXCJtZW51SXRlbS5pY29uXFxcIiAqbmdJZj1cXFwibWVudUl0ZW0uaWNvblxcXCI+PC9uYi1pY29uPlxcbiAgPHNwYW4gY2xhc3M9XFxcIm1lbnUtdGl0bGVcXFwiPnt7IG1lbnVJdGVtLnRpdGxlIH19PC9zcGFuPlxcbjwvYT5cXG48YSAqbmdJZj1cXFwibWVudUl0ZW0udXJsICYmICFtZW51SXRlbS5jaGlsZHJlbiAmJiAhbWVudUl0ZW0ubGluayAmJiAhbWVudUl0ZW0uZ3JvdXBcXFwiXFxuICAgW2F0dHIuaHJlZl09XFxcIm1lbnVJdGVtLnVybFxcXCJcXG4gICBbYXR0ci50YXJnZXRdPVxcXCJtZW51SXRlbS50YXJnZXRcXFwiXFxuICAgW2F0dHIudGl0bGVdPVxcXCJtZW51SXRlbS50aXRsZVxcXCJcXG4gICBbY2xhc3MuYWN0aXZlXT1cXFwibWVudUl0ZW0uc2VsZWN0ZWRcXFwiXFxuICAgKG1vdXNlZW50ZXIpPVxcXCJvbkhvdmVySXRlbShtZW51SXRlbSlcXFwiXFxuICAgKGNsaWNrKT1cXFwib25TZWxlY3RJdGVtKG1lbnVJdGVtKVxcXCI+XFxuICA8bmItaWNvbiBjbGFzcz1cXFwibWVudS1pY29uXFxcIiBbY29uZmlnXT1cXFwibWVudUl0ZW0uaWNvblxcXCIgKm5nSWY9XFxcIm1lbnVJdGVtLmljb25cXFwiPjwvbmItaWNvbj5cXG4gIDxzcGFuIGNsYXNzPVxcXCJtZW51LXRpdGxlXFxcIj57eyBtZW51SXRlbS50aXRsZSB9fTwvc3Bhbj5cXG48L2E+XFxuPGEgKm5nSWY9XFxcIiFtZW51SXRlbS5jaGlsZHJlbiAmJiAhbWVudUl0ZW0ubGluayAmJiAhbWVudUl0ZW0udXJsICYmICFtZW51SXRlbS5ncm91cFxcXCJcXG4gICBbYXR0ci50YXJnZXRdPVxcXCJtZW51SXRlbS50YXJnZXRcXFwiXFxuICAgW2F0dHIudGl0bGVdPVxcXCJtZW51SXRlbS50aXRsZVxcXCJcXG4gICBbY2xhc3MuYWN0aXZlXT1cXFwibWVudUl0ZW0uc2VsZWN0ZWRcXFwiXFxuICAgKG1vdXNlZW50ZXIpPVxcXCJvbkhvdmVySXRlbShtZW51SXRlbSlcXFwiXFxuICAgKGNsaWNrKT1cXFwiJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IG9uSXRlbUNsaWNrKG1lbnVJdGVtKTtcXFwiPlxcbiAgPG5iLWljb24gY2xhc3M9XFxcIm1lbnUtaWNvblxcXCIgW2NvbmZpZ109XFxcIm1lbnVJdGVtLmljb25cXFwiICpuZ0lmPVxcXCJtZW51SXRlbS5pY29uXFxcIj48L25iLWljb24+XFxuICA8c3BhbiBjbGFzcz1cXFwibWVudS10aXRsZVxcXCI+e3sgbWVudUl0ZW0udGl0bGUgfX08L3NwYW4+XFxuPC9hPlxcbjxhICpuZ0lmPVxcXCJtZW51SXRlbS5jaGlsZHJlblxcXCJcXG4gICAoY2xpY2spPVxcXCIkZXZlbnQucHJldmVudERlZmF1bHQoKTsgb25Ub2dnbGVTdWJNZW51KG1lbnVJdGVtKTtcXFwiXFxuICAgW2F0dHIudGFyZ2V0XT1cXFwibWVudUl0ZW0udGFyZ2V0XFxcIlxcbiAgIFthdHRyLnRpdGxlXT1cXFwibWVudUl0ZW0udGl0bGVcXFwiXFxuICAgW2NsYXNzLmFjdGl2ZV09XFxcIm1lbnVJdGVtLnNlbGVjdGVkXFxcIlxcbiAgIChtb3VzZWVudGVyKT1cXFwib25Ib3Zlckl0ZW0obWVudUl0ZW0pXFxcIlxcbiAgIGhyZWY9XFxcIiNcXFwiPlxcbiAgPG5iLWljb24gY2xhc3M9XFxcIm1lbnUtaWNvblxcXCIgW2NvbmZpZ109XFxcIm1lbnVJdGVtLmljb25cXFwiICpuZ0lmPVxcXCJtZW51SXRlbS5pY29uXFxcIj48L25iLWljb24+XFxuICA8c3BhbiBjbGFzcz1cXFwibWVudS10aXRsZVxcXCI+e3sgbWVudUl0ZW0udGl0bGUgfX08L3NwYW4+XFxuICA8bmItaWNvbiBjbGFzcz1cXFwiZXhwYW5kLXN0YXRlXFxcIiBbaWNvbl09XFxcImdldEV4cGFuZFN0YXRlSWNvbigpXFxcIiBwYWNrPVxcXCJuZWJ1bGFyLWVzc2VudGlhbHNcXFwiPjwvbmItaWNvbj5cXG48L2E+XFxuPHVsICpuZ0lmPVxcXCJtZW51SXRlbS5jaGlsZHJlblxcXCJcXG4gICAgW2NsYXNzLmNvbGxhcHNlZF09XFxcIiEobWVudUl0ZW0uY2hpbGRyZW4gJiYgbWVudUl0ZW0uZXhwYW5kZWQpXFxcIlxcbiAgICBbY2xhc3MuZXhwYW5kZWRdPVxcXCJtZW51SXRlbS5leHBhbmRlZFxcXCJcXG4gICAgW0B0b2dnbGVdPVxcXCJ0b2dnbGVTdGF0ZVxcXCJcXG4gICAgY2xhc3M9XFxcIm1lbnUtaXRlbXNcXFwiPlxcbiAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XFxcImxldCBpdGVtIG9mIG1lbnVJdGVtLmNoaWxkcmVuXFxcIj5cXG4gICAgPGxpIG5iTWVudUl0ZW0gKm5nSWY9XFxcIiFpdGVtLmhpZGRlblxcXCJcXG4gICAgICAgIFttZW51SXRlbV09XFxcIml0ZW1cXFwiXFxuICAgICAgICBbY2xhc3MubWVudS1ncm91cF09XFxcIml0ZW0uZ3JvdXBcXFwiXFxuICAgICAgICAoaG92ZXJJdGVtKT1cXFwib25Ib3Zlckl0ZW0oJGV2ZW50KVxcXCJcXG4gICAgICAgICh0b2dnbGVTdWJNZW51KT1cXFwib25Ub2dnbGVTdWJNZW51KCRldmVudClcXFwiXFxuICAgICAgICAoc2VsZWN0SXRlbSk9XFxcIm9uU2VsZWN0SXRlbSgkZXZlbnQpXFxcIlxcbiAgICAgICAgKGl0ZW1DbGljayk9XFxcIm9uSXRlbUNsaWNrKCRldmVudClcXFwiXFxuICAgICAgICBjbGFzcz1cXFwibWVudS1pdGVtXFxcIj5cXG4gICAgPC9saT5cXG4gIDwvbmctY29udGFpbmVyPlxcbjwvdWw+XFxuXCIsXG4gICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgIHRyaWdnZXIoJ3RvZ2dsZScsIFtcbiAgICAgICAgICAgICAgICBzdGF0ZShOYlRvZ2dsZVN0YXRlcy5Db2xsYXBzZWQsIHN0eWxlKHsgaGVpZ2h0OiAnMCcsIG1hcmdpbjogJzAnIH0pKSxcbiAgICAgICAgICAgICAgICBzdGF0ZShOYlRvZ2dsZVN0YXRlcy5FeHBhbmRlZCwgc3R5bGUoeyBoZWlnaHQ6ICcqJyB9KSksXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbihgJHtOYlRvZ2dsZVN0YXRlcy5Db2xsYXBzZWR9IDw9PiAke05iVG9nZ2xlU3RhdGVzLkV4cGFuZGVkfWAsIGFuaW1hdGUoMzAwKSksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgXVxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkNDEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJNZW51U2VydmljZSxcbiAgICAgICAgTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlXSlcbl0sIE5iTWVudUl0ZW1Db21wb25lbnQpO1xuLyoqXG4gKiBWZXJ0aWNhbCBtZW51IGNvbXBvbmVudC5cbiAqXG4gKiBBY2NlcHRzIGEgbGlzdCBvZiBtZW51IGl0ZW1zIGFuZCByZW5kZXJzIHRoZW0gYWNjb3JkaW5nbHkuIFN1cHBvcnRzIG11bHRpLWxldmVsIG1lbnVzLlxuICpcbiAqIEJhc2ljIGV4YW1wbGVcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIG1lbnUvbWVudS1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogYGBgdHNcbiAqIC8vIC4uLlxuICogaXRlbXM6IE5iTWVudUl0ZW1bXSA9IFtcbiAqICB7XG4gKiAgICB0aXRsZTogaG9tZSxcbiAqICAgIGxpbms6ICcvJ1xuICogIH0sXG4gKiAge1xuICogICAgdGl0bGU6IGRhc2hib2FyZCxcbiAqICAgIGxpbms6ICdkYXNoYm9hcmQnXG4gKiAgfVxuICogXTtcbiAqIC8vIC4uLlxuICogPG5iLW1lbnUgW2l0ZW1zXT1cIml0ZW1zXCI+PC9uYi1tZW51PlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYk1lbnVNb2R1bGUuZm9yUm9vdCgpYCB0byB5b3VyIGFwcCBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iTWVudU1vZHVsZS5mb3JSb290KCksXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cbiAqIGBgYFxuICogYW5kIGBOYk1lbnVNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUgd2hlcmUgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgc2hvd246XG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iTWVudU1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogVHdvLWxldmVsIG1lbnUgZXhhbXBsZVxuICogQHN0YWNrZWQtZXhhbXBsZShUd28gTGV2ZWxzLCBtZW51L21lbnUtY2hpbGRyZW4uY29tcG9uZW50KVxuICpcbiAqXG4gKiBBdXRvY29sbGFwc2UgbWVudSBleGFtcGxlXG4gKiBAc3RhY2tlZC1leGFtcGxlKEF1dG9jb2xsYXBzZSBNZW51LCBtZW51L21lbnUtYXV0b2NvbGxhcHNlLmNvbXBvbmVudClcbiAqXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIG1lbnUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIG1lbnUtdGV4dC1jb2xvcjpcbiAqIG1lbnUtdGV4dC1mb250LWZhbWlseTpcbiAqIG1lbnUtdGV4dC1mb250LXNpemU6XG4gKiBtZW51LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBtZW51LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBtZW51LWdyb3VwLXRleHQtY29sb3I6XG4gKiBtZW51LWl0ZW0tYm9yZGVyLXJhZGl1czpcbiAqIG1lbnUtaXRlbS1wYWRkaW5nOlxuICogbWVudS1pdGVtLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBtZW51LWl0ZW0taG92ZXItY3Vyc29yOlxuICogbWVudS1pdGVtLWhvdmVyLXRleHQtY29sb3I6XG4gKiBtZW51LWl0ZW0taWNvbi1ob3Zlci1jb2xvcjpcbiAqIG1lbnUtaXRlbS1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIG1lbnUtaXRlbS1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIG1lbnUtaXRlbS1pY29uLWFjdGl2ZS1jb2xvcjpcbiAqIG1lbnUtaXRlbS1pY29uLWNvbG9yOlxuICogbWVudS1pdGVtLWljb24tbWFyZ2luOlxuICogbWVudS1pdGVtLWljb24td2lkdGg6XG4gKiBtZW51LWl0ZW0tZGl2aWRlci1jb2xvcjpcbiAqIG1lbnUtaXRlbS1kaXZpZGVyLXN0eWxlOlxuICogbWVudS1pdGVtLWRpdmlkZXItd2lkdGg6XG4gKiBtZW51LXN1Ym1lbnUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIG1lbnUtc3VibWVudS10ZXh0LWNvbG9yOlxuICogbWVudS1zdWJtZW51LW1hcmdpbjpcbiAqIG1lbnUtc3VibWVudS1wYWRkaW5nOlxuICogbWVudS1zdWJtZW51LWl0ZW0tYm9yZGVyLWNvbG9yOlxuICogbWVudS1zdWJtZW51LWl0ZW0tYm9yZGVyLXN0eWxlOlxuICogbWVudS1zdWJtZW51LWl0ZW0tYm9yZGVyLXdpZHRoOlxuICogbWVudS1zdWJtZW51LWl0ZW0tYm9yZGVyLXJhZGl1czpcbiAqIG1lbnUtc3VibWVudS1pdGVtLXBhZGRpbmc6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogbWVudS1zdWJtZW51LWl0ZW0taG92ZXItYm9yZGVyLWNvbG9yOlxuICogbWVudS1zdWJtZW51LWl0ZW0taG92ZXItdGV4dC1jb2xvcjpcbiAqIG1lbnUtc3VibWVudS1pdGVtLWljb24taG92ZXItY29sb3I6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIG1lbnUtc3VibWVudS1pdGVtLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIG1lbnUtc3VibWVudS1pdGVtLWljb24tYWN0aXZlLWNvbG9yOlxuICogbWVudS1zdWJtZW51LWl0ZW0tYWN0aXZlLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1hY3RpdmUtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogbWVudS1zdWJtZW51LWl0ZW0tYWN0aXZlLWhvdmVyLXRleHQtY29sb3I6XG4gKiBtZW51LXN1Ym1lbnUtaXRlbS1pY29uLWFjdGl2ZS1ob3Zlci1jb2xvcjpcbiAqL1xubGV0IE5iTWVudUNvbXBvbmVudCA9IGNsYXNzIE5iTWVudUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Iod2luZG93LCBwbGF0Zm9ybUlkLCBtZW51SW50ZXJuYWxTZXJ2aWNlLCByb3V0ZXIpIHtcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMucGxhdGZvcm1JZCA9IHBsYXRmb3JtSWQ7XG4gICAgICAgIHRoaXMubWVudUludGVybmFsU2VydmljZSA9IG1lbnVJbnRlcm5hbFNlcnZpY2U7XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLl9hdXRvQ29sbGFwc2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlIGFsbCBvcGVuZWQgc3VibWVudXMgb24gdGhlIHRvZ2dsZSBldmVudFxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgXCJmYWxzZVwiXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqL1xuICAgIGdldCBhdXRvQ29sbGFwc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hdXRvQ29sbGFwc2U7XG4gICAgfVxuICAgIHNldCBhdXRvQ29sbGFwc2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYXV0b0NvbGxhcHNlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMubWVudUludGVybmFsU2VydmljZS5wcmVwYXJlSXRlbXModGhpcy5pdGVtcyk7XG4gICAgICAgIHRoaXMubWVudUludGVybmFsU2VydmljZVxuICAgICAgICAgICAgLm9uQWRkSXRlbSgpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSksIGZpbHRlcigoZGF0YSkgPT4gdGhpcy5jb21wYXJlVGFnKGRhdGEudGFnKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGRhdGEgPT4gdGhpcy5vbkFkZEl0ZW0oZGF0YSkpO1xuICAgICAgICB0aGlzLm1lbnVJbnRlcm5hbFNlcnZpY2VcbiAgICAgICAgICAgIC5vbk5hdmlnYXRlSG9tZSgpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSksIGZpbHRlcigoZGF0YSkgPT4gdGhpcy5jb21wYXJlVGFnKGRhdGEudGFnKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMubmF2aWdhdGVIb21lKCkpO1xuICAgICAgICB0aGlzLm1lbnVJbnRlcm5hbFNlcnZpY2VcbiAgICAgICAgICAgIC5vbkdldFNlbGVjdGVkSXRlbSgpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSksIGZpbHRlcigoZGF0YSkgPT4gdGhpcy5jb21wYXJlVGFnKGRhdGEudGFnKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBkYXRhLmxpc3RlbmVyLm5leHQoeyB0YWc6IHRoaXMudGFnLCBpdGVtOiB0aGlzLmdldFNlbGVjdGVkSXRlbSh0aGlzLml0ZW1zKSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWVudUludGVybmFsU2VydmljZVxuICAgICAgICAgICAgLm9uQ29sbGFwc2VBbGwoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpLCBmaWx0ZXIoKGRhdGEpID0+IHRoaXMuY29tcGFyZVRhZyhkYXRhLnRhZykpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNvbGxhcHNlQWxsKCkpO1xuICAgICAgICB0aGlzLnJvdXRlci5ldmVudHNcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSwgZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWVudUludGVybmFsU2VydmljZS5zZWxlY3RGcm9tVXJsKHRoaXMuaXRlbXMsIHRoaXMudGFnLCB0aGlzLmF1dG9Db2xsYXBzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5tZW51SW50ZXJuYWxTZXJ2aWNlLnNlbGVjdEZyb21VcmwodGhpcy5pdGVtcywgdGhpcy50YWcsIHRoaXMuYXV0b0NvbGxhcHNlKSk7XG4gICAgfVxuICAgIG9uQWRkSXRlbShkYXRhKSB7XG4gICAgICAgIHRoaXMuaXRlbXMucHVzaCguLi5kYXRhLml0ZW1zKTtcbiAgICAgICAgdGhpcy5tZW51SW50ZXJuYWxTZXJ2aWNlLnByZXBhcmVJdGVtcyh0aGlzLml0ZW1zKTtcbiAgICAgICAgdGhpcy5tZW51SW50ZXJuYWxTZXJ2aWNlLnNlbGVjdEZyb21VcmwodGhpcy5pdGVtcywgdGhpcy50YWcsIHRoaXMuYXV0b0NvbGxhcHNlKTtcbiAgICB9XG4gICAgb25Ib3Zlckl0ZW0oaXRlbSkge1xuICAgICAgICB0aGlzLm1lbnVJbnRlcm5hbFNlcnZpY2UuaXRlbUhvdmVyKGl0ZW0sIHRoaXMudGFnKTtcbiAgICB9XG4gICAgb25Ub2dnbGVTdWJNZW51KGl0ZW0pIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0NvbGxhcHNlKSB7XG4gICAgICAgICAgICB0aGlzLm1lbnVJbnRlcm5hbFNlcnZpY2UuY29sbGFwc2VBbGwodGhpcy5pdGVtcywgdGhpcy50YWcsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0uZXhwYW5kZWQgPSAhaXRlbS5leHBhbmRlZDtcbiAgICAgICAgdGhpcy5tZW51SW50ZXJuYWxTZXJ2aWNlLnN1Ym1lbnVUb2dnbGUoaXRlbSwgdGhpcy50YWcpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBpcyBub3QgZmlyZWQgb24gcGFnZSByZWxvYWRcbiAgICBvblNlbGVjdEl0ZW0oaXRlbSkge1xuICAgICAgICB0aGlzLm1lbnVJbnRlcm5hbFNlcnZpY2Uuc2VsZWN0SXRlbShpdGVtLCB0aGlzLml0ZW1zLCB0aGlzLmF1dG9Db2xsYXBzZSwgdGhpcy50YWcpO1xuICAgIH1cbiAgICBvbkl0ZW1DbGljayhpdGVtKSB7XG4gICAgICAgIHRoaXMubWVudUludGVybmFsU2VydmljZS5pdGVtQ2xpY2soaXRlbSwgdGhpcy50YWcpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBuYXZpZ2F0ZUhvbWUoKSB7XG4gICAgICAgIGNvbnN0IGhvbWVJdGVtID0gdGhpcy5nZXRIb21lSXRlbSh0aGlzLml0ZW1zKTtcbiAgICAgICAgaWYgKGhvbWVJdGVtKSB7XG4gICAgICAgICAgICBpZiAoaG9tZUl0ZW0ubGluaykge1xuICAgICAgICAgICAgICAgIHRoaXMucm91dGVyLm5hdmlnYXRlKFtob21lSXRlbS5saW5rXSwgeyBxdWVyeVBhcmFtczogaG9tZUl0ZW0ucXVlcnlQYXJhbXMsIGZyYWdtZW50OiBob21lSXRlbS5mcmFnbWVudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChob21lSXRlbS51cmwgJiYgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2luZG93LmxvY2F0aW9uLmhyZWYgPSBob21lSXRlbS51cmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29sbGFwc2VBbGwoKSB7XG4gICAgICAgIHRoaXMubWVudUludGVybmFsU2VydmljZS5jb2xsYXBzZUFsbCh0aGlzLml0ZW1zLCB0aGlzLnRhZyk7XG4gICAgfVxuICAgIGdldEhvbWVJdGVtKGl0ZW1zKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgaWYgKGl0ZW0uaG9tZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaG9tZUl0ZW0gPSBpdGVtLmNoaWxkcmVuICYmIHRoaXMuZ2V0SG9tZUl0ZW0oaXRlbS5jaGlsZHJlbik7XG4gICAgICAgICAgICBpZiAoaG9tZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG9tZUl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcGFyZVRhZyh0YWcpIHtcbiAgICAgICAgcmV0dXJuICF0YWcgfHwgdGFnID09PSB0aGlzLnRhZztcbiAgICB9XG4gICAgZ2V0U2VsZWN0ZWRJdGVtKGl0ZW1zKSB7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IG51bGw7XG4gICAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ZWQgJiYgaXRlbS5jaGlsZHJlbiAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRoaXMuZ2V0U2VsZWN0ZWRJdGVtKGl0ZW0uY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDYwKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYk1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcInRhZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ2MChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQxKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBOYk1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDYwKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJhdXRvQ29sbGFwc2VcIiwgbnVsbCk7XG5OYk1lbnVDb21wb25lbnQgPSBfX2RlY29yYXRlJDYwKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLW1lbnUnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDx1bCBjbGFzcz1cIm1lbnUtaXRlbXNcIj5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIj5cbiAgICAgICAgPGxpIG5iTWVudUl0ZW0gKm5nSWY9XCIhaXRlbS5oaWRkZW5cIlxuICAgICAgICAgICAgW21lbnVJdGVtXT1cIml0ZW1cIlxuICAgICAgICAgICAgW2NsYXNzLm1lbnUtZ3JvdXBdPVwiaXRlbS5ncm91cFwiXG4gICAgICAgICAgICAoaG92ZXJJdGVtKT1cIm9uSG92ZXJJdGVtKCRldmVudClcIlxuICAgICAgICAgICAgKHRvZ2dsZVN1Yk1lbnUpPVwib25Ub2dnbGVTdWJNZW51KCRldmVudClcIlxuICAgICAgICAgICAgKHNlbGVjdEl0ZW0pPVwib25TZWxlY3RJdGVtKCRldmVudClcIlxuICAgICAgICAgICAgKGl0ZW1DbGljayk9XCJvbkl0ZW1DbGljaygkZXZlbnQpXCJcbiAgICAgICAgICAgIGNsYXNzPVwibWVudS1pdGVtXCI+XG4gICAgICAgIDwvbGk+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L3VsPlxuICBgLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0IDo6bmctZGVlcHtkaXNwbGF5OmJsb2NrfTpob3N0IDo6bmctZGVlcCAubWVudS1pdGVtcyw6aG9zdCA6Om5nLWRlZXAgLm1lbnUtaXRlbT4ubWVudS1pdGVtc3tsaXN0LXN0eWxlLXR5cGU6bm9uZTtvdmVyZmxvdzpoaWRkZW59Omhvc3QgOjpuZy1kZWVwIC5tZW51LWl0ZW0gYXtkaXNwbGF5OmZsZXg7Y29sb3I6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246bm9uZTthbGlnbi1pdGVtczpjZW50ZXJ9Omhvc3QgOjpuZy1kZWVwIC5tZW51LWl0ZW0gYSAubWVudS10aXRsZXtmbGV4OjEgMCBhdXRvfVtkaXI9cnRsXSA6aG9zdCA6Om5nLWRlZXAgLm1lbnUtaXRlbSBhIC5tZW51LXRpdGxle3RleHQtYWxpZ246cmlnaHR9Omhvc3QgOjpuZy1kZWVwIC5tZW51LWdyb3VwIHNwYW57ZGlzcGxheTpmbGV4fVxcblwiXVxuICAgIH0pLFxuICAgIF9fcGFyYW0kMTEoMCwgSW5qZWN0KE5CX1dJTkRPVykpLFxuICAgIF9fcGFyYW0kMTEoMSwgSW5qZWN0KFBMQVRGT1JNX0lEKSksXG4gICAgX19tZXRhZGF0YSQ0MShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIE9iamVjdCwgTmJNZW51SW50ZXJuYWxTZXJ2aWNlLFxuICAgICAgICBSb3V0ZXJdKVxuXSwgTmJNZW51Q29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkNTkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIE5iTWVudU1vZHVsZV8xO1xuY29uc3QgbmJNZW51Q29tcG9uZW50cyA9IFtOYk1lbnVDb21wb25lbnQsIE5iTWVudUl0ZW1Db21wb25lbnRdO1xuY29uc3QgTkJfTUVOVV9QUk9WSURFUlMgPSBbTmJNZW51U2VydmljZSwgTmJNZW51SW50ZXJuYWxTZXJ2aWNlXTtcbmxldCBOYk1lbnVNb2R1bGUgPSBOYk1lbnVNb2R1bGVfMSA9IGNsYXNzIE5iTWVudU1vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTmJNZW51TW9kdWxlXzEsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAuLi5OQl9NRU5VX1BST1ZJREVSUyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbk5iTWVudU1vZHVsZSA9IE5iTWVudU1vZHVsZV8xID0gX19kZWNvcmF0ZSQ1OShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbTmJTaGFyZWRNb2R1bGUsIE5iSWNvbk1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogWy4uLm5iTWVudUNvbXBvbmVudHNdLFxuICAgICAgICBleHBvcnRzOiBbLi4ubmJNZW51Q29tcG9uZW50c10sXG4gICAgfSlcbl0sIE5iTWVudU1vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDYzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFJvdXRlIHRhYnNldCBjb21wb25lbnRzLlxuICogUmVuZGVycyB0YWJzIGluc2lkZSBvZiBhIHJvdXRlci1vdXRsZXQuXG4gKlxuICogYGBgdHNcbiAqICB0YWJzID0gW1xuICogIHtcbiAqICAgIHRpdGxlOiAnUm91dGUgdGFiICMxJyxcbiAqICAgIHJvdXRlOiAnL3BhZ2VzL2Rlc2NyaXB0aW9uJyxcbiAqICAgIGljb246ICdob21lJyxcbiAqICAgIHJlc3BvbnNpdmU6IHRydWUsIC8vIGhpZGUgdGl0bGUgYmVmb3JlIGByb3V0ZS10YWJzLWljb24tb25seS1tYXgtd2lkdGhgIHZhbHVlXG4gKiAgfSxcbiAqICB7XG4gKiAgICB0aXRsZTogJ1JvdXRlIHRhYiAjMicsXG4gKiAgICByb3V0ZTogJy9wYWdlcy9pbWFnZXMnLFxuICogICAgfVxuICogIF07XG4gKlxuICogIDxuYi1yb3V0ZS10YWJzZXQgW3RhYnNdPVwidGFic1wiPjwvbmItcm91dGUtdGFic2V0PlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlJvdXRlVGFic2V0TW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlJvdXRlVGFic2V0TW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShSb3V0ZSBUYWJzZXQsIHRhYnNldC9yb3V0ZS10YWJzZXQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiByb3V0ZS10YWJzZXQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC1ib3JkZXItcmFkaXVzOlxuICogcm91dGUtdGFic2V0LXNoYWRvdzpcbiAqIHJvdXRlLXRhYnNldC10YWItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC10YWItcGFkZGluZzpcbiAqIHJvdXRlLXRhYnNldC10YWItdGV4dC1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC10YWItdGV4dC1mb250LWZhbWlseTpcbiAqIHJvdXRlLXRhYnNldC10YWItdGV4dC1mb250LXNpemU6XG4gKiByb3V0ZS10YWJzZXQtdGFiLXRleHQtZm9udC13ZWlnaHQ6XG4gKiByb3V0ZS10YWJzZXQtdGFiLXRleHQtbGluZS1oZWlnaHQ6XG4gKiByb3V0ZS10YWJzZXQtdGFiLXRleHQtdHJhbnNmb3JtOlxuICogcm91dGUtdGFic2V0LXRhYi11bmRlcmxpbmUtd2lkdGg6XG4gKiByb3V0ZS10YWJzZXQtdGFiLXVuZGVybGluZS1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC10YWItYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiByb3V0ZS10YWJzZXQtdGFiLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogcm91dGUtdGFic2V0LXRhYi1hY3RpdmUtdW5kZXJsaW5lLWNvbG9yOlxuICogcm91dGUtdGFic2V0LXRhYi1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcm91dGUtdGFic2V0LXRhYi1mb2N1cy10ZXh0LWNvbG9yOlxuICogcm91dGUtdGFic2V0LXRhYi1mb2N1cy11bmRlcmxpbmUtY29sb3I6XG4gKiByb3V0ZS10YWJzZXQtdGFiLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiByb3V0ZS10YWJzZXQtdGFiLWhvdmVyLXRleHQtY29sb3I6XG4gKiByb3V0ZS10YWJzZXQtdGFiLWhvdmVyLXVuZGVybGluZS1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC10YWItZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC10YWItZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC10YWItZGlzYWJsZWQtdW5kZXJsaW5lLWNvbG9yOlxuICogcm91dGUtdGFic2V0LWRpdmlkZXItY29sb3I6XG4gKiByb3V0ZS10YWJzZXQtZGl2aWRlci1zdHlsZTpcbiAqIHJvdXRlLXRhYnNldC1kaXZpZGVyLXdpZHRoOlxuICogcm91dGUtdGFic2V0LXNjcm9sbGJhci1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC1zY3JvbGxiYXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJvdXRlLXRhYnNldC1zY3JvbGxiYXItd2lkdGg6XG4gKiByb3V0ZS10YWJzZXQtdGFiLXRleHQtaGlkZS1icmVha3BvaW50OlxuICovXG5sZXQgTmJSb3V0ZVRhYnNldENvbXBvbmVudCA9IGNsYXNzIE5iUm91dGVUYWJzZXRDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFJvdXRlIHRhYnNldCBjb21wb25lbnRzLlxuICAgICAqIFJlbmRlcnMgdGFicyBpbnNpZGUgb2YgYSByb3V0ZXItb3V0bGV0LlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiAgdGFicyA9IFtcbiAgICAgKiAge1xuICAgICAqICAgIHRpdGxlOiAnUm91dGUgdGFiICMxJyxcbiAgICAgKiAgICByb3V0ZTogJy9wYWdlcy9kZXNjcmlwdGlvbicsXG4gICAgICogICAgaWNvbjogJ2hvbWUnLFxuICAgICAqICAgIHJlc3BvbnNpdmU6IHRydWUsIC8vIGhpZGUgdGl0bGUgYmVmb3JlIGByb3V0ZS10YWJzLWljb24tb25seS1tYXgtd2lkdGhgIHZhbHVlXG4gICAgICogIH0sXG4gICAgICogIHtcbiAgICAgKiAgICB0aXRsZTogJ1JvdXRlIHRhYiAjMicsXG4gICAgICogICAgcm91dGU6ICcvcGFnZXMvaW1hZ2VzJyxcbiAgICAgKiAgICB9XG4gICAgICogIF07XG4gICAgICpcbiAgICAgKiAgPG5iLXJvdXRlLXRhYnNldCBbdGFic109XCJ0YWJzXCI+PC9uYi1yb3V0ZS10YWJzZXQ+XG4gICAgICogYGBgXG4gICAgICogIyMjIEluc3RhbGxhdGlvblxuICAgICAqXG4gICAgICogSW1wb3J0IGBOYlJvdXRlVGFic2V0TW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICAgICAqIGBgYHRzXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIGltcG9ydHM6IFtcbiAgICAgKiAgICAgLy8gLi4uXG4gICAgICogICAgIE5iUm91dGVUYWJzZXRNb2R1bGUsXG4gICAgICogICBdLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFJvdXRlIFRhYnNldCwgdGFic2V0L3JvdXRlLXRhYnNldC1zaG93Y2FzZS5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBAc3R5bGVzXG4gICAgICpcbiAgICAgKiByb3V0ZS10YWJzZXQtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiByb3V0ZS10YWJzZXQtYm9yZGVyLXJhZGl1czpcbiAgICAgKiByb3V0ZS10YWJzZXQtc2hhZG93OlxuICAgICAqIHJvdXRlLXRhYnNldC10YWItYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiByb3V0ZS10YWJzZXQtdGFiLXBhZGRpbmc6XG4gICAgICogcm91dGUtdGFic2V0LXRhYi10ZXh0LWNvbG9yOlxuICAgICAqIHJvdXRlLXRhYnNldC10YWItdGV4dC1mb250LWZhbWlseTpcbiAgICAgKiByb3V0ZS10YWJzZXQtdGFiLXRleHQtZm9udC1zaXplOlxuICAgICAqIHJvdXRlLXRhYnNldC10YWItdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiByb3V0ZS10YWJzZXQtdGFiLXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogcm91dGUtdGFic2V0LXRhYi10ZXh0LXRyYW5zZm9ybTpcbiAgICAgKiByb3V0ZS10YWJzZXQtdGFiLXVuZGVybGluZS13aWR0aDpcbiAgICAgKiByb3V0ZS10YWJzZXQtdGFiLXVuZGVybGluZS1jb2xvcjpcbiAgICAgKiByb3V0ZS10YWJzZXQtdGFiLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHJvdXRlLXRhYnNldC10YWItYWN0aXZlLXRleHQtY29sb3I6XG4gICAgICogcm91dGUtdGFic2V0LXRhYi1hY3RpdmUtdW5kZXJsaW5lLWNvbG9yOlxuICAgICAqIHJvdXRlLXRhYnNldC10YWItZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiByb3V0ZS10YWJzZXQtdGFiLWZvY3VzLXRleHQtY29sb3I6XG4gICAgICogcm91dGUtdGFic2V0LXRhYi1mb2N1cy11bmRlcmxpbmUtY29sb3I6XG4gICAgICogcm91dGUtdGFic2V0LXRhYi1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHJvdXRlLXRhYnNldC10YWItaG92ZXItdGV4dC1jb2xvcjpcbiAgICAgKiByb3V0ZS10YWJzZXQtdGFiLWhvdmVyLXVuZGVybGluZS1jb2xvcjpcbiAgICAgKiByb3V0ZS10YWJzZXQtdGFiLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogcm91dGUtdGFic2V0LXRhYi1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICAgICAqIHJvdXRlLXRhYnNldC10YWItZGlzYWJsZWQtdW5kZXJsaW5lLWNvbG9yOlxuICAgICAqIHJvdXRlLXRhYnNldC1kaXZpZGVyLWNvbG9yOlxuICAgICAqIHJvdXRlLXRhYnNldC1kaXZpZGVyLXN0eWxlOlxuICAgICAqIHJvdXRlLXRhYnNldC1kaXZpZGVyLXdpZHRoOlxuICAgICAqIHJvdXRlLXRhYnNldC1zY3JvbGxiYXItY29sb3I6XG4gICAgICogcm91dGUtdGFic2V0LXNjcm9sbGJhci1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHJvdXRlLXRhYnNldC1zY3JvbGxiYXItd2lkdGg6XG4gICAgICogcm91dGUtdGFic2V0LXRhYi10ZXh0LWhpZGUtYnJlYWtwb2ludDpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5mdWxsV2lkdGhWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9ucyBwYXNzZWQgdG8gYHJvdXRlckxpbmtBY3RpdmVPcHRpb25zYCBkaXJlY3RpdmUgd2hpY2ggc2V0IG9uIHRhYiBsaW5rcy5cbiAgICAgICAgICogYHsgZXhhY3Q6IHRydWUgfWAgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWN0aXZlTGlua09wdGlvbnMgPSB7IGV4YWN0OiB0cnVlIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIHRhYiBpcyBzZWxlY3RlZFxuICAgICAgICAgKiBAdHlwZSB7RXZlbnRFbWl0dGVyPGFueT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoYW5nZVRhYiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZSBmdWxsIHdpZHRoIG9mIGEgcGFyZW50XG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWxcbiAgICAgKi9cbiAgICBzZXQgZnVsbFdpZHRoKHZhbCkge1xuICAgICAgICB0aGlzLmZ1bGxXaWR0aFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIHNlbGVjdFRhYih0YWIpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VUYWIuZW1pdCh0YWIpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDYzKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MuZnVsbC13aWR0aCcpLFxuICAgIF9fbWV0YWRhdGEkNDMoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJSb3V0ZVRhYnNldENvbXBvbmVudC5wcm90b3R5cGUsIFwiZnVsbFdpZHRoVmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNjMoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0MyhcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgTmJSb3V0ZVRhYnNldENvbXBvbmVudC5wcm90b3R5cGUsIFwidGFic1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ2MyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQzKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJSb3V0ZVRhYnNldENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWN0aXZlTGlua09wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNjMoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0MyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDMoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlJvdXRlVGFic2V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmdWxsV2lkdGhcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDYzKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDQzKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJSb3V0ZVRhYnNldENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hhbmdlVGFiXCIsIHZvaWQgMCk7XG5OYlJvdXRlVGFic2V0Q29tcG9uZW50ID0gX19kZWNvcmF0ZSQ2MyhbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1yb3V0ZS10YWJzZXQnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDx1bCBjbGFzcz1cInJvdXRlLXRhYnNldFwiPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgdGFiIG9mIHRhYnNcIj5cbiAgICAgICAgPGxpICpuZ0lmPVwidGFiLmRpc2FibGVkOyBlbHNlIGVuYWJsZWRcIlxuICAgICAgICAgICAgW2NsYXNzLnJlc3BvbnNpdmVdPVwidGFiLnJlc3BvbnNpdmVcIlxuICAgICAgICAgICAgY2xhc3M9XCJyb3V0ZS10YWIgZGlzYWJsZWRcIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiPlxuICAgICAgICAgIDxhIHRhYmluZGV4PVwiLTFcIiBjbGFzcz1cInRhYi1saW5rXCI+XG4gICAgICAgICAgICA8bmItaWNvbiAqbmdJZj1cInRhYi5pY29uXCIgW2NvbmZpZ109XCJ0YWIuaWNvblwiPjwvbmItaWNvbj5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwidGFiLnRpdGxlXCIgY2xhc3M9XCJ0YWItdGV4dFwiPnt7IHRhYi50aXRsZSB9fTwvc3Bhbj5cbiAgICAgICAgICA8L2E+XG4gICAgICAgIDwvbGk+XG5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNlbmFibGVkPlxuICAgICAgICAgIDxsaSAoY2xpY2spPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IHNlbGVjdFRhYih0YWIpXCJcbiAgICAgICAgICAgICAgW3JvdXRlckxpbmtdPVwidGFiLnJvdXRlXCJcbiAgICAgICAgICAgICAgcm91dGVyTGlua0FjdGl2ZT1cImFjdGl2ZVwiXG4gICAgICAgICAgICAgIFtyb3V0ZXJMaW5rQWN0aXZlT3B0aW9uc109XCJhY3RpdmVMaW5rT3B0aW9uc1wiXG4gICAgICAgICAgICAgIFtjbGFzcy5yZXNwb25zaXZlXT1cInRhYi5yZXNwb25zaXZlXCJcbiAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJyb3V0ZS10YWJcIj5cbiAgICAgICAgICAgIDxhIHRhYmluZGV4PVwiLTFcIiBjbGFzcz1cInRhYi1saW5rXCI+XG4gICAgICAgICAgICAgIDxuYi1pY29uICpuZ0lmPVwidGFiLmljb25cIiBbaWNvbl09XCJ0YWIuaWNvblwiPjwvbmItaWNvbj5cbiAgICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJ0YWIudGl0bGVcIiBjbGFzcz1cInRhYi10ZXh0XCI+e3sgdGFiLnRpdGxlIH19PC9zcGFuPlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgIDwvbGk+XG4gICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L3VsPlxuICAgIDxyb3V0ZXItb3V0bGV0Pjwvcm91dGVyLW91dGxldD5cbiAgYCxcbiAgICAgICAgc3R5bGVzOiBbXCIucm91dGUtdGFic2V0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7bGlzdC1zdHlsZS10eXBlOm5vbmU7bWFyZ2luOjB9LnJvdXRlLXRhYnNldCAucm91dGUtdGFie21hcmdpbi1ib3R0b206LTFweDt0ZXh0LWFsaWduOmNlbnRlcjtwYWRkaW5nOjB9LnJvdXRlLXRhYnNldCAucm91dGUtdGFiLmFjdGl2ZSBhOjpiZWZvcmV7ZGlzcGxheTpibG9ja30ucm91dGUtdGFic2V0IC5yb3V0ZS10YWIgYXtwb3NpdGlvbjpyZWxhdGl2ZTt0ZXh0LWRlY29yYXRpb246bm9uZTtkaXNwbGF5OmlubGluZS1ibG9ja30ucm91dGUtdGFic2V0IC5yb3V0ZS10YWIgYTo6YmVmb3Jle3Bvc2l0aW9uOmFic29sdXRlO2NvbnRlbnQ6Jyc7d2lkdGg6MTAwJTtib3JkZXItcmFkaXVzOjNweDtib3R0b206LTJweDtsZWZ0OjB9LnJvdXRlLXRhYnNldCAucm91dGUtdGFiIGEgbmItaWNvbnt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9W2Rpcj1sdHJdIC5yb3V0ZS10YWJzZXQgLnJvdXRlLXRhYiBhIG5iLWljb24rc3BhbnttYXJnaW4tbGVmdDouNXJlbX1bZGlyPXJ0bF0gLnJvdXRlLXRhYnNldCAucm91dGUtdGFiIGEgbmItaWNvbitzcGFue21hcmdpbi1yaWdodDouNXJlbX06aG9zdC5mdWxsLXdpZHRoIC5yb3V0ZS10YWJzZXR7anVzdGlmeS1jb250ZW50OnNwYWNlLWFyb3VuZH1cXG5cIl1cbiAgICB9KVxuXSwgTmJSb3V0ZVRhYnNldENvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDYyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmxldCBOYlJvdXRlVGFic2V0TW9kdWxlID0gY2xhc3MgTmJSb3V0ZVRhYnNldE1vZHVsZSB7XG59O1xuTmJSb3V0ZVRhYnNldE1vZHVsZSA9IF9fZGVjb3JhdGUkNjIoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgTmJTaGFyZWRNb2R1bGUsXG4gICAgICAgICAgICBOYkljb25Nb2R1bGUsXG4gICAgICAgIF0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgTmJSb3V0ZVRhYnNldENvbXBvbmVudCxcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgTmJSb3V0ZVRhYnNldENvbXBvbmVudCxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJSb3V0ZVRhYnNldE1vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDY2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbi8qKlxuICogU2lkZWJhciBzZXJ2aWNlLlxuICpcbiAqIFJvb3QgbW9kdWxlIHNlcnZpY2UgdG8gY29udHJvbCB0aGUgc2lkZWJhciBmcm9tIGFueSBwYXJ0IG9mIHRoZSBhcHAuXG4gKlxuICogQWxsb3dzIHlvdSB0byBjaGFuZ2Ugc2lkZWJhciBzdGF0ZSBkeW5hbWljYWxseSBmcm9tIGFueSBwYXJ0IG9mIHRoZSBhcHA6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFNpZGViYXIgU3RhdGUsIHNpZGViYXIvc2lkZWJhci10b2dnbGUuY29tcG9uZW50KVxuICovXG5sZXQgTmJTaWRlYmFyU2VydmljZSA9IGNsYXNzIE5iU2lkZWJhclNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIFNpZGViYXIgc2VydmljZS5cbiAgICAgKlxuICAgICAqIFJvb3QgbW9kdWxlIHNlcnZpY2UgdG8gY29udHJvbCB0aGUgc2lkZWJhciBmcm9tIGFueSBwYXJ0IG9mIHRoZSBhcHAuXG4gICAgICpcbiAgICAgKiBBbGxvd3MgeW91IHRvIGNoYW5nZSBzaWRlYmFyIHN0YXRlIGR5bmFtaWNhbGx5IGZyb20gYW55IHBhcnQgb2YgdGhlIGFwcDpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFNpZGViYXIgU3RhdGUsIHNpZGViYXIvc2lkZWJhci10b2dnbGUuY29tcG9uZW50KVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmV4cGFuZCQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmNvbGxhcHNlJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuY29tcGFjdCQgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gdG9nZ2xlIGV2ZW50c1xuICAgICAqXG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZTx7IGNvbXBhY3Q6IGJvb2xlYW4sIHRhZzogc3RyaW5nIH0+XG4gICAgICovXG4gICAgb25Ub2dnbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZSQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIGV4cGFuZCBldmVudHNcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlPHsgdGFnOiBzdHJpbmcgfT5cbiAgICAgKi9cbiAgICBvbkV4cGFuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhwYW5kJC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gY29sbGFwc2UgZXZlbnNcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlPHsgdGFnOiBzdHJpbmcgfT5cbiAgICAgKi9cbiAgICBvbkNvbGxhcHNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsYXBzZSQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIGNvbXBhY3QgZXZlbnNcbiAgICAgKiBAcmV0dXJucyBPYnNlcnZhYmxlPHsgdGFnOiBzdHJpbmcgfT5cbiAgICAgKi9cbiAgICBvbkNvbXBhY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhY3QkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBhIHNpZGViYXJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXBhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIElmIHlvdSBoYXZlIG11bHRpcGxlIHNpZGViYXJzIG9uIHRoZSBwYWdlLCBtYXJrIHRoZW0gd2l0aCBgdGFnYCBpbnB1dCBwcm9wZXJ0eSBhbmQgcGFzcyBpdCBoZXJlXG4gICAgICogdG8gc3BlY2lmeSB3aGljaCBzaWRlYmFyIHlvdSB3YW50IHRvIGNvbnRyb2xcbiAgICAgKi9cbiAgICB0b2dnbGUoY29tcGFjdCA9IGZhbHNlLCB0YWcpIHtcbiAgICAgICAgdGhpcy50b2dnbGUkLm5leHQoeyBjb21wYWN0LCB0YWcgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYSBzaWRlYmFyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBJZiB5b3UgaGF2ZSBtdWx0aXBsZSBzaWRlYmFycyBvbiB0aGUgcGFnZSwgbWFyayB0aGVtIHdpdGggYHRhZ2AgaW5wdXQgcHJvcGVydHkgYW5kIHBhc3MgaXQgaGVyZVxuICAgICAqIHRvIHNwZWNpZnkgd2hpY2ggc2lkZWJhciB5b3Ugd2FudCB0byBjb250cm9sXG4gICAgICovXG4gICAgZXhwYW5kKHRhZykge1xuICAgICAgICB0aGlzLmV4cGFuZCQubmV4dCh7IHRhZyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIGEgc2lkZWJhclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgSWYgeW91IGhhdmUgbXVsdGlwbGUgc2lkZWJhcnMgb24gdGhlIHBhZ2UsIG1hcmsgdGhlbSB3aXRoIGB0YWdgIGlucHV0IHByb3BlcnR5IGFuZCBwYXNzIGl0IGhlcmVcbiAgICAgKiB0byBzcGVjaWZ5IHdoaWNoIHNpZGViYXIgeW91IHdhbnQgdG8gY29udHJvbFxuICAgICAqL1xuICAgIGNvbGxhcHNlKHRhZykge1xuICAgICAgICB0aGlzLmNvbGxhcHNlJC5uZXh0KHsgdGFnIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzaWRlYmFyIGNvbXBhY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIElmIHlvdSBoYXZlIG11bHRpcGxlIHNpZGViYXJzIG9uIHRoZSBwYWdlLCBtYXJrIHRoZW0gd2l0aCBgdGFnYCBpbnB1dCBwcm9wZXJ0eSBhbmQgcGFzcyBpdCBoZXJlXG4gICAgICogdG8gc3BlY2lmeSB3aGljaCBzaWRlYmFyIHlvdSB3YW50IHRvIGNvbnRyb2xcbiAgICAgKi9cbiAgICBjb21wYWN0KHRhZykge1xuICAgICAgICB0aGlzLmNvbXBhY3QkLm5leHQoeyB0YWcgfSk7XG4gICAgfVxufTtcbk5iU2lkZWJhclNlcnZpY2UgPSBfX2RlY29yYXRlJDY2KFtcbiAgICBJbmplY3RhYmxlKClcbl0sIE5iU2lkZWJhclNlcnZpY2UpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ2NSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0NCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE5iU2lkZWJhckNvbXBvbmVudF8xO1xuLyoqXG4gKiBTaWRlYmFyIGhlYWRlciBjb250YWluZXIuXG4gKlxuICogUGxhY2Vob2xkZXIgd2hpY2ggY29udGFpbnMgYSBzaWRlYmFyIGhlYWRlciBjb250ZW50LFxuICogcGxhY2VkIGF0IHRoZSB2ZXJ5IHRvcCBvZiB0aGUgc2lkZWJhciBvdXRzaWRlIG9mIHRoZSBzY3JvbGwgYXJlYS5cbiAqL1xubGV0IE5iU2lkZWJhckhlYWRlckNvbXBvbmVudCA9IGNsYXNzIE5iU2lkZWJhckhlYWRlckNvbXBvbmVudCB7XG59O1xuTmJTaWRlYmFySGVhZGVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQ2NShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1zaWRlYmFyLWhlYWRlcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICBgXG4gICAgfSlcbl0sIE5iU2lkZWJhckhlYWRlckNvbXBvbmVudCk7XG4vKipcbiAqIFNpZGViYXIgZm9vdGVyIGNvbnRhaW5lci5cbiAqXG4gKiBQbGFjZWhvbGRlciB3aGljaCBjb250YWlucyBhIHNpZGViYXIgZm9vdGVyIGNvbnRlbnQsXG4gKiBwbGFjZWQgYXQgdGhlIHZlcnkgYm90dG9tIG9mIHRoZSBzaWRlYmFyIG91dHNpZGUgb2YgdGhlIHNjcm9sbCBhcmVhLlxuICovXG5sZXQgTmJTaWRlYmFyRm9vdGVyQ29tcG9uZW50ID0gY2xhc3MgTmJTaWRlYmFyRm9vdGVyQ29tcG9uZW50IHtcbn07XG5OYlNpZGViYXJGb290ZXJDb21wb25lbnQgPSBfX2RlY29yYXRlJDY1KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLXNpZGViYXItZm9vdGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gIGBcbiAgICB9KVxuXSwgTmJTaWRlYmFyRm9vdGVyQ29tcG9uZW50KTtcbi8qKlxuICogTGF5b3V0IHNpZGViYXIgY29tcG9uZW50LlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIHNpZGViYXIvc2lkZWJhci1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJTaWRlYmFyTW9kdWxlLmZvclJvb3QoKWAgdG8geW91ciBhcHAgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlNpZGViYXJNb2R1bGUuZm9yUm9vdCgpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqIGFuZCBgTmJTaWRlYmFyTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlIHdoZXJlIHRoZSBjb21wb25lbnQgc2hvdWxkIGJlIHNob3duOlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlNpZGViYXJNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIFNpZGViYXIgY2FuIGJlIHBsYWNlZCBvbiB0aGUgbGVmdCBvciB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgbGF5b3V0LFxuICogb3Igb24gc3RhcnQvZW5kIHBvc2l0aW9uIG9mIGxheW91dCAoZGVwZW5kcyBvbiBkb2N1bWVudCBkaXJlY3Rpb24sIGxlZnQgdG8gcmlnaHQgb3IgcmlnaHQgdG8gbGVmdClcbiAqIEl0IGNhbiBiZSBmaXhlZCAoc2hvd24gYWJvdmUgdGhlIGNvbnRlbnQpIG9yIGNhbiBwdXNoIHRoZSBsYXlvdXQgd2hlbiBvcGVuZWQuXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIHN0YXRlcyAtIGBleHBhbmRlZGAsIGBjb2xsYXBzZWRgLCBgY29tcGFjdGVkYC5cbiAqIEJ5IGRlZmF1bHQgc2lkZWJhciBjb250ZW50IGlzIGZpeGVkIGFuZCBzYXZlcyBpdHMgcG9zaXRpb24gd2hpbGUgdGhlIHBhZ2UgaXMgYmVpbmcgc2Nyb2xsZWQuXG4gKlxuICogQ29tcGFjdGVkIHNpZGViYXIgZXhhbXBsZTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ29tcGFjdGVkIFNpZGViYXIsIHNpZGViYXIvc2lkZWJhci1jb21wYWN0ZWQuY29tcG9uZW50KVxuICpcbiAqIFNpZGViYXIgYWxzbyBzdXBwb3J0cyBhIGByZXNwb25zaXZlYCBiZWhhdmlvciwgbGlzdGVuaW5nIHRvIHdpbmRvdyBzaXplIGNoYW5nZSBhbmQgY2hhbmdpbmcgaXRzIHNpemUgcmVzcGVjdGFibHkuXG4gKlxuICogSW4gYSBwYWlyIHdpdGggaGVhZGVyIGl0IGlzIHBvc3NpYmxlIHRvIHNldHVwIGEgY29uZmlndXJhdGlvbiB3aGVuIGhlYWRlciBpcyBwbGFjZWQgb24gYSBzaWRlIG9mIHRoZSBzaWRlYmFyXG4gKiBhbmQgbm90IG9uIHRvcCBvZiBpdC4gVG8gYWNoaWV2ZSB0aGlzIHNpbXBseSBwdXQgYSBgc3ViaGVhZGVyYCBwcm9wZXJ0eSB0byB0aGUgaGVhZGVyIGxpa2UgdGhpczpcbiAqIGBgYGh0bWxcbiAqIDxuYi1sYXlvdXQtaGVhZGVyIHN1YmhlYWRlcj48L25iLWxheW91dC1oZWFkZXI+XG4gKiBgYGBcbiAqIEBzdGFja2VkLWV4YW1wbGUoU3ViaGVhZGVyLCBsYXlvdXQvbGF5b3V0LXNpZGViYXItc3ViaGVhZGVyLmNvbXBvbmVudClcbiAqIE5vdGUgdGhhdCBpbiBzdWNoIGNvbmZpZ3VyYXRpb24gc2lkZWJhciBzaGFkb3cgaXMgcmVtb3ZlZCBhbmQgaGVhZGVyIGNhbm5vdCBiZSBtYWtlIGBmaXhlZGAuXG4gKlxuICogQGFkZGl0aW9uYWwtZXhhbXBsZShSaWdodCBTaWRlYmFyLCBzaWRlYmFyL3NpZGViYXItcmlnaHQuY29tcG9uZW50KVxuICogQGFkZGl0aW9uYWwtZXhhbXBsZShGaXhlZCBTaWRlYmFyLCBzaWRlYmFyL3NpZGViYXItZml4ZWQuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBzaWRlYmFyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzaWRlYmFyLXRleHQtY29sb3I6XG4gKiBzaWRlYmFyLXRleHQtZm9udC1mYW1pbHk6XG4gKiBzaWRlYmFyLXRleHQtZm9udC1zaXplOlxuICogc2lkZWJhci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogc2lkZWJhci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogc2lkZWJhci1oZWlnaHQ6XG4gKiBzaWRlYmFyLXdpZHRoOlxuICogc2lkZWJhci13aWR0aC1jb21wYWN0OlxuICogc2lkZWJhci1wYWRkaW5nOlxuICogc2lkZWJhci1oZWFkZXItaGVpZ2h0OlxuICogc2lkZWJhci1mb290ZXItaGVpZ2h0OlxuICogc2lkZWJhci1zaGFkb3c6XG4gKiBzaWRlYmFyLW1lbnUtaXRlbS1oaWdobGlnaHQtY29sb3I6XG4gKiBzaWRlYmFyLXNjcm9sbGJhci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2lkZWJhci1zY3JvbGxiYXItY29sb3I6XG4gKiBzaWRlYmFyLXNjcm9sbGJhci13aWR0aDpcbiAqL1xubGV0IE5iU2lkZWJhckNvbXBvbmVudCA9IE5iU2lkZWJhckNvbXBvbmVudF8xID0gY2xhc3MgTmJTaWRlYmFyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihzaWRlYmFyU2VydmljZSwgdGhlbWVTZXJ2aWNlLCBlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuc2lkZWJhclNlcnZpY2UgPSBzaWRlYmFyU2VydmljZTtcbiAgICAgICAgdGhpcy50aGVtZVNlcnZpY2UgPSB0aGVtZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVzcG9uc2l2ZVZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbnRhaW5lckZpeGVkVmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLmZpeGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yaWdodFZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVmdFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgLy8gVE9ETzogZ2V0IHdpZHRoIGJ5IHRoZSBrZXkgYW5kIGRlZmluZSBvbmx5IG1heCB3aWR0aCBmb3IgdGhlIHRhYmxldHMgYW5kIG1vYmlsZXNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRyb2xzIG9uIHdoaWNoIHNjcmVlbiBzaXplcyBzaWRlYmFyIHNob3VsZCBiZSBzd2l0Y2hlZCB0byBjb21wYWN0ZWQgc3RhdGUuXG4gICAgICAgICAqIFdvcmtzIG9ubHkgd2hlbiByZXNwb25zaXZlIG1vZGUgaXMgb24uXG4gICAgICAgICAqIERlZmF1bHQgdmFsdWVzIGFyZSBgWyd4cycsICdpcycsICdzbScsICdtZCcsICdsZyddYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgc3RyaW5nW11cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcGFjdGVkQnJlYWtwb2ludHMgPSBbJ3hzJywgJ2lzJywgJ3NtJywgJ21kJywgJ2xnJ107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyBvbiB3aGljaCBzY3JlZW4gc2l6ZXMgc2lkZWJhciBzaG91bGQgYmUgc3dpdGNoZWQgdG8gY29sbGFwc2VkIHN0YXRlLlxuICAgICAgICAgKiBXb3JrcyBvbmx5IHdoZW4gcmVzcG9uc2l2ZSBtb2RlIGlzIG9uLlxuICAgICAgICAgKiBEZWZhdWx0IHZhbHVlcyBhcmUgYFsneHMnLCAnaXMnXWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHN0cmluZ1tdXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxhcHNlZEJyZWFrcG9pbnRzID0gWyd4cycsICdpcyddO1xuICAgICAgICB0aGlzLnJlc3BvbnNpdmVTdGF0ZSA9IE5iU2lkZWJhckNvbXBvbmVudF8xLlJFU1BPTlNJVkVfU1RBVEVfUEM7XG4gICAgfVxuICAgIC8vIFRPRE86IHJlbmFtZSBzdGF0ZVZhbHVlIHRvIHN0YXRlICh0YWtlIGEgbG9vayB0byB0aGUgY2FyZCBjb21wb25lbnQpXG4gICAgZ2V0IGV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVZhbHVlID09PSBOYlNpZGViYXJDb21wb25lbnRfMS5TVEFURV9FWFBBTkRFRDtcbiAgICB9XG4gICAgZ2V0IGNvbGxhcHNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVWYWx1ZSA9PT0gTmJTaWRlYmFyQ29tcG9uZW50XzEuU1RBVEVfQ09MTEFQU0VEO1xuICAgIH1cbiAgICBnZXQgY29tcGFjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZVZhbHVlID09PSBOYlNpZGViYXJDb21wb25lbnRfMS5TVEFURV9DT01QQUNURUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBsYWNlcyBzaWRlYmFyIG9uIHRoZSByaWdodCBzaWRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IHJpZ2h0KHZhbCkge1xuICAgICAgICB0aGlzLnJpZ2h0VmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICAgICAgdGhpcy5sZWZ0VmFsdWUgPSAhdGhpcy5yaWdodFZhbHVlO1xuICAgICAgICB0aGlzLnN0YXJ0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbmRWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGFjZXMgc2lkZWJhciBvbiB0aGUgbGVmdCBzaWRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGxlZnQodmFsKSB7XG4gICAgICAgIHRoaXMubGVmdFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgICAgIHRoaXMucmlnaHRWYWx1ZSA9ICF0aGlzLmxlZnRWYWx1ZTtcbiAgICAgICAgdGhpcy5zdGFydFZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5kVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGxhY2VzIHNpZGViYXIgb24gdGhlIHN0YXJ0IGVkZ2Ugb2YgbGF5b3V0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IHN0YXJ0KHZhbCkge1xuICAgICAgICB0aGlzLnN0YXJ0VmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICAgICAgdGhpcy5lbmRWYWx1ZSA9ICF0aGlzLnN0YXJ0VmFsdWU7XG4gICAgICAgIHRoaXMubGVmdFZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmlnaHRWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQbGFjZXMgc2lkZWJhciBvbiB0aGUgZW5kIGVkZ2Ugb2YgbGF5b3V0XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgc2V0IGVuZCh2YWwpIHtcbiAgICAgICAgdGhpcy5lbmRWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgICAgICB0aGlzLnN0YXJ0VmFsdWUgPSAhdGhpcy5lbmRWYWx1ZTtcbiAgICAgICAgdGhpcy5sZWZ0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yaWdodFZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHNpZGViYXIgZml4ZWQgKHNob3duIGFib3ZlIHRoZSBsYXlvdXQgY29udGVudClcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgZml4ZWQodmFsKSB7XG4gICAgICAgIHRoaXMuZml4ZWRWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzaWRlYmFyIGNvbnRhaW5lciBmaXhlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldCBjb250YWluZXJGaXhlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJGaXhlZFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWwgc2lkZWJhciBzdGF0ZSwgYGV4cGFuZGVkYHxgY29sbGFwc2VkYHxgY29tcGFjdGVkYFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2V0IHN0YXRlKHZhbCkge1xuICAgICAgICB0aGlzLnN0YXRlVmFsdWUgPSB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHNpZGViYXIgbGlzdGVuIHRvIG1lZGlhIHF1ZXJ5IGV2ZW50cyBhbmQgY2hhbmdlIGl0cyBiZWhhdmlvdXJcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXQgcmVzcG9uc2l2ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zaXZlVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgdG9nZ2xlUmVzcG9uc2l2ZShlbmFibGVkKSB7XG4gICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhUXVlcnlTdWJzY3JpcHRpb24gPSB0aGlzLm9uTWVkaWFRdWVyeUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1lZGlhUXVlcnlTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWFRdWVyeVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZXMucmVzcG9uc2l2ZSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVSZXNwb25zaXZlKHRoaXMucmVzcG9uc2l2ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zaWRlYmFyU2VydmljZS5vblRvZ2dsZSgpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudGFnIHx8IHRoaXMudGFnID09PSBkYXRhLnRhZykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGRhdGEuY29tcGFjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNpZGViYXJTZXJ2aWNlLm9uRXhwYW5kKClcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy50YWcgfHwgdGhpcy50YWcgPT09IGRhdGEudGFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2lkZWJhclNlcnZpY2Uub25Db2xsYXBzZSgpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudGFnIHx8IHRoaXMudGFnID09PSBkYXRhLnRhZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2lkZWJhclNlcnZpY2Uub25Db21wYWN0KClcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy50YWcgfHwgdGhpcy50YWcgPT09IGRhdGEudGFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wYWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5tZWRpYVF1ZXJ5U3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhUXVlcnlTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUT0RPOiB0aGlzIGlzIG1vcmUgb2YgYSB3b3JrYXJvdW5kLCBzaG91bGQgYmUgYSBiZXR0ZXIgd2F5IHRvIG1ha2UgY29tcG9uZW50cyBjb21tdW5pY2F0ZSB0byBlYWNoIG90aGVyXG4gICAgb25DbGljayhldmVudCkge1xuICAgICAgICBjb25zdCBtZW51ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignbmItbWVudScpO1xuICAgICAgICBpZiAobWVudSAmJiBtZW51LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmsgPSB0aGlzLmdldE1lbnVMaW5rKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICBpZiAobGluayAmJiBsaW5rLm5leHRFbGVtZW50U2libGluZyAmJiBsaW5rLm5leHRFbGVtZW50U2libGluZy5jbGFzc0xpc3QuY29udGFpbnMoJ21lbnUtaXRlbXMnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lkZWJhclNlcnZpY2UuZXhwYW5kKHRoaXMudGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgdGhlIHNpZGViYXJcbiAgICAgKi9cbiAgICBjb2xsYXBzZSgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IE5iU2lkZWJhckNvbXBvbmVudF8xLlNUQVRFX0NPTExBUFNFRDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGUgc2lkZWJhclxuICAgICAqL1xuICAgIGV4cGFuZCgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IE5iU2lkZWJhckNvbXBvbmVudF8xLlNUQVRFX0VYUEFOREVEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wYWN0cyB0aGUgc2lkZWJhciAobWluaW1pemVzKVxuICAgICAqL1xuICAgIGNvbXBhY3QoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBOYlNpZGViYXJDb21wb25lbnRfMS5TVEFURV9DT01QQUNURUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgc2lkZWJhciBzdGF0ZSAoZXhwYW5kZWR8Y29sbGFwc2VkfGNvbXBhY3RlZClcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXBhY3QgSWYgdHJ1ZSwgdGhlbiBzaWRlYmFyIHN0YXRlIHdpbGwgYmUgY2hhbmdlZCBiZXR3ZWVuIGV4cGFuZGVkICYgY29tcGFjdGVkLFxuICAgICAqIG90aGVyd2lzZSAtIGJldHdlZW4gZXhwYW5kZWQgJiBjb2xsYXBzZWQuIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBUb2dnbGUgc2lkZWJhciBzdGF0ZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiB0aGlzLnNpZGViYXIudG9nZ2xlKHRydWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHRvZ2dsZShjb21wYWN0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzcG9uc2l2ZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzcG9uc2l2ZVN0YXRlID09PSBOYlNpZGViYXJDb21wb25lbnRfMS5SRVNQT05TSVZFX1NUQVRFX01PQklMRSkge1xuICAgICAgICAgICAgICAgIGNvbXBhY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9zZWRTdGF0ZXMgPSBbTmJTaWRlYmFyQ29tcG9uZW50XzEuU1RBVEVfQ09NUEFDVEVELCBOYlNpZGViYXJDb21wb25lbnRfMS5TVEFURV9DT0xMQVBTRURdO1xuICAgICAgICBpZiAoY29tcGFjdCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGNsb3NlZFN0YXRlcy5pbmNsdWRlcyh0aGlzLnN0YXRlVmFsdWUpID9cbiAgICAgICAgICAgICAgICBOYlNpZGViYXJDb21wb25lbnRfMS5TVEFURV9FWFBBTkRFRCA6IE5iU2lkZWJhckNvbXBvbmVudF8xLlNUQVRFX0NPTVBBQ1RFRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBjbG9zZWRTdGF0ZXMuaW5jbHVkZXModGhpcy5zdGF0ZVZhbHVlKSA/XG4gICAgICAgICAgICAgICAgTmJTaWRlYmFyQ29tcG9uZW50XzEuU1RBVEVfRVhQQU5ERUQgOiBOYlNpZGViYXJDb21wb25lbnRfMS5TVEFURV9DT0xMQVBTRUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25NZWRpYVF1ZXJ5Q2hhbmdlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbWVTZXJ2aWNlLm9uTWVkaWFRdWVyeUNoYW5nZSgpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChbcHJldiwgY3VycmVudF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gdGhpcy5jb2xsYXBzZWRCcmVha3BvaW50cy5pbmNsdWRlcyhjdXJyZW50Lm5hbWUpO1xuICAgICAgICAgICAgY29uc3QgaXNDb21wYWN0ZWQgPSB0aGlzLmNvbXBhY3RlZEJyZWFrcG9pbnRzLmluY2x1ZGVzKGN1cnJlbnQubmFtZSk7XG4gICAgICAgICAgICBpZiAoaXNDb21wYWN0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpeGVkID0gdGhpcy5jb250YWluZXJGaXhlZFZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGFjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2l2ZVN0YXRlID0gTmJTaWRlYmFyQ29tcG9uZW50XzEuUkVTUE9OU0lWRV9TVEFURV9UQUJMRVQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpeGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxhcHNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zaXZlU3RhdGUgPSBOYlNpZGViYXJDb21wb25lbnRfMS5SRVNQT05TSVZFX1NUQVRFX01PQklMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNDb2xsYXBzZWQgJiYgIWlzQ29tcGFjdGVkICYmIHByZXYud2lkdGggPCBjdXJyZW50LndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpeGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zaXZlU3RhdGUgPSBOYlNpZGViYXJDb21wb25lbnRfMS5SRVNQT05TSVZFX1NUQVRFX1BDO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzcG9uc2l2ZUVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNpdmVWYWx1ZTtcbiAgICB9XG4gICAgZ2V0TWVudUxpbmsoZWxlbWVudCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICduYi1tZW51Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNZW51TGluayhlbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICAgIH1cbn07XG5OYlNpZGViYXJDb21wb25lbnQuU1RBVEVfRVhQQU5ERUQgPSAnZXhwYW5kZWQnO1xuTmJTaWRlYmFyQ29tcG9uZW50LlNUQVRFX0NPTExBUFNFRCA9ICdjb2xsYXBzZWQnO1xuTmJTaWRlYmFyQ29tcG9uZW50LlNUQVRFX0NPTVBBQ1RFRCA9ICdjb21wYWN0ZWQnO1xuTmJTaWRlYmFyQ29tcG9uZW50LlJFU1BPTlNJVkVfU1RBVEVfTU9CSUxFID0gJ21vYmlsZSc7XG5OYlNpZGViYXJDb21wb25lbnQuUkVTUE9OU0lWRV9TVEFURV9UQUJMRVQgPSAndGFibGV0Jztcbk5iU2lkZWJhckNvbXBvbmVudC5SRVNQT05TSVZFX1NUQVRFX1BDID0gJ3BjJztcbl9fZGVjb3JhdGUkNjUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5maXhlZCcpLFxuICAgIF9fbWV0YWRhdGEkNDQoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJTaWRlYmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaXhlZFZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDY1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MucmlnaHQnKSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE5iU2lkZWJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmlnaHRWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ2NShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmxlZnQnKSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE5iU2lkZWJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwibGVmdFZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDY1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhcnQnKSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE5iU2lkZWJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ2NShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmVuZCcpLFxuICAgIF9fbWV0YWRhdGEkNDQoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJTaWRlYmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJlbmRWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ2NShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmV4cGFuZGVkJyksXG4gICAgX19tZXRhZGF0YSQ0NChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ0NChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTaWRlYmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBhbmRlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNjUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5jb2xsYXBzZWQnKSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNpZGViYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbGxhcHNlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNjUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5jb21wYWN0ZWQnKSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNpZGViYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbXBhY3RlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNjUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDQoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlNpZGViYXJDb21wb25lbnQucHJvdG90eXBlLCBcInJpZ2h0XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ2NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0NChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iU2lkZWJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwibGVmdFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNjUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDQoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlNpZGViYXJDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXJ0XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ2NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0NChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iU2lkZWJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZW5kXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ2NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0NChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iU2lkZWJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZml4ZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDY1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDQoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJTaWRlYmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250YWluZXJGaXhlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNjUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NChcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YSQ0NChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgTmJTaWRlYmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGF0ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNjUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDQoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlNpZGViYXJDb21wb25lbnQucHJvdG90eXBlLCBcInJlc3BvbnNpdmVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDY1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDQoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlNpZGViYXJDb21wb25lbnQucHJvdG90eXBlLCBcInRhZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ2NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ0KFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBOYlNpZGViYXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbXBhY3RlZEJyZWFrcG9pbnRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDY1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDQoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIE5iU2lkZWJhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sbGFwc2VkQnJlYWtwb2ludHNcIiwgdm9pZCAwKTtcbk5iU2lkZWJhckNvbXBvbmVudCA9IE5iU2lkZWJhckNvbXBvbmVudF8xID0gX19kZWNvcmF0ZSQ2NShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1zaWRlYmFyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwibWFpbi1jb250YWluZXJcIlxuICAgICAgICAgW2NsYXNzLm1haW4tY29udGFpbmVyLWZpeGVkXT1cImNvbnRhaW5lckZpeGVkVmFsdWVcIj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLXNpZGViYXItaGVhZGVyXCI+PC9uZy1jb250ZW50PlxuICAgICAgPGRpdiBjbGFzcz1cInNjcm9sbGFibGVcIiAoY2xpY2spPVwib25DbGljaygkZXZlbnQpXCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgIDwvZGl2PlxuICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItc2lkZWJhci1mb290ZXJcIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG4gIGAsXG4gICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtvdmVyZmxvdzpoaWRkZW47ei1pbmRleDphdXRvO29yZGVyOjB9Omhvc3QgLnNjcm9sbGFibGV7b3ZlcmZsb3cteTphdXRvO292ZXJmbG93LXg6aGlkZGVuO2ZsZXg6MX06aG9zdCAubWFpbi1jb250YWluZXJ7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsIDAsIDApO2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW59Omhvc3QgLm1haW4tY29udGFpbmVyLWZpeGVke3Bvc2l0aW9uOmZpeGVkfTpob3N0LnJpZ2h0e21hcmdpbi1yaWdodDowO21hcmdpbi1sZWZ0OmF1dG99W2Rpcj1sdHJdIDpob3N0LnJpZ2h0e29yZGVyOjR9W2Rpcj1ydGxdIDpob3N0LnJpZ2h0e29yZGVyOjB9Omhvc3QuZW5ke29yZGVyOjR9W2Rpcj1sdHJdIDpob3N0LmVuZHttYXJnaW4tcmlnaHQ6MDttYXJnaW4tbGVmdDphdXRvfVtkaXI9cnRsXSA6aG9zdC5lbmR7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6YXV0b306aG9zdC5maXhlZHtwb3NpdGlvbjpmaXhlZDtoZWlnaHQ6MTAwJTt6LWluZGV4Ojk5OTt0b3A6MDtib3R0b206MDtsZWZ0OjB9Omhvc3QuZml4ZWQucmlnaHR7cmlnaHQ6MH1bZGlyPWx0cl0gOmhvc3QuZml4ZWQuc3RhcnR7bGVmdDowfVtkaXI9cnRsXSA6aG9zdC5maXhlZC5zdGFydHtyaWdodDowfVtkaXI9bHRyXSA6aG9zdC5maXhlZC5lbmR7cmlnaHQ6MH1bZGlyPXJ0bF0gOmhvc3QuZml4ZWQuZW5ke2xlZnQ6MH06aG9zdCA6Om5nLWRlZXAgbmItc2lkZWJhci1mb290ZXJ7bWFyZ2luLXRvcDphdXRvO2Rpc3BsYXk6YmxvY2t9Omhvc3QgOjpuZy1kZWVwIG5iLXNpZGViYXItaGVhZGVye2Rpc3BsYXk6YmxvY2t9XFxuXCJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQ0NChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYlNpZGViYXJTZXJ2aWNlLFxuICAgICAgICBOYlRoZW1lU2VydmljZSxcbiAgICAgICAgRWxlbWVudFJlZl0pXG5dLCBOYlNpZGViYXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ2NCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgTmJTaWRlYmFyTW9kdWxlXzE7XG5jb25zdCBOQl9TSURFQkFSX0NPTVBPTkVOVFMgPSBbXG4gICAgTmJTaWRlYmFyQ29tcG9uZW50LFxuICAgIE5iU2lkZWJhckZvb3RlckNvbXBvbmVudCxcbiAgICBOYlNpZGViYXJIZWFkZXJDb21wb25lbnQsXG5dO1xuY29uc3QgTkJfU0lERUJBUl9QUk9WSURFUlMgPSBbXG4gICAgTmJTaWRlYmFyU2VydmljZSxcbl07XG5sZXQgTmJTaWRlYmFyTW9kdWxlID0gTmJTaWRlYmFyTW9kdWxlXzEgPSBjbGFzcyBOYlNpZGViYXJNb2R1bGUge1xuICAgIHN0YXRpYyBmb3JSb290KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iU2lkZWJhck1vZHVsZV8xLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgLi4uTkJfU0lERUJBUl9QUk9WSURFUlMsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5OYlNpZGViYXJNb2R1bGUgPSBOYlNpZGViYXJNb2R1bGVfMSA9IF9fZGVjb3JhdGUkNjQoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgTmJTaGFyZWRNb2R1bGUsXG4gICAgICAgIF0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgLi4uTkJfU0lERUJBUl9DT01QT05FTlRTLFxuICAgICAgICBdLFxuICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAuLi5OQl9TSURFQkFSX0NPTVBPTkVOVFMsXG4gICAgICAgIF0sXG4gICAgfSlcbl0sIE5iU2lkZWJhck1vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDY4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQ1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFNwZWNpZmljIHRhYiBjb250YWluZXIuXG4gKlxuICogYGBgdHNcbiAqIDxuYi10YWIgdGFiVGl0bGU9XCJVc2Vyc1wiXG4gKiAgIGJhZGdlVGV4dD1cIjk5K1wiXG4gKiAgIGJhZGdlU3RhdHVzPVwiZGFuZ2VyXCI+XG4gKiAgIDxwPkxpc3Qgb2YgPHN0cm9uZz51c2Vyczwvc3Ryb25nPi48L3A+XG4gKiA8L25iLXRhYj5cbiBgYGBcbiAqL1xubGV0IE5iVGFiQ29tcG9uZW50ID0gY2xhc3MgTmJUYWJDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmljIHRhYiBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIDxuYi10YWIgdGFiVGl0bGU9XCJVc2Vyc1wiXG4gICAgICogICBiYWRnZVRleHQ9XCI5OStcIlxuICAgICAqICAgYmFkZ2VTdGF0dXM9XCJkYW5nZXJcIj5cbiAgICAgKiAgIDxwPkxpc3Qgb2YgPHN0cm9uZz51c2Vyczwvc3Ryb25nPi48L3A+XG4gICAgICogPC9uYi10YWI+XG4gICAgIGBgYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVzcG9uc2l2ZVZhbHVlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGlzYWJsZWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXRlbSBpcyBkaXNhYmxlZCBhbmQgY2Fubm90IGJlIG9wZW5lZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkVmFsdWU7XG4gICAgfVxuICAgIHNldCBkaXNhYmxlZCh2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgb25seSBpY29ucyB3aGVuIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiBgdGFicy1pY29uLW9ubHktbWF4LXdpZHRoYFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHNldCByZXNwb25zaXZlKHZhbCkge1xuICAgICAgICB0aGlzLnJlc3BvbnNpdmVWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgIH1cbiAgICBnZXQgcmVzcG9uc2l2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2l2ZVZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgYWN0aXZlIHRhYlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZhbHVlO1xuICAgIH1cbiAgICBzZXQgYWN0aXZlKHZhbCkge1xuICAgICAgICB0aGlzLmFjdGl2ZVZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExhenkgbG9hZCBjb250ZW50IGJlZm9yZSB0YWIgc2VsZWN0aW9uXG4gICAgICogVE9ETzogcmVuYW1lLCBhcyBsYXp5IGlzIGJ5IGRlZmF1bHQsIGFuZCB0aGlzIGlzIG1vcmUgYGluc3RhbnQgbG9hZGBcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbFxuICAgICAqL1xuICAgIHNldCBsYXp5TG9hZCh2YWwpIHtcbiAgICAgICAgdGhpcy5pbml0ID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkNjgoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVGFiQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJUaXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ2OChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ1KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJUYWJDb21wb25lbnQucHJvdG90eXBlLCBcInRhYklkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDY4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDUoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYlRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiSWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ2OChbXG4gICAgSW5wdXQoJ2Rpc2FibGVkJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YSQ0NShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDUoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDY4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDUoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ1KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJUYWJDb21wb25lbnQucHJvdG90eXBlLCBcInJlc3BvbnNpdmVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDY4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDUoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwicm91dGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNjgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5jb250ZW50LWFjdGl2ZScpLFxuICAgIF9fbWV0YWRhdGEkNDUoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJUYWJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDY4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDUoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ1KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJUYWJDb21wb25lbnQucHJvdG90eXBlLCBcImFjdGl2ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNjgoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDUoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwibGF6eUxvYWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDY4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDUoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFkZ2VUZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDY4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDUoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlRhYkNvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFkZ2VTdGF0dXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNjgoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVGFiQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYWRnZVBvc2l0aW9uXCIsIHZvaWQgMCk7XG5OYlRhYkNvbXBvbmVudCA9IF9fZGVjb3JhdGUkNjgoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItdGFiJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaW5pdFwiPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvbmctY29udGFpbmVyPlxuICBgXG4gICAgfSlcbl0sIE5iVGFiQ29tcG9uZW50KTtcbi8vIFRPRE86IENvbWJpbmUgdGFic2V0IHdpdGggcm91dGUtdGFic2V0LCBzbyB0aGF0IHdlIGNhbjpcbi8vIC0gaGF2ZSBzaW1pbGFyIGludGVyZmFjZVxuLy8gLSBlYXN5IHRvIG1pZ3JhdGUgZnJvbSBvbmUgdG8gYW5vdGhlclxuLy8gLSBjYW4gbWl4IHRoZW0gYm90aCAocm91dGUvY29udGVudCB0YWIpXG4vKipcbiAqXG4gKiBEeW5hbWljIHRhYnNldCBjb21wb25lbnQuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCB0YWJzZXQvdGFic2V0LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBCYXNpYyB0YWJzZXQgZXhhbXBsZVxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi10YWJzZXQ+XG4gKiAgPG5iLXRhYiB0YWJUaXRsZT1cIlNpbXBsZSBUYWIgIzFcIj5cbiAqICAgIFRhYiBjb250ZW50IDFcbiAqICA8L25iLXRhYj5cbiAqICA8bmItdGFiIHRhYlRpdGxlPVwiU2ltcGxlIFRhYiAjMlwiPlxuICogICAgVGFiIGNvbnRlbnQgMlxuICogIDwvbmItdGFiPlxuICogPC9uYi10YWJzZXQ+XG4gKiBgYGBcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlRhYnNldE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJUYWJzZXRNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gc2V0IGEgYmFkZ2UgdG8gYSBwYXJ0aWN1bGFyIHRhYjpcbiAqIEBzdGFja2VkLWV4YW1wbGUoVGFiIFdpdGggQmFkZ2UsIHRhYnNldC90YWJzZXQtYmFkZ2UuY29tcG9uZW50KVxuICpcbiAqIGFuZCB3ZSBjYW4gc2V0IGl0IHRvIGZ1bGwgYSB3aWR0aCBvZiBhIHBhcmVudCBjb21wb25lbnRcbiAqIEBzdGFja2VkLWV4YW1wbGUoRnVsbCBXaWR0aCwgdGFic2V0L3RhYnNldC13aWR0aC5jb21wb25lbnQpXG4gKlxuICogYHRhYkljb25gIHNob3VsZCBiZSB1c2VkIHRvIGFkZCBhbiBpY29uIHRvIHRoZSB0YWIuIEljb24gY2FuIGFsc28gYmUgY29tYmluZWQgd2l0aCB0aXRsZS5cbiAqIGByZXNwb25zaXZlYCB0YWIgcHJvcGVydHkgaWYgc2V0IGFsbG93cyB5b3UgdG8gaGlkZSB0aGUgdGl0bGUgb24gc21hbGxlciBzY3JlZW5zXG4gKiAoYHRhYnMtaWNvbi1vbmx5LW1heC13aWR0aGAgcHJvcGVydHkpIGZvciBiZXR0ZXIgcmVzcG9uc2l2ZSBiZWhhdmlvdXIuIFlvdSBjYW4gb3BlbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUgYW5kIG1ha2VcbiAqIHlvdXIgc2NyZWVuIHNtYWxsZXIgLSB0aXRsZXMgd2lsbCBiZSBoaWRkZW4gaW4gdGhlIGxhc3QgdGFic2V0IGluIHRoZSBsaXN0OlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoSWNvbiwgdGFic2V0L3RhYnNldC1pY29uLmNvbXBvbmVudClcbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGRpc2FibGUgYSB0YWIgdXNpbmcgYGRpc2FibGVkYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRGlzYWJsZWQgVGFiLCB0YWJzZXQvdGFic2V0LWRpc2FibGVkLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogdGFic2V0LWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWJzZXQtYm9yZGVyLXJhZGl1czpcbiAqIHRhYnNldC1zaGFkb3c6XG4gKiB0YWJzZXQtdGFiLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWJzZXQtdGFiLXBhZGRpbmc6XG4gKiB0YWJzZXQtdGFiLXRleHQtY29sb3I6XG4gKiB0YWJzZXQtdGFiLXRleHQtZm9udC1mYW1pbHk6XG4gKiB0YWJzZXQtdGFiLXRleHQtZm9udC1zaXplOlxuICogdGFic2V0LXRhYi10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdGFic2V0LXRhYi10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdGFic2V0LXRhYi10ZXh0LXRyYW5zZm9ybTpcbiAqIHRhYnNldC10YWItdW5kZXJsaW5lLXdpZHRoOlxuICogdGFic2V0LXRhYi11bmRlcmxpbmUtY29sb3I6XG4gKiB0YWJzZXQtdGFiLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFic2V0LXRhYi1hY3RpdmUtdGV4dC1jb2xvcjpcbiAqIHRhYnNldC10YWItYWN0aXZlLXVuZGVybGluZS1jb2xvcjpcbiAqIHRhYnNldC10YWItZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhYnNldC10YWItZm9jdXMtdGV4dC1jb2xvcjpcbiAqIHRhYnNldC10YWItZm9jdXMtdW5kZXJsaW5lLWNvbG9yOlxuICogdGFic2V0LXRhYi1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdGFic2V0LXRhYi1ob3Zlci10ZXh0LWNvbG9yOlxuICogdGFic2V0LXRhYi1ob3Zlci11bmRlcmxpbmUtY29sb3I6XG4gKiB0YWJzZXQtdGFiLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWJzZXQtdGFiLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiB0YWJzZXQtdGFiLWRpc2FibGVkLXVuZGVybGluZS1jb2xvcjpcbiAqIHRhYnNldC1kaXZpZGVyLWNvbG9yOlxuICogdGFic2V0LWRpdmlkZXItc3R5bGU6XG4gKiB0YWJzZXQtZGl2aWRlci13aWR0aDpcbiAqIHRhYnNldC1jb250ZW50LWJhY2tncm91bmQtY29sb3I6XG4gKiB0YWJzZXQtY29udGVudC1wYWRkaW5nOlxuICogdGFic2V0LWNvbnRlbnQtdGV4dC1jb2xvcjpcbiAqIHRhYnNldC1jb250ZW50LXRleHQtZm9udC1mYW1pbHk6XG4gKiB0YWJzZXQtY29udGVudC10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRhYnNldC1jb250ZW50LXRleHQtZm9udC13ZWlnaHQ6XG4gKiB0YWJzZXQtY29udGVudC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdGFic2V0LXNjcm9sbGJhci1jb2xvcjpcbiAqIHRhYnNldC1zY3JvbGxiYXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRhYnNldC1zY3JvbGxiYXItd2lkdGg6XG4gKiB0YWJzZXQtdGFiLXRleHQtaGlkZS1icmVha3BvaW50OlxuICovXG5sZXQgTmJUYWJzZXRDb21wb25lbnQgPSBjbGFzcyBOYlRhYnNldENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Iocm91dGUsIGNoYW5nZURldGVjdG9yUmVmKSB7XG4gICAgICAgIHRoaXMucm91dGUgPSByb3V0ZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZiA9IGNoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICB0aGlzLmZ1bGxXaWR0aFZhbHVlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIHRhYiBpcyBzZWxlY3RlZFxuICAgICAgICAgKiBAdHlwZSBFdmVudEVtaXR0ZXI8YW55PlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGFuZ2VUYWIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2UgZnVsbCB3aWR0aCBvZiBhIHBhcmVudFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gICAgICovXG4gICAgc2V0IGZ1bGxXaWR0aCh2YWwpIHtcbiAgICAgICAgdGhpcy5mdWxsV2lkdGhWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgIH1cbiAgICAvLyBUT0RPOiByZWZhY3RvcmluZyB0aGlzIGNvbXBvbmVudCwgYXZvaWQgY2hhbmdlIGRldGVjdGlvbiBsb29wXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLnJvdXRlLnBhcmFtc1xuICAgICAgICAgICAgLnBpcGUobWFwKChwYXJhbXMpID0+IHRoaXMudGFicy5maW5kKCh0YWIpID0+IHRoaXMucm91dGVQYXJhbSA/IHRhYi5yb3V0ZSA9PT0gcGFyYW1zW3RoaXMucm91dGVQYXJhbV0gOiB0YWIuYWN0aXZlKSksIGRlbGF5KDApLCBtYXAoKHRhYikgPT4gdGFiIHx8IHRoaXMudGFicy5maXJzdCksIGZpbHRlcigodGFiKSA9PiAhIXRhYikpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCh0YWJUb1NlbGVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RUYWIodGFiVG9TZWxlY3QpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRPRE86IG5hdmlnYXRlIHRvIHJvdXRlUGFyYW1cbiAgICBzZWxlY3RUYWIoc2VsZWN0ZWRUYWIpIHtcbiAgICAgICAgaWYgKCFzZWxlY3RlZFRhYi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy50YWJzLmZvckVhY2godGFiID0+IHRhYi5hY3RpdmUgPSB0YWIgPT09IHNlbGVjdGVkVGFiKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlVGFiLmVtaXQoc2VsZWN0ZWRUYWIpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkNjgoW1xuICAgIENvbnRlbnRDaGlsZHJlbihOYlRhYkNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YSQ0NShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIE5iVGFic2V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDY4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MuZnVsbC13aWR0aCcpLFxuICAgIF9fbWV0YWRhdGEkNDUoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJUYWJzZXRDb21wb25lbnQucHJvdG90eXBlLCBcImZ1bGxXaWR0aFZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDY4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDUoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ1KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJUYWJzZXRDb21wb25lbnQucHJvdG90eXBlLCBcImZ1bGxXaWR0aFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNjgoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVGFic2V0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3V0ZVBhcmFtXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDY4KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ1KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJUYWJzZXRDb21wb25lbnQucHJvdG90eXBlLCBcImNoYW5nZVRhYlwiLCB2b2lkIDApO1xuTmJUYWJzZXRDb21wb25lbnQgPSBfX2RlY29yYXRlJDY4KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLXRhYnNldCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHVsIGNsYXNzPVwidGFic2V0XCI+XG4gICAgICA8bGkgKm5nRm9yPVwibGV0IHRhYiBvZiB0YWJzXCJcbiAgICAgICAgICAoY2xpY2spPVwic2VsZWN0VGFiKHRhYilcIlxuICAgICAgICAgIChrZXl1cC5zcGFjZSk9XCJzZWxlY3RUYWIodGFiKVwiXG4gICAgICAgICAgKGtleXVwLmVudGVyKT1cInNlbGVjdFRhYih0YWIpXCJcbiAgICAgICAgICBbY2xhc3MucmVzcG9uc2l2ZV09XCJ0YWIucmVzcG9uc2l2ZVwiXG4gICAgICAgICAgW2NsYXNzLmFjdGl2ZV09XCJ0YWIuYWN0aXZlXCJcbiAgICAgICAgICBbY2xhc3MuZGlzYWJsZWRdPVwidGFiLmRpc2FibGVkXCJcbiAgICAgICAgICBbYXR0ci50YWJpbmRleF09XCJ0YWIuZGlzYWJsZWQgPyAtMSA6IDBcIlxuICAgICAgICAgIGNsYXNzPVwidGFiXCI+XG4gICAgICAgIDxhIGhyZWYgKGNsaWNrKT1cIiRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCIgdGFiaW5kZXg9XCItMVwiIGNsYXNzPVwidGFiLWxpbmtcIj5cbiAgICAgICAgICA8bmItaWNvbiAqbmdJZj1cInRhYi50YWJJY29uXCIgW2NvbmZpZ109XCJ0YWIudGFiSWNvblwiPjwvbmItaWNvbj5cbiAgICAgICAgICA8c3BhbiAqbmdJZj1cInRhYi50YWJUaXRsZVwiIGNsYXNzPVwidGFiLXRleHRcIj57eyB0YWIudGFiVGl0bGUgfX08L3NwYW4+XG4gICAgICAgIDwvYT5cbiAgICAgICAgPG5iLWJhZGdlICpuZ0lmPVwidGFiLmJhZGdlVGV4dFwiXG4gICAgICAgICAgW3RleHRdPVwidGFiLmJhZGdlVGV4dFwiXG4gICAgICAgICAgW3N0YXR1c109XCJ0YWIuYmFkZ2VTdGF0dXNcIlxuICAgICAgICAgIFtwb3NpdGlvbl09XCJ0YWIuYmFkZ2VQb3NpdGlvblwiPlxuICAgICAgICA8L25iLWJhZGdlPlxuICAgICAgPC9saT5cbiAgICA8L3VsPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLXRhYlwiPjwvbmctY29udGVudD5cbiAgYCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmJsb2NrfTpob3N0LmZ1bGwtd2lkdGggLnRhYnNldHtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYXJvdW5kfTpob3N0IDo6bmctZGVlcCBuYi10YWJ7ZmxleDoxOy1tcy1mbGV4OjEgMSBhdXRvO292ZXJmbG93OmF1dG87ZGlzcGxheTpub25lfTpob3N0IDo6bmctZGVlcCBuYi10YWIuY29udGVudC1hY3RpdmV7ZGlzcGxheTpibG9ja306aG9zdCAudGFic2V0e2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpyb3c7bGlzdC1zdHlsZS10eXBlOm5vbmU7bWFyZ2luOjA7cGFkZGluZzowfTpob3N0IC50YWJzZXQgLnRhYnttYXJnaW4tYm90dG9tOi0xcHg7dGV4dC1hbGlnbjpjZW50ZXI7cG9zaXRpb246cmVsYXRpdmV9Omhvc3QgLnRhYnNldCAudGFiLmFjdGl2ZSBhOjpiZWZvcmV7ZGlzcGxheTpibG9ja306aG9zdCAudGFic2V0IC50YWIgYXtkaXNwbGF5OmZsZXg7cG9zaXRpb246cmVsYXRpdmU7dGV4dC1kZWNvcmF0aW9uOm5vbmV9Omhvc3QgLnRhYnNldCAudGFiIGE6OmJlZm9yZXtwb3NpdGlvbjphYnNvbHV0ZTtjb250ZW50OicnO3dpZHRoOjEwMCU7Ym9yZGVyLXJhZGl1czozcHg7Ym90dG9tOi0ycHg7bGVmdDowfTpob3N0IC50YWJzZXQgLnRhYiBhIG5iLWljb257dmVydGljYWwtYWxpZ246bWlkZGxlfVtkaXI9bHRyXSA6aG9zdCAudGFic2V0IC50YWIgYSBuYi1pY29uK3NwYW57bWFyZ2luLWxlZnQ6LjVyZW19W2Rpcj1ydGxdIDpob3N0IC50YWJzZXQgLnRhYiBhIG5iLWljb24rc3BhbnttYXJnaW4tcmlnaHQ6LjVyZW19XFxuXCJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQ0NShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBY3RpdmF0ZWRSb3V0ZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgTmJUYWJzZXRDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ3MCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ0NiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBCYWRnZSBpcyBhIHNpbXBsZSBsYWJlbGluZyBjb21wb25lbnQuXG4gKiBJdCBjYW4gYmUgdXNlZCB0byBhZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byBhbnkgY29udGVudCBvciBoaWdobGlnaHQgdW5yZWFkIGl0ZW1zLlxuICpcbiAqIEVsZW1lbnQgaXMgYWJzb2x1dGUgcG9zaXRpb25lZCwgc28gcGFyZW50IHNob3VsZCBiZVxuICogW3Bvc2l0aW9uZWQgZWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3Bvc2l0aW9uKS5cbiAqIEl0IG1lYW5zIHBhcmVudCBgcG9zaXRpb25gIHNob3VsZCBiZSBzZXQgdG8gYW55dGhpbmcgZXhjZXB0IGBzdGF0aWNgLCBlLmcuIGByZWxhdGl2ZWAsXG4gKiBgYWJzb2x1dGVgLCBgZml4ZWRgLCBvciBgc3RpY2t5YC5cbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkJhZGdlTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkJhZGdlTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBCYWRnZSB3aXRoIGRlZmF1bHQgcG9zaXRpb24gYW5kIHN0YXR1cyhjb2xvcik6XG4gKlxuICogYGBgaHRtbFxuICogPG5iLWJhZGdlIHRleHQ9XCJiYWRnZVRleHRcIj48L25iLWJhZGdlPlxuICogYGBgXG4gKlxuICogRm9yIGV4YW1wbGUsIGJhZGdlIGNhbiBiZSBwbGFjZWQgaW50byBuYi1jYXJkIGhlYWRlcjpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGJhZGdlL2JhZGdlLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBCYWRnZSBsb2NhdGVkIG9uIHRoZSBib3R0b20gcmlnaHQgd2l0aCB3YXJuaW5nIHN0YXR1czpcbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItYmFkZ2UgdGV4dD1cImJhZGdlVGV4dFwiIHN0YXR1cz1cIndhcm5pbmdcIiBwb3NpdGlvbj1cImJvdHRvbSByaWdodFwiPlxuICogPC9uYi1iYWRnZT5cbiAqIGBgYFxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBiYWRnZS1ib3JkZXItcmFkaXVzOlxuICogYmFkZ2UtdGV4dC1mb250LWZhbWlseTpcbiAqIGJhZGdlLXRleHQtZm9udC1zaXplOlxuICogYmFkZ2UtdGV4dC1mb250LXdlaWdodDpcbiAqIGJhZGdlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBiYWRnZS1wYWRkaW5nOlxuICogYmFkZ2UtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJhZGdlLWJhc2ljLXRleHQtY29sb3I6XG4gKiBiYWRnZS1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiBiYWRnZS1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiBiYWRnZS1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gKiBiYWRnZS1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiBiYWRnZS1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiBiYWRnZS1pbmZvLXRleHQtY29sb3I6XG4gKiBiYWRnZS13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiBiYWRnZS13YXJuaW5nLXRleHQtY29sb3I6XG4gKiBiYWRnZS1kYW5nZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGJhZGdlLWRhbmdlci10ZXh0LWNvbG9yOlxuICogYmFkZ2UtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYmFkZ2UtY29udHJvbC10ZXh0LWNvbG9yOlxuICovXG5sZXQgTmJCYWRnZUNvbXBvbmVudCA9IGNsYXNzIE5iQmFkZ2VDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEJhZGdlIGlzIGEgc2ltcGxlIGxhYmVsaW5nIGNvbXBvbmVudC5cbiAgICAgKiBJdCBjYW4gYmUgdXNlZCB0byBhZGQgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byBhbnkgY29udGVudCBvciBoaWdobGlnaHQgdW5yZWFkIGl0ZW1zLlxuICAgICAqXG4gICAgICogRWxlbWVudCBpcyBhYnNvbHV0ZSBwb3NpdGlvbmVkLCBzbyBwYXJlbnQgc2hvdWxkIGJlXG4gICAgICogW3Bvc2l0aW9uZWQgZWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3Bvc2l0aW9uKS5cbiAgICAgKiBJdCBtZWFucyBwYXJlbnQgYHBvc2l0aW9uYCBzaG91bGQgYmUgc2V0IHRvIGFueXRoaW5nIGV4Y2VwdCBgc3RhdGljYCwgZS5nLiBgcmVsYXRpdmVgLFxuICAgICAqIGBhYnNvbHV0ZWAsIGBmaXhlZGAsIG9yIGBzdGlja3lgLlxuICAgICAqXG4gICAgICogIyMjIEluc3RhbGxhdGlvblxuICAgICAqXG4gICAgICogSW1wb3J0IGBOYkJhZGdlTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICAgICAqIGBgYHRzXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIGltcG9ydHM6IFtcbiAgICAgKiAgICAgLy8gLi4uXG4gICAgICogICAgIE5iQmFkZ2VNb2R1bGUsXG4gICAgICogICBdLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gICAgICogYGBgXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBCYWRnZSB3aXRoIGRlZmF1bHQgcG9zaXRpb24gYW5kIHN0YXR1cyhjb2xvcik6XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5iLWJhZGdlIHRleHQ9XCJiYWRnZVRleHRcIj48L25iLWJhZGdlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGJhZGdlIGNhbiBiZSBwbGFjZWQgaW50byBuYi1jYXJkIGhlYWRlcjpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBiYWRnZS9iYWRnZS1zaG93Y2FzZS5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBCYWRnZSBsb2NhdGVkIG9uIHRoZSBib3R0b20gcmlnaHQgd2l0aCB3YXJuaW5nIHN0YXR1czpcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmItYmFkZ2UgdGV4dD1cImJhZGdlVGV4dFwiIHN0YXR1cz1cIndhcm5pbmdcIiBwb3NpdGlvbj1cImJvdHRvbSByaWdodFwiPlxuICAgICAqIDwvbmItYmFkZ2U+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAc3R5bGVzXG4gICAgICpcbiAgICAgKiBiYWRnZS1ib3JkZXItcmFkaXVzOlxuICAgICAqIGJhZGdlLXRleHQtZm9udC1mYW1pbHk6XG4gICAgICogYmFkZ2UtdGV4dC1mb250LXNpemU6XG4gICAgICogYmFkZ2UtdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBiYWRnZS10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIGJhZGdlLXBhZGRpbmc6XG4gICAgICogYmFkZ2UtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBiYWRnZS1iYXNpYy10ZXh0LWNvbG9yOlxuICAgICAqIGJhZGdlLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBiYWRnZS1wcmltYXJ5LXRleHQtY29sb3I6XG4gICAgICogYmFkZ2Utc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGJhZGdlLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAgICAgKiBiYWRnZS1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogYmFkZ2UtaW5mby10ZXh0LWNvbG9yOlxuICAgICAqIGJhZGdlLXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBiYWRnZS13YXJuaW5nLXRleHQtY29sb3I6XG4gICAgICogYmFkZ2UtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogYmFkZ2UtZGFuZ2VyLXRleHQtY29sb3I6XG4gICAgICogYmFkZ2UtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGJhZGdlLWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRleHQgdG8gZGlzcGxheVxuICAgICAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGV4dCA9ICcnO1xuICAgICAgICB0aGlzLl9kZWZhdWx0UG9zaXRpb24gPSAndG9wIHJpZ2h0JztcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9kZWZhdWx0UG9zaXRpb247XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCYWRnZSBzdGF0dXMgKGFkZHMgc3BlY2lmaWMgc3R5bGVzKTpcbiAgICAgICAgICogJ2Jhc2ljJywgJ3ByaW1hcnknLCAnaW5mbycsICdzdWNjZXNzJywgJ3dhcm5pbmcnLCAnZGFuZ2VyJywgJ2NvbnRyb2wnXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXR1cyA9ICdwcmltYXJ5JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmFkZ2UgcG9zaXRpb25cbiAgICAgKlxuICAgICAqIENhbiBiZSBzZXQgdG8gYW55IGNsYXNzIG9yIHRvIG9uZSBvZiBwcmVkZWZpbmVkIHBvc2l0aW9uczpcbiAgICAgKiAndG9wIGxlZnQnLCAndG9wIHJpZ2h0JywgJ2JvdHRvbSBsZWZ0JywgJ2JvdHRvbSByaWdodCcsXG4gICAgICogJ3RvcCBzdGFydCcsICd0b3AgZW5kJywgJ2JvdHRvbSBzdGFydCcsICdib3R0b20gZW5kJ1xuICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAqL1xuICAgIGdldCBwb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xuICAgIH1cbiAgICBzZXQgcG9zaXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSB2YWx1ZSB8fCB0aGlzLl9kZWZhdWx0UG9zaXRpb247XG4gICAgfVxuICAgIGdldCBwcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IHN1Y2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24uaW5jbHVkZXMoJ3RvcCcpO1xuICAgIH1cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmluY2x1ZGVzKCdyaWdodCcpO1xuICAgIH1cbiAgICBnZXQgYm90dG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5pbmNsdWRlcygnYm90dG9tJyk7XG4gICAgfVxuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5pbmNsdWRlcygnbGVmdCcpO1xuICAgIH1cbiAgICBnZXQgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLmluY2x1ZGVzKCdzdGFydCcpO1xuICAgIH1cbiAgICBnZXQgZW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi5pbmNsdWRlcygnZW5kJyk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkNzAoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NihcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQmFkZ2VDb21wb25lbnQucHJvdG90eXBlLCBcInRleHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNzAoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NihcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YSQ0NihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgTmJCYWRnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDcwKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDYoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkJhZGdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGF0dXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtcHJpbWFyeScpLFxuICAgIF9fbWV0YWRhdGEkNDYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJhZGdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmltYXJ5XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1zdWNjZXNzJyksXG4gICAgX19tZXRhZGF0YSQ0NihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQmFkZ2VDb21wb25lbnQucHJvdG90eXBlLCBcInN1Y2Nlc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDcwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWluZm8nKSxcbiAgICBfX21ldGFkYXRhJDQ2KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0NihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJCYWRnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5mb1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtd2FybmluZycpLFxuICAgIF9fbWV0YWRhdGEkNDYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJhZGdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3YXJuaW5nXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1kYW5nZXInKSxcbiAgICBfX21ldGFkYXRhJDQ2KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0NihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJCYWRnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGFuZ2VyXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1iYXNpYycpLFxuICAgIF9fbWV0YWRhdGEkNDYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJhZGdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXNpY1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtY29udHJvbCcpLFxuICAgIF9fbWV0YWRhdGEkNDYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJhZGdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250cm9sXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnBvc2l0aW9uLXRvcCcpLFxuICAgIF9fbWV0YWRhdGEkNDYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkJhZGdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b3BcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDcwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MucG9zaXRpb24tcmlnaHQnKSxcbiAgICBfX21ldGFkYXRhJDQ2KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0NihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJCYWRnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicmlnaHRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDcwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MucG9zaXRpb24tYm90dG9tJyksXG4gICAgX19tZXRhZGF0YSQ0NihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQmFkZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImJvdHRvbVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5wb3NpdGlvbi1sZWZ0JyksXG4gICAgX19tZXRhZGF0YSQ0NihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQmFkZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImxlZnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDcwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MucG9zaXRpb24tc3RhcnQnKSxcbiAgICBfX21ldGFkYXRhJDQ2KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0NihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJCYWRnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhcnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDcwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MucG9zaXRpb24tZW5kJyksXG4gICAgX19tZXRhZGF0YSQ0NihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQmFkZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImVuZFwiLCBudWxsKTtcbk5iQmFkZ2VDb21wb25lbnQgPSBfX2RlY29yYXRlJDcwKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWJhZGdlJyxcbiAgICAgICAgdGVtcGxhdGU6IGB7e3RleHR9fWAsXG4gICAgICAgIHN0eWxlczogW1wiOmhvc3R7cG9zaXRpb246YWJzb2x1dGU7dGV4dC1hbGlnbjpjZW50ZXI7d2hpdGUtc3BhY2U6bm93cmFwO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfTpob3N0KC5wb3NpdGlvbi10b3Ape3RvcDowfTpob3N0KC5wb3NpdGlvbi1yaWdodCl7cmlnaHQ6MH06aG9zdCgucG9zaXRpb24tYm90dG9tKXtib3R0b206MH06aG9zdCgucG9zaXRpb24tbGVmdCl7bGVmdDowfVtkaXI9bHRyXSA6aG9zdCgucG9zaXRpb24tc3RhcnQpe2xlZnQ6MH1bZGlyPXJ0bF0gOmhvc3QoLnBvc2l0aW9uLXN0YXJ0KXtyaWdodDowfVtkaXI9bHRyXSA6aG9zdCgucG9zaXRpb24tZW5kKXtyaWdodDowfVtkaXI9cnRsXSA6aG9zdCgucG9zaXRpb24tZW5kKXtsZWZ0OjB9XFxuXCJdXG4gICAgfSlcbl0sIE5iQmFkZ2VDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ2OSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5sZXQgTmJCYWRnZU1vZHVsZSA9IGNsYXNzIE5iQmFkZ2VNb2R1bGUge1xufTtcbk5iQmFkZ2VNb2R1bGUgPSBfX2RlY29yYXRlJDY5KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGV4cG9ydHM6IFtOYkJhZGdlQ29tcG9uZW50XSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbTmJCYWRnZUNvbXBvbmVudF0sXG4gICAgfSlcbl0sIE5iQmFkZ2VNb2R1bGUpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ2NyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5jb25zdCBOQl9UQUJTRVRfQ09NUE9ORU5UUyA9IFtcbiAgICBOYlRhYnNldENvbXBvbmVudCxcbiAgICBOYlRhYkNvbXBvbmVudCxcbl07XG5sZXQgTmJUYWJzZXRNb2R1bGUgPSBjbGFzcyBOYlRhYnNldE1vZHVsZSB7XG59O1xuTmJUYWJzZXRNb2R1bGUgPSBfX2RlY29yYXRlJDY3KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgTmJCYWRnZU1vZHVsZSxcbiAgICAgICAgICAgIE5iSWNvbk1vZHVsZSxcbiAgICAgICAgXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAuLi5OQl9UQUJTRVRfQ09NUE9ORU5UUyxcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgLi4uTkJfVEFCU0VUX0NPTVBPTkVOVFMsXG4gICAgICAgIF0sXG4gICAgfSlcbl0sIE5iVGFic2V0TW9kdWxlKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkNzIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNDcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbXBvbmVudCBzaG93aW5nIGEgdXNlciBhdmF0YXIgKHBpY3R1cmUpIHdpdGggYSB1c2VyIG5hbWUgb24gdGhlIHJpZ2h0LlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgdXNlci91c2VyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBgYGB0c1xuICogICA8bmItdXNlciBuYW1lPVwiSm9obiBEb2VcIiB0aXRsZT1cIkVuZ2luZWVyXCI+PC9uYi11c2VyPlxuICogYGBgXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJVc2VyTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlVzZXJNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIEF2YWlsYWJsZSBpbiBtdWx0aXBsZSBzaXplczpcbiAqIEBzdGFja2VkLWV4YW1wbGUoTXVsdGlwbGUgU2l6ZXMsIHVzZXIvdXNlci1zaXplcy5jb21wb25lbnQpXG4gKlxuICpcbiAqIFlvdSBjYW4gaGlkZSB1bm5lY2Vzc2FyeSBjYXB0aW9ucyAobmFtZSwgdGl0bGUgb3IgYm90aCk6XG4gKiBAc3RhY2tlZC1leGFtcGxlKEhpZGUgY2FwdGlvbnMgaW4gdXNlciBjb21wb25lbnQsIHVzZXIvdXNlci1oaWRlLWNhcHRpb25zLmNvbXBvbmVudClcbiAqXG4gKlxuICogWW91IGNhbiBzZXQgY3VzdG9tIGF2YXRhciBiYWNrZ3JvdW5kLWNvbG9yLCB1c2VyIGltYWdlIChhcyBsaW5rIG9yIEJBU0U2NCBzdHJpbmcpIGFuZCBkaXNhYmxlIHVzZXIgaW5pdGlhbHM6XG4gKiBAc3RhY2tlZC1leGFtcGxlKEF2YXRhciBpbWFnZSBzZXR0aW5ncywgdXNlci91c2VyLWF2YXRhci1zZXR0aW5ncy5jb21wb25lbnQpXG4gKlxuICogQ29tcG9uZW50IHNoYXBlIGNvdWxkIGJlIGNvbnRyb2xsZWQgd2l0aCBgc2hhcGVgIGlucHV0LlxuICogQHN0YWNrZWQtZXhhbXBsZShTaGFwZXMsIHVzZXIvdXNlci1zaGFwZS5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHVzZXItcGljdHVyZS1ib3gtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHVzZXItcGljdHVyZS1ib3gtYm9yZGVyLWNvbG9yOlxuICogdXNlci1waWN0dXJlLWJveC1ib3JkZXItd2lkdGg6XG4gKiB1c2VyLWluaXRpYWxzLXRleHQtY29sb3I6XG4gKiB1c2VyLWluaXRpYWxzLXRleHQtZm9udC1mYW1pbHk6XG4gKiB1c2VyLWluaXRpYWxzLXRleHQtZm9udC13ZWlnaHQ6XG4gKiB1c2VyLW5hbWUtdGV4dC1jb2xvcjpcbiAqIHVzZXItbmFtZS10ZXh0LWZvbnQtZmFtaWx5OlxuICogdXNlci1uYW1lLXRleHQtZm9udC13ZWlnaHQ6XG4gKiB1c2VyLXRpdGxlLXRleHQtY29sb3I6XG4gKiB1c2VyLXRpdGxlLXRleHQtZm9udC1mYW1pbHk6XG4gKiB1c2VyLXRpdGxlLXRleHQtZm9udC13ZWlnaHQ6XG4gKiB1c2VyLXJlY3RhbmdsZS1ib3JkZXItcmFkaXVzOlxuICogdXNlci1zZW1pLXJvdW5kLWJvcmRlci1yYWRpdXM6XG4gKiB1c2VyLXJvdW5kLWJvcmRlci1yYWRpdXM6XG4gKiB1c2VyLXRpbnktaGVpZ2h0OlxuICogdXNlci10aW55LXdpZHRoOlxuICogdXNlci10aW55LWluaXRpYWxzLXRleHQtZm9udC1zaXplOlxuICogdXNlci10aW55LWluaXRpYWxzLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLXRpbnktbmFtZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHVzZXItdGlueS1uYW1lLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLXRpbnktdGl0bGUtdGV4dC1mb250LXNpemU6XG4gKiB1c2VyLXRpbnktdGl0bGUtdGV4dC1saW5lLWhlaWdodDpcbiAqIHVzZXItc21hbGwtaGVpZ2h0OlxuICogdXNlci1zbWFsbC13aWR0aDpcbiAqIHVzZXItc21hbGwtaW5pdGlhbHMtdGV4dC1mb250LXNpemU6XG4gKiB1c2VyLXNtYWxsLWluaXRpYWxzLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLXNtYWxsLW5hbWUtdGV4dC1mb250LXNpemU6XG4gKiB1c2VyLXNtYWxsLW5hbWUtdGV4dC1saW5lLWhlaWdodDpcbiAqIHVzZXItc21hbGwtdGl0bGUtdGV4dC1mb250LXNpemU6XG4gKiB1c2VyLXNtYWxsLXRpdGxlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLW1lZGl1bS1oZWlnaHQ6XG4gKiB1c2VyLW1lZGl1bS13aWR0aDpcbiAqIHVzZXItbWVkaXVtLWluaXRpYWxzLXRleHQtZm9udC1zaXplOlxuICogdXNlci1tZWRpdW0taW5pdGlhbHMtdGV4dC1saW5lLWhlaWdodDpcbiAqIHVzZXItbWVkaXVtLW5hbWUtdGV4dC1mb250LXNpemU6XG4gKiB1c2VyLW1lZGl1bS1uYW1lLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLW1lZGl1bS10aXRsZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHVzZXItbWVkaXVtLXRpdGxlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLWxhcmdlLWhlaWdodDpcbiAqIHVzZXItbGFyZ2Utd2lkdGg6XG4gKiB1c2VyLWxhcmdlLWluaXRpYWxzLXRleHQtZm9udC1zaXplOlxuICogdXNlci1sYXJnZS1pbml0aWFscy10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdXNlci1sYXJnZS1uYW1lLXRleHQtZm9udC1zaXplOlxuICogdXNlci1sYXJnZS1uYW1lLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB1c2VyLWxhcmdlLXRpdGxlLXRleHQtZm9udC1zaXplOlxuICogdXNlci1sYXJnZS10aXRsZS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdXNlci1naWFudC1oZWlnaHQ6XG4gKiB1c2VyLWdpYW50LXdpZHRoOlxuICogdXNlci1naWFudC1pbml0aWFscy10ZXh0LWZvbnQtc2l6ZTpcbiAqIHVzZXItZ2lhbnQtaW5pdGlhbHMtdGV4dC1saW5lLWhlaWdodDpcbiAqIHVzZXItZ2lhbnQtbmFtZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHVzZXItZ2lhbnQtbmFtZS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdXNlci1naWFudC10aXRsZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHVzZXItZ2lhbnQtdGl0bGUtdGV4dC1saW5lLWhlaWdodDpcbiAqL1xubGV0IE5iVXNlckNvbXBvbmVudCA9IGNsYXNzIE5iVXNlckNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZG9tU2FuaXRpemVyKSB7XG4gICAgICAgIHRoaXMuZG9tU2FuaXRpemVyID0gZG9tU2FuaXRpemVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lmaWVzIGEgbmFtZSB0byBiZSBzaG93biBvbiB0aGUgcmlnaHQgb2YgYSB1c2VyIHBpY3R1cmVcbiAgICAgICAgICogQHR5cGUgc3RyaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnQW5vbnltb3VzJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpemUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICogUG9zc2libGUgdmFsdWVzOiBgdGlueWAsIGBzbWFsbGAsIGBtZWRpdW1gIChkZWZhdWx0KSwgYGxhcmdlYCwgJ2dpYW50Jy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hhcGUgb2YgdGhlIHBpY3R1cmUgYm94LlxuICAgICAgICAgKiBQb3NzaWJsZSB2YWx1ZXM6IGByZWN0YW5nbGVgLCBgc2VtaS1yb3VuZGAsIGByb3VuZGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYXBlID0gJ3JvdW5kJztcbiAgICAgICAgdGhpcy5fc2hvd05hbWUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zaG93VGl0bGUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zaG93SW5pdGlhbHMgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBYnNvbHV0ZSBwYXRoIHRvIGEgdXNlciBwaWN0dXJlIG9yIGJhc2U2NCBpbWFnZS5cbiAgICAgKiBVc2VyIG5hbWUgaW5pdGlhbHMgd2lsbCBiZSBzaG93biBpZiBubyBwaWN0dXJlIHNwZWNpZmllZCAoSkQgZm9yIEpvaG4gRG9lKS5cbiAgICAgKiBAdHlwZSBzdHJpbmdcbiAgICAgKi9cbiAgICBzZXQgcGljdHVyZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmltYWdlQmFja2dyb3VuZFN0eWxlID0gdmFsdWUgPyB0aGlzLmRvbVNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0U3R5bGUoYHVybCgke3ZhbHVlfSlgKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyBhIHVzZXIgbmFtZSBvciBub3RcbiAgICAgKi9cbiAgICBnZXQgc2hvd05hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93TmFtZTtcbiAgICB9XG4gICAgc2V0IHNob3dOYW1lKHZhbCkge1xuICAgICAgICB0aGlzLl9zaG93TmFtZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHNob3cgYSB1c2VyIHRpdGxlIG9yIG5vdFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBnZXQgc2hvd1RpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvd1RpdGxlO1xuICAgIH1cbiAgICBzZXQgc2hvd1RpdGxlKHZhbCkge1xuICAgICAgICB0aGlzLl9zaG93VGl0bGUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzaG93IGEgdXNlciBpbml0aWFscyAoaWYgbm8gcGljdHVyZSBzcGVjaWZpZWQpIG9yIG5vdFxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBnZXQgc2hvd0luaXRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2hvd0luaXRpYWxzO1xuICAgIH1cbiAgICBzZXQgc2hvd0luaXRpYWxzKHZhbCkge1xuICAgICAgICB0aGlzLl9zaG93SW5pdGlhbHMgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzaG93IG9ubHkgYSBwaWN0dXJlIG9yIGFsc28gc2hvdyB0aGUgbmFtZSBhbmQgdGl0bGVcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICovXG4gICAgZ2V0IG9ubHlQaWN0dXJlKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc2hvd05hbWUgJiYgIXRoaXMuc2hvd1RpdGxlO1xuICAgIH1cbiAgICBzZXQgb25seVBpY3R1cmUodmFsKSB7XG4gICAgICAgIHRoaXMuc2hvd05hbWUgPSB0aGlzLnNob3dUaXRsZSA9ICFjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsKTtcbiAgICB9XG4gICAgZ2V0IHRpbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICd0aW55JztcbiAgICB9XG4gICAgZ2V0IHNtYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnc21hbGwnO1xuICAgIH1cbiAgICBnZXQgbWVkaXVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbWVkaXVtJztcbiAgICB9XG4gICAgZ2V0IGxhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbGFyZ2UnO1xuICAgIH1cbiAgICBnZXQgZ2lhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdnaWFudCc7XG4gICAgfVxuICAgIGdldCByZWN0YW5nbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXBlID09PSAncmVjdGFuZ2xlJztcbiAgICB9XG4gICAgZ2V0IHNlbWlSb3VuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUgPT09ICdzZW1pLXJvdW5kJztcbiAgICB9XG4gICAgZ2V0IHJvdW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFwZSA9PT0gJ3JvdW5kJztcbiAgICB9XG4gICAgZ2V0SW5pdGlhbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5uYW1lLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICByZXR1cm4gbmFtZXMubWFwKG4gPT4gbi5jaGFyQXQoMCkpLnNwbGljZSgwLCAyKS5qb2luKCcnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ3MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ3KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJVc2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDcyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlVzZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDcyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIE5iVXNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicGljdHVyZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NyhcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVXNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNzIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NyhcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVXNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ3MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ3KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJVc2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaGFwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ3MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ3KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iVXNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd05hbWVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDcyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJVc2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93VGl0bGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDcyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJVc2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93SW5pdGlhbHNcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDcyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJVc2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbmx5UGljdHVyZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0NyhcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVXNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFkZ2VUZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDcyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlVzZXJDb21wb25lbnQucHJvdG90eXBlLCBcImJhZGdlU3RhdHVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDcyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlVzZXJDb21wb25lbnQucHJvdG90eXBlLCBcImJhZGdlUG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNzIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLXRpbnknKSxcbiAgICBfX21ldGFkYXRhJDQ3KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJVc2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aW55XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3MihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtc21hbGwnKSxcbiAgICBfX21ldGFkYXRhJDQ3KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJVc2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzbWFsbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLW1lZGl1bScpLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlVzZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1lZGl1bVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLWxhcmdlJyksXG4gICAgX19tZXRhZGF0YSQ0NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVXNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibGFyZ2VcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDcyKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1naWFudCcpLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlVzZXJDb21wb25lbnQucHJvdG90eXBlLCBcImdpYW50XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3MihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNoYXBlLXJlY3RhbmdsZScpLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlVzZXJDb21wb25lbnQucHJvdG90eXBlLCBcInJlY3RhbmdsZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaGFwZS1zZW1pLXJvdW5kJyksXG4gICAgX19tZXRhZGF0YSQ0NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVXNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VtaVJvdW5kXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3MihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNoYXBlLXJvdW5kJyksXG4gICAgX19tZXRhZGF0YSQ0NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVXNlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicm91bmRcIiwgbnVsbCk7XG5OYlVzZXJDb21wb25lbnQgPSBfX2RlY29yYXRlJDcyKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLXVzZXInLFxuICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJ1c2VyLWNvbnRhaW5lclxcXCI+XFxuICA8ZGl2ICpuZ0lmPVxcXCJpbWFnZUJhY2tncm91bmRTdHlsZVxcXCIgY2xhc3M9XFxcInVzZXItcGljdHVyZSBpbWFnZVxcXCIgW3N0eWxlLmJhY2tncm91bmQtaW1hZ2VdPVxcXCJpbWFnZUJhY2tncm91bmRTdHlsZVxcXCI+XFxuICAgIDxuYi1iYWRnZSAqbmdJZj1cXFwiYmFkZ2VUZXh0XFxcIiBbdGV4dF09XFxcImJhZGdlVGV4dFxcXCIgW3N0YXR1c109XFxcImJhZGdlU3RhdHVzXFxcIiBbcG9zaXRpb25dPVxcXCJiYWRnZVBvc2l0aW9uXFxcIj48L25iLWJhZGdlPlxcbiAgPC9kaXY+XFxuICA8ZGl2ICpuZ0lmPVxcXCIhaW1hZ2VCYWNrZ3JvdW5kU3R5bGVcXFwiIGNsYXNzPVxcXCJ1c2VyLXBpY3R1cmUgaW5pdGlhbHNcXFwiIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cXFwiY29sb3JcXFwiPlxcbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVxcXCJzaG93SW5pdGlhbHNcXFwiPlxcbiAgICAgIHt7IGdldEluaXRpYWxzKCkgfX1cXG4gICAgPC9uZy1jb250YWluZXI+XFxuICAgIDxuYi1iYWRnZSAqbmdJZj1cXFwiYmFkZ2VUZXh0XFxcIiBbdGV4dF09XFxcImJhZGdlVGV4dFxcXCIgW3N0YXR1c109XFxcImJhZGdlU3RhdHVzXFxcIiBbcG9zaXRpb25dPVxcXCJiYWRnZVBvc2l0aW9uXFxcIj48L25iLWJhZGdlPlxcbiAgPC9kaXY+XFxuXFxuICA8ZGl2IGNsYXNzPVxcXCJpbmZvLWNvbnRhaW5lclxcXCI+XFxuICAgIDxkaXYgKm5nSWY9XFxcInNob3dOYW1lICYmIG5hbWVcXFwiIGNsYXNzPVxcXCJ1c2VyLW5hbWVcXFwiPnt7IG5hbWUgfX08L2Rpdj5cXG4gICAgPGRpdiAqbmdJZj1cXFwic2hvd1RpdGxlICYmIHRpdGxlXFxcIiBjbGFzcz1cXFwidXNlci10aXRsZVxcXCI+e3sgdGl0bGUgfX08L2Rpdj5cXG4gIDwvZGl2PlxcbjwvZGl2PlxcblwiLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6ZmxleH06aG9zdCAudXNlci1jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcn06aG9zdCAudXNlci1waWN0dXJle3Bvc2l0aW9uOnJlbGF0aXZlO2ZsZXgtc2hyaW5rOjB9Omhvc3QgLnVzZXItcGljdHVyZS5pbWFnZXtiYWNrZ3JvdW5kLXNpemU6Y292ZXI7YmFja2dyb3VuZC1yZXBlYXQ6bm8tcmVwZWF0fTpob3N0IC51c2VyLXBpY3R1cmUuaW5pdGlhbHN7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyfVtkaXI9cnRsXSA6aG9zdCAudXNlci1uYW1lLFtkaXI9cnRsXSA6aG9zdCAudXNlci10aXRsZXt0ZXh0LWFsaWduOnJpZ2h0fVtkaXI9bHRyXSA6aG9zdCAuaW5mby1jb250YWluZXJ7bWFyZ2luLWxlZnQ6LjVyZW19W2Rpcj1ydGxdIDpob3N0IC5pbmZvLWNvbnRhaW5lcnttYXJnaW4tcmlnaHQ6LjVyZW19XFxuXCJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQ0NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEb21TYW5pdGl6ZXJdKVxuXSwgTmJVc2VyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkNzEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuY29uc3QgTkJfVVNFUl9DT01QT05FTlRTID0gW1xuICAgIE5iVXNlckNvbXBvbmVudCxcbl07XG5sZXQgTmJVc2VyTW9kdWxlID0gY2xhc3MgTmJVc2VyTW9kdWxlIHtcbn07XG5OYlVzZXJNb2R1bGUgPSBfX2RlY29yYXRlJDcxKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgTmJCYWRnZU1vZHVsZSxcbiAgICAgICAgXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAuLi5OQl9VU0VSX0NPTVBPTkVOVFMsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIC4uLk5CX1VTRVJfQ09NUE9ORU5UUyxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJVc2VyTW9kdWxlKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkNzQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNDggPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogQWN0aW9uIGl0ZW0sIGRpc3BsYXkgYSBsaW5rIHdpdGggYW4gaWNvbiwgb3IgYW55IG90aGVyIGNvbnRlbnQgcHJvdmlkZWQgaW5zdGVhZC5cbiAqL1xubGV0IE5iQWN0aW9uQ29tcG9uZW50ID0gY2xhc3MgTmJBY3Rpb25Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEFjdGlvbiBpdGVtLCBkaXNwbGF5IGEgbGluayB3aXRoIGFuIGljb24sIG9yIGFueSBvdGhlciBjb250ZW50IHByb3ZpZGVkIGluc3RlYWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbCB0aXRsZSBmb3IgbW91c2VvdmVyXG4gICAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aXRsZSA9ICcnO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWaXN1YWxseSBkaXNhYmxlcyB0aGUgaXRlbVxuICAgICAqIEB0eXBlIGJvb2xlYW5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ3NChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ4KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJBY3Rpb25Db21wb25lbnQucHJvdG90eXBlLCBcImxpbmtcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNzQoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0OChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJocmVmXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDc0KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDgoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkFjdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNzQoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQWN0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDc0KFtcbiAgICBJbnB1dCgpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEkNDgoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJBY3Rpb25Db21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3NChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ4KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJBY3Rpb25Db21wb25lbnQucHJvdG90eXBlLCBcImJhZGdlVGV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ3NChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ4KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJBY3Rpb25Db21wb25lbnQucHJvdG90eXBlLCBcImJhZGdlU3RhdHVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDc0KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDgoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkFjdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFkZ2VQb3NpdGlvblwiLCB2b2lkIDApO1xuTmJBY3Rpb25Db21wb25lbnQgPSBfX2RlY29yYXRlJDc0KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWFjdGlvbicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImljb247IGVsc2UgcHJvamVjdGVkQ29udGVudFwiPlxuICAgICAgPGEgY2xhc3M9XCJpY29uLWNvbnRhaW5lclwiXG4gICAgICAgICBbcm91dGVyTGlua109XCJsaW5rXCJcbiAgICAgICAgIFt0aXRsZV09XCJ0aXRsZVwiXG4gICAgICAgICAqbmdJZj1cImxpbmtcIj5cbiAgICAgICAgPG5iLWljb24gW2NvbmZpZ109XCJpY29uXCI+PC9uYi1pY29uPlxuICAgICAgPC9hPlxuICAgICAgPGEgY2xhc3M9XCJpY29uLWNvbnRhaW5lclwiXG4gICAgICAgICBbaHJlZl09XCJocmVmXCJcbiAgICAgICAgIFt0aXRsZV09XCJ0aXRsZVwiXG4gICAgICAgICAqbmdJZj1cImhyZWYgJiYgIWxpbmtcIj5cbiAgICAgICAgPG5iLWljb24gW2NvbmZpZ109XCJpY29uXCI+PC9uYi1pY29uPlxuICAgICAgPC9hPlxuICAgICAgPGEgY2xhc3M9XCJpY29uLWNvbnRhaW5lclwiXG4gICAgICAgICBocmVmPVwiI1wiXG4gICAgICAgICBbdGl0bGVdPVwidGl0bGVcIlxuICAgICAgICAgKm5nSWY9XCIhaHJlZiAmJiAhbGlua1wiXG4gICAgICAgICAoY2xpY2spPVwiJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIj5cbiAgICAgICAgPG5iLWljb24gW2NvbmZpZ109XCJpY29uXCI+PC9uYi1pY29uPlxuICAgICAgPC9hPlxuICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgPG5nLXRlbXBsYXRlICNwcm9qZWN0ZWRDb250ZW50PlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvbmctdGVtcGxhdGU+XG5cbiAgICA8bmItYmFkZ2UgKm5nSWY9XCJiYWRnZVRleHRcIlxuICAgICAgICAgICAgICBbdGV4dF09XCJiYWRnZVRleHRcIlxuICAgICAgICAgICAgICBbc3RhdHVzXT1cImJhZGdlU3RhdHVzXCJcbiAgICAgICAgICAgICAgW3Bvc2l0aW9uXT1cImJhZGdlUG9zaXRpb25cIj5cbiAgICA8L25iLWJhZGdlPlxuICBgLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtwb3NpdGlvbjpyZWxhdGl2ZX06aG9zdCguZGlzYWJsZWQpe2N1cnNvcjpub3QtYWxsb3dlZH06aG9zdCguZGlzYWJsZWQpIGEsOmhvc3QoLmRpc2FibGVkKSBuYi1pY29ue2N1cnNvcjpub3QtYWxsb3dlZH06aG9zdC1jb250ZXh0KG5iLWFjdGlvbnMuZnVsbC13aWR0aCl7anVzdGlmeS1jb250ZW50OmNlbnRlcjt3aWR0aDoxMDAlfWEuaWNvbi1jb250YWluZXI6aG92ZXIsYS5pY29uLWNvbnRhaW5lcjpmb2N1c3t0ZXh0LWRlY29yYXRpb246bm9uZX1uYi1pY29uOmhvdmVye2N1cnNvcjpwb2ludGVyfVxcblwiXVxuICAgIH0pXG5dLCBOYkFjdGlvbkNvbXBvbmVudCk7XG4vKipcbiAqIFNob3dzIGEgaG9yaXpvbnRhbCBsaXN0IG9mIGFjdGlvbnMsIGF2YWlsYWJsZSBpbiBtdWx0aXBsZSBzaXplcy5cbiAqIEFsaWducyBpdGVtcyB2ZXJ0aWNhbGx5LlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGFjdGlvbi9hY3Rpb24tc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIEJhc2ljIGFjdGlvbnMgc2V0dXA6XG4gKiBgYGBodG1sXG4gKiA8bmItYWN0aW9ucyBzaXplPVwic21hbGxcIj5cbiAqICAgPG5iLWFjdGlvbiBpY29uPVwibmItc2VhcmNoXCI+PC9uYi1hY3Rpb24+XG4gKiAgIDxuYi1hY3Rpb24gaWNvbj1cIm5iLXBvd2VyLWNpcmNsZWRcIj48L25iLWFjdGlvbj5cbiAqICAgPG5iLWFjdGlvbiBpY29uPVwibmItcGVyc29uXCI+PC9uYi1hY3Rpb24+XG4gKiA8L25iLWFjdGlvbnM+XG4gKiBgYGBcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iQWN0aW9uc01vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJBY3Rpb25zTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBNdWx0aXBsZSBzaXplcyBleGFtcGxlOlxuICogQHN0YWNrZWQtZXhhbXBsZShNdWx0aXBsZSBTaXplcywgYWN0aW9uL2FjdGlvbi1zaXplcy5jb21wb25lbnQpXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBzcGVjaWZ5IGEgYGJhZGdlYCB2YWx1ZTpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEFjdGlvbiBCYWRnZSwgYWN0aW9uL2FjdGlvbi1iYWRnZS5jb21wb25lbnQpXG4gKlxuICogYW5kIHdlIGNhbiBzZXQgaXQgdG8gZnVsbCBhIHdpZHRoIG9mIGEgcGFyZW50IGNvbXBvbmVudFxuICogQHN0YWNrZWQtZXhhbXBsZShGdWxsIFdpZHRoLCBhY3Rpb24vYWN0aW9uLXdpZHRoLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogYWN0aW9ucy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYWN0aW9ucy1kaXZpZGVyLWNvbG9yOlxuICogYWN0aW9ucy1kaXZpZGVyLXN0eWxlOlxuICogYWN0aW9ucy1kaXZpZGVyLXdpZHRoOlxuICogYWN0aW9ucy1pY29uLWNvbG9yOlxuICogYWN0aW9ucy10ZXh0LWNvbG9yOlxuICogYWN0aW9ucy10ZXh0LWZvbnQtZmFtaWx5OlxuICogYWN0aW9ucy10ZXh0LWZvbnQtd2VpZ2h0OlxuICogYWN0aW9ucy10ZXh0LWxpbmUtaGVpZ2h0OlxuICogYWN0aW9ucy1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogYWN0aW9ucy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYWN0aW9ucy10aW55LWhlaWdodDpcbiAqIGFjdGlvbnMtdGlueS1pY29uLWhlaWdodDpcbiAqIGFjdGlvbnMtdGlueS1wYWRkaW5nOlxuICogYWN0aW9ucy10aW55LXRleHQtZm9udC1zaXplOlxuICogYWN0aW9ucy1zbWFsbC1oZWlnaHQ6XG4gKiBhY3Rpb25zLXNtYWxsLWljb24taGVpZ2h0OlxuICogYWN0aW9ucy1zbWFsbC1wYWRkaW5nOlxuICogYWN0aW9ucy1zbWFsbC10ZXh0LWZvbnQtc2l6ZTpcbiAqIGFjdGlvbnMtbWVkaXVtLWhlaWdodDpcbiAqIGFjdGlvbnMtbWVkaXVtLWljb24taGVpZ2h0OlxuICogYWN0aW9ucy1tZWRpdW0tcGFkZGluZzpcbiAqIGFjdGlvbnMtbWVkaXVtLXRleHQtZm9udC1zaXplOlxuICogYWN0aW9ucy1sYXJnZS1oZWlnaHQ6XG4gKiBhY3Rpb25zLWxhcmdlLWljb24taGVpZ2h0OlxuICogYWN0aW9ucy1sYXJnZS1wYWRkaW5nOlxuICogYWN0aW9ucy1sYXJnZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIGFjdGlvbnMtZ2lhbnQtaGVpZ2h0OlxuICogYWN0aW9ucy1naWFudC1pY29uLWhlaWdodDpcbiAqIGFjdGlvbnMtZ2lhbnQtcGFkZGluZzpcbiAqIGFjdGlvbnMtZ2lhbnQtdGV4dC1mb250LXNpemU6XG4gKi9cbmxldCBOYkFjdGlvbnNDb21wb25lbnQgPSBjbGFzcyBOYkFjdGlvbnNDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFNob3dzIGEgaG9yaXpvbnRhbCBsaXN0IG9mIGFjdGlvbnMsIGF2YWlsYWJsZSBpbiBtdWx0aXBsZSBzaXplcy5cbiAgICAgKiBBbGlnbnMgaXRlbXMgdmVydGljYWxseS5cbiAgICAgKlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGFjdGlvbi9hY3Rpb24tc2hvd2Nhc2UuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogQmFzaWMgYWN0aW9ucyBzZXR1cDpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5iLWFjdGlvbnMgc2l6ZT1cInNtYWxsXCI+XG4gICAgICogICA8bmItYWN0aW9uIGljb249XCJuYi1zZWFyY2hcIj48L25iLWFjdGlvbj5cbiAgICAgKiAgIDxuYi1hY3Rpb24gaWNvbj1cIm5iLXBvd2VyLWNpcmNsZWRcIj48L25iLWFjdGlvbj5cbiAgICAgKiAgIDxuYi1hY3Rpb24gaWNvbj1cIm5iLXBlcnNvblwiPjwvbmItYWN0aW9uPlxuICAgICAqIDwvbmItYWN0aW9ucz5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyMgSW5zdGFsbGF0aW9uXG4gICAgICpcbiAgICAgKiBJbXBvcnQgYE5iQWN0aW9uc01vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAgICAgKiBgYGB0c1xuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBpbXBvcnRzOiBbXG4gICAgICogICAgIC8vIC4uLlxuICAgICAqICAgICBOYkFjdGlvbnNNb2R1bGUsXG4gICAgICogICBdLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gICAgICogYGBgXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBNdWx0aXBsZSBzaXplcyBleGFtcGxlOlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoTXVsdGlwbGUgU2l6ZXMsIGFjdGlvbi9hY3Rpb24tc2l6ZXMuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBzcGVjaWZ5IGEgYGJhZGdlYCB2YWx1ZTpcbiAgICAgKlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoQWN0aW9uIEJhZGdlLCBhY3Rpb24vYWN0aW9uLWJhZGdlLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIGFuZCB3ZSBjYW4gc2V0IGl0IHRvIGZ1bGwgYSB3aWR0aCBvZiBhIHBhcmVudCBjb21wb25lbnRcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKEZ1bGwgV2lkdGgsIGFjdGlvbi9hY3Rpb24td2lkdGguY29tcG9uZW50KVxuICAgICAqXG4gICAgICogQHN0eWxlc1xuICAgICAqXG4gICAgICogYWN0aW9ucy1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGFjdGlvbnMtZGl2aWRlci1jb2xvcjpcbiAgICAgKiBhY3Rpb25zLWRpdmlkZXItc3R5bGU6XG4gICAgICogYWN0aW9ucy1kaXZpZGVyLXdpZHRoOlxuICAgICAqIGFjdGlvbnMtaWNvbi1jb2xvcjpcbiAgICAgKiBhY3Rpb25zLXRleHQtY29sb3I6XG4gICAgICogYWN0aW9ucy10ZXh0LWZvbnQtZmFtaWx5OlxuICAgICAqIGFjdGlvbnMtdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBhY3Rpb25zLXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogYWN0aW9ucy1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICAgICAqIGFjdGlvbnMtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAgICAgKiBhY3Rpb25zLXRpbnktaGVpZ2h0OlxuICAgICAqIGFjdGlvbnMtdGlueS1pY29uLWhlaWdodDpcbiAgICAgKiBhY3Rpb25zLXRpbnktcGFkZGluZzpcbiAgICAgKiBhY3Rpb25zLXRpbnktdGV4dC1mb250LXNpemU6XG4gICAgICogYWN0aW9ucy1zbWFsbC1oZWlnaHQ6XG4gICAgICogYWN0aW9ucy1zbWFsbC1pY29uLWhlaWdodDpcbiAgICAgKiBhY3Rpb25zLXNtYWxsLXBhZGRpbmc6XG4gICAgICogYWN0aW9ucy1zbWFsbC10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBhY3Rpb25zLW1lZGl1bS1oZWlnaHQ6XG4gICAgICogYWN0aW9ucy1tZWRpdW0taWNvbi1oZWlnaHQ6XG4gICAgICogYWN0aW9ucy1tZWRpdW0tcGFkZGluZzpcbiAgICAgKiBhY3Rpb25zLW1lZGl1bS10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBhY3Rpb25zLWxhcmdlLWhlaWdodDpcbiAgICAgKiBhY3Rpb25zLWxhcmdlLWljb24taGVpZ2h0OlxuICAgICAqIGFjdGlvbnMtbGFyZ2UtcGFkZGluZzpcbiAgICAgKiBhY3Rpb25zLWxhcmdlLXRleHQtZm9udC1zaXplOlxuICAgICAqIGFjdGlvbnMtZ2lhbnQtaGVpZ2h0OlxuICAgICAqIGFjdGlvbnMtZ2lhbnQtaWNvbi1oZWlnaHQ6XG4gICAgICogYWN0aW9ucy1naWFudC1wYWRkaW5nOlxuICAgICAqIGFjdGlvbnMtZ2lhbnQtdGV4dC1mb250LXNpemU6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSAnc21hbGwnO1xuICAgICAgICB0aGlzLl9mdWxsV2lkdGggPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2l6ZSBvZiB0aGUgY29tcG9uZW50OiAndGlueScsICdzbWFsbCcgKGRlZmF1bHQpLCAnbWVkaXVtJywgJ2xhcmdlJywgJ2dpYW50J1xuICAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZTtcbiAgICB9XG4gICAgc2V0IHNpemUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wb25lbnQgd2lsbCBmaWxsIGZ1bGwgd2lkdGggb2YgdGhlIGNvbnRhaW5lclxuICAgICAqL1xuICAgIGdldCBmdWxsV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mdWxsV2lkdGg7XG4gICAgfVxuICAgIHNldCBmdWxsV2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZnVsbFdpZHRoID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IHRpbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICd0aW55JztcbiAgICB9XG4gICAgZ2V0IHNtYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnc21hbGwnO1xuICAgIH1cbiAgICBnZXQgbWVkaXVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbWVkaXVtJztcbiAgICB9XG4gICAgZ2V0IGxhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbGFyZ2UnO1xuICAgIH1cbiAgICBnZXQgZ2lhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdnaWFudCc7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkNzQoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ0OChcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YSQ0OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgTmJBY3Rpb25zQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaXplXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3NChbXG4gICAgSW5wdXQoKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3MuZnVsbC13aWR0aCcpLFxuICAgIF9fbWV0YWRhdGEkNDgoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJBY3Rpb25zQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmdWxsV2lkdGhcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDc0KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS10aW55JyksXG4gICAgX19tZXRhZGF0YSQ0OChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWN0aW9uc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidGlueVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzQoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLXNtYWxsJyksXG4gICAgX19tZXRhZGF0YSQ0OChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNDgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWN0aW9uc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic21hbGxcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDc0KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1tZWRpdW0nKSxcbiAgICBfX21ldGFkYXRhJDQ4KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBY3Rpb25zQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtZWRpdW1cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDc0KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1sYXJnZScpLFxuICAgIF9fbWV0YWRhdGEkNDgoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDQ4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkFjdGlvbnNDb21wb25lbnQucHJvdG90eXBlLCBcImxhcmdlXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3NChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtZ2lhbnQnKSxcbiAgICBfX21ldGFkYXRhJDQ4KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ0OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBY3Rpb25zQ29tcG9uZW50LnByb3RvdHlwZSwgXCJnaWFudFwiLCBudWxsKTtcbk5iQWN0aW9uc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUkNzQoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItYWN0aW9ucycsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItYWN0aW9uXCI+PC9uZy1jb250ZW50PlxuICBgLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXJ9XFxuXCJdXG4gICAgfSlcbl0sIE5iQWN0aW9uc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDczID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmNvbnN0IE5CX0FDVElPTlNfQ09NUE9ORU5UUyA9IFtcbiAgICBOYkFjdGlvbkNvbXBvbmVudCxcbiAgICBOYkFjdGlvbnNDb21wb25lbnQsXG5dO1xubGV0IE5iQWN0aW9uc01vZHVsZSA9IGNsYXNzIE5iQWN0aW9uc01vZHVsZSB7XG59O1xuTmJBY3Rpb25zTW9kdWxlID0gX19kZWNvcmF0ZSQ3MyhbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBOYlNoYXJlZE1vZHVsZSxcbiAgICAgICAgICAgIE5iQmFkZ2VNb2R1bGUsXG4gICAgICAgICAgICBOYkljb25Nb2R1bGUsXG4gICAgICAgIF0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgLi4uTkJfQUNUSU9OU19DT01QT05FTlRTLFxuICAgICAgICBdLFxuICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICAuLi5OQl9BQ1RJT05TX0NPTVBPTkVOVFMsXG4gICAgICAgIF0sXG4gICAgfSlcbl0sIE5iQWN0aW9uc01vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDc3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbi8qKlxuICogU2VhcmNoIGNvbXBvbmVudCBzZXJ2aWNlLCBjb25uZWN0cyB5b3VyIGNvZGUgdG8gYSBwYWdlLWxldmVsIHNlYXJjaCBjb21wb25lbnQuXG4gKi9cbmxldCBOYlNlYXJjaFNlcnZpY2UgPSBjbGFzcyBOYlNlYXJjaFNlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIFNlYXJjaCBjb21wb25lbnQgc2VydmljZSwgY29ubmVjdHMgeW91ciBjb2RlIHRvIGEgcGFnZS1sZXZlbCBzZWFyY2ggY29tcG9uZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNlYXJjaFN1Ym1pdHRpbmdzJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuc2VhcmNoQWN0aXZhdGlvbnMkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5zZWFyY2hEZWFjdGl2YXRpb25zJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQkID0gbmV3IFN1YmplY3QoKTtcbiAgICB9XG4gICAgLyoqKlxuICAgICAqIEFjdGl2YXRlIChvcGVuKSBzZWFyY2ggY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICovXG4gICAgYWN0aXZhdGVTZWFyY2goc2VhcmNoVHlwZSwgdGFnKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoQWN0aXZhdGlvbnMkLm5leHQoeyBzZWFyY2hUeXBlLCB0YWcgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlYWN0aWJhdGUgKGNsb3NlKSBzZWFyY2ggY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gICAgICovXG4gICAgZGVhY3RpdmF0ZVNlYXJjaChzZWFyY2hUeXBlLCB0YWcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hEZWFjdGl2YXRpb25zJC5uZXh0KHsgc2VhcmNoVHlwZSwgdGFnIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHNlYXJjaCBzdWJtaXRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGVybVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWdcbiAgICAgKi9cbiAgICBzdWJtaXRTZWFyY2godGVybSwgdGFnKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoU3VibWl0dGluZ3MkLm5leHQoeyB0ZXJtLCB0YWcgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgc2VhcmNoIHN1Ym1pdCBieSBpbnB1dCBldmVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXJtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ1xuICAgICAqL1xuICAgIHNlYXJjaElucHV0KHRlcm0sIHRhZykge1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0JC5uZXh0KHsgdGVybSwgdGFnIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gJ2FjdGl2YXRlJyBldmVudFxuICAgICAqIEByZXR1cm5zIE9ic2VydmFibGU8e3NlYXJjaFR5cGU6IHN0cmluZzsgdGFnPzogc3RyaW5nfT5cbiAgICAgKi9cbiAgICBvblNlYXJjaEFjdGl2YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hBY3RpdmF0aW9ucyQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvICdkZWFjdGl2YXRlJyBldmVudFxuICAgICAqIEByZXR1cm5zIE9ic2VydmFibGU8e3NlYXJjaFR5cGU6IHN0cmluZzsgdGFnPzogc3RyaW5nfT5cbiAgICAgKi9cbiAgICBvblNlYXJjaERlYWN0aXZhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaERlYWN0aXZhdGlvbnMkLnBpcGUoc2hhcmUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byAnc3VibWl0JyBldmVudCAod2hlbiBzdWJtaXQgYnV0dG9uIGNsaWNrZWQpXG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZTx7dGVybTogc3RyaW5nOyB0YWc/OiBzdHJpbmd9PlxuICAgICAqL1xuICAgIG9uU2VhcmNoU3VibWl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hTdWJtaXR0aW5ncyQucGlwZShzaGFyZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIGlucHV0IGV2ZW50XG4gICAgICogQHJldHVybnMgT2JzZXJ2YWJsZTx7dGVybTogc3RyaW5nOyB0YWc/OiBzdHJpbmd9PlxuICAgICAqL1xuICAgIG9uU2VhcmNoSW5wdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXJjaElucHV0JC5waXBlKHNoYXJlKCkpO1xuICAgIH1cbn07XG5OYlNlYXJjaFNlcnZpY2UgPSBfX2RlY29yYXRlJDc3KFtcbiAgICBJbmplY3RhYmxlKClcbl0sIE5iU2VhcmNoU2VydmljZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDc2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDQ5ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTmJTZWFyY2hGaWVsZENvbXBvbmVudF8xO1xuLyoqXG4gKiBzZWFyY2gtZmllbGQtY29tcG9uZW50IGlzIHVzZWQgdW5kZXIgdGhlIGhvb2QgYnkgbmItc2VhcmNoIGNvbXBvbmVudFxuICogY2FuJ3QgYmUgdXNlZCBpdHNlbGZcbiAqL1xubGV0IE5iU2VhcmNoRmllbGRDb21wb25lbnQgPSBOYlNlYXJjaEZpZWxkQ29tcG9uZW50XzEgPSBjbGFzcyBOYlNlYXJjaEZpZWxkQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBzZWFyY2gtZmllbGQtY29tcG9uZW50IGlzIHVzZWQgdW5kZXIgdGhlIGhvb2QgYnkgbmItc2VhcmNoIGNvbXBvbmVudFxuICAgICAqIGNhbid0IGJlIHVzZWQgaXRzZWxmXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnNlYXJjaCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZ2V0IHNob3dDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdztcbiAgICB9XG4gICAgZ2V0IG1vZGFsWm9vbWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBOYlNlYXJjaEZpZWxkQ29tcG9uZW50XzEuVFlQRV9NT0RBTF9aT09NSU47XG4gICAgfVxuICAgIGdldCByb3RhdGVMYXlvdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IE5iU2VhcmNoRmllbGRDb21wb25lbnRfMS5UWVBFX1JPVEFURV9MQVlPVVQ7XG4gICAgfVxuICAgIGdldCBtb2RhbE1vdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IE5iU2VhcmNoRmllbGRDb21wb25lbnRfMS5UWVBFX01PREFMX01PVkU7XG4gICAgfVxuICAgIGdldCBjdXJ0YWluKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBOYlNlYXJjaEZpZWxkQ29tcG9uZW50XzEuVFlQRV9DVVJUQUlOO1xuICAgIH1cbiAgICBnZXQgY29sdW1uQ3VydGFpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gTmJTZWFyY2hGaWVsZENvbXBvbmVudF8xLlRZUEVfQ09MVU1OX0NVUlRBSU47XG4gICAgfVxuICAgIGdldCBtb2RhbERyb3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IE5iU2VhcmNoRmllbGRDb21wb25lbnRfMS5UWVBFX01PREFMX0RST1A7XG4gICAgfVxuICAgIGdldCBtb2RhbEhhbGYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IE5iU2VhcmNoRmllbGRDb21wb25lbnRfMS5UWVBFX01PREFMX0hBTEY7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKHsgc2hvdyB9KSB7XG4gICAgICAgIGNvbnN0IGJlY2FtZUhpZGRlbiA9ICFzaG93LmlzRmlyc3RDaGFuZ2UoKSAmJiBzaG93LmN1cnJlbnRWYWx1ZSA9PT0gZmFsc2U7XG4gICAgICAgIGlmIChiZWNhbWVIaWRkZW4gJiYgdGhpcy5pbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQudmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZvY3VzSW5wdXQoKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmZvY3VzSW5wdXQoKTtcbiAgICB9XG4gICAgZW1pdENsb3NlKCkge1xuICAgICAgICB0aGlzLmNsb3NlLmVtaXQoKTtcbiAgICB9XG4gICAgc3VibWl0U2VhcmNoKHRlcm0pIHtcbiAgICAgICAgaWYgKHRlcm0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoLmVtaXQodGVybSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdFNlYXJjaElucHV0KHRlcm0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5lbWl0KHRlcm0pO1xuICAgIH1cbiAgICBmb2N1c0lucHV0KCkge1xuICAgICAgICBpZiAodGhpcy5zaG93ICYmIHRoaXMuaW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RWxlbWVudC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuTmJTZWFyY2hGaWVsZENvbXBvbmVudC5UWVBFX01PREFMX1pPT01JTiA9ICdtb2RhbC16b29taW4nO1xuTmJTZWFyY2hGaWVsZENvbXBvbmVudC5UWVBFX1JPVEFURV9MQVlPVVQgPSAncm90YXRlLWxheW91dCc7XG5OYlNlYXJjaEZpZWxkQ29tcG9uZW50LlRZUEVfTU9EQUxfTU9WRSA9ICdtb2RhbC1tb3ZlJztcbk5iU2VhcmNoRmllbGRDb21wb25lbnQuVFlQRV9DVVJUQUlOID0gJ2N1cnRhaW4nO1xuTmJTZWFyY2hGaWVsZENvbXBvbmVudC5UWVBFX0NPTFVNTl9DVVJUQUlOID0gJ2NvbHVtbi1jdXJ0YWluJztcbk5iU2VhcmNoRmllbGRDb21wb25lbnQuVFlQRV9NT0RBTF9EUk9QID0gJ21vZGFsLWRyb3AnO1xuTmJTZWFyY2hGaWVsZENvbXBvbmVudC5UWVBFX01PREFMX0hBTEYgPSAnbW9kYWwtaGFsZic7XG5fX2RlY29yYXRlJDc2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlNlYXJjaEZpZWxkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDc2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlNlYXJjaEZpZWxkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ3NihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJTZWFyY2hGaWVsZENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGludFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ3NihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ5KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJTZWFyY2hGaWVsZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ3NihbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQ0OShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iU2VhcmNoRmllbGRDb21wb25lbnQucHJvdG90eXBlLCBcImNsb3NlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDc2KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ5KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJTZWFyY2hGaWVsZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VhcmNoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDc2KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ5KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJTZWFyY2hGaWVsZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VhcmNoSW5wdXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNzYoW1xuICAgIFZpZXdDaGlsZCgnc2VhcmNoSW5wdXQnLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YSQ0OShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBOYlNlYXJjaEZpZWxkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpbnB1dEVsZW1lbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNzYoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaG93JyksXG4gICAgX19tZXRhZGF0YSQ0OShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ0OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTZWFyY2hGaWVsZENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0NsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3NihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLm1vZGFsLXpvb21pbicpLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU2VhcmNoRmllbGRDb21wb25lbnQucHJvdG90eXBlLCBcIm1vZGFsWm9vbWluXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3NihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnJvdGF0ZS1sYXlvdXQnKSxcbiAgICBfX21ldGFkYXRhJDQ5KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDQ5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNlYXJjaEZpZWxkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3RhdGVMYXlvdXRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDc2KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubW9kYWwtbW92ZScpLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU2VhcmNoRmllbGRDb21wb25lbnQucHJvdG90eXBlLCBcIm1vZGFsTW92ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzYoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5jdXJ0YWluJyksXG4gICAgX19tZXRhZGF0YSQ0OShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ0OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTZWFyY2hGaWVsZENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VydGFpblwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzYoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5jb2x1bW4tY3VydGFpbicpLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU2VhcmNoRmllbGRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbHVtbkN1cnRhaW5cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDc2KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubW9kYWwtZHJvcCcpLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU2VhcmNoRmllbGRDb21wb25lbnQucHJvdG90eXBlLCBcIm1vZGFsRHJvcFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzYoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5tb2RhbC1oYWxmJyksXG4gICAgX19tZXRhZGF0YSQ0OShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ0OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTZWFyY2hGaWVsZENvbXBvbmVudC5wcm90b3R5cGUsIFwibW9kYWxIYWxmXCIsIG51bGwpO1xuTmJTZWFyY2hGaWVsZENvbXBvbmVudCA9IE5iU2VhcmNoRmllbGRDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUkNzYoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItc2VhcmNoLWZpZWxkJyxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cInNlYXJjaFwiIChrZXl1cC5lc2MpPVwiZW1pdENsb3NlKClcIj5cbiAgICAgIDxidXR0b24gKGNsaWNrKT1cImVtaXRDbG9zZSgpXCIgbmJCdXR0b24gZ2hvc3QgY2xhc3M9XCJjbG9zZS1idXR0b25cIj5cbiAgICAgICAgPG5iLWljb24gaWNvbj1cImNsb3NlLW91dGxpbmVcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCI+PC9uYi1pY29uPlxuICAgICAgPC9idXR0b24+XG4gICAgICA8ZGl2IGNsYXNzPVwiZm9ybS13cmFwcGVyXCI+XG4gICAgICAgIDxmb3JtIGNsYXNzPVwiZm9ybVwiIChrZXl1cC5lbnRlcik9XCJzdWJtaXRTZWFyY2goc2VhcmNoSW5wdXQudmFsdWUpXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tY29udGVudFwiPlxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwic2VhcmNoLWlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAjc2VhcmNoSW5wdXRcbiAgICAgICAgICAgICAgICAgICAoaW5wdXQpPVwiZW1pdFNlYXJjaElucHV0KHNlYXJjaElucHV0LnZhbHVlKVwiXG4gICAgICAgICAgICAgICAgICAgYXV0b2NvbXBsZXRlPVwib2ZmXCJcbiAgICAgICAgICAgICAgICAgICBbYXR0ci5wbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXG4gICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICAgICAgICAgICAgKGJsdXIpPVwiZm9jdXNJbnB1dCgpXCIvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaW5mb1wiPnt7IGhpbnQgfX08L3NwYW4+XG4gICAgICAgIDwvZm9ybT5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0IGJ1dHRvbnttYXJnaW46MDtwYWRkaW5nOjA7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyOm5vbmU7YmFja2dyb3VuZDpub25lfTpob3N0IGJ1dHRvbjpmb2N1c3tib3gtc2hhZG93Om5vbmU7b3V0bGluZTpub25lfTpob3N0IGlucHV0e2JvcmRlci10b3A6MDtib3JkZXItcmlnaHQ6MDtib3JkZXItbGVmdDowO2JhY2tncm91bmQ6dHJhbnNwYXJlbnQ7Ym9yZGVyLXJhZGl1czowO2xpbmUtaGVpZ2h0OjE7ZGlzcGxheTppbmxpbmUtYmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O3BhZGRpbmc6MC4wNXJlbSAwOy13ZWJraXQtYXBwZWFyYW5jZTpub25lfTpob3N0IGlucHV0OmZvY3Vze291dGxpbmU6bm9uZX06aG9zdCBpbnB1dDo6cGxhY2Vob2xkZXJ7b3BhY2l0eTowLjN9Omhvc3Qgc3Bhbntmb250LXNpemU6OTAlO2ZvbnQtd2VpZ2h0OmJvbGQ7ZGlzcGxheTpibG9jazt3aWR0aDo3NSU7bWFyZ2luOjAgYXV0bztwYWRkaW5nOjAuODVyZW0gMDt0ZXh0LWFsaWduOnJpZ2h0fTpob3N0Lm1vZGFsLXpvb21pbntkaXNwbGF5OmJsb2NrfTpob3N0Lm1vZGFsLXpvb21pbiAuc2VhcmNoe2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7dGV4dC1hbGlnbjpjZW50ZXI7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDoxMDUwO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDB2aDtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgMC41c306aG9zdC5tb2RhbC16b29taW4gLnNlYXJjaDo6YmVmb3JlLDpob3N0Lm1vZGFsLXpvb21pbiAuc2VhcmNoOjphZnRlcntjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOmNhbGMoMTAwJSArIDE1cHgpO2hlaWdodDpjYWxjKDEwMCUgKyAxNXB4KTtwb2ludGVyLWV2ZW50czpub25lfTpob3N0Lm1vZGFsLXpvb21pbiAuc2VhcmNoOjpiZWZvcmV7dG9wOjA7bGVmdDowO2JvcmRlci1yaWdodC13aWR0aDowO2JvcmRlci1ib3R0b20td2lkdGg6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoLTE1cHgsIC0xNXB4LCAwKX06aG9zdC5tb2RhbC16b29taW4gLnNlYXJjaDo6YWZ0ZXJ7cmlnaHQ6MDtib3R0b206MDtib3JkZXItdG9wLXdpZHRoOjA7Ym9yZGVyLWxlZnQtd2lkdGg6MDt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMTVweCwgMTVweCwgMCl9Omhvc3QubW9kYWwtem9vbWluIC5zZWFyY2ggYnV0dG9ue3Bvc2l0aW9uOmFic29sdXRlO3RvcDozcmVtO2ZvbnQtc2l6ZToyLjVyZW19W2Rpcj1sdHJdIDpob3N0Lm1vZGFsLXpvb21pbiAuc2VhcmNoIGJ1dHRvbntyaWdodDozcmVtfVtkaXI9cnRsXSA6aG9zdC5tb2RhbC16b29taW4gLnNlYXJjaCBidXR0b257bGVmdDozcmVtfTpob3N0Lm1vZGFsLXpvb21pbiAuc2VhcmNoIGlucHV0e2ZvbnQtc2l6ZToxMHZ3O3dpZHRoOjc1JX06aG9zdC5tb2RhbC16b29taW4gLnNlYXJjaCBidXR0b257b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZTNkKDAuOCwgMC44LCAxKTt0cmFuc2l0aW9uOm9wYWNpdHkgMC41cywgdHJhbnNmb3JtIDAuNXN9Omhvc3QubW9kYWwtem9vbWluIC5zZWFyY2ggZm9ybXtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM2QoMC44LCAwLjgsIDEpO3RyYW5zaXRpb246b3BhY2l0eSAwLjVzLCB0cmFuc2Zvcm0gMC41c306aG9zdC5tb2RhbC16b29taW4uc2hvdyAuc2VhcmNoe3BvaW50ZXItZXZlbnRzOmF1dG87b3BhY2l0eToxfTpob3N0Lm1vZGFsLXpvb21pbi5zaG93IC5zZWFyY2g6OmJlZm9yZSw6aG9zdC5tb2RhbC16b29taW4uc2hvdyAuc2VhcmNoOjphZnRlcnt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgMCwgMCk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC41c306aG9zdC5tb2RhbC16b29taW4uc2hvdyAuc2VhcmNoIGJ1dHRvbntvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM2QoMSwgMSwgMSl9Omhvc3QubW9kYWwtem9vbWluLnNob3cgLnNlYXJjaCBmb3Jte29wYWNpdHk6MTt0cmFuc2Zvcm06c2NhbGUzZCgxLCAxLCAxKX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0MHJlbSl7Omhvc3QubW9kYWwtem9vbWluIGZvcm17bWFyZ2luOjVyZW0gMCAxcmVtfTpob3N0Lm1vZGFsLXpvb21pbiBzcGFue3RleHQtYWxpZ246bGVmdH19XFxuXCIsIFwiOjpuZy1kZWVwIG5iLWxheW91dC5yb3RhdGUtbGF5b3V0e3Bvc2l0aW9uOmZpeGVkO292ZXJmbG93OmhpZGRlbjt3aWR0aDoxMDAlfTo6bmctZGVlcCBuYi1sYXlvdXQucm90YXRlLWxheW91dCAuc2Nyb2xsYWJsZS1jb250YWluZXJ7cG9zaXRpb246cmVsYXRpdmU7ei1pbmRleDoxMDAwMTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjVzIGN1YmljLWJlemllcigwLjIsIDEsIDAuMywgMSl9OjpuZy1kZWVwIG5iLWxheW91dC5yb3RhdGUtbGF5b3V0LndpdGgtc2VhcmNoIC5zY3JvbGxhYmxlLWNvbnRhaW5lcnt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjVzIGN1YmljLWJlemllcigwLjIsIDEsIDAuMywgMSk7dHJhbnNmb3JtLW9yaWdpbjo1MHZ3IDUwdmg7dHJhbnNmb3JtOnBlcnNwZWN0aXZlKDEwMDBweCkgdHJhbnNsYXRlM2QoMCwgNTB2aCwgMCkgcm90YXRlM2QoMSwgMCwgMCwgMzBkZWcpO3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3Qucm90YXRlLWxheW91dHtwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMHZ3O2hlaWdodDoxMDB2aDtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MDt0cmFuc2l0aW9uLXByb3BlcnR5Om9wYWNpdHk7dHJhbnNpdGlvbi1kZWxheTowLjRzfTpob3N0LnJvdGF0ZS1sYXlvdXQgLnNlYXJjaHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2p1c3RpZnktY29udGVudDpjZW50ZXI7YWxpZ24taXRlbXM6Y2VudGVyO3RleHQtYWxpZ246Y2VudGVyO3otaW5kZXg6MTA1MDtwb3NpdGlvbjpmaXhlZDt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6NTB2aDtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgMC41czt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4yLCAxLCAwLjMsIDEpfTpob3N0LnJvdGF0ZS1sYXlvdXQgLnNlYXJjaCBidXR0b257cG9zaXRpb246YWJzb2x1dGU7dG9wOjNyZW07Zm9udC1zaXplOjIuNXJlbTtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM2QoMC44LCAwLjgsIDEpO3RyYW5zaXRpb246b3BhY2l0eSAwLjVzLCB0cmFuc2Zvcm0gMC41czt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4yLCAxLCAwLjMsIDEpfVtkaXI9bHRyXSA6aG9zdC5yb3RhdGUtbGF5b3V0IC5zZWFyY2ggYnV0dG9ue3JpZ2h0OjNyZW19W2Rpcj1ydGxdIDpob3N0LnJvdGF0ZS1sYXlvdXQgLnNlYXJjaCBidXR0b257bGVmdDozcmVtfTpob3N0LnJvdGF0ZS1sYXlvdXQgLnNlYXJjaCBmb3Jte21hcmdpbjo1cmVtIDA7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZTNkKDAuNywgMC43LCAxKTt0cmFuc2l0aW9uOm9wYWNpdHkgMC41cywgdHJhbnNmb3JtIDAuNXM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuMiwgMSwgMC4zLCAxKX06aG9zdC5yb3RhdGUtbGF5b3V0IC5zZWFyY2ggaW5wdXR7Zm9udC1zaXplOjd2dzt3aWR0aDo3NSV9Omhvc3Qucm90YXRlLWxheW91dC5zaG93e29wYWNpdHk6MTt0cmFuc2l0aW9uLWRlbGF5OjBzfTpob3N0LnJvdGF0ZS1sYXlvdXQuc2hvdyAuc2VhcmNoe3BvaW50ZXItZXZlbnRzOmF1dG87b3BhY2l0eToxfTpob3N0LnJvdGF0ZS1sYXlvdXQuc2hvdyAuc2VhcmNoIGJ1dHRvbntvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM2QoMSwgMSwgMSl9Omhvc3Qucm90YXRlLWxheW91dC5zaG93IC5zZWFyY2ggZm9ybXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM2QoMSwgMSwgMSl9XFxuXCIsIFwiOjpuZy1kZWVwIG5iLWxheW91dC5tb2RhbC1tb3ZlIC5sYXlvdXR7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC41c306Om5nLWRlZXAgbmItbGF5b3V0Lm1vZGFsLW1vdmUud2l0aC1zZWFyY2ggLmxheW91dHt0cmFuc2Zvcm06c2NhbGUzZCgwLjgsIDAuOCwgMSk7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdC5tb2RhbC1tb3ZlIC5zZWFyY2h7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjt0ZXh0LWFsaWduOmNlbnRlcjtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjEwNTA7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMHZoO3BvaW50ZXItZXZlbnRzOm5vbmU7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAwLjVzfTpob3N0Lm1vZGFsLW1vdmUgLnNlYXJjaCBidXR0b257cG9zaXRpb246YWJzb2x1dGU7dG9wOjNyZW07Zm9udC1zaXplOjIuNXJlbTtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IDAuNXN9W2Rpcj1sdHJdIDpob3N0Lm1vZGFsLW1vdmUgLnNlYXJjaCBidXR0b257cmlnaHQ6M3JlbX1bZGlyPXJ0bF0gOmhvc3QubW9kYWwtbW92ZSAuc2VhcmNoIGJ1dHRvbntsZWZ0OjNyZW19Omhvc3QubW9kYWwtbW92ZSAuc2VhcmNoIGZvcm17bWFyZ2luOjVyZW0gMDtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM2QoMC44LCAwLjgsIDEpO3RyYW5zaXRpb246b3BhY2l0eSAwLjVzLCB0cmFuc2Zvcm0gMC41c306aG9zdC5tb2RhbC1tb3ZlIC5zZWFyY2ggaW5wdXR7Zm9udC1zaXplOjEwdnc7d2lkdGg6NzUlO3RyYW5zZm9ybTpzY2FsZTNkKDAsIDEsIDEpO3RyYW5zZm9ybS1vcmlnaW46MCA1MCU7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC4zc306aG9zdC5tb2RhbC1tb3ZlLnNob3cgLnNlYXJjaHtwb2ludGVyLWV2ZW50czphdXRvO29wYWNpdHk6MX06aG9zdC5tb2RhbC1tb3ZlLnNob3cgLnNlYXJjaCBidXR0b257b3BhY2l0eToxfTpob3N0Lm1vZGFsLW1vdmUuc2hvdyAuc2VhcmNoIGZvcm17b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpfTpob3N0Lm1vZGFsLW1vdmUuc2hvdyAuc2VhcmNoIGlucHV0e3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpO3RyYW5zaXRpb24tZHVyYXRpb246MC41c31AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0MHJlbSl7Omhvc3QubW9kYWwtbW92ZSBzcGFue3RleHQtYWxpZ246bGVmdH19XFxuXCIsIFwiOmhvc3QuY3VydGFpbiAuc2VhcmNoe3Bvc2l0aW9uOmZpeGVkO3otaW5kZXg6MTA1MDt0b3A6MDtsZWZ0OjEwMCU7b3ZlcmZsb3c6aGlkZGVuO2hlaWdodDoxMDB2aDt3aWR0aDoxMDAlO3BhZGRpbmc6M3JlbTtwb2ludGVyLWV2ZW50czpub25lO3RyYW5zaXRpb246dHJhbnNmb3JtIDAuM3M7dHJhbnNpdGlvbi1kZWxheTowLjRzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fTpob3N0LmN1cnRhaW4gLnNlYXJjaDo6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjNzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fTpob3N0LmN1cnRhaW4gLnNlYXJjaCBidXR0b257Zm9udC1zaXplOjIuNXJlbTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6M3JlbTt0cmFuc2l0aW9uOm9wYWNpdHkgMC4xczt0cmFuc2l0aW9uLWRlbGF5OjAuM3N9W2Rpcj1sdHJdIDpob3N0LmN1cnRhaW4gLnNlYXJjaCBidXR0b257cmlnaHQ6M3JlbX1bZGlyPXJ0bF0gOmhvc3QuY3VydGFpbiAuc2VhcmNoIGJ1dHRvbntsZWZ0OjNyZW19Omhvc3QuY3VydGFpbiAuc2VhcmNoIGZvcm17d2lkdGg6NTAlO29wYWNpdHk6MDt0cmFuc2Zvcm06c2NhbGUzZCgwLjgsIDAuOCwgMSk7dHJhbnNpdGlvbjpvcGFjaXR5IDAuNXMsIHRyYW5zZm9ybSAwLjVzfTpob3N0LmN1cnRhaW4gLnNlYXJjaCBpbnB1dHt3aWR0aDoxMDAlO2ZvbnQtc2l6ZTo2dnd9Omhvc3QuY3VydGFpbi5zaG93IC5zZWFyY2h7d2lkdGg6MTAwJTtwb2ludGVyLWV2ZW50czphdXRvO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMTAwJSwgMCwgMCk7dHJhbnNpdGlvbi1kZWxheTowc306aG9zdC5jdXJ0YWluLnNob3cgLnNlYXJjaDo6YWZ0ZXJ7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDEwMCUsIDAsIDApO3RyYW5zaXRpb24tZGVsYXk6MC40c306aG9zdC5jdXJ0YWluLnNob3cgLnNlYXJjaCBidXR0b257b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpfTpob3N0LmN1cnRhaW4uc2hvdyAuc2VhcmNoIGZvcm17b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpfUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDQwZW0pezpob3N0LmN1cnRhaW4gc3Bhbnt3aWR0aDo5MCV9Omhvc3QuY3VydGFpbiBpbnB1dHtmb250LXNpemU6MmVtO3dpZHRoOjkwJX19OjpuZy1kZWVwIG5iLWxheW91dC5jdXJ0YWluIC5zY3JvbGxhYmxlLWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4OjB9XFxuXCIsIFwiOjpuZy1kZWVwIG5iLWxheW91dC5jb2x1bW4tY3VydGFpbi53aXRoLXNlYXJjaCAubGF5b3V0e3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3QuY29sdW1uLWN1cnRhaW57ZGlzcGxheTpibG9jaztwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjEwNTA7dG9wOjA7bGVmdDo1MCU7b3ZlcmZsb3c6aGlkZGVuO3dpZHRoOjUwJTtoZWlnaHQ6MTAwdmg7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdC5jb2x1bW4tY3VydGFpbjo6YmVmb3Jle2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7dHJhbnNmb3JtOnNjYWxlM2QoMCwgMSwgMSk7dHJhbnNmb3JtLW9yaWdpbjowIDUwJTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjNzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjg2LCAwLCAwLjA3LCAxKX06aG9zdC5jb2x1bW4tY3VydGFpbiAuc2VhcmNoe3Bvc2l0aW9uOnJlbGF0aXZlO3BhZGRpbmc6Mi41cmVtIDEuNXJlbSAwO2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9Omhvc3QuY29sdW1uLWN1cnRhaW4gLnNlYXJjaCBidXR0b257cG9zaXRpb246YWJzb2x1dGU7dG9wOjJyZW07Zm9udC1zaXplOjIuNXJlbTtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IDAuNXN9W2Rpcj1sdHJdIDpob3N0LmNvbHVtbi1jdXJ0YWluIC5zZWFyY2ggYnV0dG9ue3JpZ2h0OjJyZW19W2Rpcj1ydGxdIDpob3N0LmNvbHVtbi1jdXJ0YWluIC5zZWFyY2ggYnV0dG9ue2xlZnQ6MnJlbX06aG9zdC5jb2x1bW4tY3VydGFpbiAuc2VhcmNoIGZvcm17d2lkdGg6ODUlO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgtMTUwJSwgMCwgMCk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC4zc306aG9zdC5jb2x1bW4tY3VydGFpbiAuc2VhcmNoIGlucHV0e2ZvbnQtc2l6ZToyLjVyZW07d2lkdGg6MTAwJX06aG9zdC5jb2x1bW4tY3VydGFpbiAuc2VhcmNoIHNwYW57Zm9udC1zaXplOjg1JX06aG9zdC5jb2x1bW4tY3VydGFpbi5zaG93e3BvaW50ZXItZXZlbnRzOmF1dG99Omhvc3QuY29sdW1uLWN1cnRhaW4uc2hvdzo6YmVmb3Jle3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpfTpob3N0LmNvbHVtbi1jdXJ0YWluLnNob3cgLnNlYXJjaCBmb3Jte3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAwLCAwKTt0cmFuc2l0aW9uLWRlbGF5OjAuMTVzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjg2LCAwLCAwLjA3LCAxKX06aG9zdC5jb2x1bW4tY3VydGFpbi5zaG93IC5zZWFyY2ggYnV0dG9ue29wYWNpdHk6MTt6LWluZGV4OjEwMH1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0MHJlbSl7Omhvc3QuY29sdW1uLWN1cnRhaW4gc3Bhbnt3aWR0aDo5MCV9Omhvc3QuY29sdW1uLWN1cnRhaW4gaW5wdXR7Zm9udC1zaXplOjJyZW07d2lkdGg6OTAlfX1cXG5cIiwgXCI6Om5nLWRlZXAgbmItbGF5b3V0Lm1vZGFsLWRyb3AgLmxheW91dHtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAwLjRzLCBvcGFjaXR5IDAuNHM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKX06Om5nLWRlZXAgbmItbGF5b3V0Lm1vZGFsLWRyb3Aud2l0aC1zZWFyY2ggLmxheW91dHtvcGFjaXR5OjA7dHJhbnNmb3JtOnNjYWxlM2QoMC45LCAwLjksIDEpO3BvaW50ZXItZXZlbnRzOm5vbmV9Omhvc3QubW9kYWwtZHJvcCAuc2VhcmNoe2Rpc3BsYXk6ZmxleDtmbGV4LWRpcmVjdGlvbjpjb2x1bW47anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7dGV4dC1hbGlnbjpjZW50ZXI7ei1pbmRleDoxMDUwO3Bvc2l0aW9uOmZpeGVkO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDB2aDtiYWNrZ3JvdW5kOm5vbmU7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdC5tb2RhbC1kcm9wIC5zZWFyY2g6OmJlZm9yZXtjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO3JpZ2h0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJTtvcGFjaXR5OjA7dHJhbnNpdGlvbjpvcGFjaXR5IDAuNHN9Omhvc3QubW9kYWwtZHJvcCAuc2VhcmNoIGJ1dHRvbntmb250LXNpemU6Mi41cmVtO3Bvc2l0aW9uOmFic29sdXRlO3RvcDozcmVtO2Rpc3BsYXk6YmxvY2s7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAwLjRzfVtkaXI9bHRyXSA6aG9zdC5tb2RhbC1kcm9wIC5zZWFyY2ggYnV0dG9ue3JpZ2h0OjNyZW19W2Rpcj1ydGxdIDpob3N0Lm1vZGFsLWRyb3AgLnNlYXJjaCBidXR0b257bGVmdDozcmVtfTpob3N0Lm1vZGFsLWRyb3AgLnNlYXJjaCBmb3Jte3Bvc2l0aW9uOnJlbGF0aXZlO21hcmdpbjo1cmVtIDAgMnJlbX06aG9zdC5tb2RhbC1kcm9wIC5zZWFyY2ggaW5wdXR7Zm9udC1zaXplOjZ2dzt3aWR0aDo2MCU7cGFkZGluZzowLjI1cmVtO3RleHQtYWxpZ246Y2VudGVyO29wYWNpdHk6MDt0cmFuc2l0aW9uOm9wYWNpdHkgMC40c306aG9zdC5tb2RhbC1kcm9wIC5zZWFyY2ggc3Bhbntwb3NpdGlvbjpyZWxhdGl2ZTt6LWluZGV4Ojk7ZGlzcGxheTpibG9jazt3aWR0aDo2MCU7cGFkZGluZzowLjg1cmVtIDA7b3BhY2l0eTowO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAtNTBweCwgMCk7dHJhbnNpdGlvbjpvcGFjaXR5IDAuNHMsIHRyYW5zZm9ybSAwLjRzfTpob3N0Lm1vZGFsLWRyb3AgLnNlYXJjaCAuZm9ybS1jb250ZW50e3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MTA7b3ZlcmZsb3c6aGlkZGVuO3RyYW5zZm9ybTp0cmFuc2xhdGUzZCgwLCAtNTBweCwgMCk7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gMC40c306aG9zdC5tb2RhbC1kcm9wIC5zZWFyY2ggLmZvcm0tY29udGVudDo6YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjIwJTt3aWR0aDo2MCU7aGVpZ2h0OjEwNSU7b3BhY2l0eTowO3RyYW5zZm9ybS1vcmlnaW46NTAlIDB9Omhvc3QubW9kYWwtZHJvcC5zaG93IC5zZWFyY2h7cG9pbnRlci1ldmVudHM6YXV0b306aG9zdC5tb2RhbC1kcm9wLnNob3cgLnNlYXJjaDo6YmVmb3Jle29wYWNpdHk6MX06aG9zdC5tb2RhbC1kcm9wLnNob3cgLnNlYXJjaCBidXR0b257b3BhY2l0eToxfTpob3N0Lm1vZGFsLWRyb3Auc2hvdyAuc2VhcmNoIC5mb3JtLWNvbnRlbnR7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsIDAsIDApO3RyYW5zaXRpb246bm9uZX06aG9zdC5tb2RhbC1kcm9wLnNob3cgLnNlYXJjaCAuZm9ybS1jb250ZW50OjphZnRlcnthbmltYXRpb246c2NhbGVVcERvd24gMC44cyBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpIGZvcndhcmRzfTpob3N0Lm1vZGFsLWRyb3Auc2hvdyAuc2VhcmNoIGlucHV0e29wYWNpdHk6MTt0cmFuc2l0aW9uOm9wYWNpdHkgMHMgMC40c306aG9zdC5tb2RhbC1kcm9wLnNob3cgLnNlYXJjaCBzcGFue29wYWNpdHk6MTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgMCwgMCk7dHJhbnNpdGlvbi1kZWxheTowLjRzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fUBrZXlmcmFtZXMgc2NhbGVVcERvd257MCV7b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNkKDEsIDAsIDEpfTUwJXt0cmFuc2Zvcm06c2NhbGUzZCgxLCAxLCAxKTt0cmFuc2Zvcm0tb3JpZ2luOjUwJSAwO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2Utb3V0fTUwLjEle3RyYW5zZm9ybS1vcmlnaW46NTAlIDEwMCU7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246ZWFzZS1vdXR9MTAwJXtvcGFjaXR5OjE7dHJhbnNmb3JtOnNjYWxlM2QoMSwgMCwgMSk7dHJhbnNmb3JtLW9yaWdpbjo1MCUgMTAwJTt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLW91dH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDogNDByZW0pezpob3N0Lm1vZGFsLWRyb3AgZm9ybXttYXJnaW46MnJlbSAwfTpob3N0Lm1vZGFsLWRyb3AgaW5wdXR7d2lkdGg6MTAwJTtsZWZ0OjB9fVxcblwiLCBcIjo6bmctZGVlcCBuYi1sYXlvdXQubW9kYWwtaGFsZiAubGF5b3V0e3RyYW5zaXRpb246dHJhbnNmb3JtIDAuNnMsIG9wYWNpdHkgMC42czt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoMC4yLCAxLCAwLjMsIDEpfTo6bmctZGVlcCBuYi1sYXlvdXQubW9kYWwtaGFsZi53aXRoLXNlYXJjaCAubGF5b3V0e3RyYW5zZm9ybTpzY2FsZTNkKDAuOCwgMC44LCAxKTtwb2ludGVyLWV2ZW50czpub25lfTpob3N0Lm1vZGFsLWhhbGYgLnNlYXJjaHt0ZXh0LWFsaWduOmNlbnRlcjtwb3NpdGlvbjpmaXhlZDt6LWluZGV4OjEwNTA7dG9wOjA7bGVmdDowO292ZXJmbG93OmhpZGRlbjt3aWR0aDoxMDAlO2hlaWdodDoxMDB2aDtiYWNrZ3JvdW5kOm5vbmU7cG9pbnRlci1ldmVudHM6bm9uZX06aG9zdC5tb2RhbC1oYWxmIC5zZWFyY2g6OmJlZm9yZXtjb250ZW50OicnO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDAlO2hlaWdodDoxMDAlO3BvaW50ZXItZXZlbnRzOm5vbmU7b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAwLjZzO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllcigwLjIsIDEsIDAuMywgMSl9Omhvc3QubW9kYWwtaGFsZiAuc2VhcmNoIGJ1dHRvbntmb250LXNpemU6Mi41cmVtO3Bvc2l0aW9uOmFic29sdXRlO3RvcDozcmVtO2Rpc3BsYXk6YmxvY2s7ei1pbmRleDoxMDA7b3BhY2l0eTowO3RyYW5zZm9ybTpzY2FsZTNkKDAuOCwgMC44LCAxKTt0cmFuc2l0aW9uOm9wYWNpdHkgMC42cywgdHJhbnNmb3JtIDAuNnM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuMiwgMSwgMC4zLCAxKX1bZGlyPWx0cl0gOmhvc3QubW9kYWwtaGFsZiAuc2VhcmNoIGJ1dHRvbntyaWdodDozcmVtfVtkaXI9cnRsXSA6aG9zdC5tb2RhbC1oYWxmIC5zZWFyY2ggYnV0dG9ue2xlZnQ6M3JlbX06aG9zdC5tb2RhbC1oYWxmIC5zZWFyY2ggLmZvcm0td3JhcHBlcntwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7d2lkdGg6MTAwJTtoZWlnaHQ6NTAlO3RyYW5zaXRpb246dHJhbnNmb3JtIDAuNnM7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKDAuMiwgMSwgMC4zLCAxKTt0cmFuc2Zvcm06dHJhbnNsYXRlM2QoMCwgLTEwMCUsIDApfTpob3N0Lm1vZGFsLWhhbGYgLnNlYXJjaCBmb3Jte3dpZHRoOjc1JTttYXJnaW46MCBhdXRvfTpob3N0Lm1vZGFsLWhhbGYgLnNlYXJjaCBpbnB1dHtmb250LXNpemU6N3Z3O3dpZHRoOjEwMCV9Omhvc3QubW9kYWwtaGFsZi5zaG93IC5zZWFyY2h7cG9pbnRlci1ldmVudHM6YXV0b306aG9zdC5tb2RhbC1oYWxmLnNob3cgLnNlYXJjaDo6YmVmb3Jle29wYWNpdHk6MX06aG9zdC5tb2RhbC1oYWxmLnNob3cgLnNlYXJjaCBidXR0b257b3BhY2l0eToxO3RyYW5zZm9ybTpzY2FsZTNkKDEsIDEsIDEpfTpob3N0Lm1vZGFsLWhhbGYuc2hvdyAuc2VhcmNoIC5mb3JtLXdyYXBwZXJ7dHJhbnNmb3JtOnRyYW5zbGF0ZTNkKDAsIDAsIDApfVxcblwiXVxuICAgIH0pXG5dLCBOYlNlYXJjaEZpZWxkQ29tcG9uZW50KTtcbi8qKlxuICogQmVhdXRpZnVsIGZ1bGwtcGFnZSBzZWFyY2ggY29udHJvbC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBzZWFyY2gvc2VhcmNoLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBCYXNpYyBzZXR1cDpcbiAqXG4gKiBgYGB0c1xuICogIDxuYi1zZWFyY2ggdHlwZT1cInJvdGF0ZS1sYXlvdXRcIj48L25iLXNlYXJjaD5cbiAqIGBgYFxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJTZWFyY2hNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iU2VhcmNoTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBTZXZlcmFsIGFuaW1hdGlvbiB0eXBlcyBhcmUgYXZhaWxhYmxlOlxuICogbW9kYWwtem9vbWluLCByb3RhdGUtbGF5b3V0LCBtb2RhbC1tb3ZlLCBjdXJ0YWluLCBjb2x1bW4tY3VydGFpbiwgbW9kYWwtZHJvcCwgbW9kYWwtaGFsZlxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gaGFuZGxlIHNlYXJjaCBldmVudCB1c2luZyBgTmJTZWFyY2hTZXJ2aWNlYDpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNlYXJjaCBFdmVudCwgc2VhcmNoL3NlYXJjaC1ldmVudC5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHNlYXJjaC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VhcmNoLWRpdmlkZXItY29sb3I6XG4gKiBzZWFyY2gtZGl2aWRlci1zdHlsZTpcbiAqIHNlYXJjaC1kaXZpZGVyLXdpZHRoOlxuICogc2VhcmNoLWV4dHJhLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWFyY2gtdGV4dC1jb2xvcjpcbiAqIHNlYXJjaC10ZXh0LWZvbnQtZmFtaWx5OlxuICogc2VhcmNoLXRleHQtZm9udC1zaXplOlxuICogc2VhcmNoLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBzZWFyY2gtdGV4dC1saW5lLWhlaWdodDpcbiAqIHNlYXJjaC1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VhcmNoLWluZm8tdGV4dC1jb2xvcjpcbiAqIHNlYXJjaC1pbmZvLXRleHQtZm9udC1mYW1pbHk6XG4gKiBzZWFyY2gtaW5mby10ZXh0LWZvbnQtc2l6ZTpcbiAqIHNlYXJjaC1pbmZvLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBzZWFyY2gtaW5mby10ZXh0LWxpbmUtaGVpZ2h0OlxuICovXG5sZXQgTmJTZWFyY2hDb21wb25lbnQgPSBjbGFzcyBOYlNlYXJjaENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc2VhcmNoU2VydmljZSwgdGhlbWVTZXJ2aWNlLCByb3V0ZXIsIG92ZXJsYXlTZXJ2aWNlLCBjaGFuZ2VEZXRlY3Rvcikge1xuICAgICAgICB0aGlzLnNlYXJjaFNlcnZpY2UgPSBzZWFyY2hTZXJ2aWNlO1xuICAgICAgICB0aGlzLnRoZW1lU2VydmljZSA9IHRoZW1lU2VydmljZTtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UgPSBvdmVybGF5U2VydmljZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zaG93U2VhcmNoRmllbGQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlYXJjaCBpbnB1dCBwbGFjZWhvbGRlclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciA9ICdTZWFyY2guLi4nO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGludCBzaG93aW5nIHVuZGVyIHRoZSBpbnB1dCBmaWVsZCB0byBpbXByb3ZlIHVzZXIgZXhwZXJpZW5jZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oaW50ID0gJ0hpdCBlbnRlciB0byBzZWFyY2gnO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIuZXZlbnRzXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSksIGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmhpZGVTZWFyY2goKSk7XG4gICAgICAgIHRoaXMuc2VhcmNoU2VydmljZS5vblNlYXJjaEFjdGl2YXRlKClcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSwgZmlsdGVyKGRhdGEgPT4gIXRoaXMudGFnIHx8IGRhdGEudGFnID09PSB0aGlzLnRhZykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMub3BlblNlYXJjaCgpKTtcbiAgICAgICAgdGhpcy5zZWFyY2hTZXJ2aWNlLm9uU2VhcmNoRGVhY3RpdmF0ZSgpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSksIGZpbHRlcihkYXRhID0+ICF0aGlzLnRhZyB8fCBkYXRhLnRhZyA9PT0gdGhpcy50YWcpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmhpZGVTZWFyY2goKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5vdmVybGF5UmVmICYmIHRoaXMub3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxheW91dENsYXNzZXMoKTtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgfVxuICAgIG9wZW5TZWFyY2goKSB7XG4gICAgICAgIGlmICghdGhpcy5vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLmNyZWF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5UmVmLmF0dGFjaCh0aGlzLnNlYXJjaEZpZWxkUG9ydGFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRoZW1lU2VydmljZS5hcHBlbmRMYXlvdXRDbGFzcyh0aGlzLnR5cGUpO1xuICAgICAgICBvZihudWxsKS5waXBlKGRlbGF5KDApKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50aGVtZVNlcnZpY2UuYXBwZW5kTGF5b3V0Q2xhc3MoJ3dpdGgtc2VhcmNoJyk7XG4gICAgICAgICAgICB0aGlzLnNob3dTZWFyY2hGaWVsZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhpZGVTZWFyY2goKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGF5b3V0Q2xhc3NlcygpO1xuICAgICAgICB0aGlzLnNob3dTZWFyY2hGaWVsZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5zZWFyY2hCdXR0b24ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbiAgICBzZWFyY2godGVybSkge1xuICAgICAgICB0aGlzLnNlYXJjaFNlcnZpY2Uuc3VibWl0U2VhcmNoKHRlcm0sIHRoaXMudGFnKTtcbiAgICAgICAgdGhpcy5oaWRlU2VhcmNoKCk7XG4gICAgfVxuICAgIGVtaXRJbnB1dCh0ZXJtKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoU2VydmljZS5zZWFyY2hJbnB1dCh0ZXJtLCB0aGlzLnRhZyk7XG4gICAgfVxuICAgIGVtaXRBY3RpdmF0ZSgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hTZXJ2aWNlLmFjdGl2YXRlU2VhcmNoKHRoaXMudHlwZSwgdGhpcy50YWcpO1xuICAgIH1cbiAgICBlbWl0RGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgdGhpcy5zZWFyY2hTZXJ2aWNlLmRlYWN0aXZhdGVTZWFyY2godGhpcy50eXBlLCB0aGlzLnRhZyk7XG4gICAgfVxuICAgIHJlbW92ZUxheW91dENsYXNzZXMoKSB7XG4gICAgICAgIHRoaXMudGhlbWVTZXJ2aWNlLnJlbW92ZUxheW91dENsYXNzKCd3aXRoLXNlYXJjaCcpO1xuICAgICAgICBvZihudWxsKS5waXBlKGRlbGF5KDUwMCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRoZW1lU2VydmljZS5yZW1vdmVMYXlvdXRDbGFzcyh0aGlzLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ3NihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJTZWFyY2hDb21wb25lbnQucHJvdG90eXBlLCBcInRhZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ3NihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJTZWFyY2hDb21wb25lbnQucHJvdG90eXBlLCBcInBsYWNlaG9sZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDc2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlNlYXJjaENvbXBvbmVudC5wcm90b3R5cGUsIFwiaGludFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ3NihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDQ5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJTZWFyY2hDb21wb25lbnQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkNzYoW1xuICAgIFZpZXdDaGlsZChOYlBvcnRhbERpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEkNDkoXCJkZXNpZ246dHlwZVwiLCBOYlBvcnRhbERpcmVjdGl2ZSlcbl0sIE5iU2VhcmNoQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWFyY2hGaWVsZFBvcnRhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ3NihbXG4gICAgVmlld0NoaWxkKCdzZWFyY2hCdXR0b24nLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YSQ0OShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBOYlNlYXJjaENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VhcmNoQnV0dG9uXCIsIHZvaWQgMCk7XG5OYlNlYXJjaENvbXBvbmVudCA9IF9fZGVjb3JhdGUkNzYoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItc2VhcmNoJyxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGJ1dHRvbiAjc2VhcmNoQnV0dG9uIGNsYXNzPVwic3RhcnQtc2VhcmNoXCIgKGNsaWNrKT1cImVtaXRBY3RpdmF0ZSgpXCIgbmJCdXR0b24gZ2hvc3Q+XG4gICAgICA8bmItaWNvbiBpY29uPVwic2VhcmNoLW91dGxpbmVcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCI+PC9uYi1pY29uPlxuICAgIDwvYnV0dG9uPlxuICAgIDxuYi1zZWFyY2gtZmllbGRcbiAgICAgICpuYlBvcnRhbFxuICAgICAgW3Nob3ddPVwic2hvd1NlYXJjaEZpZWxkXCJcbiAgICAgIFt0eXBlXT1cInR5cGVcIlxuICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcbiAgICAgIFtoaW50XT1cImhpbnRcIlxuICAgICAgKHNlYXJjaCk9XCJzZWFyY2goJGV2ZW50KVwiXG4gICAgICAoc2VhcmNoSW5wdXQpPVwiZW1pdElucHV0KCRldmVudClcIlxuICAgICAgKGNsb3NlKT1cImVtaXREZWFjdGl2YXRlKClcIj5cbiAgICA8L25iLXNlYXJjaC1maWVsZD5cbiAgYCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdCBidXR0b257Zm9udC1zaXplOjJyZW07bWFyZ2luOjAgYXV0bztwYWRkaW5nOjA7Y3Vyc29yOnBvaW50ZXI7Ym9yZGVyOm5vbmU7YmFja2dyb3VuZDpub25lfTpob3N0IGJ1dHRvbjpmb2N1c3tib3gtc2hhZG93Om5vbmU7b3V0bGluZTpub25lfTo6bmctZGVlcCBuYi1sYXlvdXQud2l0aC1zZWFyY2ggLnNjcm9sbGFibGUtY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlO3otaW5kZXg6MH1cXG5cIl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDQ5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iU2VhcmNoU2VydmljZSxcbiAgICAgICAgTmJUaGVtZVNlcnZpY2UsXG4gICAgICAgIFJvdXRlcixcbiAgICAgICAgTmJPdmVybGF5U2VydmljZSxcbiAgICAgICAgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgTmJTZWFyY2hDb21wb25lbnQpO1xuXG52YXIgX19kZWNvcmF0ZSQ3NSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5sZXQgTmJTZWFyY2hNb2R1bGUgPSBjbGFzcyBOYlNlYXJjaE1vZHVsZSB7XG59O1xuTmJTZWFyY2hNb2R1bGUgPSBfX2RlY29yYXRlJDc1KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgTmJPdmVybGF5TW9kdWxlLFxuICAgICAgICAgICAgTmJJY29uTW9kdWxlLFxuICAgICAgICAgICAgTmJCdXR0b25Nb2R1bGUsXG4gICAgICAgIF0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgTmJTZWFyY2hDb21wb25lbnQsXG4gICAgICAgICAgICBOYlNlYXJjaEZpZWxkQ29tcG9uZW50LFxuICAgICAgICBdLFxuICAgICAgICBleHBvcnRzOiBbXG4gICAgICAgICAgICBOYlNlYXJjaENvbXBvbmVudCxcbiAgICAgICAgICAgIE5iU2VhcmNoRmllbGRDb21wb25lbnQsXG4gICAgICAgIF0sXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgTmJTZWFyY2hTZXJ2aWNlLFxuICAgICAgICBdLFxuICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICAgICAgICAgIE5iU2VhcmNoRmllbGRDb21wb25lbnQsXG4gICAgICAgIF0sXG4gICAgfSlcbl0sIE5iU2VhcmNoTW9kdWxlKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkNzggPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNTAgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBOYkNoZWNrYm94Q29tcG9uZW50XzE7XG4vKipcbiAqIFN0eWxlZCBjaGVja2JveCBjb21wb25lbnRcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBjaGVja2JveC9jaGVja2JveC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJDaGVja2JveENvbXBvbmVudGAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJDaGVja2JveE1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogQ2hlY2tib3ggaXMgYXZhaWxhYmxlIGluIG11bHRpcGxlIGNvbG9ycyB1c2luZyBgc3RhdHVzYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ29sb3JlZCBDaGVja2JveGVzLCBjaGVja2JveC9jaGVja2JveC1zdGF0dXMuY29tcG9uZW50KVxuICpcbiAqIEluZGV0ZXJtaW5hdGUgc3RhdGUgaXMgYWxzbyBzdXBwb3J0ZWQ6XG4gKiBAc3RhY2tlZC1leGFtcGxlKEluZGV0ZXJtaW5hdGUgQ2hlY2tib3gsIGNoZWNrYm94L2NoZWNrYm94LWluZGV0ZXJtaW5hdGUuY29tcG9uZW50KVxuICpcbiAqIENoZWNrYm94IGNhbiBiZSBkaXNhYmxlZCB2aWEgYGRpc2FibGVkYCBhdHRyaWJ1dGUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKERpc2FibGVkIENoZWNrYm94LCBjaGVja2JveC9jaGVja2JveC1kaXNhYmxlZC5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGNoZWNrYm94LWhlaWdodDpcbiAqIGNoZWNrYm94LXdpZHRoOlxuICogY2hlY2tib3gtYm9yZGVyLXN0eWxlOlxuICogY2hlY2tib3gtYm9yZGVyLXdpZHRoOlxuICogY2hlY2tib3gtYm9yZGVyLXJhZGl1czpcbiAqIGNoZWNrYm94LW91dGxpbmUtd2lkdGg6XG4gKiBjaGVja2JveC1vdXRsaW5lLWNvbG9yOlxuICogY2hlY2tib3gtdGV4dC1mb250LWZhbWlseTpcbiAqIGNoZWNrYm94LXRleHQtZm9udC1zaXplOlxuICogY2hlY2tib3gtdGV4dC1mb250LXdlaWdodDpcbiAqIGNoZWNrYm94LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjaGVja2JveC10ZXh0LXNwYWNlOlxuICogY2hlY2tib3gtcGFkZGluZzpcbiAqIGNoZWNrYm94LWJhc2ljLXRleHQtY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1jaGVja2VkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWluZGV0ZXJtaW5hdGUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWluZGV0ZXJtaW5hdGUtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtaW5kZXRlcm1pbmF0ZS1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtZm9jdXMtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtZm9jdXMtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtaG92ZXItY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1hY3RpdmUtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtYWN0aXZlLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtYmFzaWMtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWRpc2FibGVkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LWJhc2ljLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBjaGVja2JveC1iYXNpYy1kaXNhYmxlZC1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktY2hlY2tlZC1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWluZGV0ZXJtaW5hdGUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktaW5kZXRlcm1pbmF0ZS1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWluZGV0ZXJtaW5hdGUtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWZvY3VzLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktZm9jdXMtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWFjdGl2ZS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXByaW1hcnktZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtcHJpbWFyeS1kaXNhYmxlZC1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBjaGVja2JveC1wcmltYXJ5LWRpc2FibGVkLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1jaGVja2VkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtaW5kZXRlcm1pbmF0ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1pbmRldGVybWluYXRlLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtaW5kZXRlcm1pbmF0ZS1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtZm9jdXMtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1mb2N1cy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtYWN0aXZlLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtc3VjY2Vzcy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1zdWNjZXNzLWRpc2FibGVkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGNoZWNrYm94LXN1Y2Nlc3MtZGlzYWJsZWQtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby10ZXh0LWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8tY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWNoZWNrZWQtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1pbmRldGVybWluYXRlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWluZGV0ZXJtaW5hdGUtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1pbmRldGVybWluYXRlLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8tZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8tZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1mb2N1cy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWZvY3VzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8taG92ZXItY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1hY3RpdmUtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1hY3RpdmUtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1pbmZvLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWluZm8tZGlzYWJsZWQtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogY2hlY2tib3gtaW5mby1kaXNhYmxlZC1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLXRleHQtY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctY2hlY2tlZC1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWluZGV0ZXJtaW5hdGUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctaW5kZXRlcm1pbmF0ZS1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWluZGV0ZXJtaW5hdGUtY2hlY2ttYXJrLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWZvY3VzLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctZm9jdXMtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWFjdGl2ZS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LXdhcm5pbmctZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtd2FybmluZy1kaXNhYmxlZC1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBjaGVja2JveC13YXJuaW5nLWRpc2FibGVkLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci10ZXh0LWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1jaGVja2VkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1pbmRldGVybWluYXRlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItaW5kZXRlcm1pbmF0ZS1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItaW5kZXRlcm1pbmF0ZS1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItZm9jdXMtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWZvY3VzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItaG92ZXItYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItYWN0aXZlLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1kYW5nZXItZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWRpc2FibGVkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LWRhbmdlci1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogY2hlY2tib3gtZGFuZ2VyLWRpc2FibGVkLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1jaGVja2VkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtaW5kZXRlcm1pbmF0ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1pbmRldGVybWluYXRlLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtaW5kZXRlcm1pbmF0ZS1jaGVja21hcmstY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtZm9jdXMtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1mb2N1cy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWhvdmVyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtYWN0aXZlLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtYWN0aXZlLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hlY2tib3gtY29udHJvbC1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBjaGVja2JveC1jb250cm9sLWRpc2FibGVkLWNoZWNrbWFyay1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGNoZWNrYm94LWNvbnRyb2wtZGlzYWJsZWQtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICovXG5sZXQgTmJDaGVja2JveENvbXBvbmVudCA9IE5iQ2hlY2tib3hDb21wb25lbnRfMSA9IGNsYXNzIE5iQ2hlY2tib3hDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZURldGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuX2NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gJ2Jhc2ljJztcbiAgICAgICAgdGhpcy5faW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogT3V0cHV0IHdoZW4gY2hlY2tlZCBzdGF0ZSBpcyBjaGFuZ2VkIGJ5IGEgdXNlclxuICAgICAgICAgKiBAdHlwZSBFdmVudEVtaXR0ZXI8Ym9vbGVhbj5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hlY2tlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tib3ggdmFsdWVcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEBicmVha2luZy1jaGFuZ2UgUmVtb3ZlIEA1LjAuMFxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAYnJlYWtpbmctY2hhbmdlIFJlbW92ZSBANS4wLjBcbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdOYkNoZWNrYm94OiBgdmFsdWVgIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiA1LjAuMC4gVXNlIGBjaGVja2VkYCBpbnN0ZWFkLicpO1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICAgIH1cbiAgICBzZXQgY2hlY2tlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jaGVja2VkID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgaW5wdXQgZGlzYWJsZWQgc3RhdGVcbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tib3ggc3RhdHVzLlxuICAgICAqIFBvc3NpYmxlIHZhbHVlcyBhcmU6IGBiYXNpY2AsIGBwcmltYXJ5YCwgYHN1Y2Nlc3NgLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgaW5mb2AsIGBjb250cm9sYC5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICAgIH1cbiAgICBzZXQgc3RhdHVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGVtcHR5U3RhdHVzV2FybmluZygnTmJDaGVja2JveCcpO1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gJ2Jhc2ljJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIGNoZWNrYm94IGluZGV0ZXJtaW5hdGUgc3RhdGVcbiAgICAgKi9cbiAgICBnZXQgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV0ZXJtaW5hdGU7XG4gICAgfVxuICAgIHNldCBpbmRldGVybWluYXRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdXRwdXQgd2hlbiBjaGVja2VkIHN0YXRlIGlzIGNoYW5nZWQgYnkgYSB1c2VyXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBAYnJlYWtpbmctY2hhbmdlIFJlbW92ZSBANS4wLjBcbiAgICAgKiBAdHlwZSBFdmVudEVtaXR0ZXI8Ym9vbGVhbj5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWVDaGFuZ2UoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTmJDaGVja2JveDogYHZhbHVlQ2hhbmdlYCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gNS4wLjAuIFVzZSBgY2hlY2tlZENoYW5nZWAgaW5zdGVhZC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tlZENoYW5nZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlQ2hhbmdlKHZhbHVlQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tlZENoYW5nZSA9IHZhbHVlQ2hhbmdlO1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAncHJpbWFyeSc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCBiYXNpYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnYmFzaWMnO1xuICAgIH1cbiAgICBnZXQgY29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnY29udHJvbCc7XG4gICAgfVxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH1cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICB3cml0ZVZhbHVlKHZhbCkge1xuICAgICAgICB0aGlzLl9jaGVja2VkID0gdmFsO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgc2V0RGlzYWJsZWRTdGF0ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgIH1cbiAgICBzZXRUb3VjaGVkKCkge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgIH1cbiAgICB1cGRhdGVWYWx1ZUFuZEluZGV0ZXJtaW5hdGUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IGlucHV0LmNoZWNrZWQ7XG4gICAgICAgIHRoaXMuY2hlY2tlZENoYW5nZS5lbWl0KHRoaXMuY2hlY2tlZCk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UodGhpcy5jaGVja2VkKTtcbiAgICAgICAgdGhpcy5pbmRldGVybWluYXRlID0gaW5wdXQuaW5kZXRlcm1pbmF0ZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ3OChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDUwKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1MChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iQ2hlY2tib3hDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3OChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDUwKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1MChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iQ2hlY2tib3hDb21wb25lbnQucHJvdG90eXBlLCBcImNoZWNrZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDc4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNTAoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDUwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJDaGVja2JveENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDc4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNTAoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEkNTAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIE5iQ2hlY2tib3hDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXR1c1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzgoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ1MChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNTAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYkNoZWNrYm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmRldGVybWluYXRlXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3OChbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQ1MChcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlciksXG4gICAgX19tZXRhZGF0YSQ1MChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFdmVudEVtaXR0ZXJdKVxuXSwgTmJDaGVja2JveENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVDaGFuZ2VcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDc4KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDUwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDaGVja2JveENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2hlY2tlZENoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ3OChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyksXG4gICAgX19tZXRhZGF0YSQ1MChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1MChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDaGVja2JveENvbXBvbmVudC5wcm90b3R5cGUsIFwicHJpbWFyeVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkNzgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtc3VjY2VzcycpLFxuICAgIF9fbWV0YWRhdGEkNTAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNTAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2hlY2tib3hDb21wb25lbnQucHJvdG90eXBlLCBcInN1Y2Nlc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDc4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLXdhcm5pbmcnKSxcbiAgICBfX21ldGFkYXRhJDUwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDUwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNoZWNrYm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3YXJuaW5nXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3OChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1kYW5nZXInKSxcbiAgICBfX21ldGFkYXRhJDUwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDUwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNoZWNrYm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkYW5nZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDc4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWluZm8nKSxcbiAgICBfX21ldGFkYXRhJDUwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDUwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNoZWNrYm94Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmZvXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3OChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1iYXNpYycpLFxuICAgIF9fbWV0YWRhdGEkNTAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNTAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2hlY2tib3hDb21wb25lbnQucHJvdG90eXBlLCBcImJhc2ljXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ3OChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1jb250cm9sJyksXG4gICAgX19tZXRhZGF0YSQ1MChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1MChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDaGVja2JveENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCBudWxsKTtcbk5iQ2hlY2tib3hDb21wb25lbnQgPSBOYkNoZWNrYm94Q29tcG9uZW50XzEgPSBfX2RlY29yYXRlJDc4KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWNoZWNrYm94JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bGFiZWwgY2xhc3M9XCJsYWJlbFwiPlxuICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNsYXNzPVwibmF0aXZlLWlucHV0IHZpc3VhbGx5LWhpZGRlblwiXG4gICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICBbY2hlY2tlZF09XCJjaGVja2VkXCJcbiAgICAgICAgICAgICAoY2hhbmdlKT1cInVwZGF0ZVZhbHVlQW5kSW5kZXRlcm1pbmF0ZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAoYmx1cik9XCJzZXRUb3VjaGVkKClcIlxuICAgICAgICAgICAgIChjbGljayk9XCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIlxuICAgICAgICAgICAgIFtpbmRldGVybWluYXRlXT1cImluZGV0ZXJtaW5hdGVcIj5cbiAgICAgIDxzcGFuIFtjbGFzcy5pbmRldGVybWluYXRlXT1cImluZGV0ZXJtaW5hdGVcIiBbY2xhc3MuY2hlY2tlZF09XCJjaGVja2VkXCIgY2xhc3M9XCJjdXN0b20tY2hlY2tib3hcIj5cbiAgICAgICAgPG5iLWljb24gKm5nSWY9XCJpbmRldGVybWluYXRlXCIgaWNvbj1cIm1pbnVzLWJvbGQtb3V0bGluZVwiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIj48L25iLWljb24+XG4gICAgICAgIDxuYi1pY29uICpuZ0lmPVwiY2hlY2tlZCAmJiAhaW5kZXRlcm1pbmF0ZVwiIGljb249XCJjaGVja21hcmstYm9sZC1vdXRsaW5lXCIgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiPjwvbmItaWNvbj5cbiAgICAgIDwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwidGV4dFwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICA8L3NwYW4+XG4gICAgPC9sYWJlbD5cbiAgYCxcbiAgICAgICAgcHJvdmlkZXJzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5iQ2hlY2tib3hDb21wb25lbnRfMSksXG4gICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdCAubGFiZWx7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtZmxleDthbGlnbi1pdGVtczpjZW50ZXI7bWFyZ2luOjA7bWluLWhlaWdodDppbmhlcml0fTpob3N0IC5jdXN0b20tY2hlY2tib3h7ZmxleC1zaHJpbms6MDt0cmFuc2l0aW9uLWR1cmF0aW9uOjAuMTVzO3RyYW5zaXRpb24tcHJvcGVydHk6YmFja2dyb3VuZC1jb2xvcixib3JkZXIsYm94LXNoYWRvdzt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLWlufTpob3N0IC50ZXh0e3RyYW5zaXRpb246Y29sb3IgMC4xNXMgZWFzZS1pbn1cXG5cIl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDUwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NoYW5nZURldGVjdG9yUmVmXSlcbl0sIE5iQ2hlY2tib3hDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ3OSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5sZXQgTmJDaGVja2JveE1vZHVsZSA9IGNsYXNzIE5iQ2hlY2tib3hNb2R1bGUge1xufTtcbk5iQ2hlY2tib3hNb2R1bGUgPSBfX2RlY29yYXRlJDc5KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgTmJJY29uTW9kdWxlLFxuICAgICAgICBdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYkNoZWNrYm94Q29tcG9uZW50XSxcbiAgICAgICAgZXhwb3J0czogW05iQ2hlY2tib3hDb21wb25lbnRdLFxuICAgIH0pXG5dLCBOYkNoZWNrYm94TW9kdWxlKTtcblxudmFyIF9fZGVjb3JhdGUkODEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNTIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYkR5bmFtaWNPdmVybGF5ID0gY2xhc3MgTmJEeW5hbWljT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3Iob3ZlcmxheSwgY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCB6b25lLCBvdmVybGF5Q29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyID0gY29tcG9uZW50RmFjdG9yeVJlc29sdmVyO1xuICAgICAgICB0aGlzLnpvbmUgPSB6b25lO1xuICAgICAgICB0aGlzLm92ZXJsYXlDb250YWluZXIgPSBvdmVybGF5Q29udGFpbmVyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB7fTtcbiAgICAgICAgdGhpcy5vdmVybGF5Q29uZmlnID0ge307XG4gICAgICAgIHRoaXMucG9zaXRpb25TdHJhdGVneUNoYW5nZSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmlzU2hvd24kID0gbmV3IEJlaGF2aW9yU3ViamVjdChmYWxzZSk7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgaXNBdHRhY2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmICYmIHRoaXMucmVmLmhhc0F0dGFjaGVkKCk7XG4gICAgfVxuICAgIGdldCBpc1Nob3duKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1Nob3duJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICAgIH1cbiAgICBjcmVhdGUoY29tcG9uZW50VHlwZSwgY29udGVudCwgY29udGV4dCwgcG9zaXRpb25TdHJhdGVneSwgb3ZlcmxheUNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGVudEFuZENvbnRleHQoY29udGVudCwgY29udGV4dCk7XG4gICAgICAgIHRoaXMuc2V0Q29tcG9uZW50KGNvbXBvbmVudFR5cGUpO1xuICAgICAgICB0aGlzLnNldFBvc2l0aW9uU3RyYXRlZ3kocG9zaXRpb25TdHJhdGVneSk7XG4gICAgICAgIHRoaXMuc2V0T3ZlcmxheUNvbmZpZyhvdmVybGF5Q29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldENvbnRlbnQoY29udGVudCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENvbnRleHQoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldENvbnRlbnRBbmRDb250ZXh0KGNvbnRlbnQsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDb21wb25lbnQoY29tcG9uZW50VHlwZSkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudFR5cGUgPSBjb21wb25lbnRUeXBlO1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBjb21wb25lbnQgaXMgc2hvd24gd2UgcmVjcmVhdGUgaXQgYW5kIHNob3cgaXQgYmFja1xuICAgICAgICBjb25zdCB3YXNBdHRhY2hlZCA9IHRoaXMuaXNBdHRhY2hlZDtcbiAgICAgICAgdGhpcy5kaXNwb3NlT3ZlcmxheVJlZigpO1xuICAgICAgICBpZiAod2FzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFBvc2l0aW9uU3RyYXRlZ3kocG9zaXRpb25TdHJhdGVneSkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uU3RyYXRlZ3lDaGFuZ2UkLm5leHQoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvblN0cmF0ZWd5ID0gcG9zaXRpb25TdHJhdGVneTtcbiAgICAgICAgdGhpcy5wb3NpdGlvblN0cmF0ZWd5LnBvc2l0aW9uQ2hhbmdlXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSksIHRha2VVbnRpbCh0aGlzLnBvc2l0aW9uU3RyYXRlZ3lDaGFuZ2UkKSwgZmlsdGVyKCgpID0+ICEhdGhpcy5jb250YWluZXIpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgocG9zaXRpb24pID0+IHtcbiAgICAgICAgICAgIHRoaXMubGFzdEFwcGxpZWRQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgcGF0Y2godGhpcy5jb250YWluZXIsIHsgcG9zaXRpb24gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVmLnVwZGF0ZVBvc2l0aW9uU3RyYXRlZ3kodGhpcy5wb3NpdGlvblN0cmF0ZWd5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRPdmVybGF5Q29uZmlnKG92ZXJsYXlDb25maWcpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5Q29uZmlnID0gb3ZlcmxheUNvbmZpZztcbiAgICAgICAgY29uc3Qgd2FzQXR0YWNoZWQgPSB0aGlzLmlzQXR0YWNoZWQ7XG4gICAgICAgIHRoaXMuZGlzcG9zZU92ZXJsYXlSZWYoKTtcbiAgICAgICAgaWYgKHdhc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgICBpZiAoIXRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlckNvbnRhaW5lcigpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzT3ZlcmxheUluQ29udGFpbmVyKCkpIHtcbiAgICAgICAgICAgIC8vIERpc3Bvc2Ugb3ZlcmxheSByZWYgYXMgaXQgcmVmZXJzIHRvIHRoZSBvbGQgb3ZlcmxheSBjb250YWluZXIgYW5kIGNyZWF0ZSBuZXcgYnkgY2FsbGluZyBgc2hvd2BcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZU92ZXJsYXlSZWYoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzU2hvd24kLm5leHQodHJ1ZSk7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZi5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmlzU2hvd24kLm5leHQoZmFsc2UpO1xuICAgIH1cbiAgICB0b2dnbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlT3ZlcmxheVJlZigpO1xuICAgICAgICB0aGlzLmlzU2hvd24kLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25TdHJhdGVneUNoYW5nZSQuY29tcGxldGUoKTtcbiAgICB9XG4gICAgZ2V0Q29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICAgIGNyZWF0ZU92ZXJsYXkoKSB7XG4gICAgICAgIHRoaXMucmVmID0gdGhpcy5vdmVybGF5LmNyZWF0ZShPYmplY3QuYXNzaWduKHsgcG9zaXRpb25TdHJhdGVneTogdGhpcy5wb3NpdGlvblN0cmF0ZWd5LCBzY3JvbGxTdHJhdGVneTogdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpIH0sIHRoaXMub3ZlcmxheUNvbmZpZykpO1xuICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uV2hlblN0YWJsZSgpO1xuICAgIH1cbiAgICByZW5kZXJDb250YWluZXIoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lckNvbnRleHQgPSB0aGlzLmNyZWF0ZUNvbnRhaW5lckNvbnRleHQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBjcmVhdGVDb250YWluZXIodGhpcy5yZWYsIHRoaXMuY29tcG9uZW50VHlwZSwgY29udGFpbmVyQ29udGV4dCwgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmluc3RhbmNlLnJlbmRlckNvbnRlbnQoKTtcbiAgICB9XG4gICAgdXBkYXRlQ29udGV4dCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyQ29udGV4dCA9IHRoaXMuY3JlYXRlQ29udGFpbmVyQ29udGV4dCgpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY29udGFpbmVyLmluc3RhbmNlLCBjb250YWluZXJDb250ZXh0KTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuaW5zdGFuY2UucmVuZGVyQ29udGVudCgpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRhaW5lckNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLmNvbnRlbnQsXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQsXG4gICAgICAgICAgICBjZnI6IHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubGFzdEFwcGxpZWRQb3NpdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGltZW5zaW9ucyBvZiB0aGUgY29udGFpbmVyIG1heSBjaGFuZ2UgYWZ0ZXIgY29udGVudCB1cGRhdGUuIFNvIHdlIGxpc3RlbiB0byB6b25lLnN0YWJsZSBldmVudCB0b1xuICAgICAqIHJlcG9zaXRpb24gdGhlIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICB1cGRhdGVQb3NpdGlvbldoZW5TdGFibGUoKSB7XG4gICAgICAgIHRoaXMuem9uZS5vblN0YWJsZVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZiAmJiB0aGlzLnJlZi51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFzT3ZlcmxheUluQ29udGFpbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5Q29udGFpbmVyLmdldENvbnRhaW5lckVsZW1lbnQoKS5jb250YWlucyh0aGlzLnJlZi5ob3N0RWxlbWVudCk7XG4gICAgfVxuICAgIGRpc3Bvc2VPdmVybGF5UmVmKCkge1xuICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMucmVmID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5OYkR5bmFtaWNPdmVybGF5ID0gX19kZWNvcmF0ZSQ4MShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEkNTIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJPdmVybGF5U2VydmljZSxcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIE5iT3ZlcmxheUNvbnRhaW5lcl0pXG5dLCBOYkR5bmFtaWNPdmVybGF5KTtcblxudmFyIF9fZGVjb3JhdGUkODIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNTMgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmNsYXNzIE5iRHluYW1pY092ZXJsYXlDaGFuZ2UgZXh0ZW5kcyBTaW1wbGVDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSwgZmlyc3RDaGFuZ2UgPSBmYWxzZSkge1xuICAgICAgICBzdXBlcihwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUsIGZpcnN0Q2hhbmdlKTtcbiAgICB9XG4gICAgaXNDaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50VmFsdWUgIT09IHRoaXMucHJldmlvdXNWYWx1ZTtcbiAgICB9XG59XG5sZXQgTmJEeW5hbWljT3ZlcmxheUhhbmRsZXIgPSBjbGFzcyBOYkR5bmFtaWNPdmVybGF5SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IocG9zaXRpb25CdWlsZGVyLCB0cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyLCBkeW5hbWljT3ZlcmxheVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkJ1aWxkZXIgPSBwb3NpdGlvbkJ1aWxkZXI7XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5QnVpbGRlciA9IHRyaWdnZXJTdHJhdGVneUJ1aWxkZXI7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXlTZXJ2aWNlID0gZHluYW1pY092ZXJsYXlTZXJ2aWNlO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0ge307XG4gICAgICAgIHRoaXMuX3RyaWdnZXIgPSBOYlRyaWdnZXIuTk9PUDtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBOYlBvc2l0aW9uLlRPUDtcbiAgICAgICAgdGhpcy5fYWRqdXN0bWVudCA9IE5iQWRqdXN0bWVudC5OT09QO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSAxNTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheUNvbmZpZyA9IHt9O1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSB7fTtcbiAgICB9XG4gICAgaG9zdChob3N0KSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5ob3N0ID0gbmV3IE5iRHluYW1pY092ZXJsYXlDaGFuZ2UodGhpcy5faG9zdCwgaG9zdCk7XG4gICAgICAgIHRoaXMuX2hvc3QgPSBob3N0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdHJpZ2dlcih0cmlnZ2VyJCQxKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy50cmlnZ2VyID0gbmV3IE5iRHluYW1pY092ZXJsYXlDaGFuZ2UodGhpcy5fdHJpZ2dlciwgdHJpZ2dlciQkMSk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXIgPSB0cmlnZ2VyJCQxO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLnBvc2l0aW9uID0gbmV3IE5iRHluYW1pY092ZXJsYXlDaGFuZ2UodGhpcy5fcG9zaXRpb24sIHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkanVzdG1lbnQoYWRqdXN0bWVudCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMuYWRqdXN0bWVudCA9IG5ldyBOYkR5bmFtaWNPdmVybGF5Q2hhbmdlKHRoaXMuX2FkanVzdG1lbnQsIGFkanVzdG1lbnQpO1xuICAgICAgICB0aGlzLl9hZGp1c3RtZW50ID0gYWRqdXN0bWVudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbXBvbmVudFR5cGUoY29tcG9uZW50VHlwZSkge1xuICAgICAgICB0aGlzLmNoYW5nZXMuY29tcG9uZW50VHlwZSA9IG5ldyBOYkR5bmFtaWNPdmVybGF5Q2hhbmdlKHRoaXMuX2NvbXBvbmVudFR5cGUsIGNvbXBvbmVudFR5cGUpO1xuICAgICAgICB0aGlzLl9jb21wb25lbnRUeXBlID0gY29tcG9uZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnRlbnQoY29udGVudCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMuY29udGVudCA9IG5ldyBOYkR5bmFtaWNPdmVybGF5Q2hhbmdlKHRoaXMuX2NvbnRlbnQsIGNvbnRlbnQpO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnRleHQoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMuY29udGV4dCA9IG5ldyBOYkR5bmFtaWNPdmVybGF5Q2hhbmdlKHRoaXMuX2NvbnRleHQsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLm9mZnNldCA9IG5ldyBOYkR5bmFtaWNPdmVybGF5Q2hhbmdlKHRoaXMuX29mZnNldCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb3ZlcmxheUNvbmZpZyhvdmVybGF5Q29uZmlnKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5vdmVybGF5Q29uZmlnID0gbmV3IE5iRHluYW1pY092ZXJsYXlDaGFuZ2UodGhpcy5fb3ZlcmxheUNvbmZpZywgb3ZlcmxheUNvbmZpZyk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlDb25maWcgPSBvdmVybGF5Q29uZmlnO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29tcG9uZW50VHlwZSB8fCAhdGhpcy5faG9zdCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYE5iRHluYW1pY092ZXJsYXlIYW5kbGVyOiBhdCBsZWFzdCAnY29tcG9uZW50VHlwZScgYW5kICdob3N0JyBzaG91bGQgYmVcbiAgICAgIHBhc3NlZCBiZWZvcmUgYnVpbGRpbmcgYSBkeW5hbWljIG92ZXJsYXkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheSA9IHRoaXMuZHluYW1pY092ZXJsYXlTZXJ2aWNlLmNyZWF0ZSh0aGlzLl9jb21wb25lbnRUeXBlLCB0aGlzLl9jb250ZW50LCB0aGlzLl9jb250ZXh0LCB0aGlzLmNyZWF0ZVBvc2l0aW9uU3RyYXRlZ3koKSwgdGhpcy5fb3ZlcmxheUNvbmZpZyk7XG4gICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmNsZWFyQ2hhbmdlcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5keW5hbWljT3ZlcmxheTtcbiAgICB9XG4gICAgcmVidWlsZCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdlIHNob3VsZCBub3QgdGhyb3cgaGVyZVxuICAgICAgICAgKiBhcyB3ZSB1c2UgcmVidWlsdCBpbiBsaWZlY3ljbGUgaG9va3NcbiAgICAgICAgICogd2hpY2ggaXQgY291bGQgYmUgY2FsbGVkIGJlZm9yZSB0aGUgYnVpbGRcbiAgICAgICAgICogc28gd2UganVzdCBpZ25vcmUgdGhpcyBjYWxsXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIXRoaXMuZHluYW1pY092ZXJsYXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1Bvc2l0aW9uU3RyYXRlZ3lVcGRhdGVSZXF1aXJlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5LnNldFBvc2l0aW9uU3RyYXRlZ3kodGhpcy5jcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzVHJpZ2dlclN0cmF0ZWd5VXBkYXRlUmVxdWlyZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDb250YWluZXJSZXJlbmRlclJlcXVpcmVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkuc2V0Q29udGVudEFuZENvbnRleHQodGhpcy5fY29udGVudCwgdGhpcy5fY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDb21wb25lbnRUeXBlVXBkYXRlUmVxdWlyZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS5zZXRDb21wb25lbnQodGhpcy5fY29tcG9uZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNPdmVybGF5Q29uZmlnVXBkYXRlUmVxdWlyZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS5zZXRPdmVybGF5Q29uZmlnKHRoaXMuX292ZXJsYXlDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJDaGFuZ2VzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmR5bmFtaWNPdmVybGF5O1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZHluYW1pY092ZXJsYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTmJEeW5hbWljT3ZlcmxheUhhbmRsZXI6IGNhbm5vdCBjb25uZWN0IHRvIER5bmFtaWNPdmVybGF5XG4gICAgICBhcyBpdCBpcyBub3QgY3JlYXRlZCB5ZXQuIENhbGwgYnVpbGQoKSBmaXJzdGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZU9uVHJpZ2dlcnModGhpcy5keW5hbWljT3ZlcmxheSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXJTdHJhdGVneSkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyU3RyYXRlZ3kuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLmNsZWFyQ2hhbmdlcygpO1xuICAgICAgICBpZiAodGhpcy5keW5hbWljT3ZlcmxheSkge1xuICAgICAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlUG9zaXRpb25TdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25CdWlsZGVyXG4gICAgICAgICAgICAuY29ubmVjdGVkVG8odGhpcy5faG9zdClcbiAgICAgICAgICAgIC5wb3NpdGlvbih0aGlzLl9wb3NpdGlvbilcbiAgICAgICAgICAgIC5hZGp1c3RtZW50KHRoaXMuX2FkanVzdG1lbnQpXG4gICAgICAgICAgICAub2Zmc2V0KHRoaXMuX29mZnNldCk7XG4gICAgfVxuICAgIHN1YnNjcmliZU9uVHJpZ2dlcnMoZHluYW1pY092ZXJsYXkpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyU3RyYXRlZ3kgPSB0aGlzLnRyaWdnZXJTdHJhdGVneUJ1aWxkZXJcbiAgICAgICAgICAgIC50cmlnZ2VyKHRoaXMuX3RyaWdnZXIpXG4gICAgICAgICAgICAuaG9zdCh0aGlzLl9ob3N0Lm5hdGl2ZUVsZW1lbnQpXG4gICAgICAgICAgICAuY29udGFpbmVyKCgpID0+IGR5bmFtaWNPdmVybGF5LmdldENvbnRhaW5lcigpKVxuICAgICAgICAgICAgLmJ1aWxkKCk7XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5LnNob3ckLnN1YnNjcmliZSgoKSA9PiBkeW5hbWljT3ZlcmxheS5zaG93KCkpO1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneS5oaWRlJC5zdWJzY3JpYmUoKCkgPT4gZHluYW1pY092ZXJsYXkuaGlkZSgpKTtcbiAgICB9XG4gICAgaXNDb250YWluZXJSZXJlbmRlclJlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0NvbnRlbnRVcGRhdGVkKClcbiAgICAgICAgICAgIHx8IHRoaXMuaXNDb250ZXh0VXBkYXRlZCgpXG4gICAgICAgICAgICB8fCB0aGlzLmlzUG9zaXRpb25TdHJhdGVneVVwZGF0ZVJlcXVpcmVkKCk7XG4gICAgfVxuICAgIGlzUG9zaXRpb25TdHJhdGVneVVwZGF0ZVJlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0FkanVzdG1lbnRVcGRhdGVkKCkgfHwgdGhpcy5pc1Bvc2l0aW9uVXBkYXRlZCgpIHx8IHRoaXMuaXNPZmZzZXRVcGRhdGVkKCkgfHwgdGhpcy5pc0hvc3RVcGRhdGVkKCk7XG4gICAgfVxuICAgIGlzVHJpZ2dlclN0cmF0ZWd5VXBkYXRlUmVxdWlyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVHJpZ2dlclVwZGF0ZWQoKSB8fCB0aGlzLmlzSG9zdFVwZGF0ZWQoKTtcbiAgICB9XG4gICAgaXNDb21wb25lbnRUeXBlVXBkYXRlUmVxdWlyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQ29tcG9uZW50VHlwZVVwZGF0ZWQoKTtcbiAgICB9XG4gICAgaXNPdmVybGF5Q29uZmlnVXBkYXRlUmVxdWlyZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzT3ZlcmxheUNvbmZpZ1VwZGF0ZWQoKTtcbiAgICB9XG4gICAgaXNDb21wb25lbnRUeXBlVXBkYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5jb21wb25lbnRUeXBlICYmIHRoaXMuY2hhbmdlcy5jb21wb25lbnRUeXBlLmlzQ2hhbmdlZCgpO1xuICAgIH1cbiAgICBpc0NvbnRlbnRVcGRhdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VzLmNvbnRlbnQgJiYgdGhpcy5jaGFuZ2VzLmNvbnRlbnQuaXNDaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlzQ29udGV4dFVwZGF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMuY29udGV4dCAmJiB0aGlzLmNoYW5nZXMuY29udGV4dC5pc0NoYW5nZWQoKTtcbiAgICB9XG4gICAgaXNBZGp1c3RtZW50VXBkYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5hZGp1c3RtZW50ICYmIHRoaXMuY2hhbmdlcy5hZGp1c3RtZW50LmlzQ2hhbmdlZCgpO1xuICAgIH1cbiAgICBpc1Bvc2l0aW9uVXBkYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5wb3NpdGlvbiAmJiB0aGlzLmNoYW5nZXMucG9zaXRpb24uaXNDaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlzSG9zdFVwZGF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMuaG9zdCAmJiB0aGlzLmNoYW5nZXMuaG9zdC5pc0NoYW5nZWQoKTtcbiAgICB9XG4gICAgaXNUcmlnZ2VyVXBkYXRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlcy50cmlnZ2VyICYmIHRoaXMuY2hhbmdlcy50cmlnZ2VyLmlzQ2hhbmdlZCgpO1xuICAgIH1cbiAgICBpc09mZnNldFVwZGF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMub2Zmc2V0ICYmIHRoaXMuY2hhbmdlcy5vZmZzZXQuaXNDaGFuZ2VkKCk7XG4gICAgfVxuICAgIGlzT3ZlcmxheUNvbmZpZ1VwZGF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZXMub3ZlcmxheUNvbmZpZyAmJiB0aGlzLmNoYW5nZXMub3ZlcmxheUNvbmZpZy5pc0NoYW5nZWQoKTtcbiAgICB9XG4gICAgY2xlYXJDaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSB7fTtcbiAgICB9XG59O1xuTmJEeW5hbWljT3ZlcmxheUhhbmRsZXIgPSBfX2RlY29yYXRlJDgyKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YSQ1MyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYlBvc2l0aW9uQnVpbGRlclNlcnZpY2UsXG4gICAgICAgIE5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2UsXG4gICAgICAgIE5iRHluYW1pY092ZXJsYXldKVxuXSwgTmJEeW5hbWljT3ZlcmxheUhhbmRsZXIpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ4MyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1NCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBPdmVybGF5IGNvbnRhaW5lci5cbiAqIFJlbmRlcnMgcHJvdmlkZWQgY29udGVudCBpbnNpZGUuXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHBvcG92ZXItdGV4dC1jb2xvcjpcbiAqIHBvcG92ZXItdGV4dC1mb250LWZhbWlseTpcbiAqIHBvcG92ZXItdGV4dC1mb250LXNpemU6XG4gKiBwb3BvdmVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBwb3BvdmVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBwb3BvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBwb3BvdmVyLWJvcmRlci13aWR0aDpcbiAqIHBvcG92ZXItYm9yZGVyLWNvbG9yOlxuICogcG9wb3Zlci1ib3JkZXItcmFkaXVzOlxuICogcG9wb3Zlci1zaGFkb3c6XG4gKiBwb3BvdmVyLWFycm93LXNpemU6XG4gKiBwb3BvdmVyLXBhZGRpbmc6XG4gKiAqL1xubGV0IE5iUG9wb3ZlckNvbXBvbmVudCA9IGNsYXNzIE5iUG9wb3ZlckNvbXBvbmVudCBleHRlbmRzIE5iUG9zaXRpb25lZENvbnRhaW5lciB7XG4gICAgcmVuZGVyQ29udGVudCgpIHtcbiAgICAgICAgdGhpcy5kZXRhY2hDb250ZW50KCk7XG4gICAgICAgIHRoaXMuYXR0YWNoQ29udGVudCgpO1xuICAgIH1cbiAgICBkZXRhY2hDb250ZW50KCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlDb250YWluZXIuZGV0YWNoKCk7XG4gICAgfVxuICAgIGF0dGFjaENvbnRlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZikge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hUZW1wbGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGVudCBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoQ29tcG9uZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFN0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaFRlbXBsYXRlKCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlDb250YWluZXJcbiAgICAgICAgICAgIC5hdHRhY2hUZW1wbGF0ZVBvcnRhbChuZXcgTmJUZW1wbGF0ZVBvcnRhbCh0aGlzLmNvbnRlbnQsIG51bGwsIHsgJGltcGxpY2l0OiB0aGlzLmNvbnRleHQgfSkpO1xuICAgIH1cbiAgICBhdHRhY2hDb21wb25lbnQoKSB7XG4gICAgICAgIGNvbnN0IHBvcnRhbCA9IG5ldyBOYkNvbXBvbmVudFBvcnRhbCh0aGlzLmNvbnRlbnQsIG51bGwsIG51bGwsIHRoaXMuY2ZyKTtcbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5vdmVybGF5Q29udGFpbmVyLmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIHJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICAgIGF0dGFjaFN0cmluZygpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5Q29udGFpbmVyLmF0dGFjaFN0cmluZ0NvbnRlbnQodGhpcy5jb250ZW50KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ4MyhbXG4gICAgVmlld0NoaWxkKE5iT3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEkNTQoXCJkZXNpZ246dHlwZVwiLCBOYk92ZXJsYXlDb250YWluZXJDb21wb25lbnQpXG5dLCBOYlBvcG92ZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm92ZXJsYXlDb250YWluZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkODMoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ1NChcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iUG9wb3ZlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ4MyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDU0KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJQb3BvdmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDgzKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNTQoXCJkZXNpZ246dHlwZVwiLCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpXG5dLCBOYlBvcG92ZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNmclwiLCB2b2lkIDApO1xuTmJQb3BvdmVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQ4MyhbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1wb3BvdmVyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8c3BhbiBjbGFzcz1cImFycm93XCI+PC9zcGFuPlxuICAgIDxuYi1vdmVybGF5LWNvbnRhaW5lcj48L25iLW92ZXJsYXktY29udGFpbmVyPlxuICBgLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0IC5hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowfVxcblwiXVxuICAgIH0pXG5dLCBOYlBvcG92ZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ4MCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1MSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBQb3dlcmZ1bCBwb3BvdmVyIGRpcmVjdGl2ZSwgd2hpY2ggcHJvdmlkZXMgdGhlIGJlc3QgVVggZm9yIHlvdXIgdXNlcnMuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgcG9wb3Zlci9wb3BvdmVyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBQb3BvdmVyIGNhbiBhY2NlcHQgZGlmZmVyZW50IGNvbnRlbnQgc3VjaCBhczpcbiAqIFRlbXBsYXRlUmVmXG4gKlxuICogYGBgaHRtbFxuICogPGJ1dHRvbiBbbmJQb3BvdmVyXT1cInRlbXBsYXRlUmVmXCI+PC9idXR0b24+XG4gKiA8bmctdGVtcGxhdGUgI3RlbXBsYXRlUmVmPlxuICogICA8c3Bhbj5IZWxsbywgUG9wb3ZlciE8L3NwYW4+XG4gKiA8L25nLXRlbXBsYXRlPlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlBvcG92ZXJNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iUG9wb3Zlck1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogQ3VzdG9tIGNvbXBvbmVudHNcbiAqXG4gKiBgYGBodG1sXG4gKiA8YnV0dG9uIFtuYlBvcG92ZXJdPVwiTXlQb3BvdmVyQ29tcG9uZW50XCI+PC9idXR0b24+XG4gKiBgYGBcbiAqXG4gKiBCb3RoIGN1c3RvbSBjb21wb25lbnRzIGFuZCB0ZW1wbGF0ZVJlZiBwb3BvdmVycyBjYW4gcmVjZWl2ZSAqY29udGVudENvbnRleHQqIHByb3BlcnR5XG4gKiB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjb250ZW50IHByb3BzLlxuICpcbiAqIFByaW1pdGl2ZSB0eXBlc1xuICpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b24gbmJQb3BvdmVyPVwiSGVsbG8sIFBvcG92ZXIhXCI+PC9idXR0b24+XG4gKiBgYGBcbiAqXG4gKiBQb3BvdmVyIGhhcyBkaWZmZXJlbnQgcGxhY2VtZW50cywgc3VjaCBhczogdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0LCBzdGFydCBhbmQgZW5kXG4gKiB3aGljaCBjYW4gYmUgdXNlZCBhcyBmb2xsb3dpbmc6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShQbGFjZW1lbnRzLCBwb3BvdmVyL3BvcG92ZXItcGxhY2VtZW50cy5jb21wb25lbnQpXG4gKlxuICogQnkgZGVmYXVsdCBwb3BvdmVyIHdpbGwgdHJ5IHRvIGFkanVzdCBpdHNlbGYgdG8gbWF4aW1hbGx5IGZpdCB2aWV3cG9ydFxuICogYW5kIHByb3ZpZGUgdGhlIGJlc3QgdXNlciBleHBlcmllbmNlLiBJdCB3aWxsIHRyeSB0byBjaGFuZ2UgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgY29udGFpbmVyLlxuICogSWYgeW91IHdhbnQgdG8gZGlzYWJsZSB0aGlzIGJlaGF2aW91ciBzZXQgaXQgYG5vb3BgLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxidXR0b24gbmJQb3BvdmVyPVwiSGVsbG8sIFBvcG92ZXIhXCIgbmJQb3BvdmVyQWRqdXN0bWVudD1cIm5vb3BcIj48L2J1dHRvbj5cbiAqIGBgYFxuICpcbiAqIFBvcG92ZXIgaGFzIGEgbnVtYmVyIG9mIHRyaWdnZXJzIHdoaWNoIHByb3ZpZGVzIGFuIGFiaWxpdHkgdG8gc2hvdyBhbmQgaGlkZSB0aGUgY29tcG9uZW50IGluIGRpZmZlcmVudCB3YXlzOlxuICpcbiAqIC0gQ2xpY2sgbW9kZSBzaG93cyB0aGUgY29tcG9uZW50IHdoZW4gYSB1c2VyIGNsaWNrcyBvbiB0aGUgaG9zdCBlbGVtZW50IGFuZCBoaWRlcyB3aGVuIHRoZSB1c2VyIGNsaWNrc1xuICogc29tZXdoZXJlIG9uIHRoZSBkb2N1bWVudCBvdXRzaWRlIHRoZSBjb21wb25lbnQuXG4gKiAtIEhpbnQgcHJvdmlkZXMgY2FwYWJpbGl0eSB0byBzaG93IHRoZSBjb21wb25lbnQgd2hlbiB0aGUgdXNlciBob3ZlcnMgb3ZlciB0aGUgaG9zdCBlbGVtZW50XG4gKiBhbmQgaGlkZSB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdXQgb2YgdGhlIGhvc3QuXG4gKiAtIEhvdmVyIHdvcmtzIGxpa2UgaGludCBtb2RlIHdpdGggb25lIGV4Y2VwdGlvbiAtIHdoZW4gdGhlIHVzZXIgbW92ZXMgbW91c2UgZnJvbSBob3N0IGVsZW1lbnQgdG9cbiAqIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGUgY29tcG9uZW50IHJlbWFpbnMgb3Blbiwgc28gdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBpbnRlcmFjdCB3aXRoIGl0IGNvbnRlbnQuXG4gKiAtIEZvY3VzIG1vZGUgaXMgYXBwbGllZCB3aGVuIHVzZXIgZm9jdXNlcyB0aGUgZWxlbWVudC5cbiAqIC0gTm9vcCBtb2RlIC0gdGhlIGNvbXBvbmVudCB3b24ndCByZWFjdCB0byB0aGUgdXNlciBpbnRlcmFjdGlvbi5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEF2YWlsYWJsZSBUcmlnZ2VycywgcG9wb3Zlci9wb3BvdmVyLW1vZGVzLmNvbXBvbmVudC5odG1sKVxuICpcbiAqIE5vb3AgbW9kZSBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHlvdSBuZWVkIHRvIGNvbnRyb2wgUG9wb3ZlciBwcm9ncmFtbWF0aWNhbGx5LCBmb3IgZXhhbXBsZSBzaG93L2hpZGVcbiAqIGFzIGEgcmVzdWx0IG9mIHNvbWUgdGhpcmQtcGFydHkgYWN0aW9uLCBsaWtlIEhUVFAgcmVxdWVzdCBvciB2YWxpZGF0aW9uIGNoZWNrOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoTWFudWFsIENvbnRyb2wsIHBvcG92ZXIvcG9wb3Zlci1ub29wLmNvbXBvbmVudClcbiAqXG4gKiBCZWxvdyBhcmUgZXhhbXBsZXMgZm9yIG1hbnVhbCBwb3BvdmVyIHNldHRpbmdzIGNvbnRyb2wsIGJvdGggdmlhIHRlbXBsYXRlIGJpbmRpbmcgYW5kIGNvZGUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKFBvcG92ZXIgU2V0dGluZ3MsIHBvcG92ZXIvcG9wb3Zlci1keW5hbWljLmNvbXBvbmVudClcbiAqXG4gKiBQbGVhc2Ugbm90ZSwgd2hpbGUgbWFuaXB1bGF0aW5nIFBvcG92ZXIgc2V0dGluZyB2aWEgY29kZSwgeW91IG5lZWQgdG8gY2FsbCBgcmVidWlsZCgpYCBtZXRob2QgdG8gYXBwbHkgdGhlIHNldHRpbmdzXG4gKiBjaGFuZ2VkLlxuICogQHN0YWNrZWQtZXhhbXBsZShQb3BvdmVyIFNldHRpbmdzIENvZGUsIHBvcG92ZXIvcG9wb3Zlci1keW5hbWljLWNvZGUuY29tcG9uZW50KVxuICpcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoVGVtcGxhdGUgUmVmLCBwb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUtcmVmLmNvbXBvbmVudClcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoQ3VzdG9tIENvbXBvbmVudCwgcG9wb3Zlci9wb3BvdmVyLWN1c3RvbS1jb21wb25lbnQuY29tcG9uZW50KVxuICogKi9cbmxldCBOYlBvcG92ZXJEaXJlY3RpdmUgPSBjbGFzcyBOYlBvcG92ZXJEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYsIGR5bmFtaWNPdmVybGF5SGFuZGxlcikge1xuICAgICAgICB0aGlzLmhvc3RSZWYgPSBob3N0UmVmO1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlciA9IGR5bmFtaWNPdmVybGF5SGFuZGxlcjtcbiAgICAgICAgdGhpcy5wb3BvdmVyQ29tcG9uZW50ID0gTmJQb3BvdmVyQ29tcG9uZW50O1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRhaW5lciBjb250ZW50IGNvbnRleHQuIFdpbGwgYmUgYXBwbGllZCB0byB0aGUgcmVuZGVyZWQgY29tcG9uZW50LlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvc2l0aW9uIHdpbGwgYmUgY2FsY3VsYXRlZCByZWxhdGl2ZWx5IGhvc3QgZWxlbWVudCBiYXNlZCBvbiB0aGUgcG9zaXRpb24uXG4gICAgICAgICAqIENhbiBiZSB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHN0YXJ0IG9yIGVuZC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IE5iUG9zaXRpb24uVE9QO1xuICAgICAgICB0aGlzLl9hZGp1c3RtZW50ID0gTmJBZGp1c3RtZW50LkNMT0NLV0lTRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc2NyaWJlcyB3aGVuIHRoZSBjb250YWluZXIgd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQXZhaWxhYmxlIG9wdGlvbnM6IGBjbGlja2AsIGBob3ZlcmAsIGBoaW50YCwgYGZvY3VzYCBhbmQgYG5vb3BgXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMudHJpZ2dlciA9IE5iVHJpZ2dlci5DTElDSztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgcG9wb3ZlciBvZmZzZXRcbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAxNTtcbiAgICAgICAgdGhpcy5wb3BvdmVyQ2xhc3MgPSAnJztcbiAgICAgICAgdGhpcy5uYlBvcG92ZXJTaG93U3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRhaW5lciBwb3NpdGlvbiB3aWxsIGJlIGNoYW5nZXMgYXV0b21hdGljYWxseSBiYXNlZCBvbiB0aGlzIHN0cmF0ZWd5IGlmIGNvbnRhaW5lciBjYW4ndCBmaXQgdmlldyBwb3J0LlxuICAgICAqIFNldCB0aGlzIHByb3BlcnR5IHRvIGBub29wYCB2YWx1ZSBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIGF1dG9tYXRpY2FsbHkgYWRqdXN0bWVudC5cbiAgICAgKiBBdmFpbGFibGUgdmFsdWVzOiBgY2xvY2t3aXNlYCAoZGVmYXVsdCksIGBjb3VudGVyY2xvY2t3aXNlYCwgYHZlcnRpY2FsYCwgYGhvcml6b250YWxgLCBgbm9vcGAuXG4gICAgICogKi9cbiAgICBnZXQgYWRqdXN0bWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkanVzdG1lbnQ7XG4gICAgfVxuICAgIHNldCBhZGp1c3RtZW50KHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEBicmVha2luZy1jaGFuZ2UgUmVtb3ZlIEA1LjAuMFxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBGYWxzeSB2YWx1ZXMgZm9yICduYlBvcG92ZXJBZGp1c3RtZW50JyBhcmUgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIE5lYnVsYXIgNS5cbiBVc2UgJ25vb3AnIGluc3RlYWQuYCk7XG4gICAgICAgICAgICB2YWx1ZSA9IE5iQWRqdXN0bWVudC5OT09QO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FkanVzdG1lbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGlzU2hvd24oKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmR5bmFtaWNPdmVybGF5ICYmIHRoaXMuZHluYW1pY092ZXJsYXkuaXNBdHRhY2hlZCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlclxuICAgICAgICAgICAgLmhvc3QodGhpcy5ob3N0UmVmKVxuICAgICAgICAgICAgLmNvbXBvbmVudFR5cGUodGhpcy5wb3BvdmVyQ29tcG9uZW50KTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMucmVidWlsZCgpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkgPSB0aGlzLmNvbmZpZ3VyZUR5bmFtaWNPdmVybGF5KClcbiAgICAgICAgICAgIC5idWlsZCgpO1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5LmlzU2hvd25cbiAgICAgICAgICAgIC5waXBlKHNraXAoMSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGlzU2hvd24pID0+IHRoaXMubmJQb3BvdmVyU2hvd1N0YXRlQ2hhbmdlLmVtaXQoeyBpc1Nob3duIH0pKTtcbiAgICB9XG4gICAgcmVidWlsZCgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheSA9IHRoaXMuY29uZmlndXJlRHluYW1pY092ZXJsYXkoKVxuICAgICAgICAgICAgLnJlYnVpbGQoKTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS5zaG93KCk7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkuaGlkZSgpO1xuICAgIH1cbiAgICB0b2dnbGUoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkudG9nZ2xlKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZUR5bmFtaWNPdmVybGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5keW5hbWljT3ZlcmxheUhhbmRsZXJcbiAgICAgICAgICAgIC5wb3NpdGlvbih0aGlzLnBvc2l0aW9uKVxuICAgICAgICAgICAgLnRyaWdnZXIodGhpcy50cmlnZ2VyKVxuICAgICAgICAgICAgLm9mZnNldCh0aGlzLm9mZnNldClcbiAgICAgICAgICAgIC5hZGp1c3RtZW50KHRoaXMuYWRqdXN0bWVudClcbiAgICAgICAgICAgIC5jb250ZW50KHRoaXMuY29udGVudClcbiAgICAgICAgICAgIC5jb250ZXh0KHRoaXMuY29udGV4dClcbiAgICAgICAgICAgIC5vdmVybGF5Q29uZmlnKHsgcGFuZWxDbGFzczogdGhpcy5wb3BvdmVyQ2xhc3MgfSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkODAoW1xuICAgIElucHV0KCduYlBvcG92ZXInKSxcbiAgICBfX21ldGFkYXRhJDUxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJQb3BvdmVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDgwKFtcbiAgICBJbnB1dCgnbmJQb3BvdmVyQ29udGV4dCcpLFxuICAgIF9fbWV0YWRhdGEkNTEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYlBvcG92ZXJEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkODAoW1xuICAgIElucHV0KCduYlBvcG92ZXJQbGFjZW1lbnQnKSxcbiAgICBfX21ldGFkYXRhJDUxKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJQb3BvdmVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ4MChbXG4gICAgSW5wdXQoJ25iUG9wb3ZlckFkanVzdG1lbnQnKSxcbiAgICBfX21ldGFkYXRhJDUxKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhJDUxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBOYlBvcG92ZXJEaXJlY3RpdmUucHJvdG90eXBlLCBcImFkanVzdG1lbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDgwKFtcbiAgICBJbnB1dCgnbmJQb3BvdmVyVHJpZ2dlcicpLFxuICAgIF9fbWV0YWRhdGEkNTEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlBvcG92ZXJEaXJlY3RpdmUucHJvdG90eXBlLCBcInRyaWdnZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkODAoW1xuICAgIElucHV0KCduYlBvcG92ZXJPZmZzZXQnKSxcbiAgICBfX21ldGFkYXRhJDUxKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJQb3BvdmVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvZmZzZXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkODAoW1xuICAgIElucHV0KCduYlBvcG92ZXJDbGFzcycpLFxuICAgIF9fbWV0YWRhdGEkNTEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlBvcG92ZXJEaXJlY3RpdmUucHJvdG90eXBlLCBcInBvcG92ZXJDbGFzc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ4MChbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQ1MShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iUG9wb3ZlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwibmJQb3BvdmVyU2hvd1N0YXRlQ2hhbmdlXCIsIHZvaWQgMCk7XG5OYlBvcG92ZXJEaXJlY3RpdmUgPSBfX2RlY29yYXRlJDgwKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1tuYlBvcG92ZXJdJyxcbiAgICAgICAgZXhwb3J0QXM6ICduYlBvcG92ZXInLFxuICAgICAgICBwcm92aWRlcnM6IFtOYkR5bmFtaWNPdmVybGF5SGFuZGxlciwgTmJEeW5hbWljT3ZlcmxheV0sXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQ1MShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLFxuICAgICAgICBOYkR5bmFtaWNPdmVybGF5SGFuZGxlcl0pXG5dLCBOYlBvcG92ZXJEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ4NCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5sZXQgTmJQb3BvdmVyTW9kdWxlID0gY2xhc3MgTmJQb3BvdmVyTW9kdWxlIHtcbn07XG5OYlBvcG92ZXJNb2R1bGUgPSBfX2RlY29yYXRlJDg0KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtOYk92ZXJsYXlNb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYlBvcG92ZXJEaXJlY3RpdmUsIE5iUG9wb3ZlckNvbXBvbmVudF0sXG4gICAgICAgIGV4cG9ydHM6IFtOYlBvcG92ZXJEaXJlY3RpdmVdLFxuICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtOYlBvcG92ZXJDb21wb25lbnRdLFxuICAgIH0pXG5dLCBOYlBvcG92ZXJNb2R1bGUpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ4NiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1NiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBDb250ZXh0IG1lbnUgY29tcG9uZW50IHVzZWQgYXMgY29udGVudCB3aXRoaW4gTmJDb250ZXh0TWVudURpcmVjdGl2ZS5cbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogY29udGV4dC1tZW51LWJhY2tncm91bmQtY29sb3I6XG4gKiBjb250ZXh0LW1lbnUtYm9yZGVyLWNvbG9yOlxuICogY29udGV4dC1tZW51LWJvcmRlci1zdHlsZTpcbiAqIGNvbnRleHQtbWVudS1ib3JkZXItd2lkdGg6XG4gKiBjb250ZXh0LW1lbnUtYm9yZGVyLXJhZGl1czpcbiAqIGNvbnRleHQtbWVudS1taW4td2lkdGg6XG4gKiBjb250ZXh0LW1lbnUtbWF4LXdpZHRoOlxuICogY29udGV4dC1tZW51LXNoYWRvdzpcbiAqICovXG5sZXQgTmJDb250ZXh0TWVudUNvbXBvbmVudCA9IGNsYXNzIE5iQ29udGV4dE1lbnVDb21wb25lbnQgZXh0ZW5kcyBOYlBvc2l0aW9uZWRDb250YWluZXIge1xuICAgIC8qKlxuICAgICAqIENvbnRleHQgbWVudSBjb21wb25lbnQgdXNlZCBhcyBjb250ZW50IHdpdGhpbiBOYkNvbnRleHRNZW51RGlyZWN0aXZlLlxuICAgICAqXG4gICAgICogQHN0eWxlc1xuICAgICAqXG4gICAgICogY29udGV4dC1tZW51LWJhY2tncm91bmQtY29sb3I6XG4gICAgICogY29udGV4dC1tZW51LWJvcmRlci1jb2xvcjpcbiAgICAgKiBjb250ZXh0LW1lbnUtYm9yZGVyLXN0eWxlOlxuICAgICAqIGNvbnRleHQtbWVudS1ib3JkZXItd2lkdGg6XG4gICAgICogY29udGV4dC1tZW51LWJvcmRlci1yYWRpdXM6XG4gICAgICogY29udGV4dC1tZW51LW1pbi13aWR0aDpcbiAgICAgKiBjb250ZXh0LW1lbnUtbWF4LXdpZHRoOlxuICAgICAqIGNvbnRleHQtbWVudS1zaGFkb3c6XG4gICAgICogKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB7IGl0ZW1zOiBbXSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbWV0aG9kIGlzIGVtcHR5IHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgYWRkaXRpb25hbGx5XG4gICAgICogcmVuZGVyIGlzIGhhbmRsZWQgYnkgY2hhbmdlIGRldGVjdGlvblxuICAgICAqL1xuICAgIHJlbmRlckNvbnRlbnQoKSB7IH1cbn07XG5fX2RlY29yYXRlJDg2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNTYoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIE5iQ29udGV4dE1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcIml0ZW1zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDg2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNTYoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNvbnRleHRNZW51Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkODYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ1NihcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ29udGV4dE1lbnVDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbk5iQ29udGV4dE1lbnVDb21wb25lbnQgPSBfX2RlY29yYXRlJDg2KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWNvbnRleHQtbWVudScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLW1lbnUgY2xhc3M9XCJjb250ZXh0LW1lbnVcIiBbaXRlbXNdPVwiY29udGV4dC5pdGVtc1wiIFt0YWddPVwiY29udGV4dC50YWdcIj48L25iLW1lbnU+XG4gIGBcbiAgICB9KVxuXSwgTmJDb250ZXh0TWVudUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDg1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDU1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIEZ1bGwgZmVhdHVyZWQgY29udGV4dCBtZW51IGRpcmVjdGl2ZS5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBjb250ZXh0LW1lbnUvY29udGV4dC1tZW51LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBKdXN0IHBhc3MgbWVudSBpdGVtcyBhcnJheTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8YnV0dG9uIFtuYkNvbnRleHRNZW51XT1cIml0ZW1zXCI+PC9idXR0b24+XG4gKiAuLi5cbiAqIGl0ZW1zID0gW3sgdGl0bGU6ICdQcm9maWxlJyB9LCB7IHRpdGxlOiAnTG9nIG91dCcgfV07XG4gKiBgYGBcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iQ29udGV4dE1lbnVNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iQ29udGV4dE1lbnVNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqIEFsc28gbWFrZSBzdXJlIGBOYk1lbnVNb2R1bGVgIGlzIGltcG9ydGVkIHRvIHlvdXIgYGFwcC5tb2R1bGVgLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYk1lbnVNb2R1bGUuZm9yUm9vdCgpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBoYW5kbGUgY29udGV4dCBtZW51IGNsaWNrcyB5b3UgaGF2ZSB0byBwYXNzIGBuYkNvbnRleHRNZW51VGFnYFxuICogcGFyYW0gYW5kIHJlZ2lzdGVyIHRvIGV2ZW50cyB1c2luZyBOYk1lbnVTZXJ2aWNlLlxuICogYE5iQ29udGV4dE1lbnVgIHJlbmRlcnMgcGxhaW4gYE5iTWVudWAgaW5zaWRlLCBzb1xuICogeW91IGhhdmUgdG8gd29yayB3aXRoIGl0IGp1c3QgbGlrZSB3aXRoIGBOYk1lbnVgIGNvbXBvbmVudDpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKE1lbnUgaXRlbSBjbGljaywgY29udGV4dC1tZW51L2NvbnRleHQtbWVudS1jbGljay5jb21wb25lbnQpXG4gKlxuICogQ29udGV4dCBtZW51IGhhcyBkaWZmZXJlbnQgcGxhY2VtZW50cywgc3VjaCBhczogdG9wLCBib3R0b20sIGxlZnQgYW5kIHJpZ2h0XG4gKiB3aGljaCBjYW4gYmUgdXNlZCBhcyBmb2xsb3dpbmc6XG4gKlxuICogYGBgaHRtbFxuICogPGJ1dHRvbiBbbmJDb250ZXh0TWVudV09XCJpdGVtc1wiIG5iQ29udGV4dE1lbnVQbGFjZW1lbnQ9XCJyaWdodFwiPjwvYnV0dG9uPlxuICogYGBgXG4gKlxuICogYGBgdHNcbiAqIGl0ZW1zID0gW3sgdGl0bGU6ICdQcm9maWxlJyB9LCB7IHRpdGxlOiAnTG9nIG91dCcgfV07XG4gKiBgYGBcbiAqXG4gKiBCeSBkZWZhdWx0IGNvbnRleHQgbWVudSB3aWxsIHRyeSB0byBhZGp1c3QgaXRzZWxmIHRvIG1heGltYWxseSBmaXQgdmlld3BvcnRcbiAqIGFuZCBwcm92aWRlIHRoZSBiZXN0IHVzZXIgZXhwZXJpZW5jZS4gSXQgd2lsbCB0cnkgdG8gY2hhbmdlIHBvc2l0aW9uIG9mIHRoZSBjb250ZXh0IG1lbnUuXG4gKiBJZiB5b3Ugd2FubmEgZGlzYWJsZSB0aGlzIGJlaGF2aW91ciBqdXN0IHNldCBpdCBmYWxzeSB2YWx1ZS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8YnV0dG9uIFtuYkNvbnRleHRNZW51XT1cIml0ZW1zXCIgbmJDb250ZXh0TWVudUFkanVzdG1lbnQ9XCJjb3VudGVyY2xvY2t3aXNlXCI+PC9idXR0b24+XG4gKiBgYGBcbiAqXG4gKiBgYGB0c1xuICogaXRlbXMgPSBbeyB0aXRsZTogJ1Byb2ZpbGUnIH0sIHsgdGl0bGU6ICdMb2cgb3V0JyB9XTtcbiAqIGBgYFxuICogQ29udGV4dCBtZW51IGhhcyBhIG51bWJlciBvZiB0cmlnZ2VycyB3aGljaCBwcm92aWRlcyBhbiBhYmlsaXR5IHRvIHNob3cgYW5kIGhpZGUgdGhlIGNvbXBvbmVudCBpbiBkaWZmZXJlbnQgd2F5czpcbiAqXG4gKiAtIENsaWNrIG1vZGUgc2hvd3MgdGhlIGNvbXBvbmVudCB3aGVuIGEgdXNlciBjbGlja3Mgb24gdGhlIGhvc3QgZWxlbWVudCBhbmQgaGlkZXMgd2hlbiB0aGUgdXNlciBjbGlja3NcbiAqIHNvbWV3aGVyZSBvbiB0aGUgZG9jdW1lbnQgb3V0c2lkZSB0aGUgY29tcG9uZW50LlxuICogLSBIaW50IHByb3ZpZGVzIGNhcGFiaWxpdHkgdG8gc2hvdyB0aGUgY29tcG9uZW50IHdoZW4gdGhlIHVzZXIgaG92ZXJzIG92ZXIgdGhlIGhvc3QgZWxlbWVudFxuICogYW5kIGhpZGUgd2hlbiB0aGUgdXNlciBob3ZlcnMgb3V0IG9mIHRoZSBob3N0LlxuICogLSBIb3ZlciB3b3JrcyBsaWtlIGhpbnQgbW9kZSB3aXRoIG9uZSBleGNlcHRpb24gLSB3aGVuIHRoZSB1c2VyIG1vdmVzIG1vdXNlIGZyb20gaG9zdCBlbGVtZW50IHRvXG4gKiB0aGUgY29udGFpbmVyIGVsZW1lbnQgdGhlIGNvbXBvbmVudCByZW1haW5zIG9wZW4sIHNvIHRoYXQgaXQgaXMgcG9zc2libGUgdG8gaW50ZXJhY3Qgd2l0aCBpdCBjb250ZW50LlxuICogLSBGb2N1cyBtb2RlIGlzIGFwcGxpZWQgd2hlbiB1c2VyIGZvY3VzZXMgdGhlIGVsZW1lbnQuXG4gKiAtIE5vb3AgbW9kZSAtIHRoZSBjb21wb25lbnQgd29uJ3QgcmVhY3QgdG8gdGhlIHVzZXIgaW50ZXJhY3Rpb24uXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShBdmFpbGFibGUgVHJpZ2dlcnMsIGNvbnRleHQtbWVudS9jb250ZXh0LW1lbnUtbW9kZXMuY29tcG9uZW50Lmh0bWwpXG4gKlxuICogTm9vcCBtb2RlIGlzIGVzcGVjaWFsbHkgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gY29udHJvbCBQb3BvdmVyIHByb2dyYW1tYXRpY2FsbHksIGZvciBleGFtcGxlIHNob3cvaGlkZVxuICogYXMgYSByZXN1bHQgb2Ygc29tZSB0aGlyZC1wYXJ0eSBhY3Rpb24sIGxpa2UgSFRUUCByZXF1ZXN0IG9yIHZhbGlkYXRpb24gY2hlY2s6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShNYW51YWwgQ29udHJvbCwgY29udGV4dC1tZW51L2NvbnRleHQtbWVudS1ub29wLmNvbXBvbmVudClcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKE1hbnVhbCBDb250cm9sLCBjb250ZXh0LW1lbnUvY29udGV4dC1tZW51LXJpZ2h0LWNsaWNrLmNvbXBvbmVudClcbiAqICovXG5sZXQgTmJDb250ZXh0TWVudURpcmVjdGl2ZSA9IGNsYXNzIE5iQ29udGV4dE1lbnVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYsIG1lbnVTZXJ2aWNlLCBkeW5hbWljT3ZlcmxheUhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5ob3N0UmVmID0gaG9zdFJlZjtcbiAgICAgICAgdGhpcy5tZW51U2VydmljZSA9IG1lbnVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlciA9IGR5bmFtaWNPdmVybGF5SGFuZGxlcjtcbiAgICAgICAgdGhpcy5jb250ZXh0TWVudUhvc3QgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUG9zaXRpb24gd2lsbCBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlbHkgaG9zdCBlbGVtZW50IGJhc2VkIG9uIHRoZSBwb3NpdGlvbi5cbiAgICAgICAgICogQ2FuIGJlIHRvcCwgcmlnaHQsIGJvdHRvbSBhbmQgbGVmdC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IE5iUG9zaXRpb24uQk9UVE9NO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29udGFpbmVyIHBvc2l0aW9uIHdpbGwgYmUgY2hhbmdlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHRoaXMgc3RyYXRlZ3kgaWYgY29udGFpbmVyIGNhbid0IGZpdCB2aWV3IHBvcnQuXG4gICAgICAgICAqIFNldCB0aGlzIHByb3BlcnR5IHRvIGFueSBmYWxzeSB2YWx1ZSBpZiB5b3Ugd2FudCB0byBkaXNhYmxlIGF1dG9tYXRpY2FsbHkgYWRqdXN0bWVudC5cbiAgICAgICAgICogQXZhaWxhYmxlIHZhbHVlczogY2xvY2t3aXNlLCBjb3VudGVyY2xvY2t3aXNlLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmFkanVzdG1lbnQgPSBOYkFkanVzdG1lbnQuQ0xPQ0tXSVNFO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzY3JpYmVzIHdoZW4gdGhlIGNvbnRhaW5lciB3aWxsIGJlIHNob3duLlxuICAgICAgICAgKiBBdmFpbGFibGUgb3B0aW9uczogYGNsaWNrYCwgYGhvdmVyYCwgYGhpbnRgLCBgZm9jdXNgIGFuZCBgbm9vcGBcbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy50cmlnZ2VyID0gTmJUcmlnZ2VyLkNMSUNLO1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51Q2xhc3MgPSAnJztcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhc2ljIG1lbnUgaXRlbXMsIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBpbnRlcm5hbCBOYk1lbnVDb21wb25lbnQuXG4gICAgICogKi9cbiAgICBzZXQgaXRlbXMoaXRlbXMpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUl0ZW1zKGl0ZW1zKTtcbiAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcbiAgICB9XG4gICAgO1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlclxuICAgICAgICAgICAgLmhvc3QodGhpcy5ob3N0UmVmKVxuICAgICAgICAgICAgLmNvbXBvbmVudFR5cGUoTmJDb250ZXh0TWVudUNvbXBvbmVudCk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLnJlYnVpbGQoKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5ID0gdGhpcy5jb25maWd1cmVEeW5hbWljT3ZlcmxheSgpXG4gICAgICAgICAgICAuYnVpbGQoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPbkl0ZW1DbGljaygpO1xuICAgIH1cbiAgICByZWJ1aWxkKCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5ID0gdGhpcy5jb25maWd1cmVEeW5hbWljT3ZlcmxheSgpXG4gICAgICAgICAgICAucmVidWlsZCgpO1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5LnNob3coKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS5oaWRlKCk7XG4gICAgfVxuICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS50b2dnbGUoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXlIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgY29uZmlndXJlRHluYW1pY092ZXJsYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlclxuICAgICAgICAgICAgLnBvc2l0aW9uKHRoaXMucG9zaXRpb24pXG4gICAgICAgICAgICAudHJpZ2dlcih0aGlzLnRyaWdnZXIpXG4gICAgICAgICAgICAuYWRqdXN0bWVudCh0aGlzLmFkanVzdG1lbnQpXG4gICAgICAgICAgICAuY29udGV4dCh7XG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvbixcbiAgICAgICAgICAgIGl0ZW1zOiB0aGlzLl9pdGVtcyxcbiAgICAgICAgICAgIHRhZzogdGhpcy50YWcsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAub3ZlcmxheUNvbmZpZyh7IHBhbmVsQ2xhc3M6IHRoaXMuY29udGV4dE1lbnVDbGFzcyB9KTtcbiAgICB9XG4gICAgLypcbiAgICAgKiBOYk1lbnVDb21wb25lbnQgd2lsbCBjcmFzaCBpZiBkb24ndCBwYXNzIG1lbnUgaXRlbXMgdG8gaXQuXG4gICAgICogU28sIHdlIGp1c3QgdmFsaWRhdGluZyB0aGVtIGFuZCB0aHJvdyBjdXN0b20gb2J2aW91cyBlcnJvci5cbiAgICAgKiAqL1xuICAgIHZhbGlkYXRlSXRlbXMoaXRlbXMpIHtcbiAgICAgICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgTGlzdCBvZiBtZW51IGl0ZW1zIGV4cGVjdGVkLCBidXQgZ2l2ZW46ICR7aXRlbXN9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3Vic2NyaWJlT25JdGVtQ2xpY2soKSB7XG4gICAgICAgIHRoaXMubWVudVNlcnZpY2Uub25JdGVtQ2xpY2soKVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpLCBmaWx0ZXIoKHsgdGFnIH0pID0+IHRhZyA9PT0gdGhpcy50YWcpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmhpZGUoKSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkODUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5jb250ZXh0LW1lbnUtaG9zdCcpLFxuICAgIF9fbWV0YWRhdGEkNTUoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkNvbnRleHRNZW51RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250ZXh0TWVudUhvc3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkODUoW1xuICAgIElucHV0KCduYkNvbnRleHRNZW51UGxhY2VtZW50JyksXG4gICAgX19tZXRhZGF0YSQ1NShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ29udGV4dE1lbnVEaXJlY3RpdmUucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDg1KFtcbiAgICBJbnB1dCgnbmJDb250ZXh0TWVudUFkanVzdG1lbnQnKSxcbiAgICBfX21ldGFkYXRhJDU1KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJDb250ZXh0TWVudURpcmVjdGl2ZS5wcm90b3R5cGUsIFwiYWRqdXN0bWVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ4NShbXG4gICAgSW5wdXQoJ25iQ29udGV4dE1lbnVUYWcnKSxcbiAgICBfX21ldGFkYXRhJDU1KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJDb250ZXh0TWVudURpcmVjdGl2ZS5wcm90b3R5cGUsIFwidGFnXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDg1KFtcbiAgICBJbnB1dCgnbmJDb250ZXh0TWVudScpLFxuICAgIF9fbWV0YWRhdGEkNTUoXCJkZXNpZ246dHlwZVwiLCBBcnJheSksXG4gICAgX19tZXRhZGF0YSQ1NShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtBcnJheV0pXG5dLCBOYkNvbnRleHRNZW51RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpdGVtc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkODUoW1xuICAgIElucHV0KCduYkNvbnRleHRNZW51VHJpZ2dlcicpLFxuICAgIF9fbWV0YWRhdGEkNTUoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNvbnRleHRNZW51RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0cmlnZ2VyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDg1KFtcbiAgICBJbnB1dCgnbmJDb250ZXh0TWVudUNsYXNzJyksXG4gICAgX19tZXRhZGF0YSQ1NShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ29udGV4dE1lbnVEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRleHRNZW51Q2xhc3NcIiwgdm9pZCAwKTtcbk5iQ29udGV4dE1lbnVEaXJlY3RpdmUgPSBfX2RlY29yYXRlJDg1KFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1tuYkNvbnRleHRNZW51XScsXG4gICAgICAgIHByb3ZpZGVyczogW05iRHluYW1pY092ZXJsYXlIYW5kbGVyLCBOYkR5bmFtaWNPdmVybGF5XSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDU1KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIE5iTWVudVNlcnZpY2UsXG4gICAgICAgIE5iRHluYW1pY092ZXJsYXlIYW5kbGVyXSlcbl0sIE5iQ29udGV4dE1lbnVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ4NyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5sZXQgTmJDb250ZXh0TWVudU1vZHVsZSA9IGNsYXNzIE5iQ29udGV4dE1lbnVNb2R1bGUge1xufTtcbk5iQ29udGV4dE1lbnVNb2R1bGUgPSBfX2RlY29yYXRlJDg3KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE5iT3ZlcmxheU1vZHVsZSwgTmJNZW51TW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW05iQ29udGV4dE1lbnVEaXJlY3RpdmVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYkNvbnRleHRNZW51RGlyZWN0aXZlLCBOYkNvbnRleHRNZW51Q29tcG9uZW50XSxcbiAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTmJDb250ZXh0TWVudUNvbXBvbmVudF0sXG4gICAgfSlcbl0sIE5iQ29udGV4dE1lbnVNb2R1bGUpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ4OCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1NyA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBQcm9ncmVzcyBCYXIgaXMgYSBjb21wb25lbnQgZm9yIGluZGljYXRpbmcgcHJvZ3Jlc3MuXG4gKlxuICogU2ltcGxlIHVzYWdlOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1wcm9ncmVzcy1iYXIgW3ZhbHVlXT1cIjUwXCI+PC9uYi1wcm9ncmVzcy1iYXI+XG4gKiBgYGBcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iUHJvZ3Jlc3NCYXJNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iUHJvZ3Jlc3NCYXJNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIFByb2dyZXNzIGJhciBhY2NlcHRzIHByb3BlcnR5IGB2YWx1ZWAgaW4gcmFuZ2UgMC0xMDBcbiAqIEBzdGFja2VkLWV4YW1wbGUoUHJvZ3Jlc3MgYmFyLCBwcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBQcm9ncmVzcyBiYXIgYmFja2dyb3VuZCBjb3VsZCBiZSBjb25maWd1cmVkIGJ5IHByb3ZpZGluZyBhIGBzdGF0dXNgIHByb3BlcnR5OlxuICogQHN0YWNrZWQtZXhhbXBsZShQcm9ncmVzcyBiYXIgc3RhdHVzLCBwcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLXN0YXR1cy5jb21wb25lbnQpXG4gKlxuICogUHJvZ3Jlc3MgYmFyIHNpemUgKGhlaWdodCBhbmQgZm9udC1zaXplKSBjb3VsZCBiZSBjb25maWd1cmVkIGJ5IHByb3ZpZGluZyBhIGBzaXplYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoUHJvZ3Jlc3MgYmFyIHNpemUsIHByb2dyZXNzLWJhci9wcm9ncmVzcy1iYXItc2l6ZS5jb21wb25lbnQpXG4gKlxuICogYGRpc3BsYXlWYWx1ZWAgcHJvcGVydHkgc2hvd3MgY3VycmVudCB2YWx1ZSBpbnNpZGUgcHJvZ3Jlc3MgYmFyLiBJdCdzIGFsc28gcG9zc2libGUgdG8gYWRkIGN1c3RvbSB0ZXh0IGluc2lkZTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoUHJvZ3Jlc3MgYmFyIHZhbHVlLCBwcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLXZhbHVlLmNvbXBvbmVudClcbiAqXG4gKiBQcm9ncmVzcyBiYXIgc3VwcG9ydHMgYHdpZHRoYCBhbmQgYGJhY2tncm91bmQtY29sb3JgIHRyYW5zaXRpb246XG4gKiBAc3RhY2tlZC1leGFtcGxlKFByb2dyZXNzIGJhciBpbnRlcmFjdGl2ZSwgcHJvZ3Jlc3MtYmFyL3Byb2dyZXNzLWJhci1pbnRlcmFjdGl2ZS5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHByb2dyZXNzLWJhci1hbmltYXRpb24tZHVyYXRpb246XG4gKiBwcm9ncmVzcy1iYXItYm9yZGVyLXJhZGl1czpcbiAqIHByb2dyZXNzLWJhci10ZXh0LWZvbnQtZmFtaWx5OlxuICogcHJvZ3Jlc3MtYmFyLXRpbnktaGVpZ2h0OlxuICogcHJvZ3Jlc3MtYmFyLXRpbnktdGV4dC1mb250LXNpemU6XG4gKiBwcm9ncmVzcy1iYXItdGlueS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogcHJvZ3Jlc3MtYmFyLXRpbnktdGV4dC1saW5lLWhlaWdodDpcbiAqIHByb2dyZXNzLWJhci1zbWFsbC1oZWlnaHQ6XG4gKiBwcm9ncmVzcy1iYXItc21hbGwtdGV4dC1mb250LXNpemU6XG4gKiBwcm9ncmVzcy1iYXItc21hbGwtdGV4dC1mb250LXdlaWdodDpcbiAqIHByb2dyZXNzLWJhci1zbWFsbC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogcHJvZ3Jlc3MtYmFyLW1lZGl1bS1oZWlnaHQ6XG4gKiBwcm9ncmVzcy1iYXItbWVkaXVtLXRleHQtZm9udC1zaXplOlxuICogcHJvZ3Jlc3MtYmFyLW1lZGl1bS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogcHJvZ3Jlc3MtYmFyLW1lZGl1bS10ZXh0LWxpbmUtaGVpZ2h0OlxuICogcHJvZ3Jlc3MtYmFyLWxhcmdlLWhlaWdodDpcbiAqIHByb2dyZXNzLWJhci1sYXJnZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHByb2dyZXNzLWJhci1sYXJnZS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogcHJvZ3Jlc3MtYmFyLWxhcmdlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBwcm9ncmVzcy1iYXItZ2lhbnQtaGVpZ2h0OlxuICogcHJvZ3Jlc3MtYmFyLWdpYW50LXRleHQtZm9udC1zaXplOlxuICogcHJvZ3Jlc3MtYmFyLWdpYW50LXRleHQtZm9udC13ZWlnaHQ6XG4gKiBwcm9ncmVzcy1iYXItZ2lhbnQtdGV4dC1saW5lLWhlaWdodDpcbiAqIHByb2dyZXNzLWJhci1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLWJhc2ljLWZpbGxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLWJhc2ljLXRleHQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLXByaW1hcnktZmlsbGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLXN1Y2Nlc3MtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci1zdWNjZXNzLWZpbGxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItaW5mby1maWxsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci1pbmZvLXRleHQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItd2FybmluZy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLXdhcm5pbmctZmlsbGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItd2FybmluZy10ZXh0LWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcHJvZ3Jlc3MtYmFyLWRhbmdlci1maWxsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gKiBwcm9ncmVzcy1iYXItY29udHJvbC1maWxsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHByb2dyZXNzLWJhci1jb250cm9sLXRleHQtY29sb3I6XG4gKi9cbmxldCBOYlByb2dyZXNzQmFyQ29tcG9uZW50ID0gY2xhc3MgTmJQcm9ncmVzc0JhckNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogUHJvZ3Jlc3MgQmFyIGlzIGEgY29tcG9uZW50IGZvciBpbmRpY2F0aW5nIHByb2dyZXNzLlxuICAgICAqXG4gICAgICogU2ltcGxlIHVzYWdlOlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuYi1wcm9ncmVzcy1iYXIgW3ZhbHVlXT1cIjUwXCI+PC9uYi1wcm9ncmVzcy1iYXI+XG4gICAgICogYGBgXG4gICAgICogIyMjIEluc3RhbGxhdGlvblxuICAgICAqXG4gICAgICogSW1wb3J0IGBOYlByb2dyZXNzQmFyTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICAgICAqIGBgYHRzXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIGltcG9ydHM6IFtcbiAgICAgKiAgICAgLy8gLi4uXG4gICAgICogICAgIE5iUHJvZ3Jlc3NCYXJNb2R1bGUsXG4gICAgICogICBdLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gICAgICogYGBgXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBQcm9ncmVzcyBiYXIgYWNjZXB0cyBwcm9wZXJ0eSBgdmFsdWVgIGluIHJhbmdlIDAtMTAwXG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShQcm9ncmVzcyBiYXIsIHByb2dyZXNzLWJhci9wcm9ncmVzcy1iYXItc2hvd2Nhc2UuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogUHJvZ3Jlc3MgYmFyIGJhY2tncm91bmQgY291bGQgYmUgY29uZmlndXJlZCBieSBwcm92aWRpbmcgYSBgc3RhdHVzYCBwcm9wZXJ0eTpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFByb2dyZXNzIGJhciBzdGF0dXMsIHByb2dyZXNzLWJhci9wcm9ncmVzcy1iYXItc3RhdHVzLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIFByb2dyZXNzIGJhciBzaXplIChoZWlnaHQgYW5kIGZvbnQtc2l6ZSkgY291bGQgYmUgY29uZmlndXJlZCBieSBwcm92aWRpbmcgYSBgc2l6ZWAgcHJvcGVydHk6XG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShQcm9ncmVzcyBiYXIgc2l6ZSwgcHJvZ3Jlc3MtYmFyL3Byb2dyZXNzLWJhci1zaXplLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIGBkaXNwbGF5VmFsdWVgIHByb3BlcnR5IHNob3dzIGN1cnJlbnQgdmFsdWUgaW5zaWRlIHByb2dyZXNzIGJhci4gSXQncyBhbHNvIHBvc3NpYmxlIHRvIGFkZCBjdXN0b20gdGV4dCBpbnNpZGU6XG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShQcm9ncmVzcyBiYXIgdmFsdWUsIHByb2dyZXNzLWJhci9wcm9ncmVzcy1iYXItdmFsdWUuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogUHJvZ3Jlc3MgYmFyIHN1cHBvcnRzIGB3aWR0aGAgYW5kIGBiYWNrZ3JvdW5kLWNvbG9yYCB0cmFuc2l0aW9uOlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoUHJvZ3Jlc3MgYmFyIGludGVyYWN0aXZlLCBwcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLWludGVyYWN0aXZlLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEBzdHlsZXNcbiAgICAgKlxuICAgICAqIHByb2dyZXNzLWJhci1hbmltYXRpb24tZHVyYXRpb246XG4gICAgICogcHJvZ3Jlc3MtYmFyLWJvcmRlci1yYWRpdXM6XG4gICAgICogcHJvZ3Jlc3MtYmFyLXRleHQtZm9udC1mYW1pbHk6XG4gICAgICogcHJvZ3Jlc3MtYmFyLXRpbnktaGVpZ2h0OlxuICAgICAqIHByb2dyZXNzLWJhci10aW55LXRleHQtZm9udC1zaXplOlxuICAgICAqIHByb2dyZXNzLWJhci10aW55LXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogcHJvZ3Jlc3MtYmFyLXRpbnktdGV4dC1saW5lLWhlaWdodDpcbiAgICAgKiBwcm9ncmVzcy1iYXItc21hbGwtaGVpZ2h0OlxuICAgICAqIHByb2dyZXNzLWJhci1zbWFsbC10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBwcm9ncmVzcy1iYXItc21hbGwtdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBwcm9ncmVzcy1iYXItc21hbGwtdGV4dC1saW5lLWhlaWdodDpcbiAgICAgKiBwcm9ncmVzcy1iYXItbWVkaXVtLWhlaWdodDpcbiAgICAgKiBwcm9ncmVzcy1iYXItbWVkaXVtLXRleHQtZm9udC1zaXplOlxuICAgICAqIHByb2dyZXNzLWJhci1tZWRpdW0tdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBwcm9ncmVzcy1iYXItbWVkaXVtLXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogcHJvZ3Jlc3MtYmFyLWxhcmdlLWhlaWdodDpcbiAgICAgKiBwcm9ncmVzcy1iYXItbGFyZ2UtdGV4dC1mb250LXNpemU6XG4gICAgICogcHJvZ3Jlc3MtYmFyLWxhcmdlLXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogcHJvZ3Jlc3MtYmFyLWxhcmdlLXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogcHJvZ3Jlc3MtYmFyLWdpYW50LWhlaWdodDpcbiAgICAgKiBwcm9ncmVzcy1iYXItZ2lhbnQtdGV4dC1mb250LXNpemU6XG4gICAgICogcHJvZ3Jlc3MtYmFyLWdpYW50LXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogcHJvZ3Jlc3MtYmFyLWdpYW50LXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogcHJvZ3Jlc3MtYmFyLWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogcHJvZ3Jlc3MtYmFyLWJhc2ljLWZpbGxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHByb2dyZXNzLWJhci1iYXNpYy10ZXh0LWNvbG9yOlxuICAgICAqIHByb2dyZXNzLWJhci1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gICAgICogcHJvZ3Jlc3MtYmFyLXByaW1hcnktZmlsbGVkLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogcHJvZ3Jlc3MtYmFyLXByaW1hcnktdGV4dC1jb2xvcjpcbiAgICAgKiBwcm9ncmVzcy1iYXItc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHByb2dyZXNzLWJhci1zdWNjZXNzLWZpbGxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHByb2dyZXNzLWJhci1zdWNjZXNzLXRleHQtY29sb3I6XG4gICAgICogcHJvZ3Jlc3MtYmFyLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBwcm9ncmVzcy1iYXItaW5mby1maWxsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBwcm9ncmVzcy1iYXItaW5mby10ZXh0LWNvbG9yOlxuICAgICAqIHByb2dyZXNzLWJhci13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogcHJvZ3Jlc3MtYmFyLXdhcm5pbmctZmlsbGVkLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogcHJvZ3Jlc3MtYmFyLXdhcm5pbmctdGV4dC1jb2xvcjpcbiAgICAgKiBwcm9ncmVzcy1iYXItZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogcHJvZ3Jlc3MtYmFyLWRhbmdlci1maWxsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBwcm9ncmVzcy1iYXItZGFuZ2VyLXRleHQtY29sb3I6XG4gICAgICogcHJvZ3Jlc3MtYmFyLWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBwcm9ncmVzcy1iYXItY29udHJvbC1maWxsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBwcm9ncmVzcy1iYXItY29udHJvbC10ZXh0LWNvbG9yOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZ3Jlc3MgYmFyIHZhbHVlIGluIHBlcmNlbnQgKDAgLSAxMDApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2dyZXNzIGJhciBiYWNrZ3JvdW5kIChgYmFzaWNgLCBgcHJpbWFyeWAgKGRlZmF1bHQpLCBgaW5mb2AsIGBzdWNjZXNzYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCwgYGNvbnRyb2xgKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAncHJpbWFyeSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9ncmVzcyBiYXIgc2l6ZSAoYHRpbnlgLCBgc21hbGxgLCBgbWVkaXVtYCAoZGVmYXVsdCksIGBsYXJnZWAsIGBnaWFudGApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpemUgPSAnbWVkaXVtJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXlzIHZhbHVlIGluc2lkZSBwcm9ncmVzcyBiYXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCB0aW55KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAndGlueSc7XG4gICAgfVxuICAgIGdldCBzbWFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3NtYWxsJztcbiAgICB9XG4gICAgZ2V0IG1lZGl1bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ21lZGl1bSc7XG4gICAgfVxuICAgIGdldCBsYXJnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2xhcmdlJztcbiAgICB9XG4gICAgZ2V0IGdpYW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnZ2lhbnQnO1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAncHJpbWFyeSc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgd2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnd2FybmluZyc7XG4gICAgfVxuICAgIGdldCBkYW5nZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Rhbmdlcic7XG4gICAgfVxuICAgIGdldCBiYXNpYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnYmFzaWMnO1xuICAgIH1cbiAgICBnZXQgY29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnY29udHJvbCc7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkODgoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE5iUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDg4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNTcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlByb2dyZXNzQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGF0dXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkODgoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkODgoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYlByb2dyZXNzQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNwbGF5VmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkODgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLXRpbnknKSxcbiAgICBfX21ldGFkYXRhJDU3KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJQcm9ncmVzc0JhckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGlueVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkODgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLXNtYWxsJyksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNTcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcInNtYWxsXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ4OChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtbWVkaXVtJyksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNTcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1lZGl1bVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkODgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLWxhcmdlJyksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNTcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImxhcmdlXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ4OChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtZ2lhbnQnKSxcbiAgICBfX21ldGFkYXRhJDU3KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJQcm9ncmVzc0JhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2lhbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDg4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLXByaW1hcnknKSxcbiAgICBfX21ldGFkYXRhJDU3KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJQcm9ncmVzc0JhckNvbXBvbmVudC5wcm90b3R5cGUsIFwicHJpbWFyeVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkODgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtc3VjY2VzcycpLFxuICAgIF9fbWV0YWRhdGEkNTcoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDU3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlByb2dyZXNzQmFyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdWNjZXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ4OChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1pbmZvJyksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNTcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImluZm9cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDg4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLXdhcm5pbmcnKSxcbiAgICBfX21ldGFkYXRhJDU3KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJQcm9ncmVzc0JhckNvbXBvbmVudC5wcm90b3R5cGUsIFwid2FybmluZ1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkODgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtZGFuZ2VyJyksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNTcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iUHJvZ3Jlc3NCYXJDb21wb25lbnQucHJvdG90eXBlLCBcImRhbmdlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUkODgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtYmFzaWMnKSxcbiAgICBfX21ldGFkYXRhJDU3KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJQcm9ncmVzc0JhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFzaWNcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDg4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWNvbnRyb2wnKSxcbiAgICBfX21ldGFkYXRhJDU3KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJQcm9ncmVzc0JhckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCBudWxsKTtcbk5iUHJvZ3Jlc3NCYXJDb21wb25lbnQgPSBfX2RlY29yYXRlJDg4KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLXByb2dyZXNzLWJhcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzcz1cInByb2dyZXNzLXZhbHVlXCIgW3N0eWxlLndpZHRoLiVdPVwidmFsdWVcIj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJkaXNwbGF5VmFsdWVcIj57eyB2YWx1ZSB9fSU8L3NwYW4+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6YmxvY2t9LnByb2dyZXNzLWNvbnRhaW5lcntvdmVyZmxvdzpoaWRkZW59LnByb2dyZXNzLXZhbHVle2hlaWdodDoxMDAlO3RleHQtYWxpZ246Y2VudGVyO292ZXJmbG93OmhpZGRlbn1cXG5cIl1cbiAgICB9KVxuXSwgTmJQcm9ncmVzc0JhckNvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDg5ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmxldCBOYlByb2dyZXNzQmFyTW9kdWxlID0gY2xhc3MgTmJQcm9ncmVzc0Jhck1vZHVsZSB7XG59O1xuTmJQcm9ncmVzc0Jhck1vZHVsZSA9IF9fZGVjb3JhdGUkODkoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgTmJTaGFyZWRNb2R1bGUsXG4gICAgICAgIF0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW05iUHJvZ3Jlc3NCYXJDb21wb25lbnRdLFxuICAgICAgICBleHBvcnRzOiBbTmJQcm9ncmVzc0JhckNvbXBvbmVudF0sXG4gICAgfSlcbl0sIE5iUHJvZ3Jlc3NCYXJNb2R1bGUpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ5MCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ1OCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBBbGVydCBjb21wb25lbnQuXG4gKlxuICogQmFzaWMgYWxlcnQgZXhhbXBsZTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGFsZXJ0L2FsZXJ0LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBBbGVydCBjb25maWd1cmF0aW9uOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxuYi1hbGVydCBzdGF0dXM9XCJzdWNjZXNzXCI+XG4gKiAgIFlvdSBoYXZlIGJlZW4gc3VjY2Vzc2Z1bGx5IGF1dGhlbnRpY2F0ZWQhXG4gKiA8L25iLWFsZXJ0PlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkFsZXJ0TW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkFsZXJ0TW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBBbGVydCBjb3VsZCBhZGRpdGlvbmFsbHkgaGF2ZSBhIGBjbG9zZWAgYnV0dG9uIHdoZW4gYGNsb3NhYmxlYCBwcm9wZXJ0eSBpcyBzZXQ6XG4gKiBgYGBodG1sXG4gKiA8bmItYWxlcnQgc3RhdHVzPVwic3VjY2Vzc1wiIGNsb3NhYmxlIChjbG9zZSk9XCJvbkNsb3NlKClcIj5cbiAqICAgWW91IGhhdmUgYmVlbiBzdWNjZXNzZnVsbHkgYXV0aGVudGljYXRlZCFcbiAqIDwvbmItYWxlcnQ+XG4gKiBgYGBcbiAqXG4gKiBDb2xvcmVkIGFsZXJ0cyBjb3VsZCBiZSBzaW1wbHkgY29uZmlndXJlZCBieSBwcm92aWRpbmcgYSBgc3RhdHVzYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQWxlcnQgc3RhdHVzLCBhbGVydC9hbGVydC1jb2xvcnMuY29tcG9uZW50KVxuICpcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gYXNzaWduIGFuIGBhY2NlbnRgIHByb3BlcnR5IGZvciBhIHNsaWdodCBhbGVydCBoaWdobGlnaHRcbiAqIGFzIHdlbGwgYXMgY29tYmluZSBpdCB3aXRoIGBzdGF0dXNgOlxuICogQHN0YWNrZWQtZXhhbXBsZShBbGVydCBhY2NlbnQsIGFsZXJ0L2FsZXJ0LWFjY2VudHMuY29tcG9uZW50KVxuICpcbiAqIEFuZCBgb3V0bGluZWAgcHJvcGVydHk6XG4gKiBAc3RhY2tlZC1leGFtcGxlKE91dGxpbmUgQWxlcnQsIGFsZXJ0L2FsZXJ0LW91dGxpbmUuY29tcG9uZW50KVxuICpcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoTXVsdGlwbGUgU2l6ZXMsIGFsZXJ0L2FsZXJ0LXNpemVzLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogYWxlcnQtYm9yZGVyLXJhZGl1czpcbiAqIGFsZXJ0LWJvdHRvbS1tYXJnaW46XG4gKiBhbGVydC1wYWRkaW5nOlxuICogYWxlcnQtc2Nyb2xsYmFyLWNvbG9yOlxuICogYWxlcnQtc2Nyb2xsYmFyLWJhY2tncm91bmQtY29sb3I6XG4gKiBhbGVydC1zY3JvbGxiYXItd2lkdGg6XG4gKiBhbGVydC1zaGFkb3c6XG4gKiBhbGVydC10ZXh0LWZvbnQtZmFtaWx5OlxuICogYWxlcnQtdGV4dC1mb250LXNpemU6XG4gKiBhbGVydC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogYWxlcnQtdGV4dC1saW5lLWhlaWdodDpcbiAqIGFsZXJ0LWNsb3NhYmxlLXN0YXJ0LXBhZGRpbmc6XG4gKiBhbGVydC10aW55LWhlaWdodDpcbiAqIGFsZXJ0LXNtYWxsLWhlaWdodDpcbiAqIGFsZXJ0LW1lZGl1bS1oZWlnaHQ6XG4gKiBhbGVydC1tZWRpdW0tcGFkZGluZzpcbiAqIGFsZXJ0LWxhcmdlLWhlaWdodDpcbiAqIGFsZXJ0LWdpYW50LWhlaWdodDpcbiAqIGFsZXJ0LWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiBhbGVydC1iYXNpYy10ZXh0LWNvbG9yOlxuICogYWxlcnQtcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYWxlcnQtcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogYWxlcnQtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYWxlcnQtc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogYWxlcnQtaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYWxlcnQtaW5mby10ZXh0LWNvbG9yOlxuICogYWxlcnQtd2FybmluZy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogYWxlcnQtd2FybmluZy10ZXh0LWNvbG9yOlxuICogYWxlcnQtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiBhbGVydC1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIGFsZXJ0LWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGFsZXJ0LWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIGFsZXJ0LWFjY2VudC1iYXNpYy1jb2xvcjpcbiAqIGFsZXJ0LWFjY2VudC1wcmltYXJ5LWNvbG9yOlxuICogYWxlcnQtYWNjZW50LWluZm8tY29sb3I6XG4gKiBhbGVydC1hY2NlbnQtc3VjY2Vzcy1jb2xvcjpcbiAqIGFsZXJ0LWFjY2VudC13YXJuaW5nLWNvbG9yOlxuICogYWxlcnQtYWNjZW50LWRhbmdlci1jb2xvcjpcbiAqIGFsZXJ0LWFjY2VudC1jb250cm9sLWNvbG9yOlxuICogYWxlcnQtb3V0bGluZS13aWR0aDpcbiAqIGFsZXJ0LW91dGxpbmUtYmFzaWMtY29sb3I6XG4gKiBhbGVydC1vdXRsaW5lLXByaW1hcnktY29sb3I6XG4gKiBhbGVydC1vdXRsaW5lLWluZm8tY29sb3I6XG4gKiBhbGVydC1vdXRsaW5lLXN1Y2Nlc3MtY29sb3I6XG4gKiBhbGVydC1vdXRsaW5lLXdhcm5pbmctY29sb3I6XG4gKiBhbGVydC1vdXRsaW5lLWRhbmdlci1jb2xvcjpcbiAqIGFsZXJ0LW91dGxpbmUtY29udHJvbC1jb2xvcjpcbiAqL1xubGV0IE5iQWxlcnRDb21wb25lbnQgPSBjbGFzcyBOYkFsZXJ0Q29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBBbGVydCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBCYXNpYyBhbGVydCBleGFtcGxlOlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGFsZXJ0L2FsZXJ0LXNob3djYXNlLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEFsZXJ0IGNvbmZpZ3VyYXRpb246XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5iLWFsZXJ0IHN0YXR1cz1cInN1Y2Nlc3NcIj5cbiAgICAgKiAgIFlvdSBoYXZlIGJlZW4gc3VjY2Vzc2Z1bGx5IGF1dGhlbnRpY2F0ZWQhXG4gICAgICogPC9uYi1hbGVydD5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyMgSW5zdGFsbGF0aW9uXG4gICAgICpcbiAgICAgKiBJbXBvcnQgYE5iQWxlcnRNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gICAgICogYGBgdHNcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgaW1wb3J0czogW1xuICAgICAqICAgICAvLyAuLi5cbiAgICAgKiAgICAgTmJBbGVydE1vZHVsZSxcbiAgICAgKiAgIF0sXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAgICAgKiBgYGBcbiAgICAgKiAjIyMgVXNhZ2VcbiAgICAgKlxuICAgICAqIEFsZXJ0IGNvdWxkIGFkZGl0aW9uYWxseSBoYXZlIGEgYGNsb3NlYCBidXR0b24gd2hlbiBgY2xvc2FibGVgIHByb3BlcnR5IGlzIHNldDpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5iLWFsZXJ0IHN0YXR1cz1cInN1Y2Nlc3NcIiBjbG9zYWJsZSAoY2xvc2UpPVwib25DbG9zZSgpXCI+XG4gICAgICogICBZb3UgaGF2ZSBiZWVuIHN1Y2Nlc3NmdWxseSBhdXRoZW50aWNhdGVkIVxuICAgICAqIDwvbmItYWxlcnQ+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBDb2xvcmVkIGFsZXJ0cyBjb3VsZCBiZSBzaW1wbHkgY29uZmlndXJlZCBieSBwcm92aWRpbmcgYSBgc3RhdHVzYCBwcm9wZXJ0eTpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKEFsZXJ0IHN0YXR1cywgYWxlcnQvYWxlcnQtY29sb3JzLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gYXNzaWduIGFuIGBhY2NlbnRgIHByb3BlcnR5IGZvciBhIHNsaWdodCBhbGVydCBoaWdobGlnaHRcbiAgICAgKiBhcyB3ZWxsIGFzIGNvbWJpbmUgaXQgd2l0aCBgc3RhdHVzYDpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKEFsZXJ0IGFjY2VudCwgYWxlcnQvYWxlcnQtYWNjZW50cy5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBBbmQgYG91dGxpbmVgIHByb3BlcnR5OlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoT3V0bGluZSBBbGVydCwgYWxlcnQvYWxlcnQtb3V0bGluZS5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBAYWRkaXRpb25hbC1leGFtcGxlKE11bHRpcGxlIFNpemVzLCBhbGVydC9hbGVydC1zaXplcy5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBAc3R5bGVzXG4gICAgICpcbiAgICAgKiBhbGVydC1ib3JkZXItcmFkaXVzOlxuICAgICAqIGFsZXJ0LWJvdHRvbS1tYXJnaW46XG4gICAgICogYWxlcnQtcGFkZGluZzpcbiAgICAgKiBhbGVydC1zY3JvbGxiYXItY29sb3I6XG4gICAgICogYWxlcnQtc2Nyb2xsYmFyLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogYWxlcnQtc2Nyb2xsYmFyLXdpZHRoOlxuICAgICAqIGFsZXJ0LXNoYWRvdzpcbiAgICAgKiBhbGVydC10ZXh0LWZvbnQtZmFtaWx5OlxuICAgICAqIGFsZXJ0LXRleHQtZm9udC1zaXplOlxuICAgICAqIGFsZXJ0LXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogYWxlcnQtdGV4dC1saW5lLWhlaWdodDpcbiAgICAgKiBhbGVydC1jbG9zYWJsZS1zdGFydC1wYWRkaW5nOlxuICAgICAqIGFsZXJ0LXRpbnktaGVpZ2h0OlxuICAgICAqIGFsZXJ0LXNtYWxsLWhlaWdodDpcbiAgICAgKiBhbGVydC1tZWRpdW0taGVpZ2h0OlxuICAgICAqIGFsZXJ0LW1lZGl1bS1wYWRkaW5nOlxuICAgICAqIGFsZXJ0LWxhcmdlLWhlaWdodDpcbiAgICAgKiBhbGVydC1naWFudC1oZWlnaHQ6XG4gICAgICogYWxlcnQtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBhbGVydC1iYXNpYy10ZXh0LWNvbG9yOlxuICAgICAqIGFsZXJ0LXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBhbGVydC1wcmltYXJ5LXRleHQtY29sb3I6XG4gICAgICogYWxlcnQtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGFsZXJ0LXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAgICAgKiBhbGVydC1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogYWxlcnQtaW5mby10ZXh0LWNvbG9yOlxuICAgICAqIGFsZXJ0LXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBhbGVydC13YXJuaW5nLXRleHQtY29sb3I6XG4gICAgICogYWxlcnQtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogYWxlcnQtZGFuZ2VyLXRleHQtY29sb3I6XG4gICAgICogYWxlcnQtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGFsZXJ0LWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAgICAgKiBhbGVydC1hY2NlbnQtYmFzaWMtY29sb3I6XG4gICAgICogYWxlcnQtYWNjZW50LXByaW1hcnktY29sb3I6XG4gICAgICogYWxlcnQtYWNjZW50LWluZm8tY29sb3I6XG4gICAgICogYWxlcnQtYWNjZW50LXN1Y2Nlc3MtY29sb3I6XG4gICAgICogYWxlcnQtYWNjZW50LXdhcm5pbmctY29sb3I6XG4gICAgICogYWxlcnQtYWNjZW50LWRhbmdlci1jb2xvcjpcbiAgICAgKiBhbGVydC1hY2NlbnQtY29udHJvbC1jb2xvcjpcbiAgICAgKiBhbGVydC1vdXRsaW5lLXdpZHRoOlxuICAgICAqIGFsZXJ0LW91dGxpbmUtYmFzaWMtY29sb3I6XG4gICAgICogYWxlcnQtb3V0bGluZS1wcmltYXJ5LWNvbG9yOlxuICAgICAqIGFsZXJ0LW91dGxpbmUtaW5mby1jb2xvcjpcbiAgICAgKiBhbGVydC1vdXRsaW5lLXN1Y2Nlc3MtY29sb3I6XG4gICAgICogYWxlcnQtb3V0bGluZS13YXJuaW5nLWNvbG9yOlxuICAgICAqIGFsZXJ0LW91dGxpbmUtZGFuZ2VyLWNvbG9yOlxuICAgICAqIGFsZXJ0LW91dGxpbmUtY29udHJvbC1jb2xvcjpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsZXJ0IHNpemUsIGF2YWlsYWJsZSBzaXplczpcbiAgICAgICAgICogYHRpbnlgLCBgc21hbGxgLCBgbWVkaXVtYCwgYGxhcmdlYCwgYGdpYW50YFxuICAgICAgICAgKiBVbnNldCBieSBkZWZhdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaXplID0gJyc7XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9ICdiYXNpYyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGVydCBhY2NlbnQgKGNvbG9yIG9mIHRoZSB0b3AgYm9yZGVyKTpcbiAgICAgICAgICogYGJhc2ljYCwgYHByaW1hcnlgLCBgc3VjY2Vzc2AsIGBpbmZvYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCwgYGNvbnRyb2xgLlxuICAgICAgICAgKiBVbnNldCBieSBkZWZhdWx0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY2NlbnQgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsZXJ0IG91dGxpbmUgKGNvbG9yIG9mIHRoZSBib3JkZXIpOlxuICAgICAgICAgKiBgYmFzaWNgLCBgcHJpbWFyeWAsIGBzdWNjZXNzYCwgYGluZm9gLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgY29udHJvbGAuXG4gICAgICAgICAqIFVuc2V0IGJ5IGRlZmF1bHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm91dGxpbmUgPSAnJztcbiAgICAgICAgdGhpcy5fY2xvc2FibGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIHdoZW4gY2hpcCBpcyByZW1vdmVkXG4gICAgICAgICAqIEB0eXBlIEV2ZW50RW1pdHRlcjxhbnk+XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGVydCBzdGF0dXMgKGFkZHMgc3BlY2lmaWMgc3R5bGVzKTpcbiAgICAgKiBgYmFzaWNgIChkZWZhdWx0KSwgYHByaW1hcnlgLCBgc3VjY2Vzc2AsIGBpbmZvYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCwgYGNvbnRyb2xgLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gICAgfVxuICAgIHNldCBzdGF0dXModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgZW1wdHlTdGF0dXNXYXJuaW5nKCdOYkFsZXJ0Jyk7XG4gICAgICAgICAgICB2YWx1ZSA9ICdiYXNpYyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdHVzID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIGBjbG9zZWAgaWNvblxuICAgICAqL1xuICAgIGdldCBjbG9zYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NhYmxlO1xuICAgIH1cbiAgICBzZXQgY2xvc2FibGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY2xvc2FibGUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyB0aGUgcmVtb3ZlZCBjaGlwIGV2ZW50XG4gICAgICovXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZS5lbWl0KCk7XG4gICAgfVxuICAgIGdldCB0aW55KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAndGlueSc7XG4gICAgfVxuICAgIGdldCBzbWFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3NtYWxsJztcbiAgICB9XG4gICAgZ2V0IG1lZGl1bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ21lZGl1bSc7XG4gICAgfVxuICAgIGdldCBsYXJnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2xhcmdlJztcbiAgICB9XG4gICAgZ2V0IGdpYW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnZ2lhbnQnO1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAncHJpbWFyeSc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgd2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnd2FybmluZyc7XG4gICAgfVxuICAgIGdldCBkYW5nZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Rhbmdlcic7XG4gICAgfVxuICAgIGdldCBiYXNpYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnYmFzaWMnO1xuICAgIH1cbiAgICBnZXQgY29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnY29udHJvbCc7XG4gICAgfVxuICAgIGdldCBwcmltYXJ5QWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IHN1Y2Nlc3NBY2NlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY2VudCA9PT0gJ3N1Y2Nlc3MnO1xuICAgIH1cbiAgICBnZXQgaW5mb0FjY2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZW50ID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlckFjY2VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjZW50ID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sQWNjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NlbnQgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgZ2V0IHByaW1hcnlPdXRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lID09PSAncHJpbWFyeSc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzT3V0bGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0bGluZSA9PT0gJ3N1Y2Nlc3MnO1xuICAgIH1cbiAgICBnZXQgaW5mb091dGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxpbmUgPT09ICdpbmZvJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmdPdXRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lID09PSAnd2FybmluZyc7XG4gICAgfVxuICAgIGdldCBkYW5nZXJPdXRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljT3V0bGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0bGluZSA9PT0gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xPdXRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRsaW5lID09PSAnY29udHJvbCc7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkOTAoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQWxlcnRDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTAoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhdHVzXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwiYWNjZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkFsZXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvdXRsaW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBJbnB1dCgpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5jbG9zYWJsZScpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xvc2FibGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xvc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLXRpbnknKSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkFsZXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aW55XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtc21hbGwnKSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkFsZXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzbWFsbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLW1lZGl1bScpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWxlcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm1lZGl1bVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLWxhcmdlJyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFyZ2VcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1naWFudCcpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWxlcnRDb21wb25lbnQucHJvdG90eXBlLCBcImdpYW50XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwicHJpbWFyeVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtc3VjY2VzcycpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWxlcnRDb21wb25lbnQucHJvdG90eXBlLCBcInN1Y2Nlc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWluZm8nKSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkFsZXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmZvXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy13YXJuaW5nJyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwid2FybmluZ1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtZGFuZ2VyJyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGFuZ2VyXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1iYXNpYycpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWxlcnRDb21wb25lbnQucHJvdG90eXBlLCBcImJhc2ljXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1jb250cm9sJyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NlbnQtcHJpbWFyeScpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWxlcnRDb21wb25lbnQucHJvdG90eXBlLCBcInByaW1hcnlBY2NlbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MuYWNjZW50LXN1Y2Nlc3MnKSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkFsZXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdWNjZXNzQWNjZW50XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmFjY2VudC1pbmZvJyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5mb0FjY2VudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NlbnQtd2FybmluZycpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWxlcnRDb21wb25lbnQucHJvdG90eXBlLCBcIndhcm5pbmdBY2NlbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MuYWNjZW50LWRhbmdlcicpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWxlcnRDb21wb25lbnQucHJvdG90eXBlLCBcImRhbmdlckFjY2VudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NlbnQtYmFzaWMnKSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkFsZXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXNpY0FjY2VudFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NlbnQtY29udHJvbCcpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNTgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWxlcnRDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRyb2xBY2NlbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Mub3V0bGluZS1wcmltYXJ5JyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwicHJpbWFyeU91dGxpbmVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Mub3V0bGluZS1zdWNjZXNzJyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwic3VjY2Vzc091dGxpbmVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Mub3V0bGluZS1pbmZvJyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5mb091dGxpbmVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Mub3V0bGluZS13YXJuaW5nJyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwid2FybmluZ091dGxpbmVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Mub3V0bGluZS1kYW5nZXInKSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkFsZXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkYW5nZXJPdXRsaW5lXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLm91dGxpbmUtYmFzaWMnKSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDU4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkFsZXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJiYXNpY091dGxpbmVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Mub3V0bGluZS1jb250cm9sJyksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ1OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBbGVydENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udHJvbE91dGxpbmVcIiwgbnVsbCk7XG5OYkFsZXJ0Q29tcG9uZW50ID0gX19kZWNvcmF0ZSQ5MChbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1hbGVydCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGJ1dHRvbiAqbmdJZj1cImNsb3NhYmxlXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBhcmlhLWxhYmVsPVwiQ2xvc2VcIiAoY2xpY2spPVwib25DbG9zZSgpXCI+XG4gICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgYCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3Bvc2l0aW9uOnJlbGF0aXZlfVtkaXI9bHRyXSA6aG9zdCAuY2xvc2V7cmlnaHQ6MH1bZGlyPXJ0bF0gOmhvc3QgLmNsb3Nle2xlZnQ6MH0uY2xvc2V7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7Y29sb3I6aW5oZXJpdDtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50O2JvcmRlcjowO2FwcGVhcmFuY2U6bm9uZX1cXG5cIl1cbiAgICB9KVxuXSwgTmJBbGVydENvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDkxID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmxldCBOYkFsZXJ0TW9kdWxlID0gY2xhc3MgTmJBbGVydE1vZHVsZSB7XG59O1xuTmJBbGVydE1vZHVsZSA9IF9fZGVjb3JhdGUkOTEoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW1xuICAgICAgICAgICAgTmJTaGFyZWRNb2R1bGUsXG4gICAgICAgIF0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICAgICAgTmJBbGVydENvbXBvbmVudCxcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgTmJBbGVydENvbXBvbmVudCxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJBbGVydE1vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDkzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDYwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIENoYXQgZm9ybSBjb21wb25lbnQuXG4gKlxuICogU2hvdyBhIG1lc3NhZ2UgZm9ybSB3aXRoIGEgc2VuZCBtZXNzYWdlIGJ1dHRvbi5cbiAqXG4gKiBgYGB0c1xuICogPG5iLWNoYXQtZm9ybSBzaG93QnV0dG9uPVwidHJ1ZVwiIGJ1dHRvbkljb249XCJuYi1zZW5kXCI+XG4gKiA8L25iLWNoYXQtZm9ybT5cbiAqIGBgYFxuICpcbiAqIFdoZW4gYFtkcm9wRmlsZXNdPVwidHJ1ZVwiYCBoYW5kbGVzIGZpbGVzIGRyYWcmZHJvcCB3aXRoIGEgZmlsZSBwcmV2aWV3LlxuICpcbiAqIERyYWcgJiBkcm9wIGF2YWlsYWJsZSBmb3IgZmlsZXMgYW5kIGltYWdlczpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRHJhZyAmIERyb3AgQ2hhdCwgY2hhdC9jaGF0LWRyb3AuY29tcG9uZW50KVxuICpcbiAqIE5ldyBtZXNzYWdlIGNvdWxkIGJlIHRyYWNrZWQgb3V0c2lkZSBieSB1c2luZyBgKHNlbmQpYCBvdXRwdXQuXG4gKlxuICogYGBgdHNcbiAqIDxuYi1jaGF0LWZvcm0gKHNlbmQpPVwib25OZXdNZXNzYWdlKCRldmVudClcIj5cbiAqIDwvbmItY2hhdC1mb3JtPlxuICpcbiAqIC8vIC4uLlxuICpcbiAqIG9uTmV3TWVzc2FnZSh7IG1lc3NhZ2U6IHN0cmluZywgZmlsZXM6IGFueVtdIH0pIHtcbiAqICAgdGhpcy5zZXJ2aWNlLnNlbmRUb1NlcnZlcihtZXNzYWdlLCBmaWxlcyk7XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IE5iQ2hhdEZvcm1Db21wb25lbnQgPSBjbGFzcyBOYkNoYXRGb3JtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjZCwgZG9tU2FuaXRpemVyKSB7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5kb21TYW5pdGl6ZXIgPSBkb21TYW5pdGl6ZXI7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ2Jhc2ljJztcbiAgICAgICAgdGhpcy5pbnB1dEZvY3VzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5wdXRIb3ZlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyb3BwZWRGaWxlcyA9IFtdO1xuICAgICAgICB0aGlzLmltZ0Ryb3BUeXBlcyA9IFsnaW1hZ2UvcG5nJywgJ2ltYWdlL2pwZWcnLCAnaW1hZ2UvZ2lmJ107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcmVkZWZpbmVkIG1lc3NhZ2UgdGV4dFxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kIGJ1dHRvbiB0aXRsZVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5idXR0b25UaXRsZSA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZCBidXR0b24gaWNvbiwgc2hvd24gaWYgYGJ1dHRvblRpdGxlYCBpcyBlbXB0eVxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5idXR0b25JY29uID0gJ3BhcGVyLXBsYW5lLW91dGxpbmUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdyBzZW5kIGJ1dHRvblxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvd0J1dHRvbiA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHNlbmQgYnV0dG9uXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcm9wRmlsZXMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtFdmVudEVtaXR0ZXI8eyBtZXNzYWdlOiBzdHJpbmcsIGZpbGVzOiBGaWxlW10gfT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbmQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZmlsZU92ZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgb25Ecm9wKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyb3BGaWxlcykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5maWxlT3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmRhdGFUcmFuc2ZlciAmJiBldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZXZlbnQuZGF0YVRyYW5zZmVyLmZpbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGZpbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmltZ0Ryb3BUeXBlcy5pbmNsdWRlcyhmaWxlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmci5vbmxvYWQgPSAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zcmMgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnVybFN0eWxlID0gdGhpcy5kb21TYW5pdGl6ZXIuYnlwYXNzU2VjdXJpdHlUcnVzdFN0eWxlKGB1cmwoJHtyZXMuc3JjfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNkLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJvcHBlZEZpbGVzLnB1c2gocmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlRmlsZShmaWxlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kcm9wcGVkRmlsZXMuaW5kZXhPZihmaWxlKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuZHJvcHBlZEZpbGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25EcmFnT3ZlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJvcEZpbGVzKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVPdmVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkRyYWdMZWF2ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJvcEZpbGVzKSB7XG4gICAgICAgICAgICB0aGlzLmZpbGVPdmVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VuZE1lc3NhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmRyb3BwZWRGaWxlcy5sZW5ndGggfHwgU3RyaW5nKHRoaXMubWVzc2FnZSkudHJpbSgpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zZW5kLmVtaXQoeyBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsIGZpbGVzOiB0aGlzLmRyb3BwZWRGaWxlcyB9KTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5kcm9wcGVkRmlsZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gc3RhdHVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldElucHV0U3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5maWxlT3Zlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGlnaGxpZ2h0U3RhdHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5wdXRGb2N1cyB8fCB0aGlzLmlucHV0SG92ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0QnV0dG9uU3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRIaWdobGlnaHRTdGF0dXMoKTtcbiAgICB9XG4gICAgZ2V0SGlnaGxpZ2h0U3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09ICdiYXNpYycgfHwgdGhpcy5zdGF0dXMgPT09ICdjb250cm9sJykge1xuICAgICAgICAgICAgcmV0dXJuICdwcmltYXJ5JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXM7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkOTMoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ2MChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2hhdEZvcm1Db21wb25lbnQucHJvdG90eXBlLCBcIm1lc3NhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTMoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ2MChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2hhdEZvcm1Db21wb25lbnQucHJvdG90eXBlLCBcImJ1dHRvblRpdGxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDkzKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjAoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNoYXRGb3JtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJidXR0b25JY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDkzKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjAoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJDaGF0Rm9ybUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd0J1dHRvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ5MyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDYwKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE5iQ2hhdEZvcm1Db21wb25lbnQucHJvdG90eXBlLCBcImRyb3BGaWxlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ5MyhbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQ2MChcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQ2hhdEZvcm1Db21wb25lbnQucHJvdG90eXBlLCBcInNlbmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTMoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5maWxlLW92ZXInKSxcbiAgICBfX21ldGFkYXRhJDYwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJDaGF0Rm9ybUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsZU92ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTMoW1xuICAgIEhvc3RMaXN0ZW5lcignZHJvcCcsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEkNjAoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YSQ2MChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhJDYwKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTmJDaGF0Rm9ybUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25Ecm9wXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MyhbXG4gICAgSG9zdExpc3RlbmVyKCdkcmFnb3ZlcicpLFxuICAgIF9fbWV0YWRhdGEkNjAoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YSQ2MChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhJDYwKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTmJDaGF0Rm9ybUNvbXBvbmVudC5wcm90b3R5cGUsIFwib25EcmFnT3ZlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTMoW1xuICAgIEhvc3RMaXN0ZW5lcignZHJhZ2xlYXZlJyksXG4gICAgX19tZXRhZGF0YSQ2MChcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhJDYwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgIF9fbWV0YWRhdGEkNjAoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBOYkNoYXRGb3JtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJvbkRyYWdMZWF2ZVwiLCBudWxsKTtcbk5iQ2hhdEZvcm1Db21wb25lbnQgPSBfX2RlY29yYXRlJDkzKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWNoYXQtZm9ybScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGRpdiBjbGFzcz1cImRyb3BwZWQtZmlsZXNcIiAqbmdJZj1cImRyb3BwZWRGaWxlcz8ubGVuZ3RoXCI+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBmaWxlIG9mIGRyb3BwZWRGaWxlc1wiPlxuICAgICAgICA8ZGl2ICpuZ0lmPVwiZmlsZS51cmxTdHlsZVwiIFtzdHlsZS5iYWNrZ3JvdW5kLWltYWdlXT1cImZpbGUudXJsU3R5bGVcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInJlbW92ZVwiIChjbGljayk9XCJyZW1vdmVGaWxlKGZpbGUpXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8bmItaWNvbiAqbmdJZj1cIiFmaWxlLnVybFN0eWxlXCIgaWNvbj1cImZpbGUtdGV4dC1vdXRsaW5lXCIgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiPjwvbmItaWNvbj5cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInJlbW92ZVwiIChjbGljayk9XCJyZW1vdmVGaWxlKGZpbGUpXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWVzc2FnZS1yb3dcIj5cbiAgICAgIDxpbnB1dCBuYklucHV0XG4gICAgICAgICAgICAgZnVsbFdpZHRoXG4gICAgICAgICAgICAgW3N0YXR1c109XCJnZXRJbnB1dFN0YXR1cygpXCJcbiAgICAgICAgICAgICAoZm9jdXMpPVwiaW5wdXRGb2N1cyA9IHRydWVcIlxuICAgICAgICAgICAgIChibHVyKT1cImlucHV0Rm9jdXMgPSBmYWxzZVwiXG4gICAgICAgICAgICAgKG1vdXNlZW50ZXIpPVwiaW5wdXRIb3ZlciA9IHRydWVcIlxuICAgICAgICAgICAgIChtb3VzZWxlYXZlKT1cImlucHV0SG92ZXIgPSBmYWxzZVwiXG4gICAgICAgICAgICAgWyhuZ01vZGVsKV09XCJtZXNzYWdlXCJcbiAgICAgICAgICAgICBbY2xhc3Mud2l0aC1idXR0b25dPVwic2hvd0J1dHRvblwiXG4gICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwie3sgZmlsZU92ZXIgPyAnRHJvcCBmaWxlIHRvIHNlbmQnIDogJ1R5cGUgYSBtZXNzYWdlJyB9fVwiXG4gICAgICAgICAgICAgKGtleXVwLmVudGVyKT1cInNlbmRNZXNzYWdlKClcIj5cbiAgICAgIDxidXR0b24gbmJCdXR0b25cbiAgICAgICAgICAgICAgW3N0YXR1c109XCJnZXRCdXR0b25TdGF0dXMoKVwiXG4gICAgICAgICAgICAgICpuZ0lmPVwic2hvd0J1dHRvblwiXG4gICAgICAgICAgICAgIFtjbGFzcy53aXRoLWljb25dPVwiIWJ1dHRvblRpdGxlXCJcbiAgICAgICAgICAgICAgKGNsaWNrKT1cInNlbmRNZXNzYWdlKClcIlxuICAgICAgICAgICAgICBjbGFzcz1cInNlbmQtYnV0dG9uXCI+XG4gICAgICAgIDxuYi1pY29uICpuZ0lmPVwiIWJ1dHRvblRpdGxlOyBlbHNlIHRpdGxlXCIgW2ljb25dPVwiYnV0dG9uSWNvblwiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIj48L25iLWljb24+XG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjdGl0bGU+e3sgYnV0dG9uVGl0bGUgfX08L25nLXRlbXBsYXRlPlxuICAgICAgPC9idXR0b24+XG4gICAgPC9kaXY+XG4gIGAsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQ2MChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDaGFuZ2VEZXRlY3RvclJlZiwgRG9tU2FuaXRpemVyXSlcbl0sIE5iQ2hhdEZvcm1Db21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQ5NCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2MSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKiBDaGF0IG1lc3NhZ2UgY29tcG9uZW50LlxuICpcbiAqIE11bHRpcGxlIG1lc3NhZ2UgdHlwZXMgYXJlIGF2YWlsYWJsZSB0aHJvdWdoIGEgYHR5cGVgIHByb3BlcnR5LCBzdWNoIGFzXG4gKiAtIHRleHQgLSBzaW1wbGUgdGV4dCBtZXNzYWdlXG4gKiAtIGZpbGUgLSBjb3VsZCBiZSBhIGZpbGUgcHJldmlldyBvciBhIGZpbGUgaWNvblxuICogaWYgbXVsdGlwbGUgZmlsZXMgYXJlIHByb3ZpZGVkIGdyb3VwZWQgZmlsZXMgYXJlIHNob3duXG4gKiAtIHF1b3RlIC0gcXVvdGVzIGEgbWVzc2FnZSB3aXRoIHNwZWNpZmljIHF1b3RlIHN0eWxlc1xuICogLSBtYXAgLSBzaG93cyBhIGdvb2dsZSBtYXAgcGljdHVyZSBieSBwcm92aWRlZCBbbGF0aXR1ZGVdIGFuZCBbbG9uZ2l0dWRlXSBwcm9wZXJ0aWVzXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShBdmFpbGFibGUgVHlwZXMsIGNoYXQvY2hhdC1tZXNzYWdlLXR5cGVzLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBNZXNzYWdlIHdpdGggYXR0YWNoZWQgZmlsZXM6XG4gKiBgYGBodG1sXG4gKiA8bmItY2hhdC1tZXNzYWdlXG4gKiAgIHR5cGU9XCJmaWxlXCJcbiAqICAgW2ZpbGVzXT1cIlsgeyB1cmw6ICcuLi4nIH0gXVwiXG4gKiAgIG1lc3NhZ2U9XCJIZWxsbyB3b3JsZCFcIj5cbiAqIDwvbmItY2hhdC1tZXNzYWdlPlxuICogYGBgXG4gKlxuICogTWFwIG1lc3NhZ2U6XG4gKiBgYGBodG1sXG4gKiA8bmItY2hhdC1tZXNzYWdlXG4gKiAgIHR5cGU9XCJtYXBcIlxuICogICBbbGF0aXR1ZGVdPVwiNTMuOTE0XCJcbiAqICAgW2xvbmdpdHVkZV09XCIyNy41OVwiXG4gKiAgIG1lc3NhZ2U9XCJIZXJlIEkgYW1cIj5cbiAqIDwvbmItY2hhdC1tZXNzYWdlPlxuICogYGBgXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGNoYXQtbWVzc2FnZS1iYWNrZ3JvdW5kOlxuICogY2hhdC1tZXNzYWdlLXRleHQtY29sb3I6XG4gKiBjaGF0LW1lc3NhZ2UtcmVwbHktYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoYXQtbWVzc2FnZS1yZXBseS10ZXh0LWNvbG9yOlxuICogY2hhdC1tZXNzYWdlLWF2YXRhci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hhdC1tZXNzYWdlLXNlbmRlci10ZXh0LWNvbG9yOlxuICogY2hhdC1tZXNzYWdlLXF1b3RlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LW1lc3NhZ2UtcXVvdGUtdGV4dC1jb2xvcjpcbiAqIGNoYXQtbWVzc2FnZS1maWxlLXRleHQtY29sb3I6XG4gKiBjaGF0LW1lc3NhZ2UtZmlsZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICovXG5sZXQgTmJDaGF0TWVzc2FnZUNvbXBvbmVudCA9IGNsYXNzIE5iQ2hhdE1lc3NhZ2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGRvbVNhbml0aXplcikge1xuICAgICAgICB0aGlzLmRvbVNhbml0aXplciA9IGRvbVNhbml0aXplcjtcbiAgICAgICAgdGhpcy5fcmVwbHkgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGZseUluT3V0KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IG5vdFJlcGx5KCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucmVwbHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBtZXNzYWdlIGlzIGEgcmVwbHlcbiAgICAgKi9cbiAgICBnZXQgcmVwbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXBseTtcbiAgICB9XG4gICAgc2V0IHJlcGx5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JlcGx5ID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVzc2FnZSBzZW5kIGF2YXRhclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgc2V0IGF2YXRhcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmF2YXRhclN0eWxlID0gdmFsdWUgPyB0aGlzLmRvbVNhbml0aXplci5ieXBhc3NTZWN1cml0eVRydXN0U3R5bGUoYHVybCgke3ZhbHVlfSlgKSA6IG51bGw7XG4gICAgfVxuICAgIGdldEluaXRpYWxzKCkge1xuICAgICAgICBpZiAodGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWVzID0gdGhpcy5zZW5kZXIuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lcy5tYXAobiA9PiBuLmNoYXJBdCgwKSkuc3BsaWNlKDAsIDIpLmpvaW4oJycpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDk0KFtcbiAgICBIb3N0QmluZGluZygnQGZseUluT3V0JyksXG4gICAgX19tZXRhZGF0YSQ2MShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ2MShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDaGF0TWVzc2FnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmx5SW5PdXRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDk0KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Mubm90LXJlcGx5JyksXG4gICAgX19tZXRhZGF0YSQ2MShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ2MShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDaGF0TWVzc2FnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibm90UmVwbHlcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDk0KFtcbiAgICBJbnB1dCgpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5yZXBseScpLFxuICAgIF9fbWV0YWRhdGEkNjEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDYxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJDaGF0TWVzc2FnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicmVwbHlcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDk0KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNoYXRNZXNzYWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDk0KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNoYXRNZXNzYWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZW5kZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTQoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ2MShcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBOYkNoYXRNZXNzYWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDk0KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIE5iQ2hhdE1lc3NhZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImZpbGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDk0KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNoYXRNZXNzYWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJxdW90ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ5NChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDYxKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTmJDaGF0TWVzc2FnZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibGF0aXR1ZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTQoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ2MShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE5iQ2hhdE1lc3NhZ2VDb21wb25lbnQucHJvdG90eXBlLCBcImxvbmdpdHVkZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ5NChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDYxKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhJDYxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBOYkNoYXRNZXNzYWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJhdmF0YXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDk0KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNoYXRNZXNzYWdlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5OYkNoYXRNZXNzYWdlQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQ5NChbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jaGF0LW1lc3NhZ2UnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgY2xhc3M9XCJhdmF0YXJcIiBbc3R5bGUuYmFja2dyb3VuZC1pbWFnZV09XCJhdmF0YXJTdHlsZVwiICpuZ0lmPVwiIXJlcGx5XCI+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWF2YXRhclN0eWxlXCI+XG4gICAgICAgIHt7IGdldEluaXRpYWxzKCkgfX1cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlXCI+XG4gICAgICA8bmctY29udGFpbmVyIFtuZ1N3aXRjaF09XCJ0eXBlXCI+XG5cbiAgICAgICAgPG5iLWNoYXQtbWVzc2FnZS1maWxlICpuZ1N3aXRjaENhc2U9XCInZmlsZSdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbmRlcl09XCJzZW5kZXJcIiBbZGF0ZV09XCJkYXRlXCIgW21lc3NhZ2VdPVwibWVzc2FnZVwiIFtmaWxlc109XCJmaWxlc1wiPlxuICAgICAgICA8L25iLWNoYXQtbWVzc2FnZS1maWxlPlxuXG4gICAgICAgIDxuYi1jaGF0LW1lc3NhZ2UtcXVvdGUgKm5nU3dpdGNoQ2FzZT1cIidxdW90ZSdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbmRlcl09XCJzZW5kZXJcIiBbZGF0ZV09XCJkYXRlXCIgW21lc3NhZ2VdPVwibWVzc2FnZVwiIFtxdW90ZV09XCJxdW90ZVwiPlxuICAgICAgICA8L25iLWNoYXQtbWVzc2FnZS1xdW90ZT5cblxuICAgICAgICA8bmItY2hhdC1tZXNzYWdlLW1hcCAqbmdTd2l0Y2hDYXNlPVwiJ21hcCdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3NlbmRlcl09XCJzZW5kZXJcIiBbZGF0ZV09XCJkYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttZXNzYWdlXT1cIm1lc3NhZ2VcIiBbbGF0aXR1ZGVdPVwibGF0aXR1ZGVcIiBbbG9uZ2l0dWRlXT1cImxvbmdpdHVkZVwiPlxuICAgICAgICA8L25iLWNoYXQtbWVzc2FnZS1tYXA+XG5cbiAgICAgICAgPG5iLWNoYXQtbWVzc2FnZS10ZXh0ICpuZ1N3aXRjaERlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZW5kZXJdPVwic2VuZGVyXCIgW2RhdGVdPVwiZGF0ZVwiIFttZXNzYWdlXT1cIm1lc3NhZ2VcIj5cbiAgICAgICAgPC9uYi1jaGF0LW1lc3NhZ2UtdGV4dD5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICBhbmltYXRpb25zOiBbXG4gICAgICAgICAgICB0cmlnZ2VyKCdmbHlJbk91dCcsIFtcbiAgICAgICAgICAgICAgICBzdGF0ZSgnaW4nLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoMCknIH0pKSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgtMTAwJSknIH0pLFxuICAgICAgICAgICAgICAgICAgICBhbmltYXRlKDgwKSxcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCcqID0+IHZvaWQnLCBbXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGUoODAsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWCgxMDAlKScgfSkpLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIF0sXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQ2MShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtEb21TYW5pdGl6ZXJdKVxuXSwgTmJDaGF0TWVzc2FnZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDkyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDU5ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIENvbnZlcnNhdGlvbmFsIFVJIGNvbGxlY3Rpb24gLSBhIHNldCBvZiBjb21wb25lbnRzIGZvciBjaGF0LWxpa2UgVUkgY29uc3RydWN0aW9uLlxuICpcbiAqIE1haW4gZmVhdHVyZXM6XG4gKiAtIGRpZmZlcmVudCBtZXNzYWdlIHR5cGVzIHN1cHBvcnQgKHRleHQsIGltYWdlLCBmaWxlLCBmaWxlIGdyb3VwLCBtYXAsIGV0YylcbiAqIC0gZHJhZyAmIGRyb3AgZm9yIGltYWdlcyBhbmQgZmlsZXMgd2l0aCBwcmV2aWV3XG4gKiAtIGRpZmZlcmVudCBVSSBzdHlsZXNcbiAqIC0gY3VzdG9tIGFjdGlvbiBidXR0b25zIChjb21pbmcgc29vbilcbiAqXG4gKiBIZXJlJ3MgYSBjb21wbGV0ZSBleGFtcGxlIGJ1aWxkIGluIGEgYm90LWxpa2UgYXBwLiBUeXBlIGBoZWxwYCB0byBiZSBhYmxlIHRvIHJlY2VpdmUgZGlmZmVyZW50IG1lc3NhZ2UgdHlwZXMuXG4gKiBFbmpveSB0aGUgY29udmVyc2F0aW9uIGFuZCB0aGUgYmVhdXRpZnVsIFVJLlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgY2hhdC9jaGF0LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBCYXNpYyBjaGF0IGNvbmZpZ3VyYXRpb24gYW5kIHVzYWdlOlxuICogYGBgdHNcbiAqIDxuYi1jaGF0IHRpdGxlPVwiTmVidWxhciBDb252ZXJzYXRpb25hbCBVSVwiPlxuICogICAgICAgPG5iLWNoYXQtbWVzc2FnZSAqbmdGb3I9XCJsZXQgbXNnIG9mIG1lc3NhZ2VzXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW3R5cGVdPVwibXNnLnR5cGVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbbWVzc2FnZV09XCJtc2cudGV4dFwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtyZXBseV09XCJtc2cucmVwbHlcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbc2VuZGVyXT1cIm1zZy51c2VyLm5hbWVcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbZGF0ZV09XCJtc2cuZGF0ZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtmaWxlc109XCJtc2cuZmlsZXNcIlxuICogICAgICAgICAgICAgICAgICAgICAgICBbcXVvdGVdPVwibXNnLnF1b3RlXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgW2xhdGl0dWRlXT1cIm1zZy5sYXRpdHVkZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFtsb25naXR1ZGVdPVwibXNnLmxvbmdpdHVkZVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIFthdmF0YXJdPVwibXNnLnVzZXIuYXZhdGFyXCI+XG4gKiAgIDwvbmItY2hhdC1tZXNzYWdlPlxuICpcbiAqICAgPG5iLWNoYXQtZm9ybSAoc2VuZCk9XCJzZW5kTWVzc2FnZSgkZXZlbnQpXCIgW2Ryb3BGaWxlc109XCJ0cnVlXCI+XG4gKiAgIDwvbmItY2hhdC1mb3JtPlxuICogPC9uYi1jaGF0PlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkNoYXRNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iQ2hhdE1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICpcbiAqIElmIHlvdSBuZWVkIHRvIHByb3ZpZGUgYW4gQVBJIGtleSBmb3IgYSBgbWFwYCBtZXNzYWdlIHR5cGUgKHdoaWNoIGlzIHJlcXVpcmVkIGJ5IEdvb2dsZSBNYXBzKVxuICogeW91IG1heSB1c2UgYE5iQ2hhdE1vZHVsZS5mb3JSb290KHsgLi4uIH0pYCBjYWxsIGlmIHRoaXMgaXMgYSBnbG9iYWwgYXBwIGNvbmZpZ3VyYXRpb25cbiAqIG9yIGBOYkNoYXRNb2R1bGUuZm9yQ2hpbGQoeyAuLi4gfSlgIGZvciBhIGZlYXR1cmUgbW9kdWxlIGNvbmZpZ3VyYXRpb246XG4gKlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkNoYXRNb2R1bGUuZm9yUm9vdCh7IG1lc3NhZ2VHb29nbGVNYXBLZXk6ICdNQVBfS0VZJyB9KSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuICogYGBgXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogVGhlcmUgYXJlIHRocmVlIG1haW4gY29tcG9uZW50czpcbiAqIGBgYHRzXG4gKiA8bmItY2hhdD5cbiAqIDwvbmItY2hhdD4gLy8gY2hhdCBjb250YWluZXJcbiAqXG4gKiA8bmItY2hhdC1mb3JtPlxuICogPC9uYi1jaGF0LWZvcm0+IC8vIGNoYXQgZm9ybSB3aXRoIGRyYWcmZHJvcCBmaWxlcyBmZWF0dXJlXG4gKlxuICogPG5iLWNoYXQtbWVzc2FnZT5cbiAqIDwvbmItY2hhdC1tZXNzYWdlPiAvLyBjaGF0IG1lc3NhZ2UsIGF2YWlsYWJsZSBtdWx0aXBsZSB0eXBlc1xuICogYGBgXG4gKlxuICogVHdvIHVzZXJzIGNvbnZlcnNhdGlvbiBzaG93Y2FzZTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ29udmVyc2F0aW9uLCBjaGF0L2NoYXQtY29udmVyc2F0aW9uLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBDaGF0IFVJIGlzIGFsc28gYXZhaWxhYmxlIGluIGRpZmZlcmVudCBjb2xvcnMgYnkgc3BlY2lmeWluZyBhIGBbc3RhdHVzXWAgaW5wdXQ6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShDb2xvcmVkIENoYXQsIGNoYXQvY2hhdC1jb2xvcnMuY29tcG9uZW50KVxuICpcbiAqIEFsc28gaXQgaXMgcG9zc2libGUgdG8gY29uZmlndXJlIHNpemVzIHRocm91Z2ggYFtzaXplXWAgaW5wdXQ6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShDaGF0IFNpemVzLCBjaGF0L2NoYXQtc2l6ZXMuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBjaGF0LWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LWJvcmRlcjpcbiAqIGNoYXQtYm9yZGVyLXJhZGl1czpcbiAqIGNoYXQtc2hhZG93OlxuICogY2hhdC1wYWRkaW5nOlxuICogY2hhdC1zY3JvbGxiYXItY29sb3I6XG4gKiBjaGF0LXNjcm9sbGJhci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hhdC1zY3JvbGxiYXItd2lkdGg6XG4gKiBjaGF0LXRleHQtY29sb3I6XG4gKiBjaGF0LXRleHQtZm9udC1mYW1pbHk6XG4gKiBjaGF0LXRleHQtZm9udC1zaXplOlxuICogY2hhdC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogY2hhdC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogY2hhdC1oZWFkZXItdGV4dC1mb250LWZhbWlseTpcbiAqIGNoYXQtaGVhZGVyLXRleHQtZm9udC1zaXplOlxuICogY2hhdC1oZWFkZXItdGV4dC1mb250LXdlaWdodDpcbiAqIGNoYXQtaGVhZGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBjaGF0LXRpbnktaGVpZ2h0OlxuICogY2hhdC1zbWFsbC1oZWlnaHQ6XG4gKiBjaGF0LW1lZGl1bS1oZWlnaHQ6XG4gKiBjaGF0LWxhcmdlLWhlaWdodDpcbiAqIGNoYXQtZ2lhbnQtaGVpZ2h0OlxuICogY2hhdC1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hhdC1iYXNpYy10ZXh0LWNvbG9yOlxuICogY2hhdC1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIGNoYXQtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hhdC1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiBjaGF0LWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoYXQtaW5mby10ZXh0LWNvbG9yOlxuICogY2hhdC13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIGNoYXQtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LWRhbmdlci10ZXh0LWNvbG9yOlxuICogY2hhdC1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIGNoYXQtZGl2aWRlci1jb2xvcjpcbiAqIGNoYXQtZGl2aWRlci1zdHlsZTpcbiAqIGNoYXQtZGl2aWRlci13aWR0aDpcbiAqIGNoYXQtbWVzc2FnZS1iYWNrZ3JvdW5kOlxuICogY2hhdC1tZXNzYWdlLXRleHQtY29sb3I6XG4gKiBjaGF0LW1lc3NhZ2UtcmVwbHktYmFja2dyb3VuZC1jb2xvcjpcbiAqIGNoYXQtbWVzc2FnZS1yZXBseS10ZXh0LWNvbG9yOlxuICogY2hhdC1tZXNzYWdlLWF2YXRhci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogY2hhdC1tZXNzYWdlLXNlbmRlci10ZXh0LWNvbG9yOlxuICogY2hhdC1tZXNzYWdlLXF1b3RlLWJhY2tncm91bmQtY29sb3I6XG4gKiBjaGF0LW1lc3NhZ2UtcXVvdGUtdGV4dC1jb2xvcjpcbiAqIGNoYXQtbWVzc2FnZS1maWxlLXRleHQtY29sb3I6XG4gKiBjaGF0LW1lc3NhZ2UtZmlsZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICovXG5sZXQgTmJDaGF0Q29tcG9uZW50ID0gY2xhc3MgTmJDaGF0Q29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBDb252ZXJzYXRpb25hbCBVSSBjb2xsZWN0aW9uIC0gYSBzZXQgb2YgY29tcG9uZW50cyBmb3IgY2hhdC1saWtlIFVJIGNvbnN0cnVjdGlvbi5cbiAgICAgKlxuICAgICAqIE1haW4gZmVhdHVyZXM6XG4gICAgICogLSBkaWZmZXJlbnQgbWVzc2FnZSB0eXBlcyBzdXBwb3J0ICh0ZXh0LCBpbWFnZSwgZmlsZSwgZmlsZSBncm91cCwgbWFwLCBldGMpXG4gICAgICogLSBkcmFnICYgZHJvcCBmb3IgaW1hZ2VzIGFuZCBmaWxlcyB3aXRoIHByZXZpZXdcbiAgICAgKiAtIGRpZmZlcmVudCBVSSBzdHlsZXNcbiAgICAgKiAtIGN1c3RvbSBhY3Rpb24gYnV0dG9ucyAoY29taW5nIHNvb24pXG4gICAgICpcbiAgICAgKiBIZXJlJ3MgYSBjb21wbGV0ZSBleGFtcGxlIGJ1aWxkIGluIGEgYm90LWxpa2UgYXBwLiBUeXBlIGBoZWxwYCB0byBiZSBhYmxlIHRvIHJlY2VpdmUgZGlmZmVyZW50IG1lc3NhZ2UgdHlwZXMuXG4gICAgICogRW5qb3kgdGhlIGNvbnZlcnNhdGlvbiBhbmQgdGhlIGJlYXV0aWZ1bCBVSS5cbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBjaGF0L2NoYXQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogQmFzaWMgY2hhdCBjb25maWd1cmF0aW9uIGFuZCB1c2FnZTpcbiAgICAgKiBgYGB0c1xuICAgICAqIDxuYi1jaGF0IHRpdGxlPVwiTmVidWxhciBDb252ZXJzYXRpb25hbCBVSVwiPlxuICAgICAqICAgICAgIDxuYi1jaGF0LW1lc3NhZ2UgKm5nRm9yPVwibGV0IG1zZyBvZiBtZXNzYWdlc1wiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBbdHlwZV09XCJtc2cudHlwZVwiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBbbWVzc2FnZV09XCJtc2cudGV4dFwiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBbcmVwbHldPVwibXNnLnJlcGx5XCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIFtzZW5kZXJdPVwibXNnLnVzZXIubmFtZVwiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBbZGF0ZV09XCJtc2cuZGF0ZVwiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBbZmlsZXNdPVwibXNnLmZpbGVzXCJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIFtxdW90ZV09XCJtc2cucXVvdGVcIlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgW2xhdGl0dWRlXT1cIm1zZy5sYXRpdHVkZVwiXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICBbbG9uZ2l0dWRlXT1cIm1zZy5sb25naXR1ZGVcIlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgW2F2YXRhcl09XCJtc2cudXNlci5hdmF0YXJcIj5cbiAgICAgKiAgIDwvbmItY2hhdC1tZXNzYWdlPlxuICAgICAqXG4gICAgICogICA8bmItY2hhdC1mb3JtIChzZW5kKT1cInNlbmRNZXNzYWdlKCRldmVudClcIiBbZHJvcEZpbGVzXT1cInRydWVcIj5cbiAgICAgKiAgIDwvbmItY2hhdC1mb3JtPlxuICAgICAqIDwvbmItY2hhdD5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyMgSW5zdGFsbGF0aW9uXG4gICAgICpcbiAgICAgKiBJbXBvcnQgYE5iQ2hhdE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAgICAgKiBgYGB0c1xuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBpbXBvcnRzOiBbXG4gICAgICogICAgIC8vIC4uLlxuICAgICAqICAgICBOYkNoYXRNb2R1bGUsXG4gICAgICogICBdLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJZiB5b3UgbmVlZCB0byBwcm92aWRlIGFuIEFQSSBrZXkgZm9yIGEgYG1hcGAgbWVzc2FnZSB0eXBlICh3aGljaCBpcyByZXF1aXJlZCBieSBHb29nbGUgTWFwcylcbiAgICAgKiB5b3UgbWF5IHVzZSBgTmJDaGF0TW9kdWxlLmZvclJvb3QoeyAuLi4gfSlgIGNhbGwgaWYgdGhpcyBpcyBhIGdsb2JhbCBhcHAgY29uZmlndXJhdGlvblxuICAgICAqIG9yIGBOYkNoYXRNb2R1bGUuZm9yQ2hpbGQoeyAuLi4gfSlgIGZvciBhIGZlYXR1cmUgbW9kdWxlIGNvbmZpZ3VyYXRpb246XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBpbXBvcnRzOiBbXG4gICAgICogICAgIC8vIC4uLlxuICAgICAqICAgICBOYkNoYXRNb2R1bGUuZm9yUm9vdCh7IG1lc3NhZ2VHb29nbGVNYXBLZXk6ICdNQVBfS0VZJyB9KSxcbiAgICAgKiAgIF0sXG4gICAgICogfSlcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHsgfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBUaGVyZSBhcmUgdGhyZWUgbWFpbiBjb21wb25lbnRzOlxuICAgICAqIGBgYHRzXG4gICAgICogPG5iLWNoYXQ+XG4gICAgICogPC9uYi1jaGF0PiAvLyBjaGF0IGNvbnRhaW5lclxuICAgICAqXG4gICAgICogPG5iLWNoYXQtZm9ybT5cbiAgICAgKiA8L25iLWNoYXQtZm9ybT4gLy8gY2hhdCBmb3JtIHdpdGggZHJhZyZkcm9wIGZpbGVzIGZlYXR1cmVcbiAgICAgKlxuICAgICAqIDxuYi1jaGF0LW1lc3NhZ2U+XG4gICAgICogPC9uYi1jaGF0LW1lc3NhZ2U+IC8vIGNoYXQgbWVzc2FnZSwgYXZhaWxhYmxlIG11bHRpcGxlIHR5cGVzXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUd28gdXNlcnMgY29udmVyc2F0aW9uIHNob3djYXNlOlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoQ29udmVyc2F0aW9uLCBjaGF0L2NoYXQtY29udmVyc2F0aW9uLXNob3djYXNlLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIENoYXQgVUkgaXMgYWxzbyBhdmFpbGFibGUgaW4gZGlmZmVyZW50IGNvbG9ycyBieSBzcGVjaWZ5aW5nIGEgYFtzdGF0dXNdYCBpbnB1dDpcbiAgICAgKlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoQ29sb3JlZCBDaGF0LCBjaGF0L2NoYXQtY29sb3JzLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEFsc28gaXQgaXMgcG9zc2libGUgdG8gY29uZmlndXJlIHNpemVzIHRocm91Z2ggYFtzaXplXWAgaW5wdXQ6XG4gICAgICpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKENoYXQgU2l6ZXMsIGNoYXQvY2hhdC1zaXplcy5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBAc3R5bGVzXG4gICAgICpcbiAgICAgKiBjaGF0LWJhY2tncm91bmQtY29sb3I6XG4gICAgICogY2hhdC1ib3JkZXI6XG4gICAgICogY2hhdC1ib3JkZXItcmFkaXVzOlxuICAgICAqIGNoYXQtc2hhZG93OlxuICAgICAqIGNoYXQtcGFkZGluZzpcbiAgICAgKiBjaGF0LXNjcm9sbGJhci1jb2xvcjpcbiAgICAgKiBjaGF0LXNjcm9sbGJhci1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGNoYXQtc2Nyb2xsYmFyLXdpZHRoOlxuICAgICAqIGNoYXQtdGV4dC1jb2xvcjpcbiAgICAgKiBjaGF0LXRleHQtZm9udC1mYW1pbHk6XG4gICAgICogY2hhdC10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBjaGF0LXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogY2hhdC10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIGNoYXQtaGVhZGVyLXRleHQtZm9udC1mYW1pbHk6XG4gICAgICogY2hhdC1oZWFkZXItdGV4dC1mb250LXNpemU6XG4gICAgICogY2hhdC1oZWFkZXItdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBjaGF0LWhlYWRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIGNoYXQtdGlueS1oZWlnaHQ6XG4gICAgICogY2hhdC1zbWFsbC1oZWlnaHQ6XG4gICAgICogY2hhdC1tZWRpdW0taGVpZ2h0OlxuICAgICAqIGNoYXQtbGFyZ2UtaGVpZ2h0OlxuICAgICAqIGNoYXQtZ2lhbnQtaGVpZ2h0OlxuICAgICAqIGNoYXQtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBjaGF0LWJhc2ljLXRleHQtY29sb3I6XG4gICAgICogY2hhdC1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gICAgICogY2hhdC1wcmltYXJ5LXRleHQtY29sb3I6XG4gICAgICogY2hhdC1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogY2hhdC1zdWNjZXNzLXRleHQtY29sb3I6XG4gICAgICogY2hhdC1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogY2hhdC1pbmZvLXRleHQtY29sb3I6XG4gICAgICogY2hhdC13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogY2hhdC13YXJuaW5nLXRleHQtY29sb3I6XG4gICAgICogY2hhdC1kYW5nZXItYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBjaGF0LWRhbmdlci10ZXh0LWNvbG9yOlxuICAgICAqIGNoYXQtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGNoYXQtY29udHJvbC10ZXh0LWNvbG9yOlxuICAgICAqIGNoYXQtZGl2aWRlci1jb2xvcjpcbiAgICAgKiBjaGF0LWRpdmlkZXItc3R5bGU6XG4gICAgICogY2hhdC1kaXZpZGVyLXdpZHRoOlxuICAgICAqIGNoYXQtbWVzc2FnZS1iYWNrZ3JvdW5kOlxuICAgICAqIGNoYXQtbWVzc2FnZS10ZXh0LWNvbG9yOlxuICAgICAqIGNoYXQtbWVzc2FnZS1yZXBseS1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGNoYXQtbWVzc2FnZS1yZXBseS10ZXh0LWNvbG9yOlxuICAgICAqIGNoYXQtbWVzc2FnZS1hdmF0YXItYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBjaGF0LW1lc3NhZ2Utc2VuZGVyLXRleHQtY29sb3I6XG4gICAgICogY2hhdC1tZXNzYWdlLXF1b3RlLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogY2hhdC1tZXNzYWdlLXF1b3RlLXRleHQtY29sb3I6XG4gICAgICogY2hhdC1tZXNzYWdlLWZpbGUtdGV4dC1jb2xvcjpcbiAgICAgKiBjaGF0LW1lc3NhZ2UtZmlsZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSAnYmFzaWMnO1xuICAgICAgICB0aGlzLl9zY3JvbGxCb3R0b20gPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGF0IHN0YXR1cyBjb2xvciAoYWRkcyBzcGVjaWZpYyBzdHlsZXMpOlxuICAgICAqIGBiYXNpY2AgKGRlZmF1bHQpLCBgcHJpbWFyeWAsIGBzdWNjZXNzYCwgYGluZm9gLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgY29udHJvbGAuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgICB9XG4gICAgc2V0IHN0YXR1cyh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICBlbXB0eVN0YXR1c1dhcm5pbmcoJ05iQ2hhdCcpO1xuICAgICAgICAgICAgdmFsdWUgPSAnYmFzaWMnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgY2hhdCB0byB0aGUgYm90dG9tIG9mIHRoZSBsaXN0IHdoZW4gYSBuZXcgbWVzc2FnZSBhcnJpdmVzXG4gICAgICovXG4gICAgZ2V0IHNjcm9sbEJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Njcm9sbEJvdHRvbTtcbiAgICB9XG4gICAgc2V0IHNjcm9sbEJvdHRvbSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxCb3R0b20gPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmICgnc3RhdHVzJyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZvcm1TdGF0dXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRm9ybVN0YXR1cygpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMuY2hhbmdlc1xuICAgICAgICAgICAgLnN1YnNjcmliZSgobWVzc2FnZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlldygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XG4gICAgfVxuICAgIHVwZGF0ZVZpZXcoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxMaXN0Qm90dG9tKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2Nyb2xsTGlzdEJvdHRvbSgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxhYmxlLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxhYmxlLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH1cbiAgICB1cGRhdGVGb3JtU3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5jaGF0Rm9ybSkge1xuICAgICAgICAgICAgdGhpcy5jaGF0Rm9ybS5zZXRTdGF0dXModGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0aW55KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAndGlueSc7XG4gICAgfVxuICAgIGdldCBzbWFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3NtYWxsJztcbiAgICB9XG4gICAgZ2V0IG1lZGl1bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ21lZGl1bSc7XG4gICAgfVxuICAgIGdldCBsYXJnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2xhcmdlJztcbiAgICB9XG4gICAgZ2V0IGdpYW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnZ2lhbnQnO1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAncHJpbWFyeSc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgd2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnd2FybmluZyc7XG4gICAgfVxuICAgIGdldCBkYW5nZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Rhbmdlcic7XG4gICAgfVxuICAgIGdldCBiYXNpYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnYmFzaWMnO1xuICAgIH1cbiAgICBnZXQgY29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnY29udHJvbCc7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkOTIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2hhdENvbXBvbmVudC5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2hhdENvbXBvbmVudC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ5MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDU5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhJDU5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBOYkNoYXRDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXR1c1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNTkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYkNoYXRDb21wb25lbnQucHJvdG90eXBlLCBcInNjcm9sbEJvdHRvbVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTIoW1xuICAgIFZpZXdDaGlsZCgnc2Nyb2xsYWJsZScsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhJDU5KFwiZGVzaWduOnR5cGVcIiwgRWxlbWVudFJlZilcbl0sIE5iQ2hhdENvbXBvbmVudC5wcm90b3R5cGUsIFwic2Nyb2xsYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ5MihbXG4gICAgQ29udGVudENoaWxkcmVuKE5iQ2hhdE1lc3NhZ2VDb21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEkNTkoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBOYkNoYXRDb21wb25lbnQucHJvdG90eXBlLCBcIm1lc3NhZ2VzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDkyKFtcbiAgICBDb250ZW50Q2hpbGQoTmJDaGF0Rm9ybUNvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEkNTkoXCJkZXNpZ246dHlwZVwiLCBOYkNoYXRGb3JtQ29tcG9uZW50KVxuXSwgTmJDaGF0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjaGF0Rm9ybVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ5MihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtdGlueScpLFxuICAgIF9fbWV0YWRhdGEkNTkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDU5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNoYXRDb21wb25lbnQucHJvdG90eXBlLCBcInRpbnlcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkyKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1zbWFsbCcpLFxuICAgIF9fbWV0YWRhdGEkNTkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDU5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNoYXRDb21wb25lbnQucHJvdG90eXBlLCBcInNtYWxsXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtbWVkaXVtJyksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNTkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2hhdENvbXBvbmVudC5wcm90b3R5cGUsIFwibWVkaXVtXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtbGFyZ2UnKSxcbiAgICBfX21ldGFkYXRhJDU5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDaGF0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJsYXJnZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLWdpYW50JyksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNTkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2hhdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2lhbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkyKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLXByaW1hcnknKSxcbiAgICBfX21ldGFkYXRhJDU5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDaGF0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmltYXJ5XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1zdWNjZXNzJyksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNTkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2hhdENvbXBvbmVudC5wcm90b3R5cGUsIFwic3VjY2Vzc1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkOTIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtaW5mbycpLFxuICAgIF9fbWV0YWRhdGEkNTkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDU5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkNoYXRDb21wb25lbnQucHJvdG90eXBlLCBcImluZm9cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkyKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLXdhcm5pbmcnKSxcbiAgICBfX21ldGFkYXRhJDU5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDaGF0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3YXJuaW5nXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQ5MihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1kYW5nZXInKSxcbiAgICBfX21ldGFkYXRhJDU5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDaGF0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkYW5nZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkyKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWJhc2ljJyksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNTkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQ2hhdENvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFzaWNcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDkyKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWNvbnRyb2wnKSxcbiAgICBfX21ldGFkYXRhJDU5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ1OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJDaGF0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250cm9sXCIsIG51bGwpO1xuTmJDaGF0Q29tcG9uZW50ID0gX19kZWNvcmF0ZSQ5MihbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jaGF0JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8ZGl2IGNsYXNzPVwiaGVhZGVyXCI+e3sgdGl0bGUgfX08L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwic2Nyb2xsYWJsZVwiICNzY3JvbGxhYmxlPlxuICAgICAgPGRpdiBjbGFzcz1cIm1lc3NhZ2VzXCI+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWNoYXQtbWVzc2FnZVwiPjwvbmctY29udGVudD5cbiAgICAgICAgPHAgY2xhc3M9XCJuby1tZXNzYWdlc1wiICpuZ0lmPVwiIW1lc3NhZ2VzPy5sZW5ndGhcIj5ObyBtZXNzYWdlcyB5ZXQuPC9wPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImZvcm1cIj5cbiAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWNoYXQtZm9ybVwiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO3Bvc2l0aW9uOnJlbGF0aXZlO2hlaWdodDoxMDAlfVxcblwiXVxuICAgIH0pXG5dLCBOYkNoYXRDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jbGFzcyBOYkNoYXRPcHRpb25zIHtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkOTUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNjIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogQ2hhdCBtZXNzYWdlIGNvbXBvbmVudC5cbiAqL1xubGV0IE5iQ2hhdE1lc3NhZ2VNYXBDb21wb25lbnQgPSBjbGFzcyBOYkNoYXRNZXNzYWdlTWFwQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubWFwS2V5ID0gb3B0aW9ucy5tZXNzYWdlR29vZ2xlTWFwS2V5O1xuICAgIH1cbiAgICBnZXQgZmlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICAgIHVybDogYGh0dHBzOi8vbWFwcy5nb29nbGVhcGlzLmNvbS9tYXBzL2FwaS9zdGF0aWNtYXA/Y2VudGVyPSR7dGhpcy5sYXRpdHVkZX0sJHt0aGlzLmxvbmdpdHVkZX0mem9vbT0xMiZzaXplPTQwMHg0MDAma2V5PSR7dGhpcy5tYXBLZXl9YCxcbiAgICAgICAgICAgIHR5cGU6ICdpbWFnZS9wbmcnLFxuICAgICAgICAgICAgaWNvbjogJ2xvY2F0aW9uJyxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQ5NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDYyKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJDaGF0TWVzc2FnZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ5NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDYyKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJDaGF0TWVzc2FnZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VuZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDk1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjIoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgTmJDaGF0TWVzc2FnZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ5NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDYyKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTmJDaGF0TWVzc2FnZU1hcENvbXBvbmVudC5wcm90b3R5cGUsIFwibGF0aXR1ZGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ2MihcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE5iQ2hhdE1lc3NhZ2VNYXBDb21wb25lbnQucHJvdG90eXBlLCBcImxvbmdpdHVkZVwiLCB2b2lkIDApO1xuTmJDaGF0TWVzc2FnZU1hcENvbXBvbmVudCA9IF9fZGVjb3JhdGUkOTUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItY2hhdC1tZXNzYWdlLW1hcCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLWNoYXQtbWVzc2FnZS1maWxlIFtmaWxlc109XCJbZmlsZV1cIiBbbWVzc2FnZV09XCJtZXNzYWdlXCIgW3NlbmRlcl09XCJzZW5kZXJcIiBbZGF0ZV09XCJkYXRlXCI+PC9uYi1jaGF0LW1lc3NhZ2UtZmlsZT5cbiAgYCxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDYyKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iQ2hhdE9wdGlvbnNdKVxuXSwgTmJDaGF0TWVzc2FnZU1hcENvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDk2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDYzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIENoYXQgbWVzc2FnZSBjb21wb25lbnQuXG4gKi9cbmxldCBOYkNoYXRNZXNzYWdlRmlsZUNvbXBvbmVudCA9IGNsYXNzIE5iQ2hhdE1lc3NhZ2VGaWxlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjZCwgZG9tU2FuaXRpemVyKSB7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5kb21TYW5pdGl6ZXIgPSBkb21TYW5pdGl6ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgZmlsZSBwYXRoXG4gICAgICogQHR5cGUge0RhdGV9XG4gICAgICovXG4gICAgc2V0IGZpbGVzKGZpbGVzKSB7XG4gICAgICAgIHRoaXMucmVhZHlGaWxlcyA9IChmaWxlcyB8fCBbXSkubWFwKChmaWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0ltYWdlID0gdGhpcy5pc0ltYWdlKGZpbGUpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGZpbGUsIHsgdXJsU3R5bGU6IGlzSW1hZ2UgJiYgdGhpcy5kb21TYW5pdGl6ZXIuYnlwYXNzU2VjdXJpdHlUcnVzdFN0eWxlKGB1cmwoJHtmaWxlLnVybH0pYCksIGlzSW1hZ2U6IGlzSW1hZ2UgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNkLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gICAgaXNJbWFnZShmaWxlKSB7XG4gICAgICAgIHJldHVybiBbJ2ltYWdlL3BuZycsICdpbWFnZS9qcGVnJywgJ2ltYWdlL2dpZiddLmluY2x1ZGVzKGZpbGUudHlwZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkOTYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ2MyhcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2hhdE1lc3NhZ2VGaWxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtZXNzYWdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDk2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjMoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNoYXRNZXNzYWdlRmlsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VuZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDk2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjMoXCJkZXNpZ246dHlwZVwiLCBEYXRlKVxuXSwgTmJDaGF0TWVzc2FnZUZpbGVDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ2MyhcImRlc2lnbjp0eXBlXCIsIEFycmF5KSxcbiAgICBfX21ldGFkYXRhJDYzKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0FycmF5XSlcbl0sIE5iQ2hhdE1lc3NhZ2VGaWxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmaWxlc1wiLCBudWxsKTtcbk5iQ2hhdE1lc3NhZ2VGaWxlQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQ5NihbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jaGF0LW1lc3NhZ2UtZmlsZScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLWNoYXQtbWVzc2FnZS10ZXh0IFtzZW5kZXJdPVwic2VuZGVyXCIgW2RhdGVdPVwiZGF0ZVwiIFttZXNzYWdlXT1cIm1lc3NhZ2VcIj5cbiAgICAgIHt7IG1lc3NhZ2UgfX1cbiAgICA8L25iLWNoYXQtbWVzc2FnZS10ZXh0PlxuXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInJlYWR5RmlsZXM/Lmxlbmd0aCA+IDFcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlLWNvbnRlbnQtZ3JvdXBcIj5cbiAgICAgICAgPGEgKm5nRm9yPVwibGV0IGZpbGUgb2YgcmVhZHlGaWxlc1wiIFtocmVmXT1cImZpbGUudXJsXCIgdGFyZ2V0PVwiX2JsYW5rXCI+XG4gICAgICAgICAgPG5iLWljb24gW2ljb25dPVwiZmlsZS5pY29uXCIgKm5nSWY9XCIhZmlsZS51cmxTdHlsZSAmJiBmaWxlLmljb25cIj48L25iLWljb24+XG4gICAgICAgICAgPGRpdiAqbmdJZj1cImZpbGUudXJsU3R5bGVcIiBbc3R5bGUuYmFja2dyb3VuZC1pbWFnZV09XCJmaWxlLnVybFN0eWxlXCI+PC9kaXY+XG4gICAgICAgIDwvYT5cbiAgICAgIDwvZGl2PlxuICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInJlYWR5RmlsZXM/Lmxlbmd0aCA9PT0gMVwiPlxuICAgICAgPGEgW2hyZWZdPVwicmVhZHlGaWxlc1swXS51cmxcIiB0YXJnZXQ9XCJfYmxhbmtcIj5cbiAgICAgICAgPG5iLWljb24gW2ljb25dPVwicmVhZHlGaWxlc1swXS5pY29uXCIgKm5nSWY9XCIhcmVhZHlGaWxlc1swXS51cmxTdHlsZSAmJiByZWFkeUZpbGVzWzBdLmljb25cIj48L25iLWljb24+XG4gICAgICAgIDxkaXYgKm5nSWY9XCJyZWFkeUZpbGVzWzBdLnVybFN0eWxlXCIgW3N0eWxlLmJhY2tncm91bmQtaW1hZ2VdPVwicmVhZHlGaWxlc1swXS51cmxTdHlsZVwiPjwvZGl2PlxuICAgICAgPC9hPlxuICAgIDwvbmctY29udGFpbmVyPlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkNjMoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ2hhbmdlRGV0ZWN0b3JSZWYsIERvbVNhbml0aXplcl0pXG5dLCBOYkNoYXRNZXNzYWdlRmlsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDk3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDY0ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIENoYXQgbWVzc2FnZSBjb21wb25lbnQuXG4gKi9cbmxldCBOYkNoYXRNZXNzYWdlUXVvdGVDb21wb25lbnQgPSBjbGFzcyBOYkNoYXRNZXNzYWdlUXVvdGVDb21wb25lbnQge1xufTtcbl9fZGVjb3JhdGUkOTcoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ2NChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2hhdE1lc3NhZ2VRdW90ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ5NyhbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDY0KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJDaGF0TWVzc2FnZVF1b3RlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZW5kZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTcoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ2NChcImRlc2lnbjp0eXBlXCIsIERhdGUpXG5dLCBOYkNoYXRNZXNzYWdlUXVvdGVDb21wb25lbnQucHJvdG90eXBlLCBcImRhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkOTcoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ2NChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iQ2hhdE1lc3NhZ2VRdW90ZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicXVvdGVcIiwgdm9pZCAwKTtcbk5iQ2hhdE1lc3NhZ2VRdW90ZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUkOTcoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItY2hhdC1tZXNzYWdlLXF1b3RlJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8cCBjbGFzcz1cInNlbmRlclwiICpuZ0lmPVwic2VuZGVyIHx8IGRhdGVcIj57eyBzZW5kZXIgfX0gPHRpbWU+e3sgZGF0ZSAgfCBkYXRlOidzaG9ydFRpbWUnIH19PC90aW1lPjwvcD5cbiAgICA8cCBjbGFzcz1cInF1b3RlXCI+XG4gICAgICB7eyBxdW90ZSB9fVxuICAgIDwvcD5cbiAgICA8bmItY2hhdC1tZXNzYWdlLXRleHQgW21lc3NhZ2VdPVwibWVzc2FnZVwiPlxuICAgICAge3sgbWVzc2FnZSB9fVxuICAgIDwvbmItY2hhdC1tZXNzYWdlLXRleHQ+XG4gIGAsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgfSlcbl0sIE5iQ2hhdE1lc3NhZ2VRdW90ZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDk4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDY1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIENoYXQgbWVzc2FnZSBjb21wb25lbnQuXG4gKi9cbmxldCBOYkNoYXRNZXNzYWdlVGV4dENvbXBvbmVudCA9IGNsYXNzIE5iQ2hhdE1lc3NhZ2VUZXh0Q29tcG9uZW50IHtcbn07XG5fX2RlY29yYXRlJDk4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjUoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNoYXRNZXNzYWdlVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VuZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDk4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjUoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkNoYXRNZXNzYWdlVGV4dENvbXBvbmVudC5wcm90b3R5cGUsIFwibWVzc2FnZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQ5OChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDY1KFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIE5iQ2hhdE1lc3NhZ2VUZXh0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlXCIsIHZvaWQgMCk7XG5OYkNoYXRNZXNzYWdlVGV4dENvbXBvbmVudCA9IF9fZGVjb3JhdGUkOTgoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItY2hhdC1tZXNzYWdlLXRleHQnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxwIGNsYXNzPVwic2VuZGVyXCIgKm5nSWY9XCJzZW5kZXIgfHwgZGF0ZVwiPnt7IHNlbmRlciB9fSA8dGltZT57eyBkYXRlICB8IGRhdGU6J3Nob3J0VGltZScgfX08L3RpbWU+PC9wPlxuICAgIDxwIGNsYXNzPVwidGV4dFwiICpuZ0lmPVwibWVzc2FnZVwiPnt7IG1lc3NhZ2UgfX08L3A+XG4gIGAsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgfSlcbl0sIE5iQ2hhdE1lc3NhZ2VUZXh0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTAxID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDY2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIEJhc2ljIGlucHV0IGRpcmVjdGl2ZS5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgbmJJbnB1dD48L2lucHV0PlxuICogYGBgXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJJbnB1dE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJJbnB1dE1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogRGVmYXVsdCBpbnB1dCBzaXplIGlzIGBtZWRpdW1gOlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgaW5wdXQvaW5wdXQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIElucHV0cyBhcmUgYXZhaWxhYmxlIGluIG11bHRpcGxlIGNvbG9ycyB1c2luZyBgc3RhdHVzYCBwcm9wZXJ0eTpcbiAqIEBzdGFja2VkLWV4YW1wbGUoSW5wdXQgQ29sb3JzLCBpbnB1dC9pbnB1dC1jb2xvcnMuY29tcG9uZW50KVxuICpcbiAqIFRoZXJlIGFyZSB0aHJlZSBpbnB1dCBzaXplczpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKElucHV0IFNpemVzLCBpbnB1dC9pbnB1dC1zaXplcy5jb21wb25lbnQpXG4gKlxuICogSW5wdXRzIGF2YWlsYWJsZSBpbiBkaWZmZXJlbnQgc2hhcGVzLCB3aGljaCBjb3VsZCBiZSBjb21iaW5lZCB3aXRoIHRoZSBvdGhlciBwcm9wZXJ0aWVzOlxuICogQHN0YWNrZWQtZXhhbXBsZShJbnB1dCBTaGFwZXMsIGlucHV0L2lucHV0LXNoYXBlcy5jb21wb25lbnQpXG4gKlxuICogYG5iSW5wdXRgIGNvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIGZvbGxvd2luZyBzZWxlY3RvcnMgLSBgaW5wdXRgLCBgdGV4dGFyZWFgOlxuICogQHN0YWNrZWQtZXhhbXBsZShJbnB1dCBFbGVtZW50cywgaW5wdXQvaW5wdXQtdHlwZXMuY29tcG9uZW50KVxuICpcbiAqIFlvdSBjYW4gYWRkIGBmdWxsV2lkdGhgIGF0dHJpYnV0ZSB0byBtYWtlIGVsZW1lbnQgZmlsbCBjb250YWluZXI6XG4gKiBAc3RhY2tlZC1leGFtcGxlKEZ1bGwgd2lkdGggaW5wdXRzLCBpbnB1dC9pbnB1dC1mdWxsLXdpZHRoLmNvbXBvbmVudClcbiAqXG4gKiBPciB5b3UgY2FuIGJpbmQgY29udHJvbCB3aXRoIGZvcm0gY29udHJvbHMgb3IgbmdNb2RlbDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoSW5wdXQgZm9ybSBiaW5kaW5nLCBpbnB1dC9pbnB1dC1mb3JtLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogaW5wdXQtYm9yZGVyLXN0eWxlOlxuICogaW5wdXQtYm9yZGVyLXdpZHRoOlxuICogaW5wdXQtb3V0bGluZS1jb2xvcjpcbiAqIGlucHV0LW91dGxpbmUtd2lkdGg6XG4gKiBpbnB1dC1wbGFjZWhvbGRlci10ZXh0LWZvbnQtZmFtaWx5OlxuICogaW5wdXQtdGV4dC1mb250LWZhbWlseTpcbiAqIGlucHV0LWJhc2ljLXRleHQtY29sb3I6XG4gKiBpbnB1dC1iYXNpYy1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogaW5wdXQtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LWJhc2ljLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWJhc2ljLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1iYXNpYy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1iYXNpYy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtYmFzaWMtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtYmFzaWMtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LWJhc2ljLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWJhc2ljLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBpbnB1dC1iYXNpYy1kaXNhYmxlZC1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogaW5wdXQtcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogaW5wdXQtcHJpbWFyeS1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogaW5wdXQtcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtcHJpbWFyeS1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1wcmltYXJ5LWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1wcmltYXJ5LWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LXByaW1hcnktaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LXByaW1hcnktaG92ZXItYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtcHJpbWFyeS1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtcHJpbWFyeS1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1wcmltYXJ5LWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBpbnB1dC1wcmltYXJ5LWRpc2FibGVkLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBpbnB1dC1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiBpbnB1dC1zdWNjZXNzLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBpbnB1dC1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1zdWNjZXNzLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LXN1Y2Nlc3MtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LXN1Y2Nlc3MtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtc3VjY2Vzcy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtc3VjY2Vzcy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1zdWNjZXNzLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1zdWNjZXNzLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LXN1Y2Nlc3MtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIGlucHV0LXN1Y2Nlc3MtZGlzYWJsZWQtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LWluZm8tdGV4dC1jb2xvcjpcbiAqIGlucHV0LWluZm8tcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LWluZm8tYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtaW5mby1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtaW5mby1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1pbmZvLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1pbmZvLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWluZm8tZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LWluZm8tZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtaW5mby1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogaW5wdXQtaW5mby1kaXNhYmxlZC1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogaW5wdXQtd2FybmluZy10ZXh0LWNvbG9yOlxuICogaW5wdXQtd2FybmluZy1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogaW5wdXQtd2FybmluZy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtd2FybmluZy1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC13YXJuaW5nLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC13YXJuaW5nLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LXdhcm5pbmctaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LXdhcm5pbmctaG92ZXItYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtd2FybmluZy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtd2FybmluZy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC13YXJuaW5nLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBpbnB1dC13YXJuaW5nLWRpc2FibGVkLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBpbnB1dC1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LWRhbmdlci1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogaW5wdXQtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1kYW5nZXItYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtZGFuZ2VyLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1kYW5nZXItZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtZGFuZ2VyLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1kYW5nZXItaG92ZXItYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtZGFuZ2VyLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1kYW5nZXItZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtZGFuZ2VyLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBpbnB1dC1kYW5nZXItZGlzYWJsZWQtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIGlucHV0LWNvbnRyb2wtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIGlucHV0LWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtY29udHJvbC1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogaW5wdXQtY29udHJvbC1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBpbnB1dC1jb250cm9sLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBpbnB1dC1jb250cm9sLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIGlucHV0LWNvbnRyb2wtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIGlucHV0LWNvbnRyb2wtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogaW5wdXQtY29udHJvbC1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogaW5wdXQtY29udHJvbC1kaXNhYmxlZC1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogaW5wdXQtcmVjdGFuZ2xlLWJvcmRlci1yYWRpdXM6XG4gKiBpbnB1dC1zZW1pLXJvdW5kLWJvcmRlci1yYWRpdXM6XG4gKiBpbnB1dC1yb3VuZC1ib3JkZXItcmFkaXVzOlxuICogaW5wdXQtdGlueS10ZXh0LWZvbnQtc2l6ZTpcbiAqIGlucHV0LXRpbnktdGV4dC1mb250LXdlaWdodDpcbiAqIGlucHV0LXRpbnktdGV4dC1saW5lLWhlaWdodDpcbiAqIGlucHV0LXRpbnktcGxhY2Vob2xkZXItdGV4dC1mb250LXNpemU6XG4gKiBpbnB1dC10aW55LXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBpbnB1dC10aW55LXBsYWNlaG9sZGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBpbnB1dC10aW55LXBhZGRpbmc6XG4gKiBpbnB1dC10aW55LW1heC13aWR0aDpcbiAqIGlucHV0LXNtYWxsLXRleHQtZm9udC1zaXplOlxuICogaW5wdXQtc21hbGwtdGV4dC1mb250LXdlaWdodDpcbiAqIGlucHV0LXNtYWxsLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBpbnB1dC1zbWFsbC1wbGFjZWhvbGRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIGlucHV0LXNtYWxsLXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBpbnB1dC1zbWFsbC1wbGFjZWhvbGRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogaW5wdXQtc21hbGwtcGFkZGluZzpcbiAqIGlucHV0LXNtYWxsLW1heC13aWR0aDpcbiAqIGlucHV0LW1lZGl1bS10ZXh0LWZvbnQtc2l6ZTpcbiAqIGlucHV0LW1lZGl1bS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogaW5wdXQtbWVkaXVtLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBpbnB1dC1tZWRpdW0tcGxhY2Vob2xkZXItdGV4dC1mb250LXNpemU6XG4gKiBpbnB1dC1tZWRpdW0tcGxhY2Vob2xkZXItdGV4dC1mb250LXdlaWdodDpcbiAqIGlucHV0LW1lZGl1bS1wbGFjZWhvbGRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogaW5wdXQtbWVkaXVtLXBhZGRpbmc6XG4gKiBpbnB1dC1tZWRpdW0tbWF4LXdpZHRoOlxuICogaW5wdXQtbGFyZ2UtdGV4dC1mb250LXNpemU6XG4gKiBpbnB1dC1sYXJnZS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogaW5wdXQtbGFyZ2UtdGV4dC1saW5lLWhlaWdodDpcbiAqIGlucHV0LWxhcmdlLXBsYWNlaG9sZGVyLXRleHQtZm9udC1zaXplOlxuICogaW5wdXQtbGFyZ2UtcGxhY2Vob2xkZXItdGV4dC1mb250LXdlaWdodDpcbiAqIGlucHV0LWxhcmdlLXBsYWNlaG9sZGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBpbnB1dC1sYXJnZS1wYWRkaW5nOlxuICogaW5wdXQtbGFyZ2UtbWF4LXdpZHRoOlxuICogaW5wdXQtZ2lhbnQtdGV4dC1mb250LXNpemU6XG4gKiBpbnB1dC1naWFudC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogaW5wdXQtZ2lhbnQtdGV4dC1saW5lLWhlaWdodDpcbiAqIGlucHV0LWdpYW50LXBsYWNlaG9sZGVyLXRleHQtZm9udC1zaXplOlxuICogaW5wdXQtZ2lhbnQtcGxhY2Vob2xkZXItdGV4dC1mb250LXdlaWdodDpcbiAqIGlucHV0LWdpYW50LXBsYWNlaG9sZGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBpbnB1dC1naWFudC1wYWRkaW5nOlxuICogaW5wdXQtZ2lhbnQtbWF4LXdpZHRoOlxuICovXG5sZXQgTmJJbnB1dERpcmVjdGl2ZSA9IGNsYXNzIE5iSW5wdXREaXJlY3RpdmUge1xuICAgIC8qKlxuICAgICAqIEJhc2ljIGlucHV0IGRpcmVjdGl2ZS5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aW5wdXQgbmJJbnB1dD48L2lucHV0PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIEluc3RhbGxhdGlvblxuICAgICAqXG4gICAgICogSW1wb3J0IGBOYklucHV0TW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICAgICAqIGBgYHRzXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIGltcG9ydHM6IFtcbiAgICAgKiAgICAgLy8gLi4uXG4gICAgICogICAgIE5iSW5wdXRNb2R1bGUsXG4gICAgICogICBdLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gICAgICogYGBgXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IGlucHV0IHNpemUgaXMgYG1lZGl1bWA6XG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgaW5wdXQvaW5wdXQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogSW5wdXRzIGFyZSBhdmFpbGFibGUgaW4gbXVsdGlwbGUgY29sb3JzIHVzaW5nIGBzdGF0dXNgIHByb3BlcnR5OlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoSW5wdXQgQ29sb3JzLCBpbnB1dC9pbnB1dC1jb2xvcnMuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHRocmVlIGlucHV0IHNpemVzOlxuICAgICAqXG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShJbnB1dCBTaXplcywgaW5wdXQvaW5wdXQtc2l6ZXMuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogSW5wdXRzIGF2YWlsYWJsZSBpbiBkaWZmZXJlbnQgc2hhcGVzLCB3aGljaCBjb3VsZCBiZSBjb21iaW5lZCB3aXRoIHRoZSBvdGhlciBwcm9wZXJ0aWVzOlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoSW5wdXQgU2hhcGVzLCBpbnB1dC9pbnB1dC1zaGFwZXMuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogYG5iSW5wdXRgIGNvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIGZvbGxvd2luZyBzZWxlY3RvcnMgLSBgaW5wdXRgLCBgdGV4dGFyZWFgOlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoSW5wdXQgRWxlbWVudHMsIGlucHV0L2lucHV0LXR5cGVzLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIFlvdSBjYW4gYWRkIGBmdWxsV2lkdGhgIGF0dHJpYnV0ZSB0byBtYWtlIGVsZW1lbnQgZmlsbCBjb250YWluZXI6XG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShGdWxsIHdpZHRoIGlucHV0cywgaW5wdXQvaW5wdXQtZnVsbC13aWR0aC5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBPciB5b3UgY2FuIGJpbmQgY29udHJvbCB3aXRoIGZvcm0gY29udHJvbHMgb3IgbmdNb2RlbDpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKElucHV0IGZvcm0gYmluZGluZywgaW5wdXQvaW5wdXQtZm9ybS5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBAc3R5bGVzXG4gICAgICpcbiAgICAgKiBpbnB1dC1ib3JkZXItc3R5bGU6XG4gICAgICogaW5wdXQtYm9yZGVyLXdpZHRoOlxuICAgICAqIGlucHV0LW91dGxpbmUtY29sb3I6XG4gICAgICogaW5wdXQtb3V0bGluZS13aWR0aDpcbiAgICAgKiBpbnB1dC1wbGFjZWhvbGRlci10ZXh0LWZvbnQtZmFtaWx5OlxuICAgICAqIGlucHV0LXRleHQtZm9udC1mYW1pbHk6XG4gICAgICogaW5wdXQtYmFzaWMtdGV4dC1jb2xvcjpcbiAgICAgKiBpbnB1dC1iYXNpYy1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICAgICAqIGlucHV0LWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtYmFzaWMtYm9yZGVyLWNvbG9yOlxuICAgICAqIGlucHV0LWJhc2ljLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtYmFzaWMtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICAgICAqIGlucHV0LWJhc2ljLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtYmFzaWMtaG92ZXItYm9yZGVyLWNvbG9yOlxuICAgICAqIGlucHV0LWJhc2ljLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtYmFzaWMtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICAgICAqIGlucHV0LWJhc2ljLWRpc2FibGVkLXRleHQtY29sb3I6XG4gICAgICogaW5wdXQtYmFzaWMtZGlzYWJsZWQtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAgICAgKiBpbnB1dC1wcmltYXJ5LXRleHQtY29sb3I6XG4gICAgICogaW5wdXQtcHJpbWFyeS1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICAgICAqIGlucHV0LXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBpbnB1dC1wcmltYXJ5LWJvcmRlci1jb2xvcjpcbiAgICAgKiBpbnB1dC1wcmltYXJ5LWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtcHJpbWFyeS1mb2N1cy1ib3JkZXItY29sb3I6XG4gICAgICogaW5wdXQtcHJpbWFyeS1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGlucHV0LXByaW1hcnktaG92ZXItYm9yZGVyLWNvbG9yOlxuICAgICAqIGlucHV0LXByaW1hcnktZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBpbnB1dC1wcmltYXJ5LWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAgICAgKiBpbnB1dC1wcmltYXJ5LWRpc2FibGVkLXRleHQtY29sb3I6XG4gICAgICogaW5wdXQtcHJpbWFyeS1kaXNhYmxlZC1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICAgICAqIGlucHV0LXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAgICAgKiBpbnB1dC1zdWNjZXNzLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gICAgICogaW5wdXQtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGlucHV0LXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICAgICAqIGlucHV0LXN1Y2Nlc3MtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBpbnB1dC1zdWNjZXNzLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAgICAgKiBpbnB1dC1zdWNjZXNzLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtc3VjY2Vzcy1ob3Zlci1ib3JkZXItY29sb3I6XG4gICAgICogaW5wdXQtc3VjY2Vzcy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGlucHV0LXN1Y2Nlc3MtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICAgICAqIGlucHV0LXN1Y2Nlc3MtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAgICAgKiBpbnB1dC1zdWNjZXNzLWRpc2FibGVkLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gICAgICogaW5wdXQtaW5mby10ZXh0LWNvbG9yOlxuICAgICAqIGlucHV0LWluZm8tcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAgICAgKiBpbnB1dC1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtaW5mby1ib3JkZXItY29sb3I6XG4gICAgICogaW5wdXQtaW5mby1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGlucHV0LWluZm8tZm9jdXMtYm9yZGVyLWNvbG9yOlxuICAgICAqIGlucHV0LWluZm8taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBpbnB1dC1pbmZvLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAgICAgKiBpbnB1dC1pbmZvLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtaW5mby1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gICAgICogaW5wdXQtaW5mby1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICAgICAqIGlucHV0LWluZm8tZGlzYWJsZWQtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAgICAgKiBpbnB1dC13YXJuaW5nLXRleHQtY29sb3I6XG4gICAgICogaW5wdXQtd2FybmluZy1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICAgICAqIGlucHV0LXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBpbnB1dC13YXJuaW5nLWJvcmRlci1jb2xvcjpcbiAgICAgKiBpbnB1dC13YXJuaW5nLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtd2FybmluZy1mb2N1cy1ib3JkZXItY29sb3I6XG4gICAgICogaW5wdXQtd2FybmluZy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGlucHV0LXdhcm5pbmctaG92ZXItYm9yZGVyLWNvbG9yOlxuICAgICAqIGlucHV0LXdhcm5pbmctZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBpbnB1dC13YXJuaW5nLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAgICAgKiBpbnB1dC13YXJuaW5nLWRpc2FibGVkLXRleHQtY29sb3I6XG4gICAgICogaW5wdXQtd2FybmluZy1kaXNhYmxlZC1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICAgICAqIGlucHV0LWRhbmdlci10ZXh0LWNvbG9yOlxuICAgICAqIGlucHV0LWRhbmdlci1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICAgICAqIGlucHV0LWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGlucHV0LWRhbmdlci1ib3JkZXItY29sb3I6XG4gICAgICogaW5wdXQtZGFuZ2VyLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtZGFuZ2VyLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAgICAgKiBpbnB1dC1kYW5nZXItaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBpbnB1dC1kYW5nZXItaG92ZXItYm9yZGVyLWNvbG9yOlxuICAgICAqIGlucHV0LWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGlucHV0LWRhbmdlci1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gICAgICogaW5wdXQtZGFuZ2VyLWRpc2FibGVkLXRleHQtY29sb3I6XG4gICAgICogaW5wdXQtZGFuZ2VyLWRpc2FibGVkLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gICAgICogaW5wdXQtY29udHJvbC10ZXh0LWNvbG9yOlxuICAgICAqIGlucHV0LWNvbnRyb2wtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAgICAgKiBpbnB1dC1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtY29udHJvbC1ib3JkZXItY29sb3I6XG4gICAgICogaW5wdXQtY29udHJvbC1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIGlucHV0LWNvbnRyb2wtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICAgICAqIGlucHV0LWNvbnRyb2wtaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBpbnB1dC1jb250cm9sLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAgICAgKiBpbnB1dC1jb250cm9sLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogaW5wdXQtY29udHJvbC1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gICAgICogaW5wdXQtY29udHJvbC1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICAgICAqIGlucHV0LWNvbnRyb2wtZGlzYWJsZWQtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAgICAgKiBpbnB1dC1yZWN0YW5nbGUtYm9yZGVyLXJhZGl1czpcbiAgICAgKiBpbnB1dC1zZW1pLXJvdW5kLWJvcmRlci1yYWRpdXM6XG4gICAgICogaW5wdXQtcm91bmQtYm9yZGVyLXJhZGl1czpcbiAgICAgKiBpbnB1dC10aW55LXRleHQtZm9udC1zaXplOlxuICAgICAqIGlucHV0LXRpbnktdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBpbnB1dC10aW55LXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogaW5wdXQtdGlueS1wbGFjZWhvbGRlci10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBpbnB1dC10aW55LXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogaW5wdXQtdGlueS1wbGFjZWhvbGRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIGlucHV0LXRpbnktcGFkZGluZzpcbiAgICAgKiBpbnB1dC10aW55LW1heC13aWR0aDpcbiAgICAgKiBpbnB1dC1zbWFsbC10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBpbnB1dC1zbWFsbC10ZXh0LWZvbnQtd2VpZ2h0OlxuICAgICAqIGlucHV0LXNtYWxsLXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogaW5wdXQtc21hbGwtcGxhY2Vob2xkZXItdGV4dC1mb250LXNpemU6XG4gICAgICogaW5wdXQtc21hbGwtcGxhY2Vob2xkZXItdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBpbnB1dC1zbWFsbC1wbGFjZWhvbGRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIGlucHV0LXNtYWxsLXBhZGRpbmc6XG4gICAgICogaW5wdXQtc21hbGwtbWF4LXdpZHRoOlxuICAgICAqIGlucHV0LW1lZGl1bS10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBpbnB1dC1tZWRpdW0tdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBpbnB1dC1tZWRpdW0tdGV4dC1saW5lLWhlaWdodDpcbiAgICAgKiBpbnB1dC1tZWRpdW0tcGxhY2Vob2xkZXItdGV4dC1mb250LXNpemU6XG4gICAgICogaW5wdXQtbWVkaXVtLXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogaW5wdXQtbWVkaXVtLXBsYWNlaG9sZGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogaW5wdXQtbWVkaXVtLXBhZGRpbmc6XG4gICAgICogaW5wdXQtbWVkaXVtLW1heC13aWR0aDpcbiAgICAgKiBpbnB1dC1sYXJnZS10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBpbnB1dC1sYXJnZS10ZXh0LWZvbnQtd2VpZ2h0OlxuICAgICAqIGlucHV0LWxhcmdlLXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogaW5wdXQtbGFyZ2UtcGxhY2Vob2xkZXItdGV4dC1mb250LXNpemU6XG4gICAgICogaW5wdXQtbGFyZ2UtcGxhY2Vob2xkZXItdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBpbnB1dC1sYXJnZS1wbGFjZWhvbGRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIGlucHV0LWxhcmdlLXBhZGRpbmc6XG4gICAgICogaW5wdXQtbGFyZ2UtbWF4LXdpZHRoOlxuICAgICAqIGlucHV0LWdpYW50LXRleHQtZm9udC1zaXplOlxuICAgICAqIGlucHV0LWdpYW50LXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogaW5wdXQtZ2lhbnQtdGV4dC1saW5lLWhlaWdodDpcbiAgICAgKiBpbnB1dC1naWFudC1wbGFjZWhvbGRlci10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBpbnB1dC1naWFudC1wbGFjZWhvbGRlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICAgICAqIGlucHV0LWdpYW50LXBsYWNlaG9sZGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogaW5wdXQtZ2lhbnQtcGFkZGluZzpcbiAgICAgKiBpbnB1dC1naWFudC1tYXgtd2lkdGg6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaWVsZCBzaXplIG1vZGlmaWNhdGlvbnMuIFBvc3NpYmxlIHZhbHVlczogYHNtYWxsYCwgYG1lZGl1bWAgKGRlZmF1bHQpLCBgbGFyZ2VgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWVsZFNpemUgPSAnbWVkaXVtJztcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gJ2Jhc2ljJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpZWxkIHNoYXBlcyBtb2RpZmljYXRpb25zLiBQb3NzaWJsZSB2YWx1ZXM6IGByZWN0YW5nbGVgIChkZWZhdWx0KSwgYHJvdW5kYCwgYHNlbWktcm91bmRgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaGFwZSA9ICdyZWN0YW5nbGUnO1xuICAgICAgICB0aGlzLl9mdWxsV2lkdGggPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmllbGQgc3RhdHVzIChhZGRzIHNwZWNpZmljIHN0eWxlcyk6XG4gICAgICogYGJhc2ljYCwgYHByaW1hcnlgLCBgaW5mb2AsIGBzdWNjZXNzYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCwgYGNvbnRyb2xgXG4gICAgICovXG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgICB9XG4gICAgc2V0IHN0YXR1cyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICBlbXB0eVN0YXR1c1dhcm5pbmcoJ05iSW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YXR1cyA9ICdiYXNpYyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgZWxlbWVudCB3aWxsIGZpbGwgY29udGFpbmVyLiBgZmFsc2VgIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgZ2V0IGZ1bGxXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bGxXaWR0aDtcbiAgICB9XG4gICAgc2V0IGZ1bGxXaWR0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mdWxsV2lkdGggPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgdGlueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRTaXplID09PSAndGlueSc7XG4gICAgfVxuICAgIGdldCBzbWFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGRTaXplID09PSAnc21hbGwnO1xuICAgIH1cbiAgICBnZXQgbWVkaXVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZFNpemUgPT09ICdtZWRpdW0nO1xuICAgIH1cbiAgICBnZXQgbGFyZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpZWxkU2l6ZSA9PT0gJ2xhcmdlJztcbiAgICB9XG4gICAgZ2V0IGdpYW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZFNpemUgPT09ICdnaWFudCc7XG4gICAgfVxuICAgIGdldCBwcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgZ2V0IHJlY3RhbmdsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUgPT09ICdyZWN0YW5nbGUnO1xuICAgIH1cbiAgICBnZXQgc2VtaVJvdW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFwZSA9PT0gJ3NlbWktcm91bmQnO1xuICAgIH1cbiAgICBnZXQgcm91bmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXBlID09PSAncm91bmQnO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDEwMShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmllbGRTaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEwMShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBOYklucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdGF0dXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic2hhcGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTAxKFtcbiAgICBJbnB1dCgpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5pbnB1dC1mdWxsLXdpZHRoJyksXG4gICAgX19tZXRhZGF0YSQ2NihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYklucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJmdWxsV2lkdGhcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtdGlueScpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcInRpbnlcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtc21hbGwnKSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYklucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzbWFsbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTAxKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1tZWRpdW0nKSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYklucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJtZWRpdW1cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtbGFyZ2UnKSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYklucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsYXJnZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTAxKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1naWFudCcpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImdpYW50XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMDEoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtcHJpbWFyeScpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcInByaW1hcnlcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1pbmZvJyksXG4gICAgX19tZXRhZGF0YSQ2NihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ2NihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiaW5mb1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTAxKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnKSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYklucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdWNjZXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMDEoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtd2FybmluZycpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcIndhcm5pbmdcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1kYW5nZXInKSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYklucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJkYW5nZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1iYXNpYycpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImJhc2ljXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMDEoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtY29udHJvbCcpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbnRyb2xcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNoYXBlLXJlY3RhbmdsZScpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcInJlY3RhbmdsZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTAxKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2hhcGUtc2VtaS1yb3VuZCcpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iSW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcInNlbWlSb3VuZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTAxKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2hhcGUtcm91bmQnKSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDY2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYklucHV0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJyb3VuZFwiLCBudWxsKTtcbk5iSW5wdXREaXJlY3RpdmUgPSBfX2RlY29yYXRlJDEwMShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFtuYklucHV0XSx0ZXh0YXJlYVtuYklucHV0XScsXG4gICAgfSlcbl0sIE5iSW5wdXREaXJlY3RpdmUpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMDAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuY29uc3QgTkJfSU5QVVRfQ09NUE9ORU5UUyA9IFtcbiAgICBOYklucHV0RGlyZWN0aXZlLFxuXTtcbmxldCBOYklucHV0TW9kdWxlID0gY2xhc3MgTmJJbnB1dE1vZHVsZSB7XG59O1xuTmJJbnB1dE1vZHVsZSA9IF9fZGVjb3JhdGUkMTAwKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtOYlNoYXJlZE1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogTkJfSU5QVVRfQ09NUE9ORU5UUyxcbiAgICAgICAgZXhwb3J0czogTkJfSU5QVVRfQ09NUE9ORU5UUyxcbiAgICB9KVxuXSwgTmJJbnB1dE1vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDk5ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBOYkNoYXRNb2R1bGVfMTtcbmNvbnN0IE5CX0NIQVRfQ09NUE9ORU5UUyA9IFtcbiAgICBOYkNoYXRDb21wb25lbnQsXG4gICAgTmJDaGF0TWVzc2FnZUNvbXBvbmVudCxcbiAgICBOYkNoYXRGb3JtQ29tcG9uZW50LFxuICAgIE5iQ2hhdE1lc3NhZ2VUZXh0Q29tcG9uZW50LFxuICAgIE5iQ2hhdE1lc3NhZ2VGaWxlQ29tcG9uZW50LFxuICAgIE5iQ2hhdE1lc3NhZ2VRdW90ZUNvbXBvbmVudCxcbiAgICBOYkNoYXRNZXNzYWdlTWFwQ29tcG9uZW50LFxuXTtcbmxldCBOYkNoYXRNb2R1bGUgPSBOYkNoYXRNb2R1bGVfMSA9IGNsYXNzIE5iQ2hhdE1vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iQ2hhdE1vZHVsZV8xLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOYkNoYXRPcHRpb25zLCB1c2VWYWx1ZTogb3B0aW9ucyB8fCB7fSB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZvckNoaWxkKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBOYkNoYXRNb2R1bGVfMSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTmJDaGF0T3B0aW9ucywgdXNlVmFsdWU6IG9wdGlvbnMgfHwge30gfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbk5iQ2hhdE1vZHVsZSA9IE5iQ2hhdE1vZHVsZV8xID0gX19kZWNvcmF0ZSQ5OShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBOYlNoYXJlZE1vZHVsZSxcbiAgICAgICAgICAgIE5iSWNvbk1vZHVsZSxcbiAgICAgICAgICAgIE5iSW5wdXRNb2R1bGUsXG4gICAgICAgICAgICBOYkJ1dHRvbk1vZHVsZSxcbiAgICAgICAgXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAuLi5OQl9DSEFUX0NPTVBPTkVOVFMsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIC4uLk5CX0NIQVRfQ09NUE9ORU5UUyxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJDaGF0TW9kdWxlKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTAyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDY3ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFN0eWxlZCBzcGlubmVyIGNvbXBvbmVudFxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBzcGlubmVyLXRleHQtY29sb3I6XG4gKiBzcGlubmVyLXRleHQtZm9udC1mYW1pbHk6XG4gKiBzcGlubmVyLXRleHQtZm9udC1zaXplOlxuICogc3Bpbm5lci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogc3Bpbm5lci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogc3Bpbm5lci1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc3Bpbm5lci1iYXNpYy1jaXJjbGUtZmlsbGVkLWNvbG9yOlxuICogc3Bpbm5lci1iYXNpYy1jaXJjbGUtZW1wdHktY29sb3I6XG4gKiBzcGlubmVyLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNwaW5uZXItcHJpbWFyeS1jaXJjbGUtZmlsbGVkLWNvbG9yOlxuICogc3Bpbm5lci1wcmltYXJ5LWNpcmNsZS1lbXB0eS1jb2xvcjpcbiAqIHNwaW5uZXItaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc3Bpbm5lci1pbmZvLWNpcmNsZS1maWxsZWQtY29sb3I6XG4gKiBzcGlubmVyLWluZm8tY2lyY2xlLWVtcHR5LWNvbG9yOlxuICogc3Bpbm5lci1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gKiBzcGlubmVyLXN1Y2Nlc3MtY2lyY2xlLWZpbGxlZC1jb2xvcjpcbiAqIHNwaW5uZXItc3VjY2Vzcy1jaXJjbGUtZW1wdHktY29sb3I6XG4gKiBzcGlubmVyLXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNwaW5uZXItd2FybmluZy1jaXJjbGUtZmlsbGVkLWNvbG9yOlxuICogc3Bpbm5lci13YXJuaW5nLWNpcmNsZS1lbXB0eS1jb2xvcjpcbiAqIHNwaW5uZXItZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzcGlubmVyLWRhbmdlci1jaXJjbGUtZmlsbGVkLWNvbG9yOlxuICogc3Bpbm5lci1kYW5nZXItY2lyY2xlLWVtcHR5LWNvbG9yOlxuICogc3Bpbm5lci1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gKiBzcGlubmVyLWNvbnRyb2wtY2lyY2xlLWZpbGxlZC1jb2xvcjpcbiAqIHNwaW5uZXItY29udHJvbC1jaXJjbGUtZW1wdHktY29sb3I6XG4gKiBzcGlubmVyLWhlaWdodC10aW55OlxuICogc3Bpbm5lci1oZWlnaHQtc21hbGw6XG4gKiBzcGlubmVyLWhlaWdodC1tZWRpdW06XG4gKiBzcGlubmVyLWhlaWdodC1sYXJnZTpcbiAqIHNwaW5uZXItaGVpZ2h0LWdpYW50OlxuICovXG5sZXQgTmJTcGlubmVyQ29tcG9uZW50ID0gY2xhc3MgTmJTcGlubmVyQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBTdHlsZWQgc3Bpbm5lciBjb21wb25lbnRcbiAgICAgKlxuICAgICAqIEBzdHlsZXNcbiAgICAgKlxuICAgICAqIHNwaW5uZXItdGV4dC1jb2xvcjpcbiAgICAgKiBzcGlubmVyLXRleHQtZm9udC1mYW1pbHk6XG4gICAgICogc3Bpbm5lci10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBzcGlubmVyLXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogc3Bpbm5lci10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIHNwaW5uZXItYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBzcGlubmVyLWJhc2ljLWNpcmNsZS1maWxsZWQtY29sb3I6XG4gICAgICogc3Bpbm5lci1iYXNpYy1jaXJjbGUtZW1wdHktY29sb3I6XG4gICAgICogc3Bpbm5lci1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gICAgICogc3Bpbm5lci1wcmltYXJ5LWNpcmNsZS1maWxsZWQtY29sb3I6XG4gICAgICogc3Bpbm5lci1wcmltYXJ5LWNpcmNsZS1lbXB0eS1jb2xvcjpcbiAgICAgKiBzcGlubmVyLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiBzcGlubmVyLWluZm8tY2lyY2xlLWZpbGxlZC1jb2xvcjpcbiAgICAgKiBzcGlubmVyLWluZm8tY2lyY2xlLWVtcHR5LWNvbG9yOlxuICAgICAqIHNwaW5uZXItc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHNwaW5uZXItc3VjY2Vzcy1jaXJjbGUtZmlsbGVkLWNvbG9yOlxuICAgICAqIHNwaW5uZXItc3VjY2Vzcy1jaXJjbGUtZW1wdHktY29sb3I6XG4gICAgICogc3Bpbm5lci13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogc3Bpbm5lci13YXJuaW5nLWNpcmNsZS1maWxsZWQtY29sb3I6XG4gICAgICogc3Bpbm5lci13YXJuaW5nLWNpcmNsZS1lbXB0eS1jb2xvcjpcbiAgICAgKiBzcGlubmVyLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHNwaW5uZXItZGFuZ2VyLWNpcmNsZS1maWxsZWQtY29sb3I6XG4gICAgICogc3Bpbm5lci1kYW5nZXItY2lyY2xlLWVtcHR5LWNvbG9yOlxuICAgICAqIHNwaW5uZXItY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHNwaW5uZXItY29udHJvbC1jaXJjbGUtZmlsbGVkLWNvbG9yOlxuICAgICAqIHNwaW5uZXItY29udHJvbC1jaXJjbGUtZW1wdHktY29sb3I6XG4gICAgICogc3Bpbm5lci1oZWlnaHQtdGlueTpcbiAgICAgKiBzcGlubmVyLWhlaWdodC1zbWFsbDpcbiAgICAgKiBzcGlubmVyLWhlaWdodC1tZWRpdW06XG4gICAgICogc3Bpbm5lci1oZWlnaHQtbGFyZ2U6XG4gICAgICogc3Bpbm5lci1oZWlnaHQtZ2lhbnQ6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkaW5nIHRleHQgdGhhdCBpcyBzaG93biBuZWFyIHRoZSBpY29uXG4gICAgICAgICAqIEB0eXBlIHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZXNzYWdlID0gJ0xvYWRpbmcuLi4nO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3Bpbm5lciBzaXplLCBhdmFpbGFibGUgc2l6ZXM6XG4gICAgICAgICAqIHRpbnksIHNtYWxsLCBtZWRpdW0sIGxhcmdlLCBnaWFudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSAnYmFzaWMnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTcGlubmVyIHN0YXR1cyAoYWRkcyBzcGVjaWZpYyBzdHlsZXMpOlxuICAgICAqIGBiYXNpY2AsIGBwcmltYXJ5YCwgYGluZm9gLCBgc3VjY2Vzc2AsIGB3YXJuaW5nYCwgYGRhbmdlcmAsIGBjb250cm9sYC5cbiAgICAgKi9cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICAgIH1cbiAgICBzZXQgc3RhdHVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGVtcHR5U3RhdHVzV2FybmluZygnTmJTcGlubmVyJyk7XG4gICAgICAgICAgICB2YWx1ZSA9ICdiYXNpYyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdHVzID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB0aW55KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAndGlueSc7XG4gICAgfVxuICAgIGdldCBzbWFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ3NtYWxsJztcbiAgICB9XG4gICAgZ2V0IG1lZGl1bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ21lZGl1bSc7XG4gICAgfVxuICAgIGdldCBsYXJnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2xhcmdlJztcbiAgICB9XG4gICAgZ2V0IGdpYW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnZ2lhbnQnO1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAncHJpbWFyeSc7XG4gICAgfVxuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdpbmZvJztcbiAgICB9XG4gICAgZ2V0IHN1Y2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnO1xuICAgIH1cbiAgICBnZXQgd2FybmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnd2FybmluZyc7XG4gICAgfVxuICAgIGdldCBkYW5nZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Rhbmdlcic7XG4gICAgfVxuICAgIGdldCBiYXNpYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnYmFzaWMnO1xuICAgIH1cbiAgICBnZXQgY29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnY29udHJvbCc7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTAyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlNwaW5uZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1lc3NhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTAyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlNwaW5uZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTAyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIE5iU3Bpbm5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhdHVzXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMDIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLXRpbnknKSxcbiAgICBfX21ldGFkYXRhJDY3KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDY3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNwaW5uZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRpbnlcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtc21hbGwnKSxcbiAgICBfX21ldGFkYXRhJDY3KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDY3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNwaW5uZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNtYWxsXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMDIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLW1lZGl1bScpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU3Bpbm5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWVkaXVtXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMDIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLWxhcmdlJyksXG4gICAgX19tZXRhZGF0YSQ2NyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ2NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTcGlubmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYXJnZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTAyKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1naWFudCcpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU3Bpbm5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZ2lhbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyksXG4gICAgX19tZXRhZGF0YSQ2NyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ2NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTcGlubmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmltYXJ5XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMDIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtaW5mbycpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU3Bpbm5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5mb1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTAyKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnKSxcbiAgICBfX21ldGFkYXRhJDY3KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDY3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNwaW5uZXJDb21wb25lbnQucHJvdG90eXBlLCBcInN1Y2Nlc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy13YXJuaW5nJyksXG4gICAgX19tZXRhZGF0YSQ2NyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ2NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTcGlubmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ3YXJuaW5nXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMDIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtZGFuZ2VyJyksXG4gICAgX19tZXRhZGF0YSQ2NyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ2NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTcGlubmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYW5nZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1iYXNpYycpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU3Bpbm5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFzaWNcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwMihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1jb250cm9sJyksXG4gICAgX19tZXRhZGF0YSQ2NyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ2NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTcGlubmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250cm9sXCIsIG51bGwpO1xuTmJTcGlubmVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxMDIoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItc3Bpbm5lcicsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPHNwYW4gY2xhc3M9XCJzcGluLWNpcmNsZVwiPjwvc3Bhbj5cbiAgICA8c3BhbiBjbGFzcz1cIm1lc3NhZ2VcIiAqbmdJZj1cIm1lc3NhZ2VcIj57eyBtZXNzYWdlIH19PC9zcGFuPlxuICBgLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0e29wYWNpdHk6MTtwb3NpdGlvbjphYnNvbHV0ZTtib3JkZXItcmFkaXVzOmluaGVyaXQ7dG9wOjA7cmlnaHQ6MDtsZWZ0OjA7Ym90dG9tOjA7b3ZlcmZsb3c6aGlkZGVuO3otaW5kZXg6OTk5OTtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7dmlzaWJpbGl0eTp2aXNpYmxlfTpob3N0IC5zcGluLWNpcmNsZXthbmltYXRpb246c3BpbiAwLjhzIGluZmluaXRlIGxpbmVhcjtib3JkZXItcmFkaXVzOjUwJTtib3JkZXItc3R5bGU6c29saWQ7Ym9yZGVyLXdpZHRoOjAuMTI1ZW07d2lkdGg6MWVtO2hlaWdodDoxZW19Omhvc3QgLm1lc3NhZ2V7bWFyZ2luLWxlZnQ6MC41cmVtfVxcblwiXVxuICAgIH0pXG5dLCBOYlNwaW5uZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMDMgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNjggPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogU3R5bGVkIHNwaW5uZXIgZGlyZWN0aXZlXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTcGlubmVyIFNob3djYXNlLCBzcGlubmVyL3NwaW5uZXItY2FyZC5jb21wb25lbnQpXG4gKlxuICpcbiAqIGBgYHRzXG4gKiA8bmItY2FyZCBbbmJTcGlubmVyXT1cImxvYWRpbmdcIiBuYlNwaW5uZXJTdGF0dXM9XCJkYW5nZXJcIj5cbiAqICAgPG5iLWNhcmQtYm9keT5DYXJkIENvbnRlbnQ8L25iLWNhcmQtYm9keT5cbiAqIDwvbmItY2FyZD5cbiAqIGBgYFxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iU3Bpbm5lck1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJTcGlubmVyTW9kdWxlLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICogYGBgXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBDb3VsZCBiZSBjb2xvcmVkIHVzaW5nIGBzdGF0dXNgIHByb3BlcnR5XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTcGlubmVyIENvbG9ycywgc3Bpbm5lci9zcGlubmVyLWNvbG9ycy5jb21wb25lbnQpXG4gKlxuICogQXZhaWxhYmxlIGluIGRpZmZlcmVudCBzaXplcyB3aXRoIGBzaXplYCBwcm9wZXJ0eTpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNwaW5uZXIgU2l6ZXMsIHNwaW5uZXIvc3Bpbm5lci1zaXplcy5jb21wb25lbnQpXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBwbGFjZSBpdCBpbnRvIHRoZSBidXR0b246XG4gKiBAc3RhY2tlZC1leGFtcGxlKEJ1dHRvbnMgd2l0aCBzcGlubmVyLCBzcGlubmVyL3NwaW5uZXItYnV0dG9uLmNvbXBvbmVudClcbiAqXG4gKiBPciB0YWJzOlxuICogQHN0YWNrZWQtZXhhbXBsZShTcGlubmVyIGluIHRhYnMsIHNwaW5uZXIvc3Bpbm5lci10YWJzLmNvbXBvbmVudClcbiAqL1xubGV0IE5iU3Bpbm5lckRpcmVjdGl2ZSA9IGNsYXNzIE5iU3Bpbm5lckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZGlyZWN0aXZlVmlldywgY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCByZW5kZXJlciwgZGlyZWN0aXZlRWxlbWVudCkge1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZVZpZXcgPSBkaXJlY3RpdmVWaWV3O1xuICAgICAgICB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA9IGNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZUVsZW1lbnQgPSBkaXJlY3RpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLnNob3VsZFNob3cgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwaW5uZXIgc3RhdHVzIGNvbG9yXG4gICAgICAgICAqIGBiYXNpY2AsIGBwcmltYXJ5YCwgYGluZm9gLCBgc3VjY2Vzc2AsIGB3YXJuaW5nYCwgYGRhbmdlcmAsIGBjb250cm9sYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3Bpbm5lclN0YXR1cyA9ICdiYXNpYyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGlubmVyIHNpemUuIFBvc3NpYmxlIHZhbHVlczogYHRpbnlgLCBgc21hbGxgLCBgbWVkaXVtYCAoZGVmYXVsdCksIGBsYXJnZWAsIGBnaWFudGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3Bpbm5lclNpemUgPSAnbWVkaXVtJztcbiAgICAgICAgdGhpcy5pc1NwaW5uZXJFeGlzdCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXJlY3RpdmUgdmFsdWUgLSBzaG93IG9yIGhpZGUgc3Bpbm5lclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsXG4gICAgICovXG4gICAgc2V0IG5iU3Bpbm5lcih2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50RmFjdG9yeSkge1xuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZFNob3cgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuY29tcG9uZW50RmFjdG9yeSA9IHRoaXMuY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KE5iU3Bpbm5lckNvbXBvbmVudCk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3Bpbm5lckV4aXN0KSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZVZpZXcucmVtb3ZlKCk7XG4gICAgICAgICAgICB0aGlzLmlzU3Bpbm5lckV4aXN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU3Bpbm5lckV4aXN0KSB7XG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIgPSB0aGlzLmRpcmVjdGl2ZVZpZXcuY3JlYXRlQ29tcG9uZW50KHRoaXMuY29tcG9uZW50RmFjdG9yeSk7XG4gICAgICAgICAgICB0aGlzLnNldEluc3RhbmNlSW5wdXRzKHRoaXMuc3Bpbm5lci5pbnN0YW5jZSk7XG4gICAgICAgICAgICB0aGlzLnNwaW5uZXIuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hcHBlbmRDaGlsZCh0aGlzLmRpcmVjdGl2ZUVsZW1lbnQubmF0aXZlRWxlbWVudCwgdGhpcy5zcGlubmVyLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5pc1NwaW5uZXJFeGlzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0SW5zdGFuY2VJbnB1dHMoaW5zdGFuY2UpIHtcbiAgICAgICAgaW5zdGFuY2UubWVzc2FnZSA9IHRoaXMuc3Bpbm5lck1lc3NhZ2U7XG4gICAgICAgIHR5cGVvZiB0aGlzLnNwaW5uZXJTdGF0dXMgIT09ICd1bmRlZmluZWQnICYmIChpbnN0YW5jZS5zdGF0dXMgPSB0aGlzLnNwaW5uZXJTdGF0dXMpO1xuICAgICAgICB0eXBlb2YgdGhpcy5zcGlubmVyU2l6ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgKGluc3RhbmNlLnNpemUgPSB0aGlzLnNwaW5uZXJTaXplKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxMDMoW1xuICAgIElucHV0KCduYlNwaW5uZXJNZXNzYWdlJyksXG4gICAgX19tZXRhZGF0YSQ2OChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iU3Bpbm5lckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3Bpbm5lck1lc3NhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTAzKFtcbiAgICBJbnB1dCgnbmJTcGlubmVyU3RhdHVzJyksXG4gICAgX19tZXRhZGF0YSQ2OChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iU3Bpbm5lckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3Bpbm5lclN0YXR1c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMDMoW1xuICAgIElucHV0KCduYlNwaW5uZXJTaXplJyksXG4gICAgX19tZXRhZGF0YSQ2OChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iU3Bpbm5lckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3Bpbm5lclNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTAzKFtcbiAgICBJbnB1dCgnbmJTcGlubmVyJyksXG4gICAgX19tZXRhZGF0YSQ2OChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNjgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlNwaW5uZXJEaXJlY3RpdmUucHJvdG90eXBlLCBcIm5iU3Bpbm5lclwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTAzKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubmItc3Bpbm5lci1jb250YWluZXInKSxcbiAgICBfX21ldGFkYXRhJDY4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJTcGlubmVyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJpc1NwaW5uZXJFeGlzdFwiLCB2b2lkIDApO1xuTmJTcGlubmVyRGlyZWN0aXZlID0gX19kZWNvcmF0ZSQxMDMoW1xuICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25iU3Bpbm5lcl0nIH0pLFxuICAgIF9fbWV0YWRhdGEkNjgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICBSZW5kZXJlcjIsXG4gICAgICAgIEVsZW1lbnRSZWZdKVxuXSwgTmJTcGlubmVyRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTA0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmxldCBOYlNwaW5uZXJNb2R1bGUgPSBjbGFzcyBOYlNwaW5uZXJNb2R1bGUge1xufTtcbk5iU3Bpbm5lck1vZHVsZSA9IF9fZGVjb3JhdGUkMTA0KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICBdLFxuICAgICAgICBleHBvcnRzOiBbTmJTcGlubmVyQ29tcG9uZW50LCBOYlNwaW5uZXJEaXJlY3RpdmVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYlNwaW5uZXJDb21wb25lbnQsIE5iU3Bpbm5lckRpcmVjdGl2ZV0sXG4gICAgICAgIGVudHJ5Q29tcG9uZW50czogW05iU3Bpbm5lckNvbXBvbmVudF0sXG4gICAgfSlcbl0sIE5iU3Bpbm5lck1vZHVsZSk7XG5cbmNvbnN0IE5CX1NURVBQRVIgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05lYnVsYXIgU3RlcHBlciBDb21wb25lbnQnKTtcblxudmFyIF9fZGVjb3JhdGUkMTA2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDcwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxMiA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbi8qKlxuICogQ29tcG9uZW50IGludGVuZGVkIHRvIGJlIHVzZWQgd2l0aGluICB0aGUgYDxuYi1zdGVwcGVyPmAgY29tcG9uZW50LlxuICogQ29udGFpbmVyIGZvciBhIHN0ZXBcbiAqL1xubGV0IE5iU3RlcENvbXBvbmVudCA9IGNsYXNzIE5iU3RlcENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Ioc3RlcHBlcikge1xuICAgICAgICB0aGlzLl9jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RlcHBlciA9IHN0ZXBwZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgbGFiZWwgaXMgYSBUZW1wbGF0ZVJlZi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYm9vbGVhblxuICAgICAqICovXG4gICAgZ2V0IGlzTGFiZWxUZW1wbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWwgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciBzdGVwIGlzIG1hcmtlZCBhcyBjb21wbGV0ZWQuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgY29tcGxldGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGxldGVkIHx8IHRoaXMuaXNDb21wbGV0ZWQ7XG4gICAgfVxuICAgIHNldCBjb21wbGV0ZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGVkID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGlzQ29tcGxldGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwQ29udHJvbCA/IHRoaXMuc3RlcENvbnRyb2wudmFsaWQgJiYgdGhpcy5pbnRlcmFjdGVkIDogdGhpcy5pbnRlcmFjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrIHN0ZXAgYXMgc2VsZWN0ZWRcbiAgICAgKiAqL1xuICAgIHNlbGVjdCgpIHtcbiAgICAgICAgdGhpcy5zdGVwcGVyLnNlbGVjdGVkID0gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgc3RlcCBhbmQgc3RlcENvbnRyb2wgc3RhdGVcbiAgICAgKiAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmludGVyYWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3RlcENvbnRyb2wpIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcENvbnRyb2wucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlJDEwNihbXG4gICAgVmlld0NoaWxkKFRlbXBsYXRlUmVmLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhJDcwKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBOYlN0ZXBDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTA2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNzAoXCJkZXNpZ246dHlwZVwiLCBBYnN0cmFjdENvbnRyb2wpXG5dLCBOYlN0ZXBDb21wb25lbnQucHJvdG90eXBlLCBcInN0ZXBDb250cm9sXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEwNihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDcwKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJTdGVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMDYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ3MChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYlN0ZXBDb21wb25lbnQucHJvdG90eXBlLCBcImhpZGRlblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMDYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ3MChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNzAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlN0ZXBDb21wb25lbnQucHJvdG90eXBlLCBcImNvbXBsZXRlZFwiLCBudWxsKTtcbk5iU3RlcENvbXBvbmVudCA9IF9fZGVjb3JhdGUkMTA2KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLXN0ZXAnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy10ZW1wbGF0ZT5cbiAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L25nLXRlbXBsYXRlPlxuICBgXG4gICAgfSksXG4gICAgX19wYXJhbSQxMigwLCBJbmplY3QoTkJfU1RFUFBFUikpLFxuICAgIF9fbWV0YWRhdGEkNzAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIE5iU3RlcENvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDEwNSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ2OSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE5iU3RlcHBlckNvbXBvbmVudF8xO1xuLyoqXG4gKiBTdGVwcGVyIGNvbXBvbmVudFxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIHN0ZXBwZXIvc3RlcHBlci1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJTdGVwcGVyTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlN0ZXBwZXJNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIElmIHN0ZXAgbGFiZWwgaXMgc3RyaW5nIHlvdSBjYW4gcGFzcyBpdCBhcyBgbGFiZWxgIGF0dHJpYnV0ZS4gT3RoZXJ3aXNlIG5nLXRlbXBsYXRlIHNob3VsZCBiZSB1c2VkOlxuICogYGBgaHRtbFxuICogLy8gLi4uXG4gKiA8bmItc3RlcHBlciBvcmllbnRhdGlvbj1cImhvcml6b250YWxcIj5cbiAqICAgPG5iLXN0ZXAgbGFiZWw9XCJzdGVwIG51bWJlciBvbmVcIj5cbiAqICAgICAgIC8vIC4uLiBzdGVwIGNvbnRlbnQgaGVyZVxuICogICA8L25iLXN0ZXA+XG4gKiAgIDxuYi1zdGVwIGxhYmVsPVwic3RlcExhYmVsXCI+XG4gKiAgICAgICA8bmctdGVtcGxhdGUgI3N0ZXBMYWJlbD5cbiAqICAgICAgICAgICA8ZGl2PlxuICogICAgICAgICAgICAgICBzdGVwIG51bWJlciB0d29cbiAqICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICAvLyAuLi4gc3RlcCBjb250ZW50IGhlcmVcbiAqICAgPC9uYi1zdGVwPlxuICogPC9uYi1zdGVwcGVyPlxuICogYGBgXG4gKlxuICogV2hlbiBsaW5lYXIgbW9kZSBlbmFibGVkIHVzZXIgY2FuJ3QgbW92ZSBmb3J3YXJkIHVubGVzcyBjdXJyZW50IHN0ZXAgaXMgY29tcGxldGUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKExpbmVhciwgc3RlcHBlci9zdGVwcGVyLWxpbmVhci5jb21wb25lbnQpXG4gKlxuICogU3BlY2lmeSBgW3N0ZXBDb250cm9sXT1cImZvcm1cImAgYW5kIHN0ZXBwZXIgYWxsb3cgZ28gdG8gdGhlIG5leHQgc3RlcCBvbmx5IGlmIGZvcm0gaXMgdmFsaWQuXG4gKiBZb3UgY2FuIGRpc2FibGUgaXQgdmlhIGBsaW5lYXJgIG1vZGUgc2V0dGluZy5cbiAqIGBgYGh0bWxcbiAqIC8vIC4uLlxuICogPG5iLXN0ZXBwZXIgIG9yaWVudGF0aW9uPVwiaG9yaXpvbnRhbFwiPlxuICogICA8bmItc3RlcCBsYWJlbD1cInN0ZXAgbnVtYmVyIG9uZVwiIFtzdGVwQ29udHJvbF09XCJmb3JtXCI+XG4gKiAgICAgPGZvcm0gW2Zvcm1Hcm91cF09XCJmb3JtXCI+XG4gKiAgICAgICAvLyAuLi5cbiAqICAgICA8L2Zvcm0+XG4gKiAgIDwvbmItc3RlcD5cbiAqICAgIC8vIC4uLlxuICogPC9uYi1zdGVwcGVyPlxuICogYGBgXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShWYWxpZGF0aW9uLCBzdGVwcGVyL3N0ZXBwZXItdmFsaWRhdGlvbi5jb21wb25lbnQpXG4gKlxuICogU3RlcHBlciBjb21wb25lbnQgaGFzIHR3byBsYXlvdXQgb3B0aW9ucyAtIGB2ZXJ0aWNhbGAgJiBgaG9yaXpvbnRhbGBcbiAqIEBzdGFja2VkLWV4YW1wbGUoVmVydGljYWwsIHN0ZXBwZXIvc3RlcHBlci12ZXJ0aWNhbC5jb21wb25lbnQpXG4gKlxuICogYGRpc2FibGVTdGVwTmF2aWdhdGlvbmAgZGlzYWJsZXMgbmF2aWdhdGlvbiBieSBjbGlja2luZyBvbiBzdGVwcywgc28gdXNlciBjYW4gbmF2aWdhdGUgb25seSB1c2luZ1xuICogJ25iU3RlcHBlclByZXZpb3VzJyBhbmQgJ25iU3RlcHBlck5leHQnIGJ1dHRvbnMuXG4gKiBAc3RhY2tlZC1leGFtcGxlKERpc2FibGVkIHN0ZXBzIG5hdmlnYXRpb24sIHN0ZXBwZXIvc3RlcHBlci1kaXNhYmxlZC1zdGVwLW5hdi5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHN0ZXBwZXItc3RlcC10ZXh0LWNvbG9yOlxuICogc3RlcHBlci1zdGVwLXRleHQtZm9udC1mYW1pbHk6XG4gKiBzdGVwcGVyLXN0ZXAtdGV4dC1mb250LXNpemU6XG4gKiBzdGVwcGVyLXN0ZXAtdGV4dC1mb250LXdlaWdodDpcbiAqIHN0ZXBwZXItc3RlcC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogc3RlcHBlci1zdGVwLWFjdGl2ZS10ZXh0LWNvbG9yOlxuICogc3RlcHBlci1zdGVwLWNvbXBsZXRlZC10ZXh0LWNvbG9yOlxuICogc3RlcHBlci1zdGVwLWluZGV4LWJvcmRlci1jb2xvcjpcbiAqIHN0ZXBwZXItc3RlcC1pbmRleC1ib3JkZXItc3R5bGU6XG4gKiBzdGVwcGVyLXN0ZXAtaW5kZXgtYm9yZGVyLXdpZHRoOlxuICogc3RlcHBlci1zdGVwLWluZGV4LWJvcmRlci1yYWRpdXM6XG4gKiBzdGVwcGVyLXN0ZXAtaW5kZXgtd2lkdGg6XG4gKiBzdGVwcGVyLXN0ZXAtaW5kZXgtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHN0ZXBwZXItc3RlcC1pbmRleC1jb21wbGV0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHN0ZXBwZXItc3RlcC1pbmRleC1jb21wbGV0ZWQtYm9yZGVyLWNvbG9yOlxuICogc3RlcHBlci1zdGVwLWluZGV4LWNvbXBsZXRlZC10ZXh0LWNvbG9yOlxuICogc3RlcHBlci1jb25uZWN0b3ItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHN0ZXBwZXItY29ubmVjdG9yLWNvbXBsZXRlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc3RlcHBlci1ob3Jpem9udGFsLWNvbm5lY3Rvci1tYXJnaW46XG4gKiBzdGVwcGVyLXZlcnRpY2FsLWNvbm5lY3Rvci1tYXJnaW46XG4gKiBzdGVwcGVyLXN0ZXAtY29udGVudC1wYWRkaW5nOlxuICovXG5sZXQgTmJTdGVwcGVyQ29tcG9uZW50ID0gTmJTdGVwcGVyQ29tcG9uZW50XzEgPSBjbGFzcyBOYlN0ZXBwZXJDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFN0ZXBwZXIgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBzdGVwcGVyL3N0ZXBwZXItc2hvd2Nhc2UuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogIyMjIEluc3RhbGxhdGlvblxuICAgICAqXG4gICAgICogSW1wb3J0IGBOYlN0ZXBwZXJNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gICAgICogYGBgdHNcbiAgICAgKiBATmdNb2R1bGUoe1xuICAgICAqICAgaW1wb3J0czogW1xuICAgICAqICAgICAvLyAuLi5cbiAgICAgKiAgICAgTmJTdGVwcGVyTW9kdWxlLFxuICAgICAqICAgXSxcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICAgICAqIGBgYFxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogSWYgc3RlcCBsYWJlbCBpcyBzdHJpbmcgeW91IGNhbiBwYXNzIGl0IGFzIGBsYWJlbGAgYXR0cmlidXRlLiBPdGhlcndpc2UgbmctdGVtcGxhdGUgc2hvdWxkIGJlIHVzZWQ6XG4gICAgICogYGBgaHRtbFxuICAgICAqIC8vIC4uLlxuICAgICAqIDxuYi1zdGVwcGVyIG9yaWVudGF0aW9uPVwiaG9yaXpvbnRhbFwiPlxuICAgICAqICAgPG5iLXN0ZXAgbGFiZWw9XCJzdGVwIG51bWJlciBvbmVcIj5cbiAgICAgKiAgICAgICAvLyAuLi4gc3RlcCBjb250ZW50IGhlcmVcbiAgICAgKiAgIDwvbmItc3RlcD5cbiAgICAgKiAgIDxuYi1zdGVwIGxhYmVsPVwic3RlcExhYmVsXCI+XG4gICAgICogICAgICAgPG5nLXRlbXBsYXRlICNzdGVwTGFiZWw+XG4gICAgICogICAgICAgICAgIDxkaXY+XG4gICAgICogICAgICAgICAgICAgICBzdGVwIG51bWJlciB0d29cbiAgICAgKiAgICAgICAgICAgPC9kaXY+XG4gICAgICogICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgICAgICAvLyAuLi4gc3RlcCBjb250ZW50IGhlcmVcbiAgICAgKiAgIDwvbmItc3RlcD5cbiAgICAgKiA8L25iLXN0ZXBwZXI+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBXaGVuIGxpbmVhciBtb2RlIGVuYWJsZWQgdXNlciBjYW4ndCBtb3ZlIGZvcndhcmQgdW5sZXNzIGN1cnJlbnQgc3RlcCBpcyBjb21wbGV0ZS5cbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKExpbmVhciwgc3RlcHBlci9zdGVwcGVyLWxpbmVhci5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBTcGVjaWZ5IGBbc3RlcENvbnRyb2xdPVwiZm9ybVwiYCBhbmQgc3RlcHBlciBhbGxvdyBnbyB0byB0aGUgbmV4dCBzdGVwIG9ubHkgaWYgZm9ybSBpcyB2YWxpZC5cbiAgICAgKiBZb3UgY2FuIGRpc2FibGUgaXQgdmlhIGBsaW5lYXJgIG1vZGUgc2V0dGluZy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogLy8gLi4uXG4gICAgICogPG5iLXN0ZXBwZXIgIG9yaWVudGF0aW9uPVwiaG9yaXpvbnRhbFwiPlxuICAgICAqICAgPG5iLXN0ZXAgbGFiZWw9XCJzdGVwIG51bWJlciBvbmVcIiBbc3RlcENvbnRyb2xdPVwiZm9ybVwiPlxuICAgICAqICAgICA8Zm9ybSBbZm9ybUdyb3VwXT1cImZvcm1cIj5cbiAgICAgKiAgICAgICAvLyAuLi5cbiAgICAgKiAgICAgPC9mb3JtPlxuICAgICAqICAgPC9uYi1zdGVwPlxuICAgICAqICAgIC8vIC4uLlxuICAgICAqIDwvbmItc3RlcHBlcj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoVmFsaWRhdGlvbiwgc3RlcHBlci9zdGVwcGVyLXZhbGlkYXRpb24uY29tcG9uZW50KVxuICAgICAqXG4gICAgICogU3RlcHBlciBjb21wb25lbnQgaGFzIHR3byBsYXlvdXQgb3B0aW9ucyAtIGB2ZXJ0aWNhbGAgJiBgaG9yaXpvbnRhbGBcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFZlcnRpY2FsLCBzdGVwcGVyL3N0ZXBwZXItdmVydGljYWwuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogYGRpc2FibGVTdGVwTmF2aWdhdGlvbmAgZGlzYWJsZXMgbmF2aWdhdGlvbiBieSBjbGlja2luZyBvbiBzdGVwcywgc28gdXNlciBjYW4gbmF2aWdhdGUgb25seSB1c2luZ1xuICAgICAqICduYlN0ZXBwZXJQcmV2aW91cycgYW5kICduYlN0ZXBwZXJOZXh0JyBidXR0b25zLlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoRGlzYWJsZWQgc3RlcHMgbmF2aWdhdGlvbiwgc3RlcHBlci9zdGVwcGVyLWRpc2FibGVkLXN0ZXAtbmF2LmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEBzdHlsZXNcbiAgICAgKlxuICAgICAqIHN0ZXBwZXItc3RlcC10ZXh0LWNvbG9yOlxuICAgICAqIHN0ZXBwZXItc3RlcC10ZXh0LWZvbnQtZmFtaWx5OlxuICAgICAqIHN0ZXBwZXItc3RlcC10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiBzdGVwcGVyLXN0ZXAtdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBzdGVwcGVyLXN0ZXAtdGV4dC1saW5lLWhlaWdodDpcbiAgICAgKiBzdGVwcGVyLXN0ZXAtYWN0aXZlLXRleHQtY29sb3I6XG4gICAgICogc3RlcHBlci1zdGVwLWNvbXBsZXRlZC10ZXh0LWNvbG9yOlxuICAgICAqIHN0ZXBwZXItc3RlcC1pbmRleC1ib3JkZXItY29sb3I6XG4gICAgICogc3RlcHBlci1zdGVwLWluZGV4LWJvcmRlci1zdHlsZTpcbiAgICAgKiBzdGVwcGVyLXN0ZXAtaW5kZXgtYm9yZGVyLXdpZHRoOlxuICAgICAqIHN0ZXBwZXItc3RlcC1pbmRleC1ib3JkZXItcmFkaXVzOlxuICAgICAqIHN0ZXBwZXItc3RlcC1pbmRleC13aWR0aDpcbiAgICAgKiBzdGVwcGVyLXN0ZXAtaW5kZXgtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAgICAgKiBzdGVwcGVyLXN0ZXAtaW5kZXgtY29tcGxldGVkLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogc3RlcHBlci1zdGVwLWluZGV4LWNvbXBsZXRlZC1ib3JkZXItY29sb3I6XG4gICAgICogc3RlcHBlci1zdGVwLWluZGV4LWNvbXBsZXRlZC10ZXh0LWNvbG9yOlxuICAgICAqIHN0ZXBwZXItY29ubmVjdG9yLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogc3RlcHBlci1jb25uZWN0b3ItY29tcGxldGVkLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogc3RlcHBlci1ob3Jpem9udGFsLWNvbm5lY3Rvci1tYXJnaW46XG4gICAgICogc3RlcHBlci12ZXJ0aWNhbC1jb25uZWN0b3ItbWFyZ2luOlxuICAgICAqIHN0ZXBwZXItc3RlcC1jb250ZW50LXBhZGRpbmc6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgICB0aGlzLl9kaXNhYmxlU3RlcE5hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0ZXBwZXIgb3JpZW50YXRpb24gLSBgaG9yaXpvbnRhbGB8YHZlcnRpY2FsYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJztcbiAgICAgICAgdGhpcy5fbGluZWFyID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0ZWQgc3RlcCBpbmRleFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRJbmRleDtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0ZXBzKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrQ3VycmVudFN0ZXBJbnRlcmFjdGVkKCk7XG4gICAgICAgIGlmICh0aGlzLmNhbkJlU2VsZWN0ZWQoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzYWJsZXMgbmF2aWdhdGlvbiBieSBjbGlja2luZyBvbiBzdGVwcy4gRmFsc2UgYnkgZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQgZGlzYWJsZVN0ZXBOYXZpZ2F0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVTdGVwTmF2aWdhdGlvbiA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlU3RlcE5hdmlnYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlU3RlcE5hdmlnYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdGVkIHN0ZXAgY29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcyA/IHRoaXMuc3RlcHMudG9BcnJheSgpW3RoaXMuc2VsZWN0ZWRJbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldCBzZWxlY3RlZChzdGVwKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGVwcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMuc3RlcHMudG9BcnJheSgpLmluZGV4T2Yoc3RlcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsbG93IG1vdmluZyBmb3J3YXJkIG9ubHkgaWYgdGhlIGN1cnJlbnQgc3RlcCBpcyBjb21wbGV0ZVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBzZXQgbGluZWFyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2xpbmVhciA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBsaW5lYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lYXI7XG4gICAgfVxuICAgIGdldCB2ZXJ0aWNhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCc7XG4gICAgfVxuICAgIGdldCBob3Jpem9udGFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZSB0byBuZXh0IHN0ZXBcbiAgICAgKiAqL1xuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IE1hdGgubWluKHRoaXMuc2VsZWN0ZWRJbmRleCArIDEsIHRoaXMuc3RlcHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlIHRvIHByZXZpb3VzIHN0ZXBcbiAgICAgKiAqL1xuICAgIHByZXZpb3VzKCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBNYXRoLm1heCh0aGlzLnNlbGVjdGVkSW5kZXggLSAxLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgc3RlcHBlciBhbmQgc3RlcENvbnRyb2xzIHRvIGluaXRpYWwgc3RhdGVcbiAgICAgKiAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4gc3RlcC5yZXNldCgpKTtcbiAgICB9XG4gICAgaXNTdGVwU2VsZWN0ZWQoc3RlcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZCA9PT0gc3RlcDtcbiAgICB9XG4gICAgaXNTdGVwVmFsaWQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMudG9BcnJheSgpW2luZGV4XS5jb21wbGV0ZWQ7XG4gICAgfVxuICAgIGNhbkJlU2VsZWN0ZWQoaW5kZXhUb0NoZWNrKSB7XG4gICAgICAgIGNvbnN0IG5vU3RlcHMgPSAhdGhpcy5zdGVwcyB8fCB0aGlzLnN0ZXBzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgaWYgKG5vU3RlcHMgfHwgaW5kZXhUb0NoZWNrIDwgMCB8fCBpbmRleFRvQ2hlY2sgPj0gdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXhUb0NoZWNrIDw9IHRoaXMuc2VsZWN0ZWRJbmRleCB8fCAhdGhpcy5saW5lYXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpc0FsbFN0ZXBzVmFsaWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zZWxlY3RlZEluZGV4OyBpIDwgaW5kZXhUb0NoZWNrOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1N0ZXBWYWxpZChpKSkge1xuICAgICAgICAgICAgICAgIGlzQWxsU3RlcHNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FsbFN0ZXBzVmFsaWQ7XG4gICAgfVxuICAgIG1hcmtDdXJyZW50U3RlcEludGVyYWN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkLmludGVyYWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTA1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjkoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEkNjkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcbl0sIE5iU3RlcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0ZWRJbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTA1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDY5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJTdGVwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlU3RlcE5hdmlnYXRpb25cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwNShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDY5KFwiZGVzaWduOnR5cGVcIiwgTmJTdGVwQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhJDY5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iU3RlcENvbXBvbmVudF0pXG5dLCBOYlN0ZXBwZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMDUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ2OShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iU3RlcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwib3JpZW50YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTA1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNjkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDY5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJTdGVwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsaW5lYXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEwNShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnZlcnRpY2FsJyksXG4gICAgX19tZXRhZGF0YSQ2OShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ2OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTdGVwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2ZXJ0aWNhbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTA1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MuaG9yaXpvbnRhbCcpLFxuICAgIF9fbWV0YWRhdGEkNjkoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNjkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU3RlcHBlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaG9yaXpvbnRhbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTA1KFtcbiAgICBDb250ZW50Q2hpbGRyZW4oTmJTdGVwQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhJDY5KFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgTmJTdGVwcGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGVwc1wiLCB2b2lkIDApO1xuTmJTdGVwcGVyQ29tcG9uZW50ID0gTmJTdGVwcGVyQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlJDEwNShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1zdGVwcGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IFwiPG5nLXRlbXBsYXRlPjxuZy1jb250ZW50IHNlbGVjdD1cXFwibmItc3RlcFxcXCI+PC9uZy1jb250ZW50PjwvbmctdGVtcGxhdGU+XFxuPGRpdiBjbGFzcz1cXFwiaGVhZGVyXFxcIj5cXG4gIDxuZy1jb250YWluZXIgKm5nRm9yPVxcXCJsZXQgc3RlcCBvZiBzdGVwczsgbGV0IGluZGV4ID0gaW5kZXg7IGxldCBmaXJzdCA9IGZpcnN0XFxcIj5cXG5cXG4gICAgPGRpdiAqbmdJZj1cXFwiIWZpcnN0ICYmICFzdGVwLmhpZGRlblxcXCJcXG4gICAgICAgICBbY2xhc3MuY29ubmVjdG9yLXBhc3RdPVxcXCJpbmRleCA8PSBzZWxlY3RlZEluZGV4XFxcIlxcbiAgICAgICAgIGNsYXNzPVxcXCJjb25uZWN0b3JcXFwiPjwvZGl2PlxcblxcbiAgICA8ZGl2ICpuZ0lmPVxcXCIhc3RlcC5oaWRkZW5cXFwiIGNsYXNzPVxcXCJzdGVwXFxcIlxcbiAgICAgICAgIFtjbGFzcy5zZWxlY3RlZF09XFxcImlzU3RlcFNlbGVjdGVkKHN0ZXApXFxcIlxcbiAgICAgICAgIFtjbGFzcy5jb21wbGV0ZWRdPVxcXCIhaXNTdGVwU2VsZWN0ZWQoc3RlcCkgJiYgc3RlcC5jb21wbGV0ZWRcXFwiXFxuICAgICAgICAgW2NsYXNzLm5vbmludGVyYWN0aXZlXT1cXFwiZGlzYWJsZVN0ZXBOYXZpZ2F0aW9uXFxcIlxcbiAgICAgICAgIChjbGljayk9XFxcIiFkaXNhYmxlU3RlcE5hdmlnYXRpb24gJiYgc3RlcC5zZWxlY3QoKVxcXCI+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGFiZWwtaW5kZXhcXFwiPlxcbiAgICAgICAgPHNwYW4gKm5nSWY9XFxcIiFzdGVwLmNvbXBsZXRlZCB8fCBpc1N0ZXBTZWxlY3RlZChzdGVwKVxcXCI+e3sgaW5kZXggKyAxIH19PC9zcGFuPlxcbiAgICAgICAgPG5iLWljb24gKm5nSWY9XFxcIiFpc1N0ZXBTZWxlY3RlZChzdGVwKSAmJiBzdGVwLmNvbXBsZXRlZFxcXCIgaWNvbj1cXFwiY2hlY2ttYXJrLW91dGxpbmVcXFwiIHBhY2s9XFxcIm5lYnVsYXItZXNzZW50aWFsc1xcXCI+XFxuICAgICAgICA8L25iLWljb24+XFxuICAgICAgPC9kaXY+XFxuICAgICAgPGRpdiBjbGFzcz1cXFwibGFiZWxcXFwiPlxcbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cXFwic3RlcC5pc0xhYmVsVGVtcGxhdGVcXFwiPlxcbiAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVxcXCJzdGVwLmxhYmVsXFxcIj48L25nLWNvbnRhaW5lcj5cXG4gICAgICAgIDwvbmctY29udGFpbmVyPlxcbiAgICAgICAgPHNwYW4gKm5nSWY9XFxcIiFzdGVwLmlzTGFiZWxUZW1wbGF0ZVxcXCI+e3sgc3RlcC5sYWJlbCB9fTwvc3Bhbj5cXG4gICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuICA8L25nLWNvbnRhaW5lcj5cXG48L2Rpdj5cXG48ZGl2IGNsYXNzPVxcXCJzdGVwLWNvbnRlbnRcXFwiPlxcbiAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XFxcInNlbGVjdGVkPy5jb250ZW50XFxcIj48L25nLWNvbnRhaW5lcj5cXG48L2Rpdj5cXG5cIixcbiAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOQl9TVEVQUEVSLCB1c2VFeGlzdGluZzogTmJTdGVwcGVyQ29tcG9uZW50XzEgfV0sXG4gICAgICAgIHN0eWxlczogW1wiOmhvc3QoLmhvcml6b250YWwpIC5oZWFkZXIgLnN0ZXB7ZmxleC1kaXJlY3Rpb246Y29sdW1ufTpob3N0KC5ob3Jpem9udGFsKSAuaGVhZGVyIC5jb25uZWN0b3J7aGVpZ2h0OjJweH06aG9zdCguaG9yaXpvbnRhbCkgLmxhYmVsLWluZGV4e21hcmdpbi1ib3R0b206MTBweH06aG9zdCgudmVydGljYWwpe2Rpc3BsYXk6ZmxleDtoZWlnaHQ6MTAwJX06aG9zdCgudmVydGljYWwpIC5oZWFkZXJ7ZmxleC1kaXJlY3Rpb246Y29sdW1ufTpob3N0KC52ZXJ0aWNhbCkgLmhlYWRlciAubGFiZWx7bWFyZ2luOjAgMTBweH06aG9zdCgudmVydGljYWwpIC5oZWFkZXIgLmNvbm5lY3Rvcnt3aWR0aDoycHh9LmhlYWRlcntkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW47YWxpZ24taXRlbXM6ZmxleC1zdGFydDttYXJnaW4tYm90dG9tOjEwcHh9LmhlYWRlciAuY29ubmVjdG9ye2ZsZXg6YXV0b30uaGVhZGVyIC5zdGVwe2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Y3Vyc29yOnBvaW50ZXJ9LmhlYWRlciAuc3RlcC5ub25pbnRlcmFjdGl2ZXtjdXJzb3I6ZGVmYXVsdH0uaGVhZGVyIC5sYWJlbC1pbmRleHtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9LmhlYWRlciAubGFiZWx7d2lkdGg6bWF4LWNvbnRlbnR9XFxuXCJdXG4gICAgfSlcbl0sIE5iU3RlcHBlckNvbXBvbmVudCk7XG5cbnZhciBfX2RlY29yYXRlJDEwNyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ3MSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xubGV0IE5iU3RlcHBlck5leHREaXJlY3RpdmUgPSBjbGFzcyBOYlN0ZXBwZXJOZXh0RGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGVwcGVyKSB7XG4gICAgICAgIHRoaXMuc3RlcHBlciA9IHN0ZXBwZXI7XG4gICAgICAgIHRoaXMudHlwZSA9ICdzdWJtaXQnO1xuICAgIH1cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICB0aGlzLnN0ZXBwZXIubmV4dCgpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDEwNyhbXG4gICAgSW5wdXQoKSwgSG9zdEJpbmRpbmcoJ2F0dHIudHlwZScpLFxuICAgIF9fbWV0YWRhdGEkNzEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlN0ZXBwZXJOZXh0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEwNyhbXG4gICAgSG9zdExpc3RlbmVyKCdjbGljaycpLFxuICAgIF9fbWV0YWRhdGEkNzEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YSQ3MShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhJDcxKFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTmJTdGVwcGVyTmV4dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwib25DbGlja1wiLCBudWxsKTtcbk5iU3RlcHBlck5leHREaXJlY3RpdmUgPSBfX2RlY29yYXRlJDEwNyhbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbmJTdGVwcGVyTmV4dF0nLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkNzEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJTdGVwcGVyQ29tcG9uZW50XSlcbl0sIE5iU3RlcHBlck5leHREaXJlY3RpdmUpO1xubGV0IE5iU3RlcHBlclByZXZpb3VzRGlyZWN0aXZlID0gY2xhc3MgTmJTdGVwcGVyUHJldmlvdXNEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHN0ZXBwZXIpIHtcbiAgICAgICAgdGhpcy5zdGVwcGVyID0gc3RlcHBlcjtcbiAgICAgICAgdGhpcy50eXBlID0gJ2J1dHRvbic7XG4gICAgfVxuICAgIG9uQ2xpY2soKSB7XG4gICAgICAgIHRoaXMuc3RlcHBlci5wcmV2aW91cygpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDEwNyhbXG4gICAgSW5wdXQoKSwgSG9zdEJpbmRpbmcoJ2F0dHIudHlwZScpLFxuICAgIF9fbWV0YWRhdGEkNzEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlN0ZXBwZXJQcmV2aW91c0RpcmVjdGl2ZS5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMDcoW1xuICAgIEhvc3RMaXN0ZW5lcignY2xpY2snKSxcbiAgICBfX21ldGFkYXRhJDcxKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEkNzEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YSQ3MShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE5iU3RlcHBlclByZXZpb3VzRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJvbkNsaWNrXCIsIG51bGwpO1xuTmJTdGVwcGVyUHJldmlvdXNEaXJlY3RpdmUgPSBfX2RlY29yYXRlJDEwNyhbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdidXR0b25bbmJTdGVwcGVyUHJldmlvdXNdJyxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDcxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iU3RlcHBlckNvbXBvbmVudF0pXG5dLCBOYlN0ZXBwZXJQcmV2aW91c0RpcmVjdGl2ZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDEwOCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5sZXQgTmJTdGVwcGVyTW9kdWxlID0gY2xhc3MgTmJTdGVwcGVyTW9kdWxlIHtcbn07XG5OYlN0ZXBwZXJNb2R1bGUgPSBfX2RlY29yYXRlJDEwOChbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICBOYlNoYXJlZE1vZHVsZSxcbiAgICAgICAgICAgIE5iSWNvbk1vZHVsZSxcbiAgICAgICAgXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBOYlN0ZXBwZXJDb21wb25lbnQsXG4gICAgICAgICAgICBOYlN0ZXBDb21wb25lbnQsXG4gICAgICAgICAgICBOYlN0ZXBwZXJOZXh0RGlyZWN0aXZlLFxuICAgICAgICAgICAgTmJTdGVwcGVyUHJldmlvdXNEaXJlY3RpdmUsXG4gICAgICAgIF0sXG4gICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgIE5iU3RlcHBlckNvbXBvbmVudCxcbiAgICAgICAgICAgIE5iU3RlcENvbXBvbmVudCxcbiAgICAgICAgICAgIE5iU3RlcHBlck5leHREaXJlY3RpdmUsXG4gICAgICAgICAgICBOYlN0ZXBwZXJQcmV2aW91c0RpcmVjdGl2ZSxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJTdGVwcGVyTW9kdWxlKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTA5ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDcyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIEFuIGFjY29yZGlvbiBhbGxvd3MgdG8gdG9nZ2xlIHRoZSBkaXNwbGF5IG9mIHNlY3Rpb25zIG9mIGNvbnRlbnRcbiAqXG4gKiBCYXNpYyBleGFtcGxlXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBhY2NvcmRpb24vYWNjb3JkaW9uLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBgYGB0c1xuICogPG5iLWFjY29yZGlvbj5cbiAqICA8bmItYWNjb3JkaW9uLWl0ZW0+XG4gKiAgIDxuYi1hY2NvcmRpb24taXRlbS1oZWFkZXI+UHJvZHVjdCBEZXRhaWxzPC9uYi1hY2NvcmRpb24taXRlbS1oZWFkZXI+XG4gKiAgIDxuYi1hY2NvcmRpb24taXRlbS1ib2R5PlxuICogICAgIEl0ZW0gQ29udGVudFxuICogICA8L25iLWFjY29yZGlvbi1pdGVtLWJvZHk+XG4gKiAgPC9uYi1hY2NvcmRpb24taXRlbT5cbiAqIDwvbmItYWNjb3JkaW9uPlxuICogYGBgXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkFjY29yZGlvbk1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJBY2NvcmRpb25Nb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIFdpdGggYG11bHRpYCBtb2RlIGFjY29yZGlvbiBjYW4gaGF2ZSBtdWx0aXBsZSBpdGVtcyBleHBhbmRlZDpcbiAqIEBzdGFja2VkLWV4YW1wbGUoTXVsdGlwbGUgZXhwYW5kZWQgaXRlbXMsIGFjY29yZGlvbi9hY2NvcmRpb24tbXVsdGkuY29tcG9uZW50KVxuICpcbiAqIGBOYkFjY29yZGlvbkl0ZW1Db21wb25lbnRgIGhhcyBzZXZlcmFsIG1ldGhvZHMsIGZvciBleGFtcGxlIGl0IGlzIHBvc3NpYmxlIHRvIHRyaWdnZXIgaXRlbSBjbGljay90b2dnbGU6XG4gKiBAc3RhY2tlZC1leGFtcGxlKEV4cGFuZCBBUEksIGFjY29yZGlvbi9hY2NvcmRpb24tdG9nZ2xlLmNvbXBvbmVudClcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogYWNjb3JkaW9uLWJvcmRlci1yYWRpdXM6XG4gKiBhY2NvcmRpb24tcGFkZGluZzpcbiAqIGFjY29yZGlvbi1zaGFkb3c6XG4gKiBhY2NvcmRpb24taGVhZGVyLXRleHQtY29sb3I6XG4gKiBhY2NvcmRpb24taGVhZGVyLXRleHQtZm9udC1mYW1pbHk6XG4gKiBhY2NvcmRpb24taGVhZGVyLXRleHQtZm9udC1zaXplOlxuICogYWNjb3JkaW9uLWhlYWRlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogYWNjb3JkaW9uLWhlYWRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogYWNjb3JkaW9uLWhlYWRlci1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogYWNjb3JkaW9uLWhlYWRlci1ib3JkZXItY29sb3I6XG4gKiBhY2NvcmRpb24taGVhZGVyLWJvcmRlci1zdHlsZTpcbiAqIGFjY29yZGlvbi1oZWFkZXItYm9yZGVyLXdpZHRoOlxuICogYWNjb3JkaW9uLWl0ZW0tYmFja2dyb3VuZC1jb2xvcjpcbiAqIGFjY29yZGlvbi1pdGVtLXRleHQtY29sb3I6XG4gKiBhY2NvcmRpb24taXRlbS10ZXh0LWZvbnQtZmFtaWx5OlxuICogYWNjb3JkaW9uLWl0ZW0tdGV4dC1mb250LXNpemU6XG4gKiBhY2NvcmRpb24taXRlbS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogYWNjb3JkaW9uLWl0ZW0tdGV4dC1saW5lLWhlaWdodDpcbiAqL1xubGV0IE5iQWNjb3JkaW9uQ29tcG9uZW50ID0gY2xhc3MgTmJBY2NvcmRpb25Db21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEFuIGFjY29yZGlvbiBhbGxvd3MgdG8gdG9nZ2xlIHRoZSBkaXNwbGF5IG9mIHNlY3Rpb25zIG9mIGNvbnRlbnRcbiAgICAgKlxuICAgICAqIEJhc2ljIGV4YW1wbGVcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBhY2NvcmRpb24vYWNjb3JkaW9uLXNob3djYXNlLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogPG5iLWFjY29yZGlvbj5cbiAgICAgKiAgPG5iLWFjY29yZGlvbi1pdGVtPlxuICAgICAqICAgPG5iLWFjY29yZGlvbi1pdGVtLWhlYWRlcj5Qcm9kdWN0IERldGFpbHM8L25iLWFjY29yZGlvbi1pdGVtLWhlYWRlcj5cbiAgICAgKiAgIDxuYi1hY2NvcmRpb24taXRlbS1ib2R5PlxuICAgICAqICAgICBJdGVtIENvbnRlbnRcbiAgICAgKiAgIDwvbmItYWNjb3JkaW9uLWl0ZW0tYm9keT5cbiAgICAgKiAgPC9uYi1hY2NvcmRpb24taXRlbT5cbiAgICAgKiA8L25iLWFjY29yZGlvbj5cbiAgICAgKiBgYGBcbiAgICAgKiAjIyMgSW5zdGFsbGF0aW9uXG4gICAgICpcbiAgICAgKiBJbXBvcnQgYE5iQWNjb3JkaW9uTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICAgICAqIGBgYHRzXG4gICAgICogQE5nTW9kdWxlKHtcbiAgICAgKiAgIGltcG9ydHM6IFtcbiAgICAgKiAgICAgLy8gLi4uXG4gICAgICogICAgIE5iQWNjb3JkaW9uTW9kdWxlLFxuICAgICAqICAgXSxcbiAgICAgKiB9KVxuICAgICAqIGV4cG9ydCBjbGFzcyBQYWdlTW9kdWxlIHsgfVxuICAgICAqIGBgYFxuICAgICAqICMjIyBVc2FnZVxuICAgICAqXG4gICAgICogV2l0aCBgbXVsdGlgIG1vZGUgYWNjb3JkaW9uIGNhbiBoYXZlIG11bHRpcGxlIGl0ZW1zIGV4cGFuZGVkOlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoTXVsdGlwbGUgZXhwYW5kZWQgaXRlbXMsIGFjY29yZGlvbi9hY2NvcmRpb24tbXVsdGkuY29tcG9uZW50KVxuICAgICAqXG4gICAgICogYE5iQWNjb3JkaW9uSXRlbUNvbXBvbmVudGAgaGFzIHNldmVyYWwgbWV0aG9kcywgZm9yIGV4YW1wbGUgaXQgaXMgcG9zc2libGUgdG8gdHJpZ2dlciBpdGVtIGNsaWNrL3RvZ2dsZTpcbiAgICAgKiBAc3RhY2tlZC1leGFtcGxlKEV4cGFuZCBBUEksIGFjY29yZGlvbi9hY2NvcmRpb24tdG9nZ2xlLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEBzdHlsZXNcbiAgICAgKlxuICAgICAqIGFjY29yZGlvbi1ib3JkZXItcmFkaXVzOlxuICAgICAqIGFjY29yZGlvbi1wYWRkaW5nOlxuICAgICAqIGFjY29yZGlvbi1zaGFkb3c6XG4gICAgICogYWNjb3JkaW9uLWhlYWRlci10ZXh0LWNvbG9yOlxuICAgICAqIGFjY29yZGlvbi1oZWFkZXItdGV4dC1mb250LWZhbWlseTpcbiAgICAgKiBhY2NvcmRpb24taGVhZGVyLXRleHQtZm9udC1zaXplOlxuICAgICAqIGFjY29yZGlvbi1oZWFkZXItdGV4dC1mb250LXdlaWdodDpcbiAgICAgKiBhY2NvcmRpb24taGVhZGVyLXRleHQtbGluZS1oZWlnaHQ6XG4gICAgICogYWNjb3JkaW9uLWhlYWRlci1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICAgICAqIGFjY29yZGlvbi1oZWFkZXItYm9yZGVyLWNvbG9yOlxuICAgICAqIGFjY29yZGlvbi1oZWFkZXItYm9yZGVyLXN0eWxlOlxuICAgICAqIGFjY29yZGlvbi1oZWFkZXItYm9yZGVyLXdpZHRoOlxuICAgICAqIGFjY29yZGlvbi1pdGVtLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogYWNjb3JkaW9uLWl0ZW0tdGV4dC1jb2xvcjpcbiAgICAgKiBhY2NvcmRpb24taXRlbS10ZXh0LWZvbnQtZmFtaWx5OlxuICAgICAqIGFjY29yZGlvbi1pdGVtLXRleHQtZm9udC1zaXplOlxuICAgICAqIGFjY29yZGlvbi1pdGVtLXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogYWNjb3JkaW9uLWl0ZW0tdGV4dC1saW5lLWhlaWdodDpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5vcGVuQ2xvc2VJdGVtcyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMubXVsdGlWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiAgQWxsb3cgbXVsdGlwbGUgaXRlbXMgdG8gYmUgZXhwYW5kZWQgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgbXVsdGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpVmFsdWU7XG4gICAgfVxuICAgIHNldCBtdWx0aSh2YWwpIHtcbiAgICAgICAgdGhpcy5tdWx0aVZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIGFsbCBlbmFibGVkIGFjY29yZGlvbiBpdGVtcy5cbiAgICAgKi9cbiAgICBvcGVuQWxsKCkge1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuQ2xvc2VJdGVtcy5uZXh0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIGVuYWJsZWQgYWNjb3JkaW9uIGl0ZW1zLlxuICAgICAqL1xuICAgIGNsb3NlQWxsKCkge1xuICAgICAgICB0aGlzLm9wZW5DbG9zZUl0ZW1zLm5leHQodHJ1ZSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTA5KFtcbiAgICBJbnB1dCgnbXVsdGknKSxcbiAgICBfX21ldGFkYXRhJDcyKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ3MihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iQWNjb3JkaW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtdWx0aVwiLCBudWxsKTtcbk5iQWNjb3JkaW9uQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxMDkoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItYWNjb3JkaW9uJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1hY2NvcmRpb24taXRlbVwiPjwvbmctY29udGVudD5cbiAgYCxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICB9KVxuXSwgTmJBY2NvcmRpb25Db21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMTAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNzMgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDEzID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBDb21wb25lbnQgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoaW4gYDxuYi1hY2NvcmRpb24+YCBjb21wb25lbnRcbiAqL1xubGV0IE5iQWNjb3JkaW9uSXRlbUNvbXBvbmVudCA9IGNsYXNzIE5iQWNjb3JkaW9uSXRlbUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYWNjb3JkaW9uLCBjZCkge1xuICAgICAgICB0aGlzLmFjY29yZGlvbiA9IGFjY29yZGlvbjtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgd2hlbmV2ZXIgdGhlIGV4cGFuZGVkIHN0YXRlIG9mIHRoZSBhY2NvcmRpb24gY2hhbmdlcy5cbiAgICAgICAgICogUHJpbWFyaWx5IHVzZWQgdG8gZmFjaWxpdGF0ZSB0d28td2F5IGJpbmRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbGxhcHNlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY2NvcmRpb25JdGVtSW52YWxpZGF0ZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkVmFsdWUgPSB0cnVlO1xuICAgICAgICB0aGlzLmRpc2FibGVkVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZW0gaXMgY29sbGFwc2UgKGB0cnVlYCBieSBkZWZhdWx0KVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjb2xsYXBzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxhcHNlZFZhbHVlO1xuICAgIH1cbiAgICBzZXQgY29sbGFwc2VkKHZhbCkge1xuICAgICAgICB0aGlzLmNvbGxhcHNlZFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkQ2hhbmdlLmVtaXQodGhpcy5jb2xsYXBzZWRWYWx1ZSk7XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJdGVtIGlzIGV4cGFuZGVkIChgZmFsc2VgIGJ5IGRlZmF1bHQpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGV4cGFuZGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sbGFwc2VkO1xuICAgIH1cbiAgICBzZXQgZXhwYW5kZWQodmFsKSB7XG4gICAgICAgIHRoaXMuY29sbGFwc2VkVmFsdWUgPSAhY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZW0gaXMgZGlzYWJsZWQgYW5kIGNhbm5vdCBiZSBvcGVuZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZFZhbHVlO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQodmFsKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWRWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWwpO1xuICAgICAgICB0aGlzLmludmFsaWRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3Blbi9jbG9zZSB0aGUgaXRlbVxuICAgICAqL1xuICAgIHRvZ2dsZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdGVtcG9yYXJ5IHZhcmlhYmxlIGFzIGBvcGVuQ2xvc2VJdGVtcy5uZXh0YCB3aWxsIGNoYW5nZSBjdXJyZW50IHZhbHVlIHdlIG5lZWQgdG8gc2F2ZVxuICAgICAgICAgICAgY29uc3Qgd2lsbFNldCA9ICF0aGlzLmNvbGxhcHNlZDtcbiAgICAgICAgICAgIGlmICghdGhpcy5hY2NvcmRpb24ubXVsdGkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjY29yZGlvbi5vcGVuQ2xvc2VJdGVtcy5uZXh0KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2xsYXBzZWQgPSB3aWxsU2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIGl0ZW0uXG4gICAgICovXG4gICAgb3BlbigpIHtcbiAgICAgICAgIXRoaXMuZGlzYWJsZWQgJiYgKHRoaXMuY29sbGFwc2VkID0gZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZSB0aGUgaXRlbS5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgIXRoaXMuZGlzYWJsZWQgJiYgKHRoaXMuY29sbGFwc2VkID0gdHJ1ZSk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmFjY29yZGlvbi5vcGVuQ2xvc2VJdGVtc1xuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShjb2xsYXBzZWQgPT4ge1xuICAgICAgICAgICAgIXRoaXMuZGlzYWJsZWQgJiYgKHRoaXMuY29sbGFwc2VkID0gY29sbGFwc2VkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5hY2NvcmRpb25JdGVtSW52YWxpZGF0ZS5uZXh0KHRydWUpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFjY29yZGlvbkl0ZW1JbnZhbGlkYXRlLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIHRoaXMuYWNjb3JkaW9uSXRlbUludmFsaWRhdGUubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxMTAoW1xuICAgIElucHV0KCdjb2xsYXBzZWQnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3MuY29sbGFwc2VkJyksXG4gICAgX19tZXRhZGF0YSQ3MyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNzMoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYkFjY29yZGlvbkl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImNvbGxhcHNlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTEwKFtcbiAgICBJbnB1dCgnZXhwYW5kZWQnKSxcbiAgICBIb3N0QmluZGluZygnY2xhc3MuZXhwYW5kZWQnKSxcbiAgICBfX21ldGFkYXRhJDczKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ3MyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iQWNjb3JkaW9uSXRlbUNvbXBvbmVudC5wcm90b3R5cGUsIFwiZXhwYW5kZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDExMChbXG4gICAgSW5wdXQoJ2Rpc2FibGVkJyksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YSQ3MyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNzMoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYkFjY29yZGlvbkl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMTAoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNzMoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkFjY29yZGlvbkl0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImNvbGxhcHNlZENoYW5nZVwiLCB2b2lkIDApO1xuTmJBY2NvcmRpb25JdGVtQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxMTAoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItYWNjb3JkaW9uLWl0ZW0nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIm5iLWFjY29yZGlvbi1pdGVtLWhlYWRlclwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1hY2NvcmRpb24taXRlbS1ib2R5XCI+PC9uZy1jb250ZW50PlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1ufVxcblwiXVxuICAgIH0pLFxuICAgIF9fcGFyYW0kMTMoMCwgSG9zdCgpKSxcbiAgICBfX21ldGFkYXRhJDczKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iQWNjb3JkaW9uQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBOYkFjY29yZGlvbkl0ZW1Db21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMTEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNzQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDE0ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuY29uc3QgYWNjb3JkaW9uSXRlbUJvZHlUcmlnZ2VyID0gdHJpZ2dlcignYWNjb3JkaW9uSXRlbUJvZHknLCBbXG4gICAgc3RhdGUoJ2NvbGxhcHNlZCcsIHN0eWxlKHtcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJyxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgIH0pKSxcbiAgICBzdGF0ZSgnZXhwYW5kZWQnLCBzdHlsZSh7XG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnLFxuICAgIH0pKSxcbiAgICB0cmFuc2l0aW9uKCdjb2xsYXBzZWQgPT4gZXhwYW5kZWQnLCBhbmltYXRlKCcxMDBtcyBlYXNlLWluJykpLFxuICAgIHRyYW5zaXRpb24oJ2V4cGFuZGVkID0+IGNvbGxhcHNlZCcsIGFuaW1hdGUoJzEwMG1zIGVhc2Utb3V0JykpLFxuXSk7XG4vKipcbiAqIENvbXBvbmVudCBpbnRlbmRlZCB0byBiZSB1c2VkIHdpdGhpbiBgPG5iLWFjY29yZGlvbi1pdGVtPmAgY29tcG9uZW50XG4gKi9cbmxldCBOYkFjY29yZGlvbkl0ZW1Cb2R5Q29tcG9uZW50ID0gY2xhc3MgTmJBY2NvcmRpb25JdGVtQm9keUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYWNjb3JkaW9uSXRlbSwgY2QpIHtcbiAgICAgICAgdGhpcy5hY2NvcmRpb25JdGVtID0gYWNjb3JkaW9uSXRlbTtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY2NvcmRpb25JdGVtLmNvbGxhcHNlZCA/ICdjb2xsYXBzZWQnIDogJ2V4cGFuZGVkJztcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuYWNjb3JkaW9uSXRlbS5hY2NvcmRpb25JdGVtSW52YWxpZGF0ZVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNkLm1hcmtGb3JDaGVjaygpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICB9XG59O1xuTmJBY2NvcmRpb25JdGVtQm9keUNvbXBvbmVudCA9IF9fZGVjb3JhdGUkMTExKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWFjY29yZGlvbi1pdGVtLWJvZHknLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgW0BhY2NvcmRpb25JdGVtQm9keV09XCJ7IHZhbHVlOiBzdGF0ZSB9XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiaXRlbS1ib2R5XCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICBgLFxuICAgICAgICBhbmltYXRpb25zOiBbYWNjb3JkaW9uSXRlbUJvZHlUcmlnZ2VyXSxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICB9KSxcbiAgICBfX3BhcmFtJDE0KDAsIEhvc3QoKSksXG4gICAgX19tZXRhZGF0YSQ3NChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYkFjY29yZGlvbkl0ZW1Db21wb25lbnQsIENoYW5nZURldGVjdG9yUmVmXSlcbl0sIE5iQWNjb3JkaW9uSXRlbUJvZHlDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMTIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNzUgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDE1ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBDb21wb25lbnQgaW50ZW5kZWQgdG8gYmUgdXNlZCB3aXRoaW4gYDxuYi1hY2NvcmRpb24taXRlbT5gIGNvbXBvbmVudFxuICovXG5sZXQgTmJBY2NvcmRpb25JdGVtSGVhZGVyQ29tcG9uZW50ID0gY2xhc3MgTmJBY2NvcmRpb25JdGVtSGVhZGVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhY2NvcmRpb25JdGVtLCBjZCkge1xuICAgICAgICB0aGlzLmFjY29yZGlvbkl0ZW0gPSBhY2NvcmRpb25JdGVtO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBnZXQgaXNDb2xsYXBzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjY29yZGlvbkl0ZW0uY29sbGFwc2VkO1xuICAgIH1cbiAgICBnZXQgZXhwYW5kZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5hY2NvcmRpb25JdGVtLmNvbGxhcHNlZDtcbiAgICB9XG4gICAgLy8gaXNzdWUgIzc5NFxuICAgIGdldCB0YWJiYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjb3JkaW9uSXRlbS5kaXNhYmxlZCA/ICctMScgOiAnMCc7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjb3JkaW9uSXRlbS5kaXNhYmxlZDtcbiAgICB9XG4gICAgdG9nZ2xlKCkge1xuICAgICAgICB0aGlzLmFjY29yZGlvbkl0ZW0udG9nZ2xlKCk7XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnY29sbGFwc2VkJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgcmV0dXJuICdleHBhbmRlZCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuYWNjb3JkaW9uSXRlbS5hY2NvcmRpb25JdGVtSW52YWxpZGF0ZVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNkLm1hcmtGb3JDaGVjaygpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxMTIoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hY2NvcmRpb24taXRlbS1oZWFkZXItY29sbGFwc2VkJyksXG4gICAgX19tZXRhZGF0YSQ3NShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkNzUoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWNjb3JkaW9uSXRlbUhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNDb2xsYXBzZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDExMihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmFjY29yZGlvbi1pdGVtLWhlYWRlci1leHBhbmRlZCcpLFxuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZXhwYW5kZWQnKSxcbiAgICBfX21ldGFkYXRhJDc1KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ3NShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJBY2NvcmRpb25JdGVtSGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBhbmRlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTEyKFtcbiAgICBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpLFxuICAgIF9fbWV0YWRhdGEkNzUoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEkNzUoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iQWNjb3JkaW9uSXRlbUhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidGFiYmFibGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDExMihbXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEkNzUoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDc1KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYkFjY29yZGlvbkl0ZW1IZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMTIoW1xuICAgIEhvc3RMaXN0ZW5lcignY2xpY2snKSxcbiAgICBIb3N0TGlzdGVuZXIoJ2tleWRvd24uc3BhY2UnKSxcbiAgICBIb3N0TGlzdGVuZXIoJ2tleWRvd24uZW50ZXInKSxcbiAgICBfX21ldGFkYXRhJDc1KFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEkNzUoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YSQ3NShcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE5iQWNjb3JkaW9uSXRlbUhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwidG9nZ2xlXCIsIG51bGwpO1xuTmJBY2NvcmRpb25JdGVtSGVhZGVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxMTIoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItYWNjb3JkaW9uLWl0ZW0taGVhZGVyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1hY2NvcmRpb24taXRlbS10aXRsZVwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1hY2NvcmRpb24taXRlbS1kZXNjcmlwdGlvblwiPjwvbmctY29udGVudD5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPG5iLWljb24gaWNvbj1cImNoZXZyb24tZG93bi1vdXRsaW5lXCJcbiAgICAgICAgICAgICBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCJcbiAgICAgICAgICAgICBbQGV4cGFuc2lvbkluZGljYXRvcl09XCJzdGF0ZVwiXG4gICAgICAgICAgICAgKm5nSWY9XCIhZGlzYWJsZWRcIlxuICAgICAgICAgICAgIGNsYXNzPVwiZXhwYW5zaW9uLWluZGljYXRvclwiPlxuICAgIDwvbmItaWNvbj5cbiAgYCxcbiAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgdHJpZ2dlcignZXhwYW5zaW9uSW5kaWNhdG9yJywgW1xuICAgICAgICAgICAgICAgIHN0YXRlKCdleHBhbmRlZCcsIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiAncm90YXRlKDE4MGRlZyknLFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCdjb2xsYXBzZWQgPT4gZXhwYW5kZWQnLCBhbmltYXRlKCcxMDBtcyBlYXNlLWluJykpLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJ2V4cGFuZGVkID0+IGNvbGxhcHNlZCcsIGFuaW1hdGUoJzEwMG1zIGVhc2Utb3V0JykpLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIF0sXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXI7Y3Vyc29yOnBvaW50ZXJ9Omhvc3Q6Zm9jdXN7b3V0bGluZTowfVxcblwiXVxuICAgIH0pLFxuICAgIF9fcGFyYW0kMTUoMCwgSG9zdCgpKSxcbiAgICBfX21ldGFkYXRhJDc1KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iQWNjb3JkaW9uSXRlbUNvbXBvbmVudCwgQ2hhbmdlRGV0ZWN0b3JSZWZdKVxuXSwgTmJBY2NvcmRpb25JdGVtSGVhZGVyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTEzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmNvbnN0IE5CX0FDQ09SRElPTl9DT01QT05FTlRTID0gW1xuICAgIE5iQWNjb3JkaW9uQ29tcG9uZW50LFxuICAgIE5iQWNjb3JkaW9uSXRlbUNvbXBvbmVudCxcbiAgICBOYkFjY29yZGlvbkl0ZW1IZWFkZXJDb21wb25lbnQsXG4gICAgTmJBY2NvcmRpb25JdGVtQm9keUNvbXBvbmVudCxcbl07XG5sZXQgTmJBY2NvcmRpb25Nb2R1bGUgPSBjbGFzcyBOYkFjY29yZGlvbk1vZHVsZSB7XG59O1xuTmJBY2NvcmRpb25Nb2R1bGUgPSBfX2RlY29yYXRlJDExMyhbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBOYkljb25Nb2R1bGVdLFxuICAgICAgICBleHBvcnRzOiBbLi4uTkJfQUNDT1JESU9OX0NPTVBPTkVOVFNdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFsuLi5OQl9BQ0NPUkRJT05fQ09NUE9ORU5UU10sXG4gICAgICAgIHByb3ZpZGVyczogW10sXG4gICAgfSlcbl0sIE5iQWNjb3JkaW9uTW9kdWxlKTtcblxudmFyIF9fZGVjb3JhdGUkMTE0ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDc2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIExpc3QgaXMgYSBjb250YWluZXIgY29tcG9uZW50IHRoYXQgd3JhcHMgYG5iLWxpc3QtaXRlbWAgY29tcG9uZW50LlxuICpcbiAqIEJhc2ljIGV4YW1wbGU6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFNpbXBsZSBsaXN0LCBsaXN0L3NpbXBsZS1saXN0LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBgbmItbGlzdC1pdGVtYCBhY2NlcHRzIGFyYml0cmFyeSBjb250ZW50LCBzbyB5b3UgY2FuIGNyZWF0ZSBhIGxpc3Qgb2YgYW55IGNvbXBvbmVudHMuXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJMaXN0TW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkxpc3RNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIExpc3Qgb2YgdXNlcnM6XG4gKiBAc3RhY2tlZC1leGFtcGxlKFVzZXJzIGxpc3QsIGxpc3QvdXNlcnMtbGlzdC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIGxpc3QtaXRlbS1kaXZpZGVyLWNvbG9yOlxuICogbGlzdC1pdGVtLWRpdmlkZXItc3R5bGU6XG4gKiBsaXN0LWl0ZW0tZGl2aWRlci13aWR0aDpcbiAqIGxpc3QtaXRlbS1wYWRkaW5nOlxuICogbGlzdC1pdGVtLXRleHQtY29sb3I6XG4gKiBsaXN0LWl0ZW0tZm9udC1mYW1pbHk6XG4gKiBsaXN0LWl0ZW0tZm9udC1zaXplOlxuICogbGlzdC1pdGVtLWZvbnQtd2VpZ2h0OlxuICogbGlzdC1pdGVtLWxpbmUtaGVpZ2h0OlxuICovXG5sZXQgTmJMaXN0Q29tcG9uZW50ID0gY2xhc3MgTmJMaXN0Q29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBMaXN0IGlzIGEgY29udGFpbmVyIGNvbXBvbmVudCB0aGF0IHdyYXBzIGBuYi1saXN0LWl0ZW1gIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEJhc2ljIGV4YW1wbGU6XG4gICAgICogQHN0YWNrZWQtZXhhbXBsZShTaW1wbGUgbGlzdCwgbGlzdC9zaW1wbGUtbGlzdC1zaG93Y2FzZS5jb21wb25lbnQpXG4gICAgICpcbiAgICAgKiBgbmItbGlzdC1pdGVtYCBhY2NlcHRzIGFyYml0cmFyeSBjb250ZW50LCBzbyB5b3UgY2FuIGNyZWF0ZSBhIGxpc3Qgb2YgYW55IGNvbXBvbmVudHMuXG4gICAgICpcbiAgICAgKiAjIyMgSW5zdGFsbGF0aW9uXG4gICAgICpcbiAgICAgKiBJbXBvcnQgYE5iTGlzdE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAgICAgKiBgYGB0c1xuICAgICAqIEBOZ01vZHVsZSh7XG4gICAgICogICBpbXBvcnRzOiBbXG4gICAgICogICAgIC8vIC4uLlxuICAgICAqICAgICBOYkxpc3RNb2R1bGUsXG4gICAgICogICBdLFxuICAgICAqIH0pXG4gICAgICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gICAgICogYGBgXG4gICAgICogIyMjIFVzYWdlXG4gICAgICpcbiAgICAgKiBMaXN0IG9mIHVzZXJzOlxuICAgICAqIEBzdGFja2VkLWV4YW1wbGUoVXNlcnMgbGlzdCwgbGlzdC91c2Vycy1saXN0LXNob3djYXNlLmNvbXBvbmVudClcbiAgICAgKlxuICAgICAqIEBzdHlsZXNcbiAgICAgKlxuICAgICAqIGxpc3QtaXRlbS1kaXZpZGVyLWNvbG9yOlxuICAgICAqIGxpc3QtaXRlbS1kaXZpZGVyLXN0eWxlOlxuICAgICAqIGxpc3QtaXRlbS1kaXZpZGVyLXdpZHRoOlxuICAgICAqIGxpc3QtaXRlbS1wYWRkaW5nOlxuICAgICAqIGxpc3QtaXRlbS10ZXh0LWNvbG9yOlxuICAgICAqIGxpc3QtaXRlbS1mb250LWZhbWlseTpcbiAgICAgKiBsaXN0LWl0ZW0tZm9udC1zaXplOlxuICAgICAqIGxpc3QtaXRlbS1mb250LXdlaWdodDpcbiAgICAgKiBsaXN0LWl0ZW0tbGluZS1oZWlnaHQ6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSb2xlIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yb2xlID0gJ2xpc3QnO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDExNChbXG4gICAgSW5wdXQoKSxcbiAgICBIb3N0QmluZGluZygnYXR0ci5yb2xlJyksXG4gICAgX19tZXRhZGF0YSQ3NihcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iTGlzdENvbXBvbmVudC5wcm90b3R5cGUsIFwicm9sZVwiLCB2b2lkIDApO1xuTmJMaXN0Q29tcG9uZW50ID0gX19kZWNvcmF0ZSQxMTQoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItbGlzdCcsXG4gICAgICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItbGlzdC1pdGVtXCI+PC9uZy1jb250ZW50PmAsXG4gICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjtmbGV4OjEgMSBhdXRvO292ZXJmbG93OmF1dG99XFxuXCJdXG4gICAgfSlcbl0sIE5iTGlzdENvbXBvbmVudCk7XG4vKipcbiAqIExpc3QgaXRlbSBjb21wb25lbnQgaXMgYSBncm91cGluZyBjb21wb25lbnQgdGhhdCBhY2NlcHRzIGFyYml0cmFyeSBjb250ZW50LlxuICogSXQgc2hvdWxkIGJlIGRpcmVjdCBjaGlsZCBvZiBgbmItbGlzdGAgY29tcG9uZXQuXG4gKi9cbmxldCBOYkxpc3RJdGVtQ29tcG9uZW50ID0gY2xhc3MgTmJMaXN0SXRlbUNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogTGlzdCBpdGVtIGNvbXBvbmVudCBpcyBhIGdyb3VwaW5nIGNvbXBvbmVudCB0aGF0IGFjY2VwdHMgYXJiaXRyYXJ5IGNvbnRlbnQuXG4gICAgICogSXQgc2hvdWxkIGJlIGRpcmVjdCBjaGlsZCBvZiBgbmItbGlzdGAgY29tcG9uZXQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSb2xlIGF0dHJpYnV0ZSB2YWx1ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yb2xlID0gJ2xpc3RpdGVtJztcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxMTQoW1xuICAgIElucHV0KCksXG4gICAgSG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpLFxuICAgIF9fbWV0YWRhdGEkNzYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkxpc3RJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyb2xlXCIsIHZvaWQgMCk7XG5OYkxpc3RJdGVtQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxMTQoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItbGlzdC1pdGVtJyxcbiAgICAgICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2ZsZXgtc2hyaW5rOjB9XFxuXCJdXG4gICAgfSlcbl0sIE5iTGlzdEl0ZW1Db21wb25lbnQpO1xuXG52YXIgX19kZWNvcmF0ZSQxMTYgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNzcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogTGlzdCBwYWdlciBkaXJlY3RpdmVcbiAqXG4gKiBEaXJlY3RpdmUgYWxsb3dzIHlvdSB0byBkZXRlcm1pbmUgcGFnZSBvZiBjdXJyZW50bHkgdmlld2luZyBpdGVtcy5cbiAqXG4gKi9cbmxldCBOYkxpc3RQYWdlVHJhY2tlckRpcmVjdGl2ZSA9IGNsYXNzIE5iTGlzdFBhZ2VUcmFja2VyRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYWdlIHRvIHN0YXJ0IGNvdW50aW5nIHdpdGguXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0UGFnZSA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIGFub3RoZXIgcGFnZSBiZWNvbWUgdmlzaWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFnZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHRoaXMuY2hlY2tGb3JQYWdlQ2hhbmdlKGVudHJpZXMpLCB7IHRocmVzaG9sZDogMC41IH0pO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3RJdGVtcyAmJiB0aGlzLmxpc3RJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0SXRlbXMuY2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9ic2VydmVJdGVtcygpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCAmJiB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgb2JzZXJ2ZUl0ZW1zKCkge1xuICAgICAgICB0aGlzLmxpc3RJdGVtcy5mb3JFYWNoKGkgPT4gdGhpcy5vYnNlcnZlci5vYnNlcnZlKGkubmF0aXZlRWxlbWVudCkpO1xuICAgIH1cbiAgICBjaGVja0ZvclBhZ2VDaGFuZ2UoZW50cmllcykge1xuICAgICAgICBjb25zdCBtb3N0VmlzaWJsZVBhZ2UgPSB0aGlzLmZpbmRNb3N0VmlzaWJsZVBhZ2UoZW50cmllcyk7XG4gICAgICAgIGlmIChtb3N0VmlzaWJsZVBhZ2UgJiYgdGhpcy5jdXJyZW50UGFnZSAhPT0gbW9zdFZpc2libGVQYWdlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYWdlID0gbW9zdFZpc2libGVQYWdlO1xuICAgICAgICAgICAgdGhpcy5wYWdlQ2hhbmdlLmVtaXQodGhpcy5jdXJyZW50UGFnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZE1vc3RWaXNpYmxlUGFnZShlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdGlvblJhdGlvQnlQYWdlID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA8IDAuNSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZWxlbWVudEluZGV4ID0gdGhpcy5lbGVtZW50SW5kZXgoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYWdlID0gdGhpcy5zdGFydFBhZ2UgKyBNYXRoLmZsb29yKGVsZW1lbnRJbmRleCAvIHRoaXMucGFnZVNpemUpO1xuICAgICAgICAgICAgbGV0IHJhdGlvID0gZW50cnkuaW50ZXJzZWN0aW9uUmF0aW87XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uUmF0aW9CeVBhZ2UuaGFzKHBhZ2UpKSB7XG4gICAgICAgICAgICAgICAgcmF0aW8gKz0gaW50ZXJzZWN0aW9uUmF0aW9CeVBhZ2UuZ2V0KHBhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uUmF0aW9CeVBhZ2Uuc2V0KHBhZ2UsIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF4UmF0aW8gPSAwO1xuICAgICAgICBsZXQgbW9zdFZpc2libGVQYWdlO1xuICAgICAgICBpbnRlcnNlY3Rpb25SYXRpb0J5UGFnZS5mb3JFYWNoKChyYXRpbywgcGFnZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHJhdGlvID4gbWF4UmF0aW8pIHtcbiAgICAgICAgICAgICAgICBtYXhSYXRpbyA9IHJhdGlvO1xuICAgICAgICAgICAgICAgIG1vc3RWaXNpYmxlUGFnZSA9IHBhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbW9zdFZpc2libGVQYWdlO1xuICAgIH1cbiAgICBlbGVtZW50SW5kZXgoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5wYXJlbnRFbGVtZW50ICYmIGVsZW1lbnQucGFyZW50RWxlbWVudC5jaGlsZHJlblxuICAgICAgICAgICAgPyBBcnJheS5mcm9tKGVsZW1lbnQucGFyZW50RWxlbWVudC5jaGlsZHJlbikuaW5kZXhPZihlbGVtZW50KVxuICAgICAgICAgICAgOiAtMTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxMTYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ3NyhcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE5iTGlzdFBhZ2VUcmFja2VyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJwYWdlU2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMTYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ3NyhcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE5iTGlzdFBhZ2VUcmFja2VyRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJzdGFydFBhZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTE2KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDc3KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJMaXN0UGFnZVRyYWNrZXJEaXJlY3RpdmUucHJvdG90eXBlLCBcInBhZ2VDaGFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTE2KFtcbiAgICBDb250ZW50Q2hpbGRyZW4oTmJMaXN0SXRlbUNvbXBvbmVudCwgeyByZWFkOiBFbGVtZW50UmVmIH0pLFxuICAgIF9fbWV0YWRhdGEkNzcoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBOYkxpc3RQYWdlVHJhY2tlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwibGlzdEl0ZW1zXCIsIHZvaWQgMCk7XG5OYkxpc3RQYWdlVHJhY2tlckRpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkMTE2KFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1tuYkxpc3RQYWdlVHJhY2tlcl0nLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkNzcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iTGlzdFBhZ2VUcmFja2VyRGlyZWN0aXZlKTtcblxudmFyIF9fZGVjb3JhdGUkMTE3ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDc4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5jbGFzcyBOYlNjcm9sbGFibGVDb250YWluZXJEaW1lbnRpb25zIHtcbn1cbi8qKlxuICogSW5maW5pdGUgTGlzdCBEaXJlY3RpdmVcbiAqXG4gKiBgYGBodG1sXG4gKiAgPG5iLWxpc3QgbmJJbmZpbml0ZUxpc3QgW3RocmVzaG9sZF09XCI1MDBcIiAoYm90dG9tVGhyZXNob2xkKT1cImxvYWROZXh0KClcIj5cbiAqICAgIDxuYi1saXN0LWl0ZW0gKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXNcIj48L25iLWxpc3QtaXRlbT5cbiAqICA8L25iLWxpc3Q+XG4gKiBgYGBcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNpbXBsZSBpbmZpbml0ZSBsaXN0LCBpbmZpbml0ZS1saXN0L2luZmluaXRlLWxpc3Qtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIERpcmVjdGl2ZSB3aWxsIG5vdGlmeSB3aGVuIGxpc3Qgc2Nyb2xsZWQgdXAgb3IgZG93biB0byBhIGdpdmVuIHRocmVzaG9sZC5cbiAqIEJ5IGRlZmF1bHQgaXQgbGlzdGVuIHRvIHNjcm9sbCBvZiBsaXN0IG9uIHdoaWNoIGFwcGxpZWQsIGJ1dCBhbHNvIGNhbiBiZSBzZXQgdG8gbGlzdGVuIHRvIHdpbmRvdyBzY3JvbGwuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTY3JvbGwgbW9kZXMsIGluZmluaXRlLWxpc3QvaW5maW5pdGUtbGlzdC1zY3JvbGwtbW9kZXMuY29tcG9uZW50KVxuICpcbiAqIFRvIGltcHJvdmUgVVggb2YgaW5maW5pdGUgbGlzdHMsIGl0J3MgYmV0dGVyIHRvIGtlZXAgY3VycmVudCBwYWdlIGluIHVybCxcbiAqIHNvIHVzZXIgYWJsZSB0byByZXR1cm4gdG8gdGhlIGxhc3Qgdmlld2VkIHBhZ2Ugb3IgdG8gc2hhcmUgYSBsaW5rIHRvIHRoaXMgcGFnZS5cbiAqIGBuYkxpc3RQYWdlVHJhY2tlcmAgZGlyZWN0aXZlIHdpbGwgaGVscCB5b3UgdG8ga25vdywgd2hhdCBwYWdlIHVzZXIgY3VycmVudGx5IHZpZXdpbmcuXG4gKiBKdXN0IHB1dCBpdCBvbiBhIGxpc3QsIHNldCBwYWdlIHNpemUgYW5kIGl0IHdpbGwgY2FsY3VsYXRlIHBhZ2UgdGhhdCBjdXJyZW50bHkgaW4gdmlld3BvcnQuXG4gKiBZb3UgY2FuIFtvcGVuIHRoZSBleGFtcGxlXShleGFtcGxlL2luZmluaXRlLWxpc3QvaW5maW5pdGUtbmV3cy1saXN0LmNvbXBvbmVudClcbiAqIGluIGEgbmV3IHRhYiB0byBjaGVjayBvdXQgdGhpcyBmZWF0dXJlLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoSW5maW5pdGUgbGlzdCB3aXRoIHBhZ2VyLCBpbmZpbml0ZS1saXN0L2luZmluaXRlLW5ld3MtbGlzdC5jb21wb25lbnQpXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShJbmZpbml0ZSBsaXN0IHdpdGggcGxhY2Vob2xkZXJzIGF0IHRoZSB0b3AsIGluZmluaXRlLWxpc3QvaW5maW5pdGUtbGlzdC1wbGFjZWhvbGRlcnMuY29tcG9uZW50KVxuICpcbiAqL1xubGV0IE5iSW5maW5pdGVMaXN0RGlyZWN0aXZlID0gY2xhc3MgTmJJbmZpbml0ZUxpc3REaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWYsIHNjcm9sbFNlcnZpY2UsIGRpbWVuc2lvbnNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZSA9IHNjcm9sbFNlcnZpY2U7XG4gICAgICAgIHRoaXMuZGltZW5zaW9uc1NlcnZpY2UgPSBkaW1lbnNpb25zU2VydmljZTtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMud2luZG93U2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIGRpc3RhbmNlIGJldHdlZW4gbGlzdCBib3R0b20gYW5kIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGlzIGxlc3MgdGhhbiB0aHJlc2hvbGQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdHRvbVRocmVzaG9sZCA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyB3aGVuIGRpc3RhbmNlIGJldHdlZW4gbGlzdCB0b3AgYW5kIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGlzIGxlc3MgdGhhbiB0aHJlc2hvbGQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvcFRocmVzaG9sZCA9IG5ldyBFdmVudEVtaXR0ZXIodHJ1ZSk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50U2Nyb2xsKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMud2luZG93U2Nyb2xsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCeSBkZWZhdWx0IGNvbXBvbmVudCBvYnNlcnZlcyBsaXN0IHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBJZiBzZXQgdG8gYHRydWVgLCBjb21wb25lbnQgd2lsbCBvYnNlcnZlIHBvc2l0aW9uIG9mIHBhZ2Ugc2Nyb2xsIGluc3RlYWQuXG4gICAgICovXG4gICAgc2V0IGxpc3RlbldpbmRvd1Njcm9sbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLndpbmRvd1Njcm9sbCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIG9uRWxlbWVudFNjcm9sbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudFNjcm9sbCkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1Bvc2l0aW9uKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsU2VydmljZS5vblNjcm9sbCgpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSksIGZpbHRlcigoKSA9PiB0aGlzLndpbmRvd1Njcm9sbCksIHN3aXRjaE1hcCgoKSA9PiB0aGlzLmdldENvbnRhaW5lckRpbWVuc2lvbnMoKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGRpbWVudGlvbnMgPT4gdGhpcy5jaGVja1Bvc2l0aW9uKGRpbWVudGlvbnMpKTtcbiAgICAgICAgdGhpcy5saXN0SXRlbXMuY2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpLCBcbiAgICAgICAgLy8gRm9yIHNvbWUgcmVhc29uLCBjaGFuZ2VzIGFyZSBlbWl0dGVkIGJlZm9yZSBsaXN0IGl0ZW0gcmVtb3ZlZCBmcm9tIGRvbSxcbiAgICAgICAgLy8gc28gZGltZW5zaW9ucyB3aWxsIGJlIGluY29ycmVjdC5cbiAgICAgICAgLy8gQ2hlY2sgZXZlcnkgNTBtcyBmb3IgYSBzZWNvbmQgaWYgZG9tIGFuZCBxdWVyeSBhcmUgaW4gc3luYy5cbiAgICAgICAgLy8gT25jZSB0aGV5IHN5bmNocm9uaXplZCwgd2UgY2FuIGdldCBwcm9wZXIgZGltZW5zaW9ucy5cbiAgICAgICAgc3dpdGNoTWFwKCgpID0+IGludGVydmFsKDUwKS5waXBlKHRha2VVbnRpbCh0aW1lcigxMDAwKSksIGZpbHRlcigoKSA9PiB0aGlzLmluU3luY1dpdGhEb20oKSksIHRha2UoMSkpKSwgc3dpdGNoTWFwKCgpID0+IHRoaXMuZ2V0Q29udGFpbmVyRGltZW5zaW9ucygpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZGltZW50aW9ucyA9PiB0aGlzLmNoZWNrUG9zaXRpb24oZGltZW50aW9ucykpO1xuICAgICAgICB0aGlzLmdldENvbnRhaW5lckRpbWVuc2lvbnMoKS5zdWJzY3JpYmUoZGltZW50aW9ucyA9PiB0aGlzLmNoZWNrUG9zaXRpb24oZGltZW50aW9ucykpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBjaGVja1Bvc2l0aW9uKHsgc2Nyb2xsSGVpZ2h0LCBzY3JvbGxUb3AsIGNsaWVudEhlaWdodCB9KSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxDaGVjayA9IHRoaXMubGFzdFNjcm9sbFBvc2l0aW9uID09IG51bGw7XG4gICAgICAgIGNvbnN0IG1hbnVhbENoZWNrID0gdGhpcy5sYXN0U2Nyb2xsUG9zaXRpb24gPT09IHNjcm9sbFRvcDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsVXAgPSBzY3JvbGxUb3AgPCB0aGlzLmxhc3RTY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgY29uc3Qgc2Nyb2xsRG93biA9IHNjcm9sbFRvcCA+IHRoaXMubGFzdFNjcm9sbFBvc2l0aW9uO1xuICAgICAgICBjb25zdCBkaXN0YW5jZVRvQm90dG9tID0gc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsVG9wIC0gY2xpZW50SGVpZ2h0O1xuICAgICAgICBpZiAoKGluaXRpYWxDaGVjayB8fCBtYW51YWxDaGVjayB8fCBzY3JvbGxEb3duKSAmJiBkaXN0YW5jZVRvQm90dG9tIDw9IHRoaXMudGhyZXNob2xkKSB7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbVRocmVzaG9sZC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChpbml0aWFsQ2hlY2sgfHwgc2Nyb2xsVXApICYmIHNjcm9sbFRvcCA8PSB0aGlzLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgdGhpcy50b3BUaHJlc2hvbGQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFNjcm9sbFBvc2l0aW9uID0gc2Nyb2xsVG9wO1xuICAgIH1cbiAgICBnZXRDb250YWluZXJEaW1lbnNpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50U2Nyb2xsKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0LCBjbGllbnRIZWlnaHQgfSA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgcmV0dXJuIG9mKHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQsIGNsaWVudEhlaWdodCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ya0pvaW4odGhpcy5zY3JvbGxTZXJ2aWNlLmdldFBvc2l0aW9uKCksIHRoaXMuZGltZW5zaW9uc1NlcnZpY2UuZ2V0RGltZW5zaW9ucygpKVxuICAgICAgICAgICAgLnBpcGUobWFwKChbc2Nyb2xsUG9zaXRpb24sIGRpbWVuc2lvbnNdKSA9PiAoe1xuICAgICAgICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxQb3NpdGlvbi55LFxuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0OiBkaW1lbnNpb25zLnNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgIGNsaWVudEhlaWdodDogZGltZW5zaW9ucy5jbGllbnRIZWlnaHQsXG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIGluU3luY1dpdGhEb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IHRoaXMubGlzdEl0ZW1zLmxlbmd0aDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxMTcoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ3OChcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIE5iSW5maW5pdGVMaXN0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJ0aHJlc2hvbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTE3KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNzgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkNzgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIE5iSW5maW5pdGVMaXN0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsaXN0ZW5XaW5kb3dTY3JvbGxcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDExNyhbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQ3OChcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iSW5maW5pdGVMaXN0RGlyZWN0aXZlLnByb3RvdHlwZSwgXCJib3R0b21UaHJlc2hvbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTE3KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDc4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJJbmZpbml0ZUxpc3REaXJlY3RpdmUucHJvdG90eXBlLCBcInRvcFRocmVzaG9sZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMTcoW1xuICAgIEhvc3RMaXN0ZW5lcignc2Nyb2xsJyksXG4gICAgX19tZXRhZGF0YSQ3OChcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhJDc4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgIF9fbWV0YWRhdGEkNzgoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBOYkluZmluaXRlTGlzdERpcmVjdGl2ZS5wcm90b3R5cGUsIFwib25FbGVtZW50U2Nyb2xsXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMTcoW1xuICAgIENvbnRlbnRDaGlsZHJlbihOYkxpc3RJdGVtQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhJDc4KFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgTmJJbmZpbml0ZUxpc3REaXJlY3RpdmUucHJvdG90eXBlLCBcImxpc3RJdGVtc1wiLCB2b2lkIDApO1xuTmJJbmZpbml0ZUxpc3REaXJlY3RpdmUgPSBfX2RlY29yYXRlJDExNyhbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdbbmJJbmZpbml0ZUxpc3RdJyxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDc4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIE5iTGF5b3V0U2Nyb2xsU2VydmljZSxcbiAgICAgICAgTmJMYXlvdXRSdWxlclNlcnZpY2VdKVxuXSwgTmJJbmZpbml0ZUxpc3REaXJlY3RpdmUpO1xuXG52YXIgX19kZWNvcmF0ZSQxMTUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuY29uc3QgY29tcG9uZW50cyA9IFtcbiAgICBOYkxpc3RDb21wb25lbnQsXG4gICAgTmJMaXN0SXRlbUNvbXBvbmVudCxcbiAgICBOYkxpc3RQYWdlVHJhY2tlckRpcmVjdGl2ZSxcbiAgICBOYkluZmluaXRlTGlzdERpcmVjdGl2ZSxcbl07XG5sZXQgTmJMaXN0TW9kdWxlID0gY2xhc3MgTmJMaXN0TW9kdWxlIHtcbn07XG5OYkxpc3RNb2R1bGUgPSBfX2RlY29yYXRlJDExNShbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBkZWNsYXJhdGlvbnM6IGNvbXBvbmVudHMsXG4gICAgICAgIGV4cG9ydHM6IGNvbXBvbmVudHMsXG4gICAgfSlcbl0sIE5iTGlzdE1vZHVsZSk7XG5cbnZhciBfX2RlY29yYXRlJDExOCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5sZXQgTmJEaXJlY3Rpb25hbGl0eSA9IGNsYXNzIE5iRGlyZWN0aW9uYWxpdHkgZXh0ZW5kcyBEaXJlY3Rpb25hbGl0eSB7XG59O1xuTmJEaXJlY3Rpb25hbGl0eSA9IF9fZGVjb3JhdGUkMTE4KFtcbiAgICBJbmplY3RhYmxlKClcbl0sIE5iRGlyZWN0aW9uYWxpdHkpO1xuXG52YXIgX19kZWNvcmF0ZSQxMTkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xubGV0IE5iQmlkaU1vZHVsZSA9IGNsYXNzIE5iQmlkaU1vZHVsZSBleHRlbmRzIEJpZGlNb2R1bGUge1xufTtcbk5iQmlkaU1vZHVsZSA9IF9fZGVjb3JhdGUkMTE5KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgeyBwcm92aWRlOiBOYkRpcmVjdGlvbmFsaXR5LCB1c2VFeGlzdGluZzogRGlyZWN0aW9uYWxpdHkgfSxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJCaWRpTW9kdWxlKTtcblxuY2xhc3MgTmJQbGF0Zm9ybSQxIGV4dGVuZHMgUGxhdGZvcm0ge1xufVxuXG52YXIgX19kZWNvcmF0ZSQxMjAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xubGV0IE5iUGxhdGZvcm1Nb2R1bGUgPSBjbGFzcyBOYlBsYXRmb3JtTW9kdWxlIGV4dGVuZHMgUGxhdGZvcm1Nb2R1bGUge1xufTtcbk5iUGxhdGZvcm1Nb2R1bGUgPSBfX2RlY29yYXRlJDEyMChbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTmJQbGF0Zm9ybSQxLCB1c2VFeGlzdGluZzogUGxhdGZvcm0gfSxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJQbGF0Zm9ybU1vZHVsZSk7XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm5iaW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMjEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkNzkgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBOYkNlbGxEZWZEaXJlY3RpdmVfMTtcbnZhciBOYkhlYWRlckNlbGxEZWZEaXJlY3RpdmVfMTtcbnZhciBOYkZvb3RlckNlbGxEZWZEaXJlY3RpdmVfMTtcbnZhciBOYkNvbHVtbkRlZkRpcmVjdGl2ZV8xO1xuLyoqXG4gKiBDZWxsIGRlZmluaXRpb24gZm9yIHRoZSBuYi10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSB0ZW1wbGF0ZSBvZiBhIGNvbHVtbidzIGRhdGEgcm93IGNlbGwgYXMgd2VsbCBhcyBjZWxsLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cbmxldCBOYkNlbGxEZWZEaXJlY3RpdmUgPSBOYkNlbGxEZWZEaXJlY3RpdmVfMSA9IGNsYXNzIE5iQ2VsbERlZkRpcmVjdGl2ZSBleHRlbmRzIENka0NlbGxEZWYge1xufTtcbk5iQ2VsbERlZkRpcmVjdGl2ZSA9IE5iQ2VsbERlZkRpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZSQxMjEoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW25iQ2VsbERlZl0nLFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka0NlbGxEZWYsIHVzZUV4aXN0aW5nOiBOYkNlbGxEZWZEaXJlY3RpdmVfMSB9XSxcbiAgICB9KVxuXSwgTmJDZWxsRGVmRGlyZWN0aXZlKTtcbi8qKlxuICogSGVhZGVyIGNlbGwgZGVmaW5pdGlvbiBmb3IgdGhlIG5iLXRhYmxlLlxuICogQ2FwdHVyZXMgdGhlIHRlbXBsYXRlIG9mIGEgY29sdW1uJ3MgaGVhZGVyIGNlbGwgYW5kIGFzIHdlbGwgYXMgY2VsbC1zcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICovXG5sZXQgTmJIZWFkZXJDZWxsRGVmRGlyZWN0aXZlID0gTmJIZWFkZXJDZWxsRGVmRGlyZWN0aXZlXzEgPSBjbGFzcyBOYkhlYWRlckNlbGxEZWZEaXJlY3RpdmUgZXh0ZW5kcyBDZGtIZWFkZXJDZWxsRGVmIHtcbn07XG5OYkhlYWRlckNlbGxEZWZEaXJlY3RpdmUgPSBOYkhlYWRlckNlbGxEZWZEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUkMTIxKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1tuYkhlYWRlckNlbGxEZWZdJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtIZWFkZXJDZWxsRGVmLCB1c2VFeGlzdGluZzogTmJIZWFkZXJDZWxsRGVmRGlyZWN0aXZlXzEgfV0sXG4gICAgfSlcbl0sIE5iSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSk7XG4vKipcbiAqIEZvb3RlciBjZWxsIGRlZmluaXRpb24gZm9yIHRoZSBuYi10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSB0ZW1wbGF0ZSBvZiBhIGNvbHVtbidzIGZvb3RlciBjZWxsIGFuZCBhcyB3ZWxsIGFzIGNlbGwtc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqL1xubGV0IE5iRm9vdGVyQ2VsbERlZkRpcmVjdGl2ZSA9IE5iRm9vdGVyQ2VsbERlZkRpcmVjdGl2ZV8xID0gY2xhc3MgTmJGb290ZXJDZWxsRGVmRGlyZWN0aXZlIGV4dGVuZHMgQ2RrRm9vdGVyQ2VsbERlZiB7XG59O1xuTmJGb290ZXJDZWxsRGVmRGlyZWN0aXZlID0gTmJGb290ZXJDZWxsRGVmRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlJDEyMShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdbbmJGb290ZXJDZWxsRGVmXScsXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrRm9vdGVyQ2VsbERlZiwgdXNlRXhpc3Rpbmc6IE5iRm9vdGVyQ2VsbERlZkRpcmVjdGl2ZV8xIH1dLFxuICAgIH0pXG5dLCBOYkZvb3RlckNlbGxEZWZEaXJlY3RpdmUpO1xuY29uc3QgTkJfU09SVF9IRUFERVJfQ09MVU1OX0RFRiA9IG5ldyBJbmplY3Rpb25Ub2tlbignTkJfU09SVF9IRUFERVJfQ09MVU1OX0RFRicpO1xuLyoqXG4gKiBDb2x1bW4gZGVmaW5pdGlvbiBmb3IgdGhlIG5iLXRhYmxlLlxuICogRGVmaW5lcyBhIHNldCBvZiBjZWxscyBhdmFpbGFibGUgZm9yIGEgdGFibGUgY29sdW1uLlxuICovXG5sZXQgTmJDb2x1bW5EZWZEaXJlY3RpdmUgPSBOYkNvbHVtbkRlZkRpcmVjdGl2ZV8xID0gY2xhc3MgTmJDb2x1bW5EZWZEaXJlY3RpdmUgZXh0ZW5kcyBDZGtDb2x1bW5EZWYge1xufTtcbl9fZGVjb3JhdGUkMTIxKFtcbiAgICBJbnB1dCgnbmJDb2x1bW5EZWYnKSxcbiAgICBfX21ldGFkYXRhJDc5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJDb2x1bW5EZWZEaXJlY3RpdmUucHJvdG90eXBlLCBcIm5hbWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTIxKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkNzkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJDb2x1bW5EZWZEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0aWNreVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMjEoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ3OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYkNvbHVtbkRlZkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3RpY2t5RW5kXCIsIHZvaWQgMCk7XG5OYkNvbHVtbkRlZkRpcmVjdGl2ZSA9IE5iQ29sdW1uRGVmRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlJDEyMShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdbbmJDb2x1bW5EZWZdJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7IHByb3ZpZGU6IENka0NvbHVtbkRlZiwgdXNlRXhpc3Rpbmc6IE5iQ29sdW1uRGVmRGlyZWN0aXZlXzEgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTkJfU09SVF9IRUFERVJfQ09MVU1OX0RFRiwgdXNlRXhpc3Rpbmc6IE5iQ29sdW1uRGVmRGlyZWN0aXZlXzEgfSxcbiAgICAgICAgXSxcbiAgICB9KVxuXSwgTmJDb2x1bW5EZWZEaXJlY3RpdmUpO1xuLyoqIEhlYWRlciBjZWxsIHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGFkZHMgdGhlIHJpZ2h0IGNsYXNzZXMgYW5kIHJvbGUuICovXG5sZXQgTmJIZWFkZXJDZWxsRGlyZWN0aXZlID0gY2xhc3MgTmJIZWFkZXJDZWxsRGlyZWN0aXZlIGV4dGVuZHMgQ2RrSGVhZGVyQ2VsbCB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgICAgIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGBuYi1jb2x1bW4tJHtjb2x1bW5EZWYuY3NzQ2xhc3NGcmllbmRseU5hbWV9YCk7XG4gICAgfVxufTtcbk5iSGVhZGVyQ2VsbERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkMTIxKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWhlYWRlci1jZWxsLCB0aFtuYkhlYWRlckNlbGxdJyxcbiAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgJ2NsYXNzJzogJ25iLWhlYWRlci1jZWxsJyxcbiAgICAgICAgICAgICdyb2xlJzogJ2NvbHVtbmhlYWRlcicsXG4gICAgICAgIH0sXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQ3OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYkNvbHVtbkRlZkRpcmVjdGl2ZSxcbiAgICAgICAgRWxlbWVudFJlZl0pXG5dLCBOYkhlYWRlckNlbGxEaXJlY3RpdmUpO1xuLyoqIEZvb3RlciBjZWxsIHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGFkZHMgdGhlIHJpZ2h0IGNsYXNzZXMgYW5kIHJvbGUuICovXG5sZXQgTmJGb290ZXJDZWxsRGlyZWN0aXZlID0gY2xhc3MgTmJGb290ZXJDZWxsRGlyZWN0aXZlIGV4dGVuZHMgQ2RrRm9vdGVyQ2VsbCB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmKSB7XG4gICAgICAgIHN1cGVyKGNvbHVtbkRlZiwgZWxlbWVudFJlZik7XG4gICAgICAgIGVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGBuYi1jb2x1bW4tJHtjb2x1bW5EZWYuY3NzQ2xhc3NGcmllbmRseU5hbWV9YCk7XG4gICAgfVxufTtcbk5iRm9vdGVyQ2VsbERpcmVjdGl2ZSA9IF9fZGVjb3JhdGUkMTIxKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWZvb3Rlci1jZWxsLCB0ZFtuYkZvb3RlckNlbGxdJyxcbiAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgJ2NsYXNzJzogJ25iLWZvb3Rlci1jZWxsJyxcbiAgICAgICAgICAgICdyb2xlJzogJ2dyaWRjZWxsJyxcbiAgICAgICAgfSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDc5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iQ29sdW1uRGVmRGlyZWN0aXZlLFxuICAgICAgICBFbGVtZW50UmVmXSlcbl0sIE5iRm9vdGVyQ2VsbERpcmVjdGl2ZSk7XG4vKiogQ2VsbCB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBhZGRzIHRoZSByaWdodCBjbGFzc2VzIGFuZCByb2xlLiAqL1xubGV0IE5iQ2VsbERpcmVjdGl2ZSA9IGNsYXNzIE5iQ2VsbERpcmVjdGl2ZSBleHRlbmRzIENka0NlbGwge1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbkRlZiwgZWxlbWVudFJlZikge1xuICAgICAgICBzdXBlcihjb2x1bW5EZWYsIGVsZW1lbnRSZWYpO1xuICAgICAgICBlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChgbmItY29sdW1uLSR7Y29sdW1uRGVmLmNzc0NsYXNzRnJpZW5kbHlOYW1lfWApO1xuICAgIH1cbn07XG5OYkNlbGxEaXJlY3RpdmUgPSBfX2RlY29yYXRlJDEyMShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1jZWxsLCB0ZFtuYkNlbGxdJyxcbiAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgJ2NsYXNzJzogJ25iLWNlbGwnLFxuICAgICAgICAgICAgJ3JvbGUnOiAnZ3JpZGNlbGwnLFxuICAgICAgICB9LFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkNzkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJDb2x1bW5EZWZEaXJlY3RpdmUsXG4gICAgICAgIEVsZW1lbnRSZWZdKVxuXSwgTmJDZWxsRGlyZWN0aXZlKTtcblxuY2xhc3MgTmJEYXRhU291cmNlIGV4dGVuZHMgRGF0YVNvdXJjZSB7XG59XG5cbnZhciBfX2RlY29yYXRlJDEyMiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ4MCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE5iRGF0YVJvd091dGxldERpcmVjdGl2ZV8xO1xudmFyIE5iSGVhZGVyUm93T3V0bGV0RGlyZWN0aXZlXzE7XG52YXIgTmJGb290ZXJSb3dPdXRsZXREaXJlY3RpdmVfMTtcbnZhciBOYkNlbGxPdXRsZXREaXJlY3RpdmVfMTtcbnZhciBOYkhlYWRlclJvd0RlZkRpcmVjdGl2ZV8xO1xudmFyIE5iRm9vdGVyUm93RGVmRGlyZWN0aXZlXzE7XG52YXIgTmJSb3dEZWZEaXJlY3RpdmVfMTtcbnZhciBOYkhlYWRlclJvd0NvbXBvbmVudF8xO1xudmFyIE5iRm9vdGVyUm93Q29tcG9uZW50XzE7XG52YXIgTmJSb3dDb21wb25lbnRfMTtcbmxldCBOYkRhdGFSb3dPdXRsZXREaXJlY3RpdmUgPSBOYkRhdGFSb3dPdXRsZXREaXJlY3RpdmVfMSA9IGNsYXNzIE5iRGF0YVJvd091dGxldERpcmVjdGl2ZSBleHRlbmRzIERhdGFSb3dPdXRsZXQge1xufTtcbk5iRGF0YVJvd091dGxldERpcmVjdGl2ZSA9IE5iRGF0YVJvd091dGxldERpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZSQxMjIoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW25iUm93T3V0bGV0XScsXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogRGF0YVJvd091dGxldCwgdXNlRXhpc3Rpbmc6IE5iRGF0YVJvd091dGxldERpcmVjdGl2ZV8xIH1dLFxuICAgIH0pXG5dLCBOYkRhdGFSb3dPdXRsZXREaXJlY3RpdmUpO1xubGV0IE5iSGVhZGVyUm93T3V0bGV0RGlyZWN0aXZlID0gTmJIZWFkZXJSb3dPdXRsZXREaXJlY3RpdmVfMSA9IGNsYXNzIE5iSGVhZGVyUm93T3V0bGV0RGlyZWN0aXZlIGV4dGVuZHMgSGVhZGVyUm93T3V0bGV0IHtcbn07XG5OYkhlYWRlclJvd091dGxldERpcmVjdGl2ZSA9IE5iSGVhZGVyUm93T3V0bGV0RGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlJDEyMihbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdbbmJIZWFkZXJSb3dPdXRsZXRdJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBIZWFkZXJSb3dPdXRsZXQsIHVzZUV4aXN0aW5nOiBOYkhlYWRlclJvd091dGxldERpcmVjdGl2ZV8xIH1dLFxuICAgIH0pXG5dLCBOYkhlYWRlclJvd091dGxldERpcmVjdGl2ZSk7XG5sZXQgTmJGb290ZXJSb3dPdXRsZXREaXJlY3RpdmUgPSBOYkZvb3RlclJvd091dGxldERpcmVjdGl2ZV8xID0gY2xhc3MgTmJGb290ZXJSb3dPdXRsZXREaXJlY3RpdmUgZXh0ZW5kcyBGb290ZXJSb3dPdXRsZXQge1xufTtcbk5iRm9vdGVyUm93T3V0bGV0RGlyZWN0aXZlID0gTmJGb290ZXJSb3dPdXRsZXREaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUkMTIyKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1tuYkZvb3RlclJvd091dGxldF0nLFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IEZvb3RlclJvd091dGxldCwgdXNlRXhpc3Rpbmc6IE5iRm9vdGVyUm93T3V0bGV0RGlyZWN0aXZlXzEgfV0sXG4gICAgfSlcbl0sIE5iRm9vdGVyUm93T3V0bGV0RGlyZWN0aXZlKTtcbmxldCBOYkNlbGxPdXRsZXREaXJlY3RpdmUgPSBOYkNlbGxPdXRsZXREaXJlY3RpdmVfMSA9IGNsYXNzIE5iQ2VsbE91dGxldERpcmVjdGl2ZSBleHRlbmRzIENka0NlbGxPdXRsZXQge1xufTtcbk5iQ2VsbE91dGxldERpcmVjdGl2ZSA9IE5iQ2VsbE91dGxldERpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZSQxMjIoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW25iQ2VsbE91dGxldF0nLFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka0NlbGxPdXRsZXQsIHVzZUV4aXN0aW5nOiBOYkNlbGxPdXRsZXREaXJlY3RpdmVfMSB9XSxcbiAgICB9KVxuXSwgTmJDZWxsT3V0bGV0RGlyZWN0aXZlKTtcbi8qKlxuICogSGVhZGVyIHJvdyBkZWZpbml0aW9uIGZvciB0aGUgbmItdGFibGUuXG4gKiBDYXB0dXJlcyB0aGUgaGVhZGVyIHJvdydzIHRlbXBsYXRlIGFuZCBvdGhlciBoZWFkZXIgcHJvcGVydGllcyBzdWNoIGFzIHRoZSBjb2x1bW5zIHRvIGRpc3BsYXkuXG4gKi9cbmxldCBOYkhlYWRlclJvd0RlZkRpcmVjdGl2ZSA9IE5iSGVhZGVyUm93RGVmRGlyZWN0aXZlXzEgPSBjbGFzcyBOYkhlYWRlclJvd0RlZkRpcmVjdGl2ZSBleHRlbmRzIENka0hlYWRlclJvd0RlZiB7XG59O1xuX19kZWNvcmF0ZSQxMjIoW1xuICAgIElucHV0KCduYkhlYWRlclJvd0RlZicpLFxuICAgIF9fbWV0YWRhdGEkODAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkhlYWRlclJvd0RlZkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMjIoW1xuICAgIElucHV0KCduYkhlYWRlclJvd0RlZlN0aWNreScpLFxuICAgIF9fbWV0YWRhdGEkODAoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJIZWFkZXJSb3dEZWZEaXJlY3RpdmUucHJvdG90eXBlLCBcInN0aWNreVwiLCB2b2lkIDApO1xuTmJIZWFkZXJSb3dEZWZEaXJlY3RpdmUgPSBOYkhlYWRlclJvd0RlZkRpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZSQxMjIoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW25iSGVhZGVyUm93RGVmXScsXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrSGVhZGVyUm93RGVmLCB1c2VFeGlzdGluZzogTmJIZWFkZXJSb3dEZWZEaXJlY3RpdmVfMSB9XSxcbiAgICB9KVxuXSwgTmJIZWFkZXJSb3dEZWZEaXJlY3RpdmUpO1xuLyoqXG4gKiBGb290ZXIgcm93IGRlZmluaXRpb24gZm9yIHRoZSBuYi10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSBmb290ZXIgcm93J3MgdGVtcGxhdGUgYW5kIG90aGVyIGZvb3RlciBwcm9wZXJ0aWVzIHN1Y2ggYXMgdGhlIGNvbHVtbnMgdG8gZGlzcGxheS5cbiAqL1xubGV0IE5iRm9vdGVyUm93RGVmRGlyZWN0aXZlID0gTmJGb290ZXJSb3dEZWZEaXJlY3RpdmVfMSA9IGNsYXNzIE5iRm9vdGVyUm93RGVmRGlyZWN0aXZlIGV4dGVuZHMgQ2RrRm9vdGVyUm93RGVmIHtcbn07XG5fX2RlY29yYXRlJDEyMihbXG4gICAgSW5wdXQoJ25iRm9vdGVyUm93RGVmJyksXG4gICAgX19tZXRhZGF0YSQ4MChcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iRm9vdGVyUm93RGVmRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb2x1bW5zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEyMihbXG4gICAgSW5wdXQoJ25iRm9vdGVyUm93RGVmU3RpY2t5JyksXG4gICAgX19tZXRhZGF0YSQ4MChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYkZvb3RlclJvd0RlZkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3RpY2t5XCIsIHZvaWQgMCk7XG5OYkZvb3RlclJvd0RlZkRpcmVjdGl2ZSA9IE5iRm9vdGVyUm93RGVmRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlJDEyMihbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdbbmJGb290ZXJSb3dEZWZdJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBDZGtGb290ZXJSb3dEZWYsIHVzZUV4aXN0aW5nOiBOYkZvb3RlclJvd0RlZkRpcmVjdGl2ZV8xIH1dLFxuICAgIH0pXG5dLCBOYkZvb3RlclJvd0RlZkRpcmVjdGl2ZSk7XG4vKipcbiAqIERhdGEgcm93IGRlZmluaXRpb24gZm9yIHRoZSBuYi10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSBkYXRhIHJvdydzIHRlbXBsYXRlIGFuZCBvdGhlciBwcm9wZXJ0aWVzIHN1Y2ggYXMgdGhlIGNvbHVtbnMgdG8gZGlzcGxheSBhbmRcbiAqIGEgd2hlbiBwcmVkaWNhdGUgdGhhdCBkZXNjcmliZXMgd2hlbiB0aGlzIHJvdyBzaG91bGQgYmUgdXNlZC5cbiAqL1xubGV0IE5iUm93RGVmRGlyZWN0aXZlID0gTmJSb3dEZWZEaXJlY3RpdmVfMSA9IGNsYXNzIE5iUm93RGVmRGlyZWN0aXZlIGV4dGVuZHMgQ2RrUm93RGVmIHtcbn07XG5fX2RlY29yYXRlJDEyMihbXG4gICAgSW5wdXQoJ25iUm93RGVmQ29sdW1ucycpLFxuICAgIF9fbWV0YWRhdGEkODAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYlJvd0RlZkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMjIoW1xuICAgIElucHV0KCduYlJvd0RlZldoZW4nKSxcbiAgICBfX21ldGFkYXRhJDgwKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBOYlJvd0RlZkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwid2hlblwiLCB2b2lkIDApO1xuTmJSb3dEZWZEaXJlY3RpdmUgPSBOYlJvd0RlZkRpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZSQxMjIoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW25iUm93RGVmXScsXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrUm93RGVmLCB1c2VFeGlzdGluZzogTmJSb3dEZWZEaXJlY3RpdmVfMSB9XSxcbiAgICB9KVxuXSwgTmJSb3dEZWZEaXJlY3RpdmUpO1xuLyoqIEZvb3RlciB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGUgY2VsbCBvdXRsZXQuIEFkZHMgdGhlIHJpZ2h0IGNsYXNzIGFuZCByb2xlLiAqL1xubGV0IE5iSGVhZGVyUm93Q29tcG9uZW50ID0gTmJIZWFkZXJSb3dDb21wb25lbnRfMSA9IGNsYXNzIE5iSGVhZGVyUm93Q29tcG9uZW50IGV4dGVuZHMgQ2RrSGVhZGVyUm93IHtcbn07XG5OYkhlYWRlclJvd0NvbXBvbmVudCA9IE5iSGVhZGVyUm93Q29tcG9uZW50XzEgPSBfX2RlY29yYXRlJDEyMihbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1oZWFkZXItcm93LCB0cltuYkhlYWRlclJvd10nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250YWluZXIgbmJDZWxsT3V0bGV0PjwvbmctY29udGFpbmVyPmAsXG4gICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICdjbGFzcyc6ICduYi1oZWFkZXItcm93JyxcbiAgICAgICAgICAgICdyb2xlJzogJ3JvdycsXG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka0hlYWRlclJvdywgdXNlRXhpc3Rpbmc6IE5iSGVhZGVyUm93Q29tcG9uZW50XzEgfV1cbiAgICB9KVxuXSwgTmJIZWFkZXJSb3dDb21wb25lbnQpO1xuLyoqIEZvb3RlciB0ZW1wbGF0ZSBjb250YWluZXIgdGhhdCBjb250YWlucyB0aGUgY2VsbCBvdXRsZXQuIEFkZHMgdGhlIHJpZ2h0IGNsYXNzIGFuZCByb2xlLiAqL1xubGV0IE5iRm9vdGVyUm93Q29tcG9uZW50ID0gTmJGb290ZXJSb3dDb21wb25lbnRfMSA9IGNsYXNzIE5iRm9vdGVyUm93Q29tcG9uZW50IGV4dGVuZHMgQ2RrRm9vdGVyUm93IHtcbn07XG5OYkZvb3RlclJvd0NvbXBvbmVudCA9IE5iRm9vdGVyUm93Q29tcG9uZW50XzEgPSBfX2RlY29yYXRlJDEyMihbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1mb290ZXItcm93LCB0cltuYkZvb3RlclJvd10nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250YWluZXIgbmJDZWxsT3V0bGV0PjwvbmctY29udGFpbmVyPmAsXG4gICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICdjbGFzcyc6ICduYi1mb290ZXItcm93JyxcbiAgICAgICAgICAgICdyb2xlJzogJ3JvdycsXG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka0Zvb3RlclJvdywgdXNlRXhpc3Rpbmc6IE5iRm9vdGVyUm93Q29tcG9uZW50XzEgfV1cbiAgICB9KVxuXSwgTmJGb290ZXJSb3dDb21wb25lbnQpO1xuLyoqIERhdGEgcm93IHRlbXBsYXRlIGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoZSBjZWxsIG91dGxldC4gQWRkcyB0aGUgcmlnaHQgY2xhc3MgYW5kIHJvbGUuICovXG5sZXQgTmJSb3dDb21wb25lbnQgPSBOYlJvd0NvbXBvbmVudF8xID0gY2xhc3MgTmJSb3dDb21wb25lbnQgZXh0ZW5kcyBDZGtSb3cge1xufTtcbk5iUm93Q29tcG9uZW50ID0gTmJSb3dDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUkMTIyKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLXJvdywgdHJbbmJSb3ddJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGFpbmVyIG5iQ2VsbE91dGxldD48L25nLWNvbnRhaW5lcj5gLFxuICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAnY2xhc3MnOiAnbmItcm93JyxcbiAgICAgICAgICAgICdyb2xlJzogJ3JvdycsXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogQ2RrUm93LCB1c2VFeGlzdGluZzogTmJSb3dDb21wb25lbnRfMSB9XSxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICB9KVxuXSwgTmJSb3dDb21wb25lbnQpO1xuXG52YXIgX19kZWNvcmF0ZSQxMjMgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkODEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDE2ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuY29uc3QgTkJfVEFCTEVfVEVNUExBVEUgPSBgXG4gIDxuZy1jb250YWluZXIgbmJIZWFkZXJSb3dPdXRsZXQ+PC9uZy1jb250YWluZXI+XG4gIDxuZy1jb250YWluZXIgbmJSb3dPdXRsZXQ+PC9uZy1jb250YWluZXI+XG4gIDxuZy1jb250YWluZXIgbmJGb290ZXJSb3dPdXRsZXQ+PC9uZy1jb250YWluZXI+YDtcbmxldCBOYlRhYmxlID0gY2xhc3MgTmJUYWJsZSBleHRlbmRzIENka1RhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihkaWZmZXJzLCBjaGFuZ2VEZXRlY3RvclJlZiwgZWxlbWVudFJlZiwgcm9sZSwgZGlyLCBkb2N1bWVudCwgcGxhdGZvcm0pIHtcbiAgICAgICAgc3VwZXIoZGlmZmVycywgY2hhbmdlRGV0ZWN0b3JSZWYsIGVsZW1lbnRSZWYsIHJvbGUsIGRpciwgZG9jdW1lbnQsIHBsYXRmb3JtKTtcbiAgICB9XG59O1xuTmJUYWJsZSA9IF9fZGVjb3JhdGUkMTIzKFtcbiAgICBfX3BhcmFtJDE2KDMsIEF0dHJpYnV0ZSgncm9sZScpKSxcbiAgICBfX3BhcmFtJDE2KDUsIEluamVjdChOQl9ET0NVTUVOVCkpLFxuICAgIF9fbWV0YWRhdGEkODEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSXRlcmFibGVEaWZmZXJzLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgRWxlbWVudFJlZiwgU3RyaW5nLCBOYkRpcmVjdGlvbmFsaXR5LCBPYmplY3QsIE5iUGxhdGZvcm0kMV0pXG5dLCBOYlRhYmxlKTtcbmNvbnN0IENPTVBPTkVOVFMkMSA9IFtcbiAgICBOYlRhYmxlLFxuICAgIC8vIFRlbXBsYXRlIGRlZnNcbiAgICBOYkhlYWRlckNlbGxEZWZEaXJlY3RpdmUsXG4gICAgTmJIZWFkZXJSb3dEZWZEaXJlY3RpdmUsXG4gICAgTmJDb2x1bW5EZWZEaXJlY3RpdmUsXG4gICAgTmJDZWxsRGVmRGlyZWN0aXZlLFxuICAgIE5iUm93RGVmRGlyZWN0aXZlLFxuICAgIE5iRm9vdGVyQ2VsbERlZkRpcmVjdGl2ZSxcbiAgICBOYkZvb3RlclJvd0RlZkRpcmVjdGl2ZSxcbiAgICAvLyBPdXRsZXRzXG4gICAgTmJEYXRhUm93T3V0bGV0RGlyZWN0aXZlLFxuICAgIE5iSGVhZGVyUm93T3V0bGV0RGlyZWN0aXZlLFxuICAgIE5iRm9vdGVyUm93T3V0bGV0RGlyZWN0aXZlLFxuICAgIE5iQ2VsbE91dGxldERpcmVjdGl2ZSxcbiAgICAvLyBDZWxsIGRpcmVjdGl2ZXNcbiAgICBOYkhlYWRlckNlbGxEaXJlY3RpdmUsXG4gICAgTmJDZWxsRGlyZWN0aXZlLFxuICAgIE5iRm9vdGVyQ2VsbERpcmVjdGl2ZSxcbiAgICAvLyBSb3cgZGlyZWN0aXZlc1xuICAgIE5iSGVhZGVyUm93Q29tcG9uZW50LFxuICAgIE5iUm93Q29tcG9uZW50LFxuICAgIE5iRm9vdGVyUm93Q29tcG9uZW50LFxuXTtcbmxldCBOYlRhYmxlTW9kdWxlID0gY2xhc3MgTmJUYWJsZU1vZHVsZSBleHRlbmRzIENka1RhYmxlTW9kdWxlIHtcbn07XG5OYlRhYmxlTW9kdWxlID0gX19kZWNvcmF0ZSQxMjMoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW05iQmlkaU1vZHVsZSwgTmJQbGF0Zm9ybU1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogWy4uLkNPTVBPTkVOVFMkMV0sXG4gICAgICAgIGV4cG9ydHM6IFsuLi5DT01QT05FTlRTJDFdLFxuICAgIH0pXG5dLCBOYlRhYmxlTW9kdWxlKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgTkJfRElBTE9HX0NPTkZJRyA9IG5ldyBJbmplY3Rpb25Ub2tlbignRGVmYXVsdCBkaWFsb2cgb3B0aW9ucycpO1xuLyoqXG4gKiBEZXNjcmliZXMgYWxsIGF2YWlsYWJsZSBvcHRpb25zIHRoYXQgbWF5IGJlIHBhc3NlZCB0byB0aGUgTmJEaWFsb2dTZXJ2aWNlLlxuICogKi9cbmNsYXNzIE5iRGlhbG9nQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUgdGhhbiBvdmVybGF5IHdpbGwgcmVuZGVyIGJhY2tkcm9wIHVuZGVyIGEgZGlhbG9nLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmhhc0JhY2tkcm9wID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsYXNzIHRoYXQnbGwgYmUgYXNzaWduZWQgdG8gdGhlIGJhY2tkcm9wIGVsZW1lbnQuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuYmFja2Ryb3BDbGFzcyA9ICdvdmVybGF5LWJhY2tkcm9wJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsYXNzIHRoYXQnbGwgYmUgYXNzaWduZWQgdG8gdGhlIGRpYWxvZyBvdmVybGF5LlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmRpYWxvZ0NsYXNzID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlIHRoZW4gbW91c2UgY2xpY2tzIGJ5IGJhY2tkcm9wIHdpbGwgY2xvc2UgYSBkaWFsb2cuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuY2xvc2VPbkJhY2tkcm9wQ2xpY2sgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdHJ1ZSB0aGVuIGVzY2FwZSBwcmVzcyB3aWxsIGNsb3NlIGEgZGlhbG9nLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmNsb3NlT25Fc2MgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlzYWJsZXMgc2Nyb2xsIG9uIGNvbnRlbnQgdW5kZXIgZGlhbG9nIGlmIHRydWUgYW5kIGRvZXMgbm90aGluZyBvdGhlcndpc2UuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuaGFzU2Nyb2xsID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb2N1c2VzIGRpYWxvZyBhdXRvbWF0aWNhbGx5IGFmdGVyIG9wZW4gaWYgdHJ1ZS5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5hdXRvRm9jdXMgPSB0cnVlO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNvbmZpZyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG4vKipcbiAqIFRoZSBgTmJEaWFsb2dSZWZgIGhlbHBzIHRvIG1hbmlwdWxhdGUgZGlhbG9nIGFmdGVyIGl0IHdhcyBjcmVhdGVkLlxuICogVGhlIGRpYWxvZyBjYW4gYmUgZGlzbWlzc2VkIGJ5IHVzaW5nIGBjbG9zZWAgbWV0aG9kIG9mIHRoZSBkaWFsb2dSZWYuXG4gKiBZb3UgY2FuIGFjY2VzcyByZW5kZXJlZCBjb21wb25lbnQgYXMgYGNvbnRlbnRgIHByb3BlcnR5IG9mIHRoZSBkaWFsb2dSZWYuXG4gKiBgb25CYWNrZHJvcENsaWNrYCBzdHJlYW1zIGNsaWNrIGV2ZW50cyBvbiB0aGUgYmFja2Ryb3Agb2YgdGhlIGRpYWxvZy5cbiAqICovXG5jbGFzcyBOYkRpYWxvZ1JlZiB7XG4gICAgY29uc3RydWN0b3Iob3ZlcmxheVJlZikge1xuICAgICAgICB0aGlzLm92ZXJsYXlSZWYgPSBvdmVybGF5UmVmO1xuICAgICAgICB0aGlzLm9uQ2xvc2UkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlID0gdGhpcy5vbkNsb3NlJC5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5vbkJhY2tkcm9wQ2xpY2sgPSB0aGlzLm92ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyBkaWFsb2cuXG4gICAgICogKi9cbiAgICBjbG9zZShyZXMpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICB0aGlzLm92ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLm9uQ2xvc2UkLm5leHQocmVzKTtcbiAgICAgICAgdGhpcy5vbkNsb3NlJC5jb21wbGV0ZSgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTI1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDgzID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIENvbnRhaW5lciBjb21wb25lbnQgZm9yIGVhY2ggZGlhbG9nLlxuICogQWxsIHRoZSBkaWFsb2dzIHdpbGwgYmUgYXR0YWNoZWQgdG8gaXQuXG4gKiAvLyBUT0RPIGFkZCBhbmltYXRpb25zXG4gKiAqL1xubGV0IE5iRGlhbG9nQ29udGFpbmVyQ29tcG9uZW50ID0gY2xhc3MgTmJEaWFsb2dDb250YWluZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgZWxlbWVudFJlZiwgZm9jdXNUcmFwRmFjdG9yeSkge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXBGYWN0b3J5ID0gZm9jdXNUcmFwRmFjdG9yeTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRvRm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwID0gdGhpcy5mb2N1c1RyYXBGYWN0b3J5LmNyZWF0ZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5ibHVyUHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCk7XG4gICAgICAgICAgICB0aGlzLmZvY3VzVHJhcC5mb2N1c0luaXRpYWxFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hdXRvRm9jdXMgJiYgdGhpcy5mb2N1c1RyYXApIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLnJlc3RvcmVGb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9ydGFsT3V0bGV0LmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpO1xuICAgIH1cbiAgICBhdHRhY2hUZW1wbGF0ZVBvcnRhbChwb3J0YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9ydGFsT3V0bGV0LmF0dGFjaFRlbXBsYXRlUG9ydGFsKHBvcnRhbCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTI1KFtcbiAgICBWaWV3Q2hpbGQoTmJQb3J0YWxPdXRsZXREaXJlY3RpdmUsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEkODMoXCJkZXNpZ246dHlwZVwiLCBOYlBvcnRhbE91dGxldERpcmVjdGl2ZSlcbl0sIE5iRGlhbG9nQ29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3J0YWxPdXRsZXRcIiwgdm9pZCAwKTtcbk5iRGlhbG9nQ29udGFpbmVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxMjUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItZGlhbG9nLWNvbnRhaW5lcicsXG4gICAgICAgIHRlbXBsYXRlOiAnPG5nLXRlbXBsYXRlIG5iUG9ydGFsT3V0bGV0PjwvbmctdGVtcGxhdGU+J1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkODMoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJEaWFsb2dDb25maWcsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIE5iRm9jdXNUcmFwRmFjdG9yeVNlcnZpY2VdKVxuXSwgTmJEaWFsb2dDb250YWluZXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMjQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkODIgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDE3ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBUaGUgYE5iRGlhbG9nU2VydmljZWAgaGVscHMgdG8gb3BlbiBkaWFsb2dzLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIGRpYWxvZy9kaWFsb2ctc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqIEEgbmV3IGRpYWxvZyBpcyBvcGVuZWQgYnkgY2FsbGluZyB0aGUgYG9wZW5gIG1ldGhvZCB3aXRoIGEgY29tcG9uZW50IHRvIGJlIGxvYWRlZCBhbmQgYW4gb3B0aW9uYWwgY29uZmlndXJhdGlvbi5cbiAqIGBvcGVuYCBtZXRob2Qgd2lsbCByZXR1cm4gYE5iRGlhbG9nUmVmYCB0aGF0IGNhbiBiZSB1c2VkIGZvciB0aGUgZnVydGhlciBtYW5pcHVsYXRpb25zLlxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iRGlhbG9nTW9kdWxlLmZvclJvb3QoKWAgdG8geW91ciBhcHAgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkRpYWxvZ01vZHVsZS5mb3JSb290KGNvbmZpZyksXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcE1vZHVsZSB7IH1cbiAqIGBgYFxuICpcbiAqIElmIHlvdSBhcmUgdXNpbmcgaXQgaW4gYSBsYXp5IGxvYWRlZCBtb2R1bGUgdGhhbiB5b3UgaGF2ZSB0byBpbnN0YWxsIGl0IHdpdGggYE5iRGlhbG9nTW9kdWxlLmZvckNoaWxkKClgOlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkRpYWxvZ01vZHVsZS5mb3JDaGlsZChjb25maWcpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBMYXp5TG9hZGVkTW9kdWxlIHsgfVxuICogYGBgXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGRpYWxvZ1JlZiA9IHRoaXMuZGlhbG9nU2VydmljZS5vcGVuKE15RGlhbG9nQ29tcG9uZW50LCB7IC4uLiB9KTtcbiAqIGBgYFxuICpcbiAqIGBOYkRpYWxvZ1JlZmAgZ2l2ZXMgY2FwYWJpbGl0eSBhY2Nlc3MgcmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlZCBkaWFsb2cgY29tcG9uZW50LFxuICogZGVzdHJveSBkaWFsb2cgYW5kIHNvbWUgb3RoZXIgb3B0aW9ucyBkZXNjcmliZWQgYmVsb3cuXG4gKlxuICogQWxzbywgeW91IGNhbiBpbmplY3QgYE5iRGlhbG9nUmVmYCBpbiBkaWFsb2cgY29tcG9uZW50LlxuICpcbiAqIGBgYHRzXG4gKiB0aGlzLmRpYWxvZ1NlcnZpY2Uub3BlbihNeURpYWxvZ0NvbXBvbmVudCwgeyAuLi4gfSk7XG4gKlxuICogLy8gbXktZGlhbG9nLmNvbXBvbmVudC50c1xuICogY29uc3RydWN0b3IocHJvdGVjdGVkIGRpYWxvZ1JlZjogTmJEaWFsb2dSZWYpIHtcbiAqIH1cbiAqXG4gKiBjbG9zZSgpIHtcbiAqICAgdGhpcy5kaWFsb2dSZWYuY2xvc2UoKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEluc3RlYWQgb2YgY29tcG9uZW50IHlvdSBjYW4gY3JlYXRlIGRpYWxvZyBmcm9tIFRlbXBsYXRlUmVmOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoVGVtcGxhdGUgcmVmLCBkaWFsb2cvZGlhbG9nLXRlbXBsYXRlLmNvbXBvbmVudClcbiAqXG4gKiBUaGUgZGlhbG9nIG1heSByZXR1cm4gcmVzdWx0IHRocm91Z2ggYE5iRGlhbG9nUmVmYC4gQ2FsbGluZyBjb21wb25lbnQgY2FuIHJlY2VpdmUgdGhpcyByZXN1bHQgd2l0aCBgb25DbG9zZWBcbiAqIHN0cmVhbSBvZiBgTmJEaWFsb2dSZWZgLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoUmVzdWx0LCBkaWFsb2cvZGlhbG9nLXJlc3VsdC5jb21wb25lbnQpXG4gKlxuICogIyMjIENvbmZpZ3VyYXRpb25cbiAqXG4gKiBBcyB3ZSBtZW50aW9uZWQgYWJvdmUsIGBvcGVuYCBtZXRob2Qgb2YgdGhlIGBOYkRpYWxvZ1NlcnZpY2VgIG1heSByZWNlaXZlIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEFsc28sIHlvdSBjYW4gcHJvdmlkZSBnbG9iYWwgZGlhbG9ncyBjb25maWd1cmF0aW9uIHRocm91Z2ggYE5iRGlhbG9nTW9kdWxlLmZvclJvb3QoeyAuLi4gfSlgLlxuICpcbiAqIFRoaXMgY29uZmlnIG1heSBjb250YWluIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogYGNvbnRleHRgIC0gYm90aCwgdGVtcGxhdGUgYW5kIGNvbXBvbmVudCBtYXkgcmVjZWl2ZSBkYXRhIHRocm91Z2ggYGNvbmZpZy5jb250ZXh0YCBwcm9wZXJ0eS5cbiAqIEZvciBjb21wb25lbnRzLCB0aGlzIGRhdGEgd2lsbCBiZSBhc3NpZ25lZCB0aHJvdWdoIGlucHV0cy5cbiAqIEZvciB0ZW1wbGF0ZXMsIHlvdSBjYW4gYWNjZXNzIGl0IGluc2lkZSB0ZW1wbGF0ZSBhcyAkaW1wbGljaXQuXG4gKlxuICogYGBgdHNcbiAqIHRoaXMuZGlhbG9nU2VydmljZS5vcGVuKHRlbXBsYXRlLCB7IGNvbnRleHQ6ICdwYXNzIGRhdGEgaW4gdGVtcGxhdGUnIH0pO1xuICogYGBgXG4gKlxuICogYGBgaHRtbFxuICogPG5nLXRlbXBsYXRlIGxldC1zb21lLWFkZGl0aW9uYWwtZGF0YT5cbiAqICAge3sgc29tZS1hZGRpdGlvbmFsLWRhdGEgfX1cbiAqIDxuZy10ZW1wbGF0ZS8+XG4gKiBgYGBcbiAqXG4gKiBgaGFzQmFja2Ryb3BgIC0gZGV0ZXJtaW5lcyBpcyBzZXJ2aWNlIGhhdmUgdG8gcmVuZGVyIGJhY2tkcm9wIHVuZGVyIHRoZSBkaWFsb2cuXG4gKiBEZWZhdWx0IGlzIHRydWUuXG4gKiBAc3RhY2tlZC1leGFtcGxlKEJhY2tkcm9wLCBkaWFsb2cvZGlhbG9nLWhhcy1iYWNrZHJvcC5jb21wb25lbnQpXG4gKlxuICogYGNsb3NlT25CYWNrZHJvcENsaWNrYCAtIGNsb3NlIGRpYWxvZyBvbiBiYWNrZHJvcCBjbGljayBpZiB0cnVlLlxuICogRGVmYXVsdCBpcyB0cnVlLlxuICogQHN0YWNrZWQtZXhhbXBsZShCYWNrZHJvcCBjbGljaywgZGlhbG9nL2RpYWxvZy1iYWNrZHJvcC1jbGljay5jb21wb25lbnQpXG4gKlxuICogYGNsb3NlT25Fc2NgIC0gY2xvc2UgZGlhbG9nIG9uIGVzY2FwZSBidXR0b24gb24gdGhlIGtleWJvYXJkLlxuICogRGVmYXVsdCBpcyB0cnVlLlxuICogQHN0YWNrZWQtZXhhbXBsZShFc2NhcGUgaGl0LCBkaWFsb2cvZGlhbG9nLWVzYy5jb21wb25lbnQpXG4gKlxuICogYGhhc1Njcm9sbGAgLSBEaXNhYmxlcyBzY3JvbGwgb24gY29udGVudCB1bmRlciBkaWFsb2cgaWYgdHJ1ZSBhbmQgZG9lcyBub3RoaW5nIG90aGVyd2lzZS5cbiAqIERlZmF1bHQgaXMgZmFsc2UuXG4gKiBQbGVhc2UsIG9wZW4gZGlhbG9ncyBpbiB0aGUgc2VwYXJhdGUgd2luZG93IGFuZCB0cnkgdG8gc2Nyb2xsLlxuICogQHN0YWNrZWQtZXhhbXBsZShTY3JvbGwsIGRpYWxvZy9kaWFsb2ctc2Nyb2xsLmNvbXBvbmVudClcbiAqXG4gKiBgYXV0b0ZvY3VzYCAtIEZvY3VzZXMgZGlhbG9nIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgb3BlbiBpZiB0cnVlLiBJdCdzIHVzZWZ1bCB0byBwcmV2ZW50IG1pc2NsaWNrcyBvblxuICogdHJpZ2dlciBlbGVtZW50cyBhbmQgb3BlbmluZyBtdWx0aXBsZSBkaWFsb2dzLlxuICogRGVmYXVsdCBpcyB0cnVlLlxuICpcbiAqIEFzIHlvdSBjYW4gc2VlLCBpZiB5b3Ugb3BlbiBkaWFsb2cgd2l0aCBhdXRvIGZvY3VzIGRpYWxvZyB3aWxsIGZvY3VzIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50XG4gKiBvciBqdXN0IGJsdXIgcHJldmlvdXNseSBmb2N1c2VkIGF1dG9tYXRpY2FsbHkuXG4gKiBPdGhlcndpc2UsIHdpdGhvdXQgYXV0byBmb2N1cywgdGhlIGZvY3VzIHdpbGwgc3RheSBvbiB0aGUgcHJldmlvdXNseSBmb2N1c2VkIGVsZW1lbnQuXG4gKiBQbGVhc2UsIG9wZW4gZGlhbG9ncyBpbiB0aGUgc2VwYXJhdGUgd2luZG93IGFuZCB0cnkgdG8gY2xpY2sgb24gdGhlIGJ1dHRvbiB3aXRob3V0IGZvY3VzXG4gKiBhbmQgdGhlbiBoaXQgc3BhY2UgYW55IHRpbWVzLiBNdWx0aXBsZSBzYW1lIGRpYWxvZ3Mgd2lsbCBiZSBvcGVuZWQuXG4gKiBAc3RhY2tlZC1leGFtcGxlKEF1dG8gZm9jdXMsIGRpYWxvZy9kaWFsb2ctYXV0by1mb2N1cy5jb21wb25lbnQpXG4gKiAqL1xubGV0IE5iRGlhbG9nU2VydmljZSA9IGNsYXNzIE5iRGlhbG9nU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIGdsb2JhbENvbmZpZywgcG9zaXRpb25CdWlsZGVyLCBvdmVybGF5LCBpbmplY3RvciwgY2ZyKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5nbG9iYWxDb25maWcgPSBnbG9iYWxDb25maWc7XG4gICAgICAgIHRoaXMucG9zaXRpb25CdWlsZGVyID0gcG9zaXRpb25CdWlsZGVyO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLmluamVjdG9yID0gaW5qZWN0b3I7XG4gICAgICAgIHRoaXMuY2ZyID0gY2ZyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyBuZXcgaW5zdGFuY2Ugb2YgdGhlIGRpYWxvZywgbWF5IHJlY2VpdmUgb3B0aW9uYWwgY29uZmlnLlxuICAgICAqICovXG4gICAgb3Blbihjb250ZW50LCB1c2VyQ29uZmlnID0ge30pIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gbmV3IE5iRGlhbG9nQ29uZmlnKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2xvYmFsQ29uZmlnLCB1c2VyQ29uZmlnKSk7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB0aGlzLmNyZWF0ZU92ZXJsYXkoY29uZmlnKTtcbiAgICAgICAgY29uc3QgZGlhbG9nUmVmID0gbmV3IE5iRGlhbG9nUmVmKG92ZXJsYXlSZWYpO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNyZWF0ZUNvbnRhaW5lcihjb25maWcsIG92ZXJsYXlSZWYpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbnRlbnQoY29uZmlnLCBjb250ZW50LCBjb250YWluZXIsIGRpYWxvZ1JlZik7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJDbG9zZUxpc3RlbmVycyhjb25maWcsIG92ZXJsYXlSZWYsIGRpYWxvZ1JlZik7XG4gICAgICAgIHJldHVybiBkaWFsb2dSZWY7XG4gICAgfVxuICAgIGNyZWF0ZU92ZXJsYXkoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLmNyZWF0ZVBvc2l0aW9uU3RyYXRlZ3koKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLmNyZWF0ZVNjcm9sbFN0cmF0ZWd5KGNvbmZpZy5oYXNTY3JvbGwpO1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5LmNyZWF0ZSh7XG4gICAgICAgICAgICBwb3NpdGlvblN0cmF0ZWd5LFxuICAgICAgICAgICAgc2Nyb2xsU3RyYXRlZ3ksXG4gICAgICAgICAgICBoYXNCYWNrZHJvcDogY29uZmlnLmhhc0JhY2tkcm9wLFxuICAgICAgICAgICAgYmFja2Ryb3BDbGFzczogY29uZmlnLmJhY2tkcm9wQ2xhc3MsXG4gICAgICAgICAgICBwYW5lbENsYXNzOiBjb25maWcuZGlhbG9nQ2xhc3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbkJ1aWxkZXJcbiAgICAgICAgICAgIC5nbG9iYWwoKVxuICAgICAgICAgICAgLmNlbnRlclZlcnRpY2FsbHkoKVxuICAgICAgICAgICAgLmNlbnRlckhvcml6b250YWxseSgpO1xuICAgIH1cbiAgICBjcmVhdGVTY3JvbGxTdHJhdGVneShoYXNTY3JvbGwpIHtcbiAgICAgICAgaWYgKGhhc1Njcm9sbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLm5vb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5ibG9jaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZUNvbnRhaW5lcihjb25maWcsIG92ZXJsYXlSZWYpIHtcbiAgICAgICAgY29uc3QgaW5qZWN0b3IgPSBuZXcgTmJQb3J0YWxJbmplY3Rvcih0aGlzLmNyZWF0ZUluamVjdG9yKGNvbmZpZyksIG5ldyBXZWFrTWFwKFtbTmJEaWFsb2dDb25maWcsIGNvbmZpZ11dKSk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclBvcnRhbCA9IG5ldyBOYkNvbXBvbmVudFBvcnRhbChOYkRpYWxvZ0NvbnRhaW5lckNvbXBvbmVudCwgbnVsbCwgaW5qZWN0b3IsIHRoaXMuY2ZyKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyUmVmID0gb3ZlcmxheVJlZi5hdHRhY2goY29udGFpbmVyUG9ydGFsKTtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lclJlZi5pbnN0YW5jZTtcbiAgICB9XG4gICAgY3JlYXRlQ29udGVudChjb25maWcsIGNvbnRlbnQsIGNvbnRhaW5lciwgZGlhbG9nUmVmKSB7XG4gICAgICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgVGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcnRhbCA9IHRoaXMuY3JlYXRlVGVtcGxhdGVQb3J0YWwoY29uZmlnLCBjb250ZW50LCBkaWFsb2dSZWYpO1xuICAgICAgICAgICAgY29udGFpbmVyLmF0dGFjaFRlbXBsYXRlUG9ydGFsKHBvcnRhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwb3J0YWwgPSB0aGlzLmNyZWF0ZUNvbXBvbmVudFBvcnRhbChjb25maWcsIGNvbnRlbnQsIGRpYWxvZ1JlZik7XG4gICAgICAgICAgICBkaWFsb2dSZWYuY29tcG9uZW50UmVmID0gY29udGFpbmVyLmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkaWFsb2dSZWYuY29tcG9uZW50UmVmLmluc3RhbmNlLCBPYmplY3QuYXNzaWduKHt9LCBjb25maWcuY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVRlbXBsYXRlUG9ydGFsKGNvbmZpZywgY29udGVudCwgZGlhbG9nUmVmKSB7XG4gICAgICAgIHJldHVybiBuZXcgTmJUZW1wbGF0ZVBvcnRhbChjb250ZW50LCBudWxsLCB7ICRpbXBsaWNpdDogY29uZmlnLmNvbnRleHQsIGRpYWxvZ1JlZiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2UncmUgY3JlYXRpbmcgcG9ydGFsIHdpdGggY3VzdG9tIGluamVjdG9yIHByb3ZpZGVkIHRocm91Z2ggY29uZmlnIG9yIHVzaW5nIGdsb2JhbCBpbmplY3Rvci5cbiAgICAgKiBUaGlzIGFwcHJvYWNoIHByb3ZpZGVzIHVzIGNhcGFiaWxpdHkgaW5qZWN0IGBOYkRpYWxvZ1JlZmAgaW4gZGlhbG9nIGNvbXBvbmVudC5cbiAgICAgKiAqL1xuICAgIGNyZWF0ZUNvbXBvbmVudFBvcnRhbChjb25maWcsIGNvbnRlbnQsIGRpYWxvZ1JlZikge1xuICAgICAgICBjb25zdCBpbmplY3RvciA9IHRoaXMuY3JlYXRlSW5qZWN0b3IoY29uZmlnKTtcbiAgICAgICAgY29uc3QgcG9ydGFsSW5qZWN0b3IgPSBuZXcgTmJQb3J0YWxJbmplY3RvcihpbmplY3RvciwgbmV3IFdlYWtNYXAoW1tOYkRpYWxvZ1JlZiwgZGlhbG9nUmVmXV0pKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOYkNvbXBvbmVudFBvcnRhbChjb250ZW50LCBjb25maWcudmlld0NvbnRhaW5lclJlZiwgcG9ydGFsSW5qZWN0b3IpO1xuICAgIH1cbiAgICBjcmVhdGVJbmplY3Rvcihjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy52aWV3Q29udGFpbmVyUmVmICYmIGNvbmZpZy52aWV3Q29udGFpbmVyUmVmLmluamVjdG9yIHx8IHRoaXMuaW5qZWN0b3I7XG4gICAgfVxuICAgIHJlZ2lzdGVyQ2xvc2VMaXN0ZW5lcnMoY29uZmlnLCBvdmVybGF5UmVmLCBkaWFsb2dSZWYpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5jbG9zZU9uQmFja2Ryb3BDbGljaykge1xuICAgICAgICAgICAgb3ZlcmxheVJlZi5iYWNrZHJvcENsaWNrKCkuc3Vic2NyaWJlKCgpID0+IGRpYWxvZ1JlZi5jbG9zZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmNsb3NlT25Fc2MpIHtcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAna2V5dXAnKVxuICAgICAgICAgICAgICAgIC5waXBlKGZpbHRlcigoZXZlbnQpID0+IGV2ZW50LmtleUNvZGUgPT09IDI3KSwgdGFrZVVudGlsKGRpYWxvZ1JlZi5vbkNsb3NlKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IGRpYWxvZ1JlZi5jbG9zZSgpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5OYkRpYWxvZ1NlcnZpY2UgPSBfX2RlY29yYXRlJDEyNChbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fcGFyYW0kMTcoMCwgSW5qZWN0KE5CX0RPQ1VNRU5UKSksXG4gICAgX19wYXJhbSQxNygxLCBJbmplY3QoTkJfRElBTE9HX0NPTkZJRykpLFxuICAgIF9fbWV0YWRhdGEkODIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBPYmplY3QsIE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSxcbiAgICAgICAgTmJPdmVybGF5U2VydmljZSxcbiAgICAgICAgSW5qZWN0b3IsXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcl0pXG5dLCBOYkRpYWxvZ1NlcnZpY2UpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMjYgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIE5iRGlhbG9nTW9kdWxlXzE7XG5sZXQgTmJEaWFsb2dNb2R1bGUgPSBOYkRpYWxvZ01vZHVsZV8xID0gY2xhc3MgTmJEaWFsb2dNb2R1bGUge1xuICAgIHN0YXRpYyBmb3JSb290KGRpYWxvZ0NvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogTmJEaWFsb2dNb2R1bGVfMSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIE5iRGlhbG9nU2VydmljZSxcbiAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IE5CX0RJQUxPR19DT05GSUcsIHVzZVZhbHVlOiBkaWFsb2dDb25maWcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmb3JDaGlsZChkaWFsb2dDb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iRGlhbG9nTW9kdWxlXzEsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBOYkRpYWxvZ1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9ESUFMT0dfQ09ORklHLCB1c2VWYWx1ZTogZGlhbG9nQ29uZmlnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5OYkRpYWxvZ01vZHVsZSA9IE5iRGlhbG9nTW9kdWxlXzEgPSBfX2RlY29yYXRlJDEyNihbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbTmJTaGFyZWRNb2R1bGUsIE5iT3ZlcmxheU1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW05iRGlhbG9nQ29udGFpbmVyQ29tcG9uZW50XSxcbiAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTmJEaWFsb2dDb250YWluZXJDb21wb25lbnRdLFxuICAgIH0pXG5dLCBOYkRpYWxvZ01vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNsYXNzIE5iVG9hc3Qge1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMzAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkODYgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogVGhlIGBOYlRvYXN0Q29tcG9uZW50YCBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIGVhY2ggdG9hc3Qgd2l0aCBhcHByb3ByaWF0ZSBzdHlsZXMuXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHRvYXN0ci1ib3JkZXItc3R5bGU6XG4gKiB0b2FzdHItYm9yZGVyLXdpZHRoOlxuICogdG9hc3RyLWJvcmRlci1yYWRpdXM6XG4gKiB0b2FzdHItcGFkZGluZzpcbiAqIHRvYXN0ci1zaGFkb3c6XG4gKiB0b2FzdHItdGV4dC1mb250LWZhbWlseTpcbiAqIHRvYXN0ci10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRvYXN0ci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdG9hc3RyLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0b2FzdHItdGl0bGUtdGV4dC1mb250LWZhbWlseTpcbiAqIHRvYXN0ci10aXRsZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRvYXN0ci10aXRsZS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdG9hc3RyLXRpdGxlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0b2FzdHItYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvYXN0ci1iYXNpYy1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItYmFzaWMtdGV4dC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItaWNvbi1iYXNpYy1jb2xvcjpcbiAqIHRvYXN0ci1kZXN0cm95YWJsZS1ob3Zlci1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLWhvdmVyLWJhc2ljLWJvcmRlci1jb2xvcjpcbiAqIHRvYXN0ci1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItcHJpbWFyeS1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogdG9hc3RyLWljb24tcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWljb24tcHJpbWFyeS1jb2xvcjpcbiAqIHRvYXN0ci1kZXN0cm95YWJsZS1ob3Zlci1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItZGVzdHJveWFibGUtaG92ZXItcHJpbWFyeS1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICogdG9hc3RyLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLXN1Y2Nlc3MtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLXN1Y2Nlc3MtY29sb3I6XG4gKiB0b2FzdHItZGVzdHJveWFibGUtaG92ZXItc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLWhvdmVyLXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICogdG9hc3RyLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvYXN0ci1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIHRvYXN0ci1pbmZvLXRleHQtY29sb3I6XG4gKiB0b2FzdHItaWNvbi1pbmZvLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItaWNvbi1pbmZvLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLWhvdmVyLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvYXN0ci1kZXN0cm95YWJsZS1ob3Zlci1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIHRvYXN0ci13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItd2FybmluZy1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItd2FybmluZy10ZXh0LWNvbG9yOlxuICogdG9hc3RyLWljb24td2FybmluZy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWljb24td2FybmluZy1jb2xvcjpcbiAqIHRvYXN0ci1kZXN0cm95YWJsZS1ob3Zlci13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItZGVzdHJveWFibGUtaG92ZXItd2FybmluZy1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2FzdHItZGFuZ2VyLWJvcmRlci1jb2xvcjpcbiAqIHRvYXN0ci1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWljb24tZGFuZ2VyLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLWhvdmVyLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLWhvdmVyLWRhbmdlci1ib3JkZXItY29sb3I6XG4gKiB0b2FzdHItY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogdG9hc3RyLWNvbnRyb2wtdGV4dC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLWNvbnRyb2wtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvYXN0ci1pY29uLWNvbnRyb2wtY29sb3I6XG4gKiB0b2FzdHItZGVzdHJveWFibGUtaG92ZXItY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9hc3RyLWRlc3Ryb3lhYmxlLWhvdmVyLWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogKi9cbmxldCBOYlRvYXN0Q29tcG9uZW50ID0gY2xhc3MgTmJUb2FzdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIsIGVsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLmRlc3Ryb3kgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdC5jb25maWcuc3RhdHVzID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdC5jb25maWcuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdC5jb25maWcuc3RhdHVzID09PSAnd2FybmluZyc7XG4gICAgfVxuICAgIGdldCBwcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdC5jb25maWcuc3RhdHVzID09PSAncHJpbWFyeSc7XG4gICAgfVxuICAgIGdldCBkYW5nZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYXN0LmNvbmZpZy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgYmFzaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYXN0LmNvbmZpZy5zdGF0dXMgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2FzdC5jb25maWcuc3RhdHVzID09PSAnY29udHJvbCc7XG4gICAgfVxuICAgIGdldCBkZXN0cm95QnlDbGljaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9hc3QuY29uZmlnLmRlc3Ryb3lCeUNsaWNrO1xuICAgIH1cbiAgICBnZXQgaGFzSWNvbigpIHtcbiAgICAgICAgY29uc3QgeyBpY29uIH0gPSB0aGlzLnRvYXN0LmNvbmZpZztcbiAgICAgICAgaWYgKHR5cGVvZiBpY29uID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhKGljb24gJiYgaWNvbi5pY29uKTtcbiAgICB9XG4gICAgZ2V0IGN1c3RvbUljb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuaWNvbjtcbiAgICB9XG4gICAgZ2V0IGljb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYXN0LmNvbmZpZy5pY29uO1xuICAgIH1cbiAgICAvKiBAZGVwcmVjYXRlZCBVc2UgcGFjayBwcm9wZXJ0eSBvZiBpY29uIGNvbmZpZyAqL1xuICAgIGdldCBpY29uUGFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9hc3QuY29uZmlnLmljb25QYWNrO1xuICAgIH1cbiAgICAvKlxuICAgICAgQGJyZWFraW5nLWNoYW5nZSA1IHJlbW92ZVxuICAgICAgQGRlcHJlY2F0ZWRcbiAgICAqL1xuICAgIGdldCBpY29uQ29uZmlnKCkge1xuICAgICAgICBjb25zdCB0b2FzdENvbmZpZyA9IHRoaXMudG9hc3QuY29uZmlnO1xuICAgICAgICBjb25zdCBpc0ljb25OYW1lID0gdHlwZW9mIHRoaXMuaWNvbiA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGlmICghaXNJY29uTmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvYXN0Q29uZmlnLmljb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaWNvbkNvbmZpZyA9IHsgaWNvbjogdG9hc3RDb25maWcuaWNvbiB9O1xuICAgICAgICBpZiAodG9hc3RDb25maWcuaWNvblBhY2spIHtcbiAgICAgICAgICAgIGljb25Db25maWcucGFjayA9IHRvYXN0Q29uZmlnLmljb25QYWNrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpY29uQ29uZmlnO1xuICAgIH1cbiAgICBvbkNsaWNrKCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kuZW1pdCgpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMudG9hc3QuY29uZmlnLnRvYXN0Q2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMudG9hc3QuY29uZmlnLnRvYXN0Q2xhc3MpO1xuICAgICAgICB9XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTMwKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246dHlwZVwiLCBOYlRvYXN0KVxuXSwgTmJUb2FzdENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9hc3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTMwKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDg2KFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgTmJUb2FzdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVzdHJveVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtc3VjY2VzcycpLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvYXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdWNjZXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtaW5mbycpLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvYXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJpbmZvXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtd2FybmluZycpLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvYXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ3YXJuaW5nXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtcHJpbWFyeScpLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvYXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwcmltYXJ5XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtZGFuZ2VyJyksXG4gICAgX19tZXRhZGF0YSQ4NihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVG9hc3RDb21wb25lbnQucHJvdG90eXBlLCBcImRhbmdlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTMwKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWJhc2ljJyksXG4gICAgX19tZXRhZGF0YSQ4NihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVG9hc3RDb21wb25lbnQucHJvdG90eXBlLCBcImJhc2ljXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtY29udHJvbCcpLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvYXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250cm9sXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5kZXN0cm95LWJ5LWNsaWNrJyksXG4gICAgX19tZXRhZGF0YSQ4NihcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVG9hc3RDb21wb25lbnQucHJvdG90eXBlLCBcImRlc3Ryb3lCeUNsaWNrXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5oYXMtaWNvbicpLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvYXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJoYXNJY29uXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzAoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5jdXN0b20taWNvbicpLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvYXN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjdXN0b21JY29uXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzAoW1xuICAgIEhvc3RMaXN0ZW5lcignY2xpY2snKSxcbiAgICBfX21ldGFkYXRhJDg2KFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEkODYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YSQ4NihcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE5iVG9hc3RDb21wb25lbnQucHJvdG90eXBlLCBcIm9uQ2xpY2tcIiwgbnVsbCk7XG5OYlRvYXN0Q29tcG9uZW50ID0gX19kZWNvcmF0ZSQxMzAoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItdG9hc3QnLFxuICAgICAgICB0ZW1wbGF0ZTogXCI8ZGl2IGNsYXNzPVxcXCJpY29uLWNvbnRhaW5lclxcXCIgKm5nSWY9XFxcImhhc0ljb24gJiYgaWNvblxcXCI+XFxuICA8bmItaWNvbiBbY29uZmlnXT1cXFwiaWNvbkNvbmZpZ1xcXCI+PC9uYi1pY29uPlxcbjwvZGl2PlxcbjxkaXYgY2xhc3M9XFxcImNvbnRlbnQtY29udGFpbmVyXFxcIj5cXG4gIDxzcGFuIGNsYXNzPVxcXCJ0aXRsZSBzdWJ0aXRsZVxcXCI+e3sgdG9hc3QudGl0bGUgfX08L3NwYW4+XFxuICA8ZGl2IGNsYXNzPVxcXCJtZXNzYWdlXFxcIj57eyB0b2FzdC5tZXNzYWdlIH19PC9kaXY+XFxuPC9kaXY+XFxuXCIsXG4gICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjt3aWR0aDoyNXJlbTttYXJnaW46MC41cmVtfTpob3N0IC50aXRsZXttYXJnaW4tcmlnaHQ6MC4yNXJlbX06aG9zdC5kZWZhdWx0IC5jb250ZW50LWNvbnRhaW5lciw6aG9zdDpub3QoLmhhcy1pY29uKSAuY29udGVudC1jb250YWluZXJ7ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOnJvd306aG9zdC5kZXN0cm95LWJ5LWNsaWNre2N1cnNvcjpwb2ludGVyfTpob3N0IG5iLWljb257Zm9udC1zaXplOjIuNXJlbX06aG9zdCBzdmd7d2lkdGg6Mi41cmVtO2hlaWdodDoyLjVyZW19XFxuXCJdXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQ4NihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtSZW5kZXJlcjIsIEVsZW1lbnRSZWZdKVxuXSwgTmJUb2FzdENvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDEyOSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ4NSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuY29uc3Qgdm9pZFN0YXRlID0gc3R5bGUoe1xuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoe3sgZGlyZWN0aW9uIH19MTEwJSknLFxuICAgIGhlaWdodDogMCxcbiAgICBtYXJnaW5MZWZ0OiAnMCcsXG4gICAgbWFyZ2luUmlnaHQ6ICcwJyxcbiAgICBtYXJnaW5Ub3A6ICcwJyxcbiAgICBtYXJnaW5Cb3R0b206ICcwJyxcbn0pO1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7IHBhcmFtczogeyBkaXJlY3Rpb246ICcnIH0gfTtcbmxldCBOYlRvYXN0ckNvbnRhaW5lckNvbXBvbmVudCA9IGNsYXNzIE5iVG9hc3RyQ29udGFpbmVyQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXREaXJlY3Rpb24sIHBvc2l0aW9uSGVscGVyKSB7XG4gICAgICAgIHRoaXMubGF5b3V0RGlyZWN0aW9uID0gbGF5b3V0RGlyZWN0aW9uO1xuICAgICAgICB0aGlzLnBvc2l0aW9uSGVscGVyID0gcG9zaXRpb25IZWxwZXI7XG4gICAgICAgIHRoaXMuZGVzdHJveSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMubGF5b3V0RGlyZWN0aW9uLm9uRGlyZWN0aW9uQ2hhbmdlKClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5vbkRpcmVjdGlvbkNoYW5nZSgpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIG9uRGlyZWN0aW9uQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLnBvc2l0aW9uSGVscGVyLmlzUmlnaHRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKSA/ICcnIDogJy0nO1xuICAgICAgICB0aGlzLmZhZGVJbiA9IHsgdmFsdWU6ICcnLCBwYXJhbXM6IHsgZGlyZWN0aW9uIH0gfTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxMjkoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ4NShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgTmJUb2FzdHJDb250YWluZXJDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTI5KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkODUoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYlRvYXN0ckNvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMjkoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ4NShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVG9hc3RyQ29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMjkoW1xuICAgIFZpZXdDaGlsZHJlbihOYlRvYXN0Q29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhJDg1KFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgTmJUb2FzdHJDb250YWluZXJDb21wb25lbnQucHJvdG90eXBlLCBcInRvYXN0c1wiLCB2b2lkIDApO1xuTmJUb2FzdHJDb250YWluZXJDb21wb25lbnQgPSBfX2RlY29yYXRlJDEyOShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi10b2FzdHItY29udGFpbmVyJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmItdG9hc3QgW0BmYWRlSW5dPVwiZmFkZUluXCIgKm5nRm9yPVwibGV0IHRvYXN0IG9mIGNvbnRlbnRcIiBbdG9hc3RdPVwidG9hc3RcIj48L25iLXRvYXN0PmAsXG4gICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgIHRyaWdnZXIoJ2ZhZGVJbicsIFtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbdm9pZFN0YXRlLCBhbmltYXRlKDEwMCldLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW2FuaW1hdGUoMTAwLCB2b2lkU3RhdGUpXSwgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIF1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDg1KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iTGF5b3V0RGlyZWN0aW9uU2VydmljZSxcbiAgICAgICAgTmJQb3NpdGlvbkhlbHBlcl0pXG5dLCBOYlRvYXN0ckNvbnRhaW5lckNvbXBvbmVudCk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IE5CX1RPQVNUUl9DT05GSUcgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0RlZmF1bHQgdG9hc3RyIG9wdGlvbnMnKTtcbi8qKlxuICogVGhlIGBOYlRvYXN0ckNvbmZpZ2AgY2xhc3MgZGVzY3JpYmVzIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGBOYlRvYXN0clNlcnZpY2Uuc2hvd2AgYW5kIGdsb2JhbCB0b2FzdHIgY29uZmlndXJhdGlvbi5cbiAqICovXG5jbGFzcyBOYlRvYXN0ckNvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHdoZXJlIG9uIHRoZSBzY3JlZW4gdG9hc3QgaGF2ZSB0byBiZSByZW5kZXJlZC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IE5iR2xvYmFsTG9naWNhbFBvc2l0aW9uLlRPUF9FTkQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGF0dXMgY2hvb3NlcyBjb2xvciBzY2hlbWUgZm9yIHRoZSB0b2FzdC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5zdGF0dXMgPSAncHJpbWFyeSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEdXJhdGlvbiBpcyB0aW1lb3V0IGJldHdlZW4gdG9hc3QgYXBwZWFycyBhbmQgZGlzYXBwZWFycy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDMwMDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95IGJ5IGNsaWNrIG1lYW5zIHlvdSBjYW4gaGlkZSB0aGUgdG9hc3QgYnkgY2xpY2tpbmcgaXQuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuZGVzdHJveUJ5Q2xpY2sgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcHJldmVudER1cGxpY2F0ZXMgaXMgdHJ1ZSB0aGVuIHRoZSB0b2FzdCB3aXRoIHRoZSBzYW1lIHRpdGxlLCBtZXNzYWdlIGFuZCBzdGF0dXMgd2lsbCBub3QgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqIEZpbmQgZHVwbGljYXRlcyBiZWhhdmlvdXIgZGV0ZXJtaW5lZCBieSBgcHJldmVudER1cGxpY2F0ZXNgLlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBgcHJldmlvdXNgIGR1cGxpY2F0ZSBiZWhhdmlvdXIgaXMgdXNlZC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5wcmV2ZW50RHVwbGljYXRlcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyB0aGUgaG93IHRvIHRocmVhdCBkdXBsaWNhdGVzLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmR1cGxpY2F0ZXNCZWhhdmlvdXIgPSAncHJldmlvdXMnO1xuICAgICAgICAvKlxuICAgICAgICAqIFRoZSBudW1iZXIgb2YgdmlzaWJsZSB0b2FzdHMuIElmIHRoZSBsaW1pdCBleGNlZWRlZCB0aGUgb2xkZXN0IHRvYXN0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmxpbWl0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHRvYXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2FzdENsYXNzID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIHJlbmRlciBpY29uIG9yIG5vdC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5oYXNJY29uID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEljb24gbmFtZSBvciBpY29uIGNvbmZpZyBvYmplY3QgdGhhdCBjYW4gYmUgcHJvdmlkZWQgdG8gcmVuZGVyIGN1c3RvbSBpY29uLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLmljb24gPSAnZW1haWwnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVG9hc3Qgc3RhdHVzIGljb24tY2xhc3MgbWFwcGluZy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5pY29ucyA9IHtcbiAgICAgICAgICAgIGRhbmdlcjogJ2ZsYXNoLW91dGxpbmUnLFxuICAgICAgICAgICAgc3VjY2VzczogJ2NoZWNrbWFyay1vdXRsaW5lJyxcbiAgICAgICAgICAgIGluZm86ICdxdWVzdGlvbi1tYXJrLW91dGxpbmUnLFxuICAgICAgICAgICAgd2FybmluZzogJ2FsZXJ0LXRyaWFuZ2xlLW91dGxpbmUnLFxuICAgICAgICAgICAgcHJpbWFyeTogJ2VtYWlsLW91dGxpbmUnLFxuICAgICAgICAgICAgY29udHJvbDogJ2VtYWlsLW91dGxpbmUnLFxuICAgICAgICAgICAgYmFzaWM6ICdlbWFpbC1vdXRsaW5lJyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNvbmZpZy5zdGF0dXMgPT09ICcnKSB7XG4gICAgICAgICAgICBlbXB0eVN0YXR1c1dhcm5pbmcoJ05iVG9hc3RyJyk7XG4gICAgICAgICAgICBjb25maWcuc3RhdHVzID0gJ3ByaW1hcnknO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0Y2hJY29uKGNvbmZpZyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29uZmlnKTtcbiAgICB9XG4gICAgcGF0Y2hJY29uKGNvbmZpZykge1xuICAgICAgICBpZiAoISgnaWNvbicgaW4gY29uZmlnKSkge1xuICAgICAgICAgICAgY29uZmlnLmljb24gPSB7XG4gICAgICAgICAgICAgICAgaWNvbjogdGhpcy5pY29uc1tjb25maWcuc3RhdHVzIHx8ICdwcmltYXJ5J10sXG4gICAgICAgICAgICAgICAgcGFjazogJ25lYnVsYXItZXNzZW50aWFscycsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMjggPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkODQgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDE4ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuY2xhc3MgTmJUb2FzdFJlZiB7XG4gICAgY29uc3RydWN0b3IodG9hc3RDb250YWluZXIsIHRvYXN0KSB7XG4gICAgICAgIHRoaXMudG9hc3RDb250YWluZXIgPSB0b2FzdENvbnRhaW5lcjtcbiAgICAgICAgdGhpcy50b2FzdCA9IHRvYXN0O1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy50b2FzdENvbnRhaW5lci5kZXN0cm95KHRoaXMudG9hc3QpO1xuICAgIH1cbn1cbmNsYXNzIE5iVG9hc3RDb250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKHBvc2l0aW9uLCBjb250YWluZXJSZWYsIHBvc2l0aW9uSGVscGVyKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgdGhpcy5jb250YWluZXJSZWYgPSBjb250YWluZXJSZWY7XG4gICAgICAgIHRoaXMucG9zaXRpb25IZWxwZXIgPSBwb3NpdGlvbkhlbHBlcjtcbiAgICAgICAgdGhpcy50b2FzdHMgPSBbXTtcbiAgICAgICAgdGhpcy50b2FzdER1cGxpY2F0ZUNvbXBhcmVGdW5jID0gKHQxLCB0MikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHQxLm1lc3NhZ2UgPT09IHQyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAmJiB0MS50aXRsZSA9PT0gdDIudGl0bGVcbiAgICAgICAgICAgICAgICAmJiB0MS5jb25maWcuc3RhdHVzID09PSB0Mi5jb25maWcuc3RhdHVzO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgbmF0aXZlRWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyUmVmLmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIGF0dGFjaCh0b2FzdCkge1xuICAgICAgICBpZiAodG9hc3QuY29uZmlnLnByZXZlbnREdXBsaWNhdGVzICYmIHRoaXMuaXNEdXBsaWNhdGUodG9hc3QpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVUb2FzdElmTGltaXRSZWFjaGVkKHRvYXN0KTtcbiAgICAgICAgY29uc3QgdG9hc3RDb21wb25lbnQgPSB0aGlzLmF0dGFjaFRvYXN0KHRvYXN0KTtcbiAgICAgICAgaWYgKHRvYXN0LmNvbmZpZy5kZXN0cm95QnlDbGljaykge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVPbkNsaWNrKHRvYXN0Q29tcG9uZW50LCB0b2FzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvYXN0LmNvbmZpZy5kdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZXREZXN0cm95VGltZW91dCh0b2FzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2VG9hc3QgPSB0b2FzdDtcbiAgICAgICAgcmV0dXJuIG5ldyBOYlRvYXN0UmVmKHRoaXMsIHRvYXN0KTtcbiAgICB9XG4gICAgZGVzdHJveSh0b2FzdCkge1xuICAgICAgICBpZiAodGhpcy5wcmV2VG9hc3QgPT09IHRvYXN0KSB7XG4gICAgICAgICAgICB0aGlzLnByZXZUb2FzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b2FzdHMgPSB0aGlzLnRvYXN0cy5maWx0ZXIodCA9PiB0ICE9PSB0b2FzdCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udGFpbmVyKCk7XG4gICAgfVxuICAgIGlzRHVwbGljYXRlKHRvYXN0KSB7XG4gICAgICAgIHJldHVybiB0b2FzdC5jb25maWcuZHVwbGljYXRlc0JlaGF2aW91ciA9PT0gJ3ByZXZpb3VzJ1xuICAgICAgICAgICAgPyB0aGlzLmlzRHVwbGljYXRlUHJldmlvdXModG9hc3QpXG4gICAgICAgICAgICA6IHRoaXMuaXNEdXBsaWNhdGVBbW9uZ0FsbCh0b2FzdCk7XG4gICAgfVxuICAgIGlzRHVwbGljYXRlUHJldmlvdXModG9hc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldlRvYXN0ICYmIHRoaXMudG9hc3REdXBsaWNhdGVDb21wYXJlRnVuYyh0aGlzLnByZXZUb2FzdCwgdG9hc3QpO1xuICAgIH1cbiAgICBpc0R1cGxpY2F0ZUFtb25nQWxsKHRvYXN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvYXN0cy5zb21lKHQgPT4gdGhpcy50b2FzdER1cGxpY2F0ZUNvbXBhcmVGdW5jKHQsIHRvYXN0KSk7XG4gICAgfVxuICAgIHJlbW92ZVRvYXN0SWZMaW1pdFJlYWNoZWQodG9hc3QpIHtcbiAgICAgICAgaWYgKCF0b2FzdC5jb25maWcubGltaXQgfHwgdGhpcy50b2FzdHMubGVuZ3RoIDwgdG9hc3QuY29uZmlnLmxpbWl0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25IZWxwZXIuaXNUb3BQb3NpdGlvbih0b2FzdC5jb25maWcucG9zaXRpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnRvYXN0cy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9hc3RzLnNoaWZ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoVG9hc3QodG9hc3QpIHtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb25IZWxwZXIuaXNUb3BQb3NpdGlvbih0b2FzdC5jb25maWcucG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2hUb1RvcCh0b2FzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2hUb0JvdHRvbSh0b2FzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXR0YWNoVG9Ub3AodG9hc3QpIHtcbiAgICAgICAgdGhpcy50b2FzdHMudW5zaGlmdCh0b2FzdCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ29udGFpbmVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lclJlZi5pbnN0YW5jZS50b2FzdHMuZmlyc3Q7XG4gICAgfVxuICAgIGF0dGFjaFRvQm90dG9tKHRvYXN0KSB7XG4gICAgICAgIHRoaXMudG9hc3RzLnB1c2godG9hc3QpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lcigpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluZXJSZWYuaW5zdGFuY2UudG9hc3RzLmxhc3Q7XG4gICAgfVxuICAgIHNldERlc3Ryb3lUaW1lb3V0KHRvYXN0KSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kZXN0cm95KHRvYXN0KSwgdG9hc3QuY29uZmlnLmR1cmF0aW9uKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlT25DbGljayh0b2FzdENvbXBvbmVudCwgdG9hc3QpIHtcbiAgICAgICAgdG9hc3RDb21wb25lbnQuZGVzdHJveS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5kZXN0cm95KHRvYXN0KSk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbnRhaW5lcigpIHtcbiAgICAgICAgcGF0Y2godGhpcy5jb250YWluZXJSZWYsIHsgY29udGVudDogdGhpcy50b2FzdHMsIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uIH0pO1xuICAgIH1cbn1cbmxldCBOYlRvYXN0ckNvbnRhaW5lclJlZ2lzdHJ5ID0gY2xhc3MgTmJUb2FzdHJDb250YWluZXJSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3Iob3ZlcmxheSwgcG9zaXRpb25CdWlsZGVyLCBwb3NpdGlvbkhlbHBlciwgY2ZyLCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBvc2l0aW9uQnVpbGRlciA9IHBvc2l0aW9uQnVpbGRlcjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkhlbHBlciA9IHBvc2l0aW9uSGVscGVyO1xuICAgICAgICB0aGlzLmNmciA9IGNmcjtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLm92ZXJsYXlzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXQocG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgbG9naWNhbFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbkhlbHBlci50b0xvZ2ljYWxQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlXaXRoQ29udGFpbmVyID0gdGhpcy5vdmVybGF5cy5nZXQobG9naWNhbFBvc2l0aW9uKTtcbiAgICAgICAgaWYgKCFvdmVybGF5V2l0aENvbnRhaW5lciB8fCAhdGhpcy5leGlzdHNJbkRvbShvdmVybGF5V2l0aENvbnRhaW5lci50b2FzdHJDb250YWluZXIpKSB7XG4gICAgICAgICAgICBpZiAob3ZlcmxheVdpdGhDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5V2l0aENvbnRhaW5lci5vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5zdGFudGlhdGVDb250YWluZXIobG9naWNhbFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5cy5nZXQobG9naWNhbFBvc2l0aW9uKS50b2FzdHJDb250YWluZXI7XG4gICAgfVxuICAgIGluc3RhbnRpYXRlQ29udGFpbmVyKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRvYXN0ck92ZXJsYXlXaXRoQ29udGFpbmVyID0gdGhpcy5jcmVhdGVDb250YWluZXIocG9zaXRpb24pO1xuICAgICAgICB0aGlzLm92ZXJsYXlzLnNldChwb3NpdGlvbiwgdG9hc3RyT3ZlcmxheVdpdGhDb250YWluZXIpO1xuICAgIH1cbiAgICBjcmVhdGVDb250YWluZXIocG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25TdHJhdGVneSA9IHRoaXMucG9zaXRpb25CdWlsZGVyLmdsb2JhbCgpLnBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5vdmVybGF5LmNyZWF0ZSh7IHBvc2l0aW9uU3RyYXRlZ3kgfSk7XG4gICAgICAgIHRoaXMuYWRkQ2xhc3NUb092ZXJsYXlIb3N0KHJlZik7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IHJlZi5hdHRhY2gobmV3IE5iQ29tcG9uZW50UG9ydGFsKE5iVG9hc3RyQ29udGFpbmVyQ29tcG9uZW50LCBudWxsLCBudWxsLCB0aGlzLmNmcikpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3ZlcmxheVJlZjogcmVmLFxuICAgICAgICAgICAgdG9hc3RyQ29udGFpbmVyOiBuZXcgTmJUb2FzdENvbnRhaW5lcihwb3NpdGlvbiwgY29udGFpbmVyUmVmLCB0aGlzLnBvc2l0aW9uSGVscGVyKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkQ2xhc3NUb092ZXJsYXlIb3N0KG92ZXJsYXlSZWYpIHtcbiAgICAgICAgb3ZlcmxheVJlZi5ob3N0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCd0b2FzdHItb3ZlcmxheS1jb250YWluZXInKTtcbiAgICB9XG4gICAgZXhpc3RzSW5Eb20odG9hc3RDb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuYm9keS5jb250YWlucyh0b2FzdENvbnRhaW5lci5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG59O1xuTmJUb2FzdHJDb250YWluZXJSZWdpc3RyeSA9IF9fZGVjb3JhdGUkMTI4KFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSQxOCg0LCBJbmplY3QoTkJfRE9DVU1FTlQpKSxcbiAgICBfX21ldGFkYXRhJDg0KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iT3ZlcmxheVNlcnZpY2UsXG4gICAgICAgIE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSxcbiAgICAgICAgTmJQb3NpdGlvbkhlbHBlcixcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBPYmplY3RdKVxuXSwgTmJUb2FzdHJDb250YWluZXJSZWdpc3RyeSk7XG4vKipcbiAqIFRoZSBgTmJUb2FzdHJTZXJ2aWNlYCBwcm92aWRlcyBhIGNhcGFiaWxpdHkgdG8gYnVpbGQgdG9hc3Qgbm90aWZpY2F0aW9ucy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCB0b2FzdHIvdG9hc3RyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBgTmJUb2FzdHJTZXJ2aWNlLnNob3cobWVzc2FnZSwgdGl0bGUsIGNvbmZpZylgIGFjY2VwdHMgdGhyZWUgcGFyYW1zLCB0aXRsZSBhbmQgY29uZmlnIGFyZSBvcHRpb25hbC5cbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlRvYXN0ck1vZHVsZS5mb3JSb290KClgIHRvIHlvdXIgYXBwIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJUb2FzdHJNb2R1bGUuZm9yUm9vdChjb25maWcpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBDYWxsaW5nIGBOYlRvYXN0clNlcnZpY2Uuc2hvdyguLi4pYCB3aWxsIHJlbmRlciBuZXcgdG9hc3QgYW5kIHJldHVybiBgTmJUb2FzdHJSZWZgIHdpdGhcbiAqIGhlbHAgb2Ygd2hpY2ggeW91IG1heSBjbG9zZSBuZXdseSBjcmVhdGVkIHRvYXN0IGJ5IGNhbGxpbmcgYGNsb3NlYCBtZXRob2QuXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHRvYXN0UmVmOiBOYlRvYXN0UmVmID0gdGhpcy50b2FzdHJTZXJ2aWNlLnNob3coLi4uKTtcbiAqIHRvYXN0UmVmLmNsb3NlKCk7XG4gKiBgYGBcbiAqXG4gKiBDb25maWcgYWNjZXB0cyBmb2xsb3dpbmcgb3B0aW9uczpcbiAqXG4gKiBgcG9zaXRpb25gIC0gZGV0ZXJtaW5lcyB3aGVyZSBvbiB0aGUgc2NyZWVuIHRvYXN0IHdpbGwgYmUgcmVuZGVyZWQuXG4gKiBEZWZhdWx0IGlzIGB0b3AtZW5kYC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFBvc2l0aW9uLCB0b2FzdHIvdG9hc3RyLXBvc2l0aW9ucy5jb21wb25lbnQpXG4gKlxuICogYHN0YXR1c2AgLSBjb2xvcmluZyBhbmQgaWNvbiBvZiB0aGUgdG9hc3QuXG4gKiBEZWZhdWx0IGlzIGBwcmltYXJ5YC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFN0YXR1cywgdG9hc3RyL3RvYXN0ci1zdGF0dXNlcy5jb21wb25lbnQpXG4gKlxuICogYGR1cmF0aW9uYCAtIHRoZSB0aW1lIGFmdGVyIHdoaWNoIHRoZSB0b2FzdCB3aWxsIGJlIGRlc3Ryb3llZC5cbiAqIGAwYCBtZWFucyBlbmRsZXNzIHRvYXN0LCB0aGF0IG1heSBiZSBkZXN0cm95ZWQgYnkgY2xpY2sgb25seS5cbiAqIERlZmF1bHQgaXMgMzAwMCBtcy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKER1cmF0aW9uLCB0b2FzdHIvdG9hc3RyLWR1cmF0aW9uLmNvbXBvbmVudClcbiAqXG4gKiBgZGVzdHJveUJ5Q2xpY2tgIC0gcHJvdmlkZXMgYSBjYXBhYmlsaXR5IHRvIGRlc3Ryb3kgdG9hc3QgYnkgY2xpY2suXG4gKiBEZWZhdWx0IGlzIHRydWUuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShEZXN0cm95IGJ5IGNsaWNrLCB0b2FzdHIvdG9hc3RyLWRlc3Ryb3ktYnktY2xpY2suY29tcG9uZW50KVxuICpcbiAqIGBwcmV2ZW50RHVwbGljYXRlc2AgLSBkb24ndCBjcmVhdGUgbmV3IHRvYXN0IGlmIGl0IGhhcyB0aGUgc2FtZSB0aXRsZSwgbWVzc2FnZSBhbmQgc3RhdHVzLlxuICogRGVmYXVsdCBpcyBmYWxzZS5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFByZXZlbnQgZHVwbGljYXRlcywgdG9hc3RyL3RvYXN0ci1wcmV2ZW50LWR1cGxpY2F0ZXMuY29tcG9uZW50KVxuICpcbiAqIGBkdXBsaWNhdGVzQmVoYXZpb3VyYCAtIGRldGVybWluZXMgaG93IHRvIHRocmVhdCB0aGUgdG9hc3RzIGR1cGxpY2F0aW9uLlxuICogQ29tcGFyZSB3aXRoIHRoZSBwcmV2aW91cyBtZXNzYWdlIGBwcmV2aW91c2BcbiAqIG9yIHdpdGggYWxsIHZpc2libGUgbWVzc2FnZXMgYGFsbGAuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShQcmV2ZW50IGR1cGxpY2F0ZXMgYmVoYXZpb3VyICwgdG9hc3RyL3RvYXN0ci1wcmV2ZW50LWR1cGxpY2F0ZXMtYmVoYXZpb3VyLmNvbXBvbmVudClcbiAqXG4gKiBgbGltaXRgIC0gdGhlIG51bWJlciBvZiB2aXNpYmxlIHRvYXN0cyBpbiB0aGUgdG9hc3QgY29udGFpbmVyLiBUaGUgbnVtYmVyIG9mIHRvYXN0cyBpcyB1bmxpbWl0ZWQgYnkgZGVmYXVsdC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFByZXZlbnQgZHVwbGljYXRlcyBiZWhhdmlvdXIgLCB0b2FzdHIvdG9hc3RyLWxpbWl0LmNvbXBvbmVudClcbiAqXG4gKiBgaGFzSWNvbmAgLSBpZiB0cnVlIHRoZW4gcmVuZGVyIHRvYXN0IGljb24uXG4gKiBgaWNvbmAgLSB5b3UgY2FuIHBhc3MgaWNvbiBjbGFzcyB0aGF0IHdpbGwgYmUgYXBwbGllZCBpbnRvIHRoZSB0b2FzdC5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKEhhcyBpY29uLCB0b2FzdHIvdG9hc3RyLWljb24uY29tcG9uZW50KVxuICogKi9cbmxldCBOYlRvYXN0clNlcnZpY2UgPSBjbGFzcyBOYlRvYXN0clNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGdsb2JhbENvbmZpZywgY29udGFpbmVyUmVnaXN0cnkpIHtcbiAgICAgICAgdGhpcy5nbG9iYWxDb25maWcgPSBnbG9iYWxDb25maWc7XG4gICAgICAgIHRoaXMuY29udGFpbmVyUmVnaXN0cnkgPSBjb250YWluZXJSZWdpc3RyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdG9hc3Qgd2l0aCBtZXNzYWdlLCB0aXRsZSBhbmQgdXNlciBjb25maWcuXG4gICAgICogKi9cbiAgICBzaG93KG1lc3NhZ2UsIHRpdGxlLCB1c2VyQ29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBOYlRvYXN0ckNvbmZpZyhPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdsb2JhbENvbmZpZywgdXNlckNvbmZpZykpO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lclJlZ2lzdHJ5LmdldChjb25maWcucG9zaXRpb24pO1xuICAgICAgICBjb25zdCB0b2FzdCA9IHsgbWVzc2FnZSwgdGl0bGUsIGNvbmZpZyB9O1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmF0dGFjaCh0b2FzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHN1Y2Nlc3MgdG9hc3Qgd2l0aCBtZXNzYWdlLCB0aXRsZSBhbmQgdXNlciBjb25maWcuXG4gICAgICogKi9cbiAgICBzdWNjZXNzKG1lc3NhZ2UsIHRpdGxlLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhtZXNzYWdlLCB0aXRsZSwgT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7IHN0YXR1czogJ3N1Y2Nlc3MnIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgaW5mbyB0b2FzdCB3aXRoIG1lc3NhZ2UsIHRpdGxlIGFuZCB1c2VyIGNvbmZpZy5cbiAgICAgKiAqL1xuICAgIGluZm8obWVzc2FnZSwgdGl0bGUsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93KG1lc3NhZ2UsIHRpdGxlLCBPYmplY3QuYXNzaWduKHt9LCBjb25maWcsIHsgc3RhdHVzOiAnaW5mbycgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyB3YXJuaW5nIHRvYXN0IHdpdGggbWVzc2FnZSwgdGl0bGUgYW5kIHVzZXIgY29uZmlnLlxuICAgICAqICovXG4gICAgd2FybmluZyhtZXNzYWdlLCB0aXRsZSwgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3cobWVzc2FnZSwgdGl0bGUsIE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZywgeyBzdGF0dXM6ICd3YXJuaW5nJyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIHByaW1hcnkgdG9hc3Qgd2l0aCBtZXNzYWdlLCB0aXRsZSBhbmQgdXNlciBjb25maWcuXG4gICAgICogKi9cbiAgICBwcmltYXJ5KG1lc3NhZ2UsIHRpdGxlLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhtZXNzYWdlLCB0aXRsZSwgT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7IHN0YXR1czogJ3ByaW1hcnknIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgZGFuZ2VyIHRvYXN0IHdpdGggbWVzc2FnZSwgdGl0bGUgYW5kIHVzZXIgY29uZmlnLlxuICAgICAqICovXG4gICAgZGFuZ2VyKG1lc3NhZ2UsIHRpdGxlLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdyhtZXNzYWdlLCB0aXRsZSwgT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7IHN0YXR1czogJ2RhbmdlcicgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBiYXNpYyB0b2FzdCB3aXRoIG1lc3NhZ2UsIHRpdGxlIGFuZCB1c2VyIGNvbmZpZy5cbiAgICAgKiAqL1xuICAgIGRlZmF1bHQobWVzc2FnZSwgdGl0bGUsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG93KG1lc3NhZ2UsIHRpdGxlLCBPYmplY3QuYXNzaWduKHt9LCBjb25maWcsIHsgc3RhdHVzOiAnYmFzaWMnIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgY29udHJvbCB0b2FzdCB3aXRoIG1lc3NhZ2UsIHRpdGxlIGFuZCB1c2VyIGNvbmZpZy5cbiAgICAgKiAqL1xuICAgIGNvbnRyb2wobWVzc2FnZSwgdGl0bGUsIGNvbmZpZykge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0KG1lc3NhZ2UsIHRpdGxlLCBPYmplY3QuYXNzaWduKHt9LCBjb25maWcsIHsgc3RhdHVzOiAnY29udHJvbCcgfSkpO1xuICAgIH1cbn07XG5OYlRvYXN0clNlcnZpY2UgPSBfX2RlY29yYXRlJDEyOChbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fcGFyYW0kMTgoMCwgSW5qZWN0KE5CX1RPQVNUUl9DT05GSUcpKSxcbiAgICBfX21ldGFkYXRhJDg0KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iVG9hc3RyQ29uZmlnLFxuICAgICAgICBOYlRvYXN0ckNvbnRhaW5lclJlZ2lzdHJ5XSlcbl0sIE5iVG9hc3RyU2VydmljZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDEyNyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgTmJUb2FzdHJNb2R1bGVfMTtcbmxldCBOYlRvYXN0ck1vZHVsZSA9IE5iVG9hc3RyTW9kdWxlXzEgPSBjbGFzcyBOYlRvYXN0ck1vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QodG9hc3RyQ29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBOYlRvYXN0ck1vZHVsZV8xLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgTmJUb2FzdHJTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIE5iVG9hc3RyQ29udGFpbmVyUmVnaXN0cnksXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9UT0FTVFJfQ09ORklHLCB1c2VWYWx1ZTogdG9hc3RyQ29uZmlnIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbn07XG5OYlRvYXN0ck1vZHVsZSA9IE5iVG9hc3RyTW9kdWxlXzEgPSBfX2RlY29yYXRlJDEyNyhbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbTmJTaGFyZWRNb2R1bGUsIE5iT3ZlcmxheU1vZHVsZSwgTmJJY29uTW9kdWxlXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbTmJUb2FzdHJDb250YWluZXJDb21wb25lbnQsIE5iVG9hc3RDb21wb25lbnRdLFxuICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtOYlRvYXN0ckNvbnRhaW5lckNvbXBvbmVudCwgTmJUb2FzdENvbXBvbmVudF0sXG4gICAgfSlcbl0sIE5iVG9hc3RyTW9kdWxlKTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMzIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkODcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogVG9vbHRpcCBjb250YWluZXIuXG4gKiBSZW5kZXJzIHByb3ZpZGVkIHRvb2x0aXAgaW5zaWRlLlxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiB0b29sdGlwLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b29sdGlwLWJvcmRlci1jb2xvcjpcbiAqIHRvb2x0aXAtYm9yZGVyLXN0eWxlOlxuICogdG9vbHRpcC1ib3JkZXItd2lkdGg6XG4gKiB0b29sdGlwLWJvcmRlci1yYWRpdXM6XG4gKiB0b29sdGlwLXBhZGRpbmc6XG4gKiB0b29sdGlwLXRleHQtY29sb3I6XG4gKiB0b29sdGlwLXRleHQtZm9udC1mYW1pbHk6XG4gKiB0b29sdGlwLXRleHQtZm9udC1zaXplOlxuICogdG9vbHRpcC10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdG9vbHRpcC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdG9vbHRpcC1pY29uLWhlaWdodDpcbiAqIHRvb2x0aXAtaWNvbi13aWR0aDpcbiAqIHRvb2x0aXAtbWF4LXdpZHRoOlxuICogdG9vbHRpcC1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9vbHRpcC1iYXNpYy1ib3JkZXItY29sb3I6XG4gKiB0b29sdGlwLWJhc2ljLXRleHQtY29sb3I6XG4gKiB0b29sdGlwLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvb2x0aXAtcHJpbWFyeS1ib3JkZXItY29sb3I6XG4gKiB0b29sdGlwLXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIHRvb2x0aXAtaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9vbHRpcC1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIHRvb2x0aXAtaW5mby10ZXh0LWNvbG9yOlxuICogdG9vbHRpcC1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b29sdGlwLXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICogdG9vbHRpcC1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiB0b29sdGlwLXdhcm5pbmctYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvb2x0aXAtd2FybmluZy1ib3JkZXItY29sb3I6XG4gKiB0b29sdGlwLXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIHRvb2x0aXAtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b29sdGlwLWRhbmdlci1ib3JkZXItY29sb3I6XG4gKiB0b29sdGlwLWRhbmdlci10ZXh0LWNvbG9yOlxuICogdG9vbHRpcC1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b29sdGlwLWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogdG9vbHRpcC1jb250cm9sLXRleHQtY29sb3I6XG4gKiB0b29sdGlwLXNoYWRvdzpcbiAqL1xubGV0IE5iVG9vbHRpcENvbXBvbmVudCA9IGNsYXNzIE5iVG9vbHRpcENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogVG9vbHRpcCBjb250YWluZXIuXG4gICAgICogUmVuZGVycyBwcm92aWRlZCB0b29sdGlwIGluc2lkZS5cbiAgICAgKlxuICAgICAqIEBzdHlsZXNcbiAgICAgKlxuICAgICAqIHRvb2x0aXAtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiB0b29sdGlwLWJvcmRlci1jb2xvcjpcbiAgICAgKiB0b29sdGlwLWJvcmRlci1zdHlsZTpcbiAgICAgKiB0b29sdGlwLWJvcmRlci13aWR0aDpcbiAgICAgKiB0b29sdGlwLWJvcmRlci1yYWRpdXM6XG4gICAgICogdG9vbHRpcC1wYWRkaW5nOlxuICAgICAqIHRvb2x0aXAtdGV4dC1jb2xvcjpcbiAgICAgKiB0b29sdGlwLXRleHQtZm9udC1mYW1pbHk6XG4gICAgICogdG9vbHRpcC10ZXh0LWZvbnQtc2l6ZTpcbiAgICAgKiB0b29sdGlwLXRleHQtZm9udC13ZWlnaHQ6XG4gICAgICogdG9vbHRpcC10ZXh0LWxpbmUtaGVpZ2h0OlxuICAgICAqIHRvb2x0aXAtaWNvbi1oZWlnaHQ6XG4gICAgICogdG9vbHRpcC1pY29uLXdpZHRoOlxuICAgICAqIHRvb2x0aXAtbWF4LXdpZHRoOlxuICAgICAqIHRvb2x0aXAtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiB0b29sdGlwLWJhc2ljLWJvcmRlci1jb2xvcjpcbiAgICAgKiB0b29sdGlwLWJhc2ljLXRleHQtY29sb3I6XG4gICAgICogdG9vbHRpcC1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gICAgICogdG9vbHRpcC1wcmltYXJ5LWJvcmRlci1jb2xvcjpcbiAgICAgKiB0b29sdGlwLXByaW1hcnktdGV4dC1jb2xvcjpcbiAgICAgKiB0b29sdGlwLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAgICAgKiB0b29sdGlwLWluZm8tYm9yZGVyLWNvbG9yOlxuICAgICAqIHRvb2x0aXAtaW5mby10ZXh0LWNvbG9yOlxuICAgICAqIHRvb2x0aXAtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHRvb2x0aXAtc3VjY2Vzcy1ib3JkZXItY29sb3I6XG4gICAgICogdG9vbHRpcC1zdWNjZXNzLXRleHQtY29sb3I6XG4gICAgICogdG9vbHRpcC13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gICAgICogdG9vbHRpcC13YXJuaW5nLWJvcmRlci1jb2xvcjpcbiAgICAgKiB0b29sdGlwLXdhcm5pbmctdGV4dC1jb2xvcjpcbiAgICAgKiB0b29sdGlwLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHRvb2x0aXAtZGFuZ2VyLWJvcmRlci1jb2xvcjpcbiAgICAgKiB0b29sdGlwLWRhbmdlci10ZXh0LWNvbG9yOlxuICAgICAqIHRvb2x0aXAtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICAgICAqIHRvb2x0aXAtY29udHJvbC1ib3JkZXItY29sb3I6XG4gICAgICogdG9vbHRpcC1jb250cm9sLXRleHQtY29sb3I6XG4gICAgICogdG9vbHRpcC1zaGFkb3c6XG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb3BvdmVyIHBvc2l0aW9uIHJlbGF0aXZlbHkgaG9zdCBlbGVtZW50LlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gTmJQb3NpdGlvbi5UT1A7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHt9O1xuICAgIH1cbiAgICBnZXQgYmluZGluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucG9zaXRpb259ICR7dGhpcy5zdGF0dXNDbGFzc31gO1xuICAgIH1cbiAgICBnZXQgc2hvdygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldCBzdGF0dXNDbGFzcygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5zdGF0dXMpIHtcbiAgICAgICAgICAgIHJldHVybiBgc3RhdHVzLSR7dGhpcy5jb250ZXh0LnN0YXR1c31gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG1ldGhvZCBpcyBlbXB0eSBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nIGFkZGl0aW9uYWxseVxuICAgICAqIHJlbmRlciBpcyBoYW5kbGVkIGJ5IGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgKi9cbiAgICByZW5kZXJDb250ZW50KCkgeyB9XG59O1xuX19kZWNvcmF0ZSQxMzIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ4NyhcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMzIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ4NyhcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTMyKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MnKSxcbiAgICBfX21ldGFkYXRhJDg3KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDg3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLCBcImJpbmRpbmdcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEzMihbXG4gICAgSG9zdEJpbmRpbmcoJ0BzaG93VG9vbHRpcCcpLFxuICAgIF9fbWV0YWRhdGEkODcoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkODcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUsIFwic2hvd1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTMyKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkODcoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYlRvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRleHRcIiwgdm9pZCAwKTtcbk5iVG9vbHRpcENvbXBvbmVudCA9IF9fZGVjb3JhdGUkMTMyKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLXRvb2x0aXAnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxzcGFuIGNsYXNzPVwiYXJyb3dcIj48L3NwYW4+XG4gICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cbiAgICAgIDxuYi1pY29uICpuZ0lmPVwiY29udGV4dD8uaWNvblwiIFtjb25maWddPVwiY29udGV4dC5pY29uXCI+PC9uYi1pY29uPlxuICAgICAgPHNwYW4gKm5nSWY9XCJjb250ZW50XCI+e3sgY29udGVudCB9fTwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgYCxcbiAgICAgICAgYW5pbWF0aW9uczogW1xuICAgICAgICAgICAgdHJpZ2dlcignc2hvd1Rvb2x0aXAnLCBbXG4gICAgICAgICAgICAgICAgc3RhdGUoJ2luJywgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKSxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCBbXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlKHsgb3BhY2l0eTogMCB9KSxcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgxMDApLFxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJyogPT4gdm9pZCcsIFtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0ZSgxMDAsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSksXG4gICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgXSxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHt6LWluZGV4OjEwMDAwfTpob3N0IC5jb250ZW50e2Rpc3BsYXk6ZmxleDthbGlnbi1pdGVtczpjZW50ZXJ9Omhvc3QucmlnaHQgLmNvbnRlbnR7ZmxleC1kaXJlY3Rpb246cm93LXJldmVyc2V9Omhvc3QgLmFycm93e3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjA7aGVpZ2h0OjB9Omhvc3QgbmItaWNvbitzcGFue21hcmdpbi1sZWZ0OjAuNXJlbX06aG9zdC5yaWdodCBuYi1pY29uK3NwYW57bWFyZ2luLXJpZ2h0OjAuNXJlbX06aG9zdCAuYXJyb3d7Ym9yZGVyLWxlZnQ6NnB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yaWdodDo2cHggc29saWQgdHJhbnNwYXJlbnR9Omhvc3QoLmJvdHRvbSkgLmFycm93e3RvcDotNnB4O2xlZnQ6Y2FsYyg1MCUgLSA2cHgpfTpob3N0KC5ib3R0b20tc3RhcnQpIC5hcnJvd3t0b3A6LTZweH1bZGlyPWx0cl0gOmhvc3QoLmJvdHRvbS1zdGFydCkgLmFycm93e3JpZ2h0OjZweH1bZGlyPXJ0bF0gOmhvc3QoLmJvdHRvbS1zdGFydCkgLmFycm93e2xlZnQ6NnB4fTpob3N0KC5ib3R0b20tZW5kKSAuYXJyb3d7dG9wOi02cHh9W2Rpcj1sdHJdIDpob3N0KC5ib3R0b20tZW5kKSAuYXJyb3d7bGVmdDo2cHh9W2Rpcj1ydGxdIDpob3N0KC5ib3R0b20tZW5kKSAuYXJyb3d7cmlnaHQ6NnB4fTpob3N0KC5sZWZ0KSAuYXJyb3csOmhvc3QoLnN0YXJ0KSAuYXJyb3d7dG9wOmNhbGMoNTAlIC0gMi40cHgpfVtkaXI9bHRyXSA6aG9zdCgubGVmdCkgLmFycm93LFtkaXI9bHRyXSA6aG9zdCguc3RhcnQpIC5hcnJvd3tyaWdodDotOHB4O3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfVtkaXI9cnRsXSA6aG9zdCgubGVmdCkgLmFycm93LFtkaXI9cnRsXSA6aG9zdCguc3RhcnQpIC5hcnJvd3tsZWZ0Oi04cHg7dHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpfTpob3N0KC5zdGFydC10b3ApIC5hcnJvd3tyaWdodDotOHB4O2JvdHRvbTo2cHg7dHJhbnNmb3JtOnJvdGF0ZSg5MGRlZyl9Omhvc3QoLnN0YXJ0LWJvdHRvbSkgLmFycm93e3JpZ2h0Oi04cHg7dG9wOjZweDt0cmFuc2Zvcm06cm90YXRlKDkwZGVnKX06aG9zdCgudG9wKSAuYXJyb3d7Ym90dG9tOi02cHg7bGVmdDpjYWxjKDUwJSAtIDZweCk7dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfTpob3N0KC50b3Atc3RhcnQpIC5hcnJvd3tib3R0b206Y2FsYygtMSAqIDZweCArIDFweCk7dHJhbnNmb3JtOnJvdGF0ZSgxODBkZWcpfVtkaXI9bHRyXSA6aG9zdCgudG9wLXN0YXJ0KSAuYXJyb3d7cmlnaHQ6NnB4fVtkaXI9cnRsXSA6aG9zdCgudG9wLXN0YXJ0KSAuYXJyb3d7bGVmdDo2cHh9Omhvc3QoLnRvcC1lbmQpIC5hcnJvd3tib3R0b206Y2FsYygtNnB4ICsgMXB4KTt0cmFuc2Zvcm06cm90YXRlKDE4MGRlZyl9W2Rpcj1sdHJdIDpob3N0KC50b3AtZW5kKSAuYXJyb3d7bGVmdDo2cHh9W2Rpcj1ydGxdIDpob3N0KC50b3AtZW5kKSAuYXJyb3d7cmlnaHQ6NnB4fTpob3N0KC5yaWdodCkgLmFycm93LDpob3N0KC5lbmQpIC5hcnJvd3t0b3A6Y2FsYyg1MCUgLSAyLjRweCl9W2Rpcj1sdHJdIDpob3N0KC5yaWdodCkgLmFycm93LFtkaXI9bHRyXSA6aG9zdCguZW5kKSAuYXJyb3d7bGVmdDotOHB4O3RyYW5zZm9ybTpyb3RhdGUoMjcwZGVnKX1bZGlyPXJ0bF0gOmhvc3QoLnJpZ2h0KSAuYXJyb3csW2Rpcj1ydGxdIDpob3N0KC5lbmQpIC5hcnJvd3tyaWdodDotOHB4O3RyYW5zZm9ybTpyb3RhdGUoOTBkZWcpfTpob3N0KC5lbmQtdG9wKSAuYXJyb3d7bGVmdDpjYWxjKC02cHggLSA2cHggLyAyLjUpO2JvdHRvbTo2cHg7dHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpfTpob3N0KC5lbmQtYm90dG9tKSAuYXJyb3d7bGVmdDpjYWxjKC02cHggLSA2cHggLyAyLjUpO3RvcDo2cHg7dHJhbnNmb3JtOnJvdGF0ZSgyNzBkZWcpfVxcblwiXVxuICAgIH0pXG5dLCBOYlRvb2x0aXBDb21wb25lbnQpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDEzMyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ4OCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuLyoqXG4gKlxuICogVG9vbHRpcCBkaXJlY3RpdmUgZm9yIHNtYWxsIHRleHQvaWNvbiBoaW50cy5cbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlRvb2x0aXBNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iVG9vbHRpcE1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgdG9vbHRpcC90b29sdGlwLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiBUb29sdGlwIGNhbiBhY2NlcHQgYSBoaW50IHRleHQgYW5kL29yIGFuIGljb246XG4gKiBAc3RhY2tlZC1leGFtcGxlKFdpdGggSWNvbiwgdG9vbHRpcC90b29sdGlwLXdpdGgtaWNvbi5jb21wb25lbnQpXG4gKlxuICogU2FtZSB3YXkgYXMgUG9wb3ZlciwgdG9vbHRpcCBjYW4gYWNjZXB0IHBsYWNlbWVudCBwb3NpdGlvbiB3aXRoIGBuYlRvb2x0aXBQbGFjZW1lbnRgIHByb3BlcnR5OlxuICogQHN0YWNrZWQtZXhhbXBsZShQbGFjZW1lbnRzLCB0b29sdGlwL3Rvb2x0aXAtcGxhY2VtZW50cy5jb21wb25lbnQpXG4gKlxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBzcGVjaWZ5IHRvb2x0aXAgY29sb3IgdXNpbmcgYG5iVG9vbHRpcFN0YXR1c2AgcHJvcGVydHk6XG4gKiBAc3RhY2tlZC1leGFtcGxlKENvbG9yZWQgVG9vbHRpcHMsIHRvb2x0aXAvdG9vbHRpcC1jb2xvcnMuY29tcG9uZW50KVxuICpcbiAqIFRvb2x0aXAgaGFzIGEgbnVtYmVyIG9mIHRyaWdnZXJzIHdoaWNoIHByb3ZpZGVzIGFuIGFiaWxpdHkgdG8gc2hvdyBhbmQgaGlkZSB0aGUgY29tcG9uZW50IGluIGRpZmZlcmVudCB3YXlzOlxuICpcbiAqIC0gQ2xpY2sgbW9kZSBzaG93cyB0aGUgY29tcG9uZW50IHdoZW4gYSB1c2VyIGNsaWNrcyBvbiB0aGUgaG9zdCBlbGVtZW50IGFuZCBoaWRlcyB3aGVuIHRoZSB1c2VyIGNsaWNrc1xuICogc29tZXdoZXJlIG9uIHRoZSBkb2N1bWVudCBvdXRzaWRlIHRoZSBjb21wb25lbnQuXG4gKiAtIEhpbnQgcHJvdmlkZXMgY2FwYWJpbGl0eSB0byBzaG93IHRoZSBjb21wb25lbnQgd2hlbiB0aGUgdXNlciBob3ZlcnMgb3ZlciB0aGUgaG9zdCBlbGVtZW50XG4gKiBhbmQgaGlkZSB3aGVuIHRoZSB1c2VyIGhvdmVycyBvdXQgb2YgdGhlIGhvc3QuXG4gKiAtIEhvdmVyIHdvcmtzIGxpa2UgaGludCBtb2RlIHdpdGggb25lIGV4Y2VwdGlvbiAtIHdoZW4gdGhlIHVzZXIgbW92ZXMgbW91c2UgZnJvbSBob3N0IGVsZW1lbnQgdG9cbiAqIHRoZSBjb250YWluZXIgZWxlbWVudCB0aGUgY29tcG9uZW50IHJlbWFpbnMgb3Blbiwgc28gdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBpbnRlcmFjdCB3aXRoIGl0IGNvbnRlbnQuXG4gKiAtIEZvY3VzIG1vZGUgaXMgYXBwbGllZCB3aGVuIHVzZXIgZm9jdXNlcyB0aGUgZWxlbWVudC5cbiAqIC0gTm9vcCBtb2RlIC0gdGhlIGNvbXBvbmVudCB3b24ndCByZWFjdCB0byB0aGUgdXNlciBpbnRlcmFjdGlvbi5cbiAqL1xubGV0IE5iVG9vbHRpcERpcmVjdGl2ZSA9IGNsYXNzIE5iVG9vbHRpcERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZiwgZHluYW1pY092ZXJsYXlIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuaG9zdFJlZiA9IGhvc3RSZWY7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXlIYW5kbGVyID0gZHluYW1pY092ZXJsYXlIYW5kbGVyO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy50b29sdGlwQ29tcG9uZW50ID0gTmJUb29sdGlwQ29tcG9uZW50O1xuICAgICAgICB0aGlzLm9mZnNldCA9IDg7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUG9zaXRpb24gd2lsbCBiZSBjYWxjdWxhdGVkIHJlbGF0aXZlbHkgaG9zdCBlbGVtZW50IGJhc2VkIG9uIHRoZSBwb3NpdGlvbi5cbiAgICAgICAgICogQ2FuIGJlIHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQgb3IgZW5kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IE5iUG9zaXRpb24uVE9QO1xuICAgICAgICB0aGlzLl9hZGp1c3RtZW50ID0gTmJBZGp1c3RtZW50LkNMT0NLV0lTRTtcbiAgICAgICAgdGhpcy50b29sdGlwQ2xhc3MgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc2NyaWJlcyB3aGVuIHRoZSBjb250YWluZXIgd2lsbCBiZSBzaG93bi5cbiAgICAgICAgICogQXZhaWxhYmxlIG9wdGlvbnM6IGBjbGlja2AsIGBob3ZlcmAsIGBoaW50YCwgYGZvY3VzYCBhbmQgYG5vb3BgXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMudHJpZ2dlciA9IE5iVHJpZ2dlci5ISU5UO1xuICAgICAgICB0aGlzLm5iVG9vbHRpcFNob3dTdGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udGFpbmVyIHBvc2l0aW9uIHdpbGwgY2hhbmdlIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhpcyBzdHJhdGVneSBpZiBjb250YWluZXIgY2FuJ3QgZml0IHZpZXcgcG9ydC5cbiAgICAgKiBTZXQgdGhpcyBwcm9wZXJ0eSB0byBgbm9vcGAgdmFsdWUgaWYgeW91IHdhbnQgdG8gZGlzYWJsZSBhdXRvbWF0aWMgYWRqdXN0bWVudC5cbiAgICAgKiBBdmFpbGFibGUgdmFsdWVzOiBgY2xvY2t3aXNlYCAoZGVmYXVsdCksIGBjb3VudGVyY2xvY2t3aXNlYCwgYHZlcnRpY2FsYCwgYGhvcml6b250YWxgLCBgbm9vcGAuXG4gICAgICovXG4gICAgZ2V0IGFkanVzdG1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGp1c3RtZW50O1xuICAgIH1cbiAgICBzZXQgYWRqdXN0bWVudCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAvLyBAYnJlYWtpbmctY2hhbmdlIFJlbW92ZSBANS4wLjBcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFsc3kgdmFsdWVzIGZvciAnbmJQb3BvdmVyQWRqdXN0bWVudCcgYXJlIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBOZWJ1bGFyIDUuXG4gVXNlICdub29wJyBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgdmFsdWUgPSBOYkFkanVzdG1lbnQuTk9PUDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hZGp1c3RtZW50ID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgaWNvbiBuYW1lIG9yIGljb24gY29uZmlnIG9iamVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgTmJJY29uQ29uZmlnfSBpY29uIG5hbWUgb3IgY29uZmlnIG9iamVjdFxuICAgICAqL1xuICAgIHNldCBpY29uKGljb24pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gT2JqZWN0LmFzc2lnbih0aGlzLmNvbnRleHQsIHsgaWNvbiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzXG4gICAgICovXG4gICAgc2V0IHN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gT2JqZWN0LmFzc2lnbih0aGlzLmNvbnRleHQsIHsgc3RhdHVzIH0pO1xuICAgIH1cbiAgICBnZXQgaXNTaG93bigpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZHluYW1pY092ZXJsYXkgJiYgdGhpcy5keW5hbWljT3ZlcmxheS5pc0F0dGFjaGVkKTtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXlIYW5kbGVyXG4gICAgICAgICAgICAuaG9zdCh0aGlzLmhvc3RSZWYpXG4gICAgICAgICAgICAuY29tcG9uZW50VHlwZSh0aGlzLnRvb2x0aXBDb21wb25lbnQpXG4gICAgICAgICAgICAub2Zmc2V0KHRoaXMub2Zmc2V0KTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMucmVidWlsZCgpO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkgPSB0aGlzLmNvbmZpZ3VyZUR5bmFtaWNPdmVybGF5KClcbiAgICAgICAgICAgIC5idWlsZCgpO1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5LmlzU2hvd25cbiAgICAgICAgICAgIC5waXBlKHNraXAoMSksIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGlzU2hvd24pID0+IHRoaXMubmJUb29sdGlwU2hvd1N0YXRlQ2hhbmdlLmVtaXQoeyBpc1Nob3duIH0pKTtcbiAgICB9XG4gICAgcmVidWlsZCgpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheSA9IHRoaXMuY29uZmlndXJlRHluYW1pY092ZXJsYXkoKVxuICAgICAgICAgICAgLnJlYnVpbGQoKTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcmxheS5zaG93KCk7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkuaGlkZSgpO1xuICAgIH1cbiAgICB0b2dnbGUoKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY092ZXJsYXkudG9nZ2xlKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmR5bmFtaWNPdmVybGF5SGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZUR5bmFtaWNPdmVybGF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5keW5hbWljT3ZlcmxheUhhbmRsZXJcbiAgICAgICAgICAgIC5wb3NpdGlvbih0aGlzLnBvc2l0aW9uKVxuICAgICAgICAgICAgLnRyaWdnZXIodGhpcy50cmlnZ2VyKVxuICAgICAgICAgICAgLmFkanVzdG1lbnQodGhpcy5hZGp1c3RtZW50KVxuICAgICAgICAgICAgLmNvbnRlbnQodGhpcy5jb250ZW50KVxuICAgICAgICAgICAgLmNvbnRleHQodGhpcy5jb250ZXh0KVxuICAgICAgICAgICAgLm92ZXJsYXlDb25maWcoeyBwYW5lbENsYXNzOiB0aGlzLnRvb2x0aXBDbGFzcyB9KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxMzMoW1xuICAgIElucHV0KCduYlRvb2x0aXAnKSxcbiAgICBfX21ldGFkYXRhJDg4KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJUb29sdGlwRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEzMyhbXG4gICAgSW5wdXQoJ25iVG9vbHRpcFBsYWNlbWVudCcpLFxuICAgIF9fbWV0YWRhdGEkODgoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEzMyhbXG4gICAgSW5wdXQoJ25iVG9vbHRpcEFkanVzdG1lbnQnKSxcbiAgICBfX21ldGFkYXRhJDg4KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhJDg4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBOYlRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImFkanVzdG1lbnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEzMyhbXG4gICAgSW5wdXQoJ25iVG9vbHRpcENsYXNzJyksXG4gICAgX19tZXRhZGF0YSQ4OChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidG9vbHRpcENsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEzMyhbXG4gICAgSW5wdXQoJ25iVG9vbHRpcEljb24nKSxcbiAgICBfX21ldGFkYXRhJDg4KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDg4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBOYlRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcImljb25cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEzMyhbXG4gICAgSW5wdXQoJ25iVG9vbHRpcFN0YXR1cycpLFxuICAgIF9fbWV0YWRhdGEkODgoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEkODgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIE5iVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic3RhdHVzXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzMoW1xuICAgIElucHV0KCduYlRvb2x0aXBUcmlnZ2VyJyksXG4gICAgX19tZXRhZGF0YSQ4OChcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVG9vbHRpcERpcmVjdGl2ZS5wcm90b3R5cGUsIFwidHJpZ2dlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMzMoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkODgoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYlRvb2x0aXBEaXJlY3RpdmUucHJvdG90eXBlLCBcIm5iVG9vbHRpcFNob3dTdGF0ZUNoYW5nZVwiLCB2b2lkIDApO1xuTmJUb29sdGlwRGlyZWN0aXZlID0gX19kZWNvcmF0ZSQxMzMoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW25iVG9vbHRpcF0nLFxuICAgICAgICBleHBvcnRBczogJ25iVG9vbHRpcCcsXG4gICAgICAgIHByb3ZpZGVyczogW05iRHluYW1pY092ZXJsYXlIYW5kbGVyLCBOYkR5bmFtaWNPdmVybGF5XSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDg4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0VsZW1lbnRSZWYsXG4gICAgICAgIE5iRHluYW1pY092ZXJsYXlIYW5kbGVyXSlcbl0sIE5iVG9vbHRpcERpcmVjdGl2ZSk7XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTMxID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmxldCBOYlRvb2x0aXBNb2R1bGUgPSBjbGFzcyBOYlRvb2x0aXBNb2R1bGUge1xufTtcbk5iVG9vbHRpcE1vZHVsZSA9IF9fZGVjb3JhdGUkMTMxKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtOYlNoYXJlZE1vZHVsZSwgTmJPdmVybGF5TW9kdWxlLCBOYkljb25Nb2R1bGVdLFxuICAgICAgICBkZWNsYXJhdGlvbnM6IFtOYlRvb2x0aXBDb21wb25lbnQsIE5iVG9vbHRpcERpcmVjdGl2ZV0sXG4gICAgICAgIGV4cG9ydHM6IFtOYlRvb2x0aXBEaXJlY3RpdmVdLFxuICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtOYlRvb2x0aXBDb21wb25lbnRdLFxuICAgIH0pXG5dLCBOYlRvb2x0aXBNb2R1bGUpO1xuXG5jb25zdCBOQl9TRUxFQ1RfSU5KRUNUSU9OX1RPS0VOID0gbmV3IEluamVjdGlvblRva2VuKCdOQl9TRUxFQ1RfSU5KRUNUSU9OX1RPS0VOJyk7XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTM2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDkwID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQyMCA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmxldCBOYk9wdGlvbkNvbXBvbmVudCA9IGNsYXNzIE5iT3B0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGVsZW1lbnRSZWYsIGNkKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5kaXNhYmxlZEJ5R3JvdXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHZhbHVlIHdoZW4gb3B0aW9uIHNlbGVjdGlvbiBjaGFuZ2UuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBvcHRpb24gY2xpY2tlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbGljayQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZEJ5R3JvdXA7XG4gICAgfVxuICAgIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBjbGljaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpY2skLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHNob3VsZCB3ZSByZW5kZXIgY2hlY2tib3guXG4gICAgICogKi9cbiAgICBnZXQgd2l0aENoZWNrYm94KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSAmJiB0aGlzLnZhbHVlICE9IG51bGw7XG4gICAgfVxuICAgIGdldCBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIGdldCBtdWx0aXBsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm11bHRpcGxlO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQ7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZEF0dHJpYnV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyAnJyA6IG51bGw7XG4gICAgfVxuICAgIGdldCB0YWJpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuICctMSc7XG4gICAgfVxuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgdGhpcy5jbGljayQubmV4dCh0aGlzKTtcbiAgICAgICAgLy8gUHJldmVudCBzY3JvbGwgb24gc3BhY2UgY2xpY2ssIGV0Yy5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgc2VsZWN0KCkge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGlvbih0cnVlKTtcbiAgICB9XG4gICAgZGVzZWxlY3QoKSB7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBkaXNhYmxlZCBieSBncm91cCBzdGF0ZSBhbmQgbWFya3MgY29tcG9uZW50IGZvciBjaGVjay5cbiAgICAgKi9cbiAgICBzZXREaXNhYmxlZEJ5R3JvdXBTdGF0ZShkaXNhYmxlZCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZEJ5R3JvdXAgIT09IGRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGVkQnlHcm91cCA9IGRpc2FibGVkO1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTZWxlY3Rpb24oc2VsZWN0ZWQpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluIGNhc2Ugb2YgY2hhbmdpbmcgb3B0aW9ucyBpbiBydW50aW1lIHRoZSByZWZlcmVuY2UgdG8gdGhlIHNlbGVjdGVkIG9wdGlvbiB3aWxsIGJlIGtlcHQgaW4gc2VsZWN0IGNvbXBvbmVudC5cbiAgICAgICAgICogVGhpcyBtYXkgbGVhZCB0byBleGNlcHRpb25zIHdpdGggZGV0ZWN0aW5nIGNoYW5nZXMgaW4gZGVzdHJveWVkIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQWxzbyBBbmd1bGFyIGNhbiBjYWxsIHdyaXRlVmFsdWUgb24gZGVzdHJveWVkIHZpZXcgKHNlbGVjdCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yKS5cbiAgICAgICAgICogYW5ndWxhci9hbmd1bGFyIzI3ODAzXG4gICAgICAgICAqICovXG4gICAgICAgIGlmICh0aGlzLmFsaXZlICYmIHRoaXMuc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbkNoYW5nZS5lbWl0KHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gICAgZ2V0TGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTM2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYk9wdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTM2KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTAoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDkwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJPcHRpb25Db21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzYoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTAoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOYk9wdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwic2VsZWN0aW9uQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEzNihbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNlbGVjdGVkJyksXG4gICAgX19tZXRhZGF0YSQ5MChcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkOTAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iT3B0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZENsYXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzYoW1xuICAgIEhvc3RCaW5kaW5nKCdhdHRyLmRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YSQ5MChcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YSQ5MChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJPcHRpb25Db21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkQXR0cmlidXRlXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzYoW1xuICAgIEhvc3RCaW5kaW5nKCd0YWJJbmRleCcpLFxuICAgIF9fbWV0YWRhdGEkOTAoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkOTAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iT3B0aW9uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0YWJpbmRleFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTM2KFtcbiAgICBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSksXG4gICAgSG9zdExpc3RlbmVyKCdrZXlkb3duLnNwYWNlJywgWyckZXZlbnQnXSksXG4gICAgSG9zdExpc3RlbmVyKCdrZXlkb3duLmVudGVyJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YSQ5MChcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhJDkwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEkOTAoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBOYk9wdGlvbkNvbXBvbmVudC5wcm90b3R5cGUsIFwib25DbGlja1wiLCBudWxsKTtcbk5iT3B0aW9uQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxMzYoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItb3B0aW9uJyxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLWNoZWNrYm94ICpuZ0lmPVwid2l0aENoZWNrYm94XCJcbiAgICAgICAgICAgICAgICAgW2NoZWNrZWRdPVwic2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICA8L25iLWNoZWNrYm94PlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgYCxcbiAgICAgICAgc3R5bGVzOiBbXCIvKiFcXG4gKiBAbGljZW5zZVxcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxcbiAqLzpob3N0e2Rpc3BsYXk6ZmxleDt0cmFuc2l0aW9uLWR1cmF0aW9uOjAuMTVzO3RyYW5zaXRpb24tcHJvcGVydHk6YmFja2dyb3VuZC1jb2xvcixjb2xvcjt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLWlufTpob3N0OmhvdmVye2N1cnNvcjpwb2ludGVyfTpob3N0IG5iLWNoZWNrYm94e2Rpc3BsYXk6ZmxleDtwb2ludGVyLWV2ZW50czpub25lfVtkaXI9bHRyXSA6aG9zdCBuYi1jaGVja2JveHttYXJnaW4tcmlnaHQ6LjVyZW19W2Rpcj1ydGxdIDpob3N0IG5iLWNoZWNrYm94e21hcmdpbi1sZWZ0Oi41cmVtfTpob3N0IG5iLWNoZWNrYm94IDo6bmctZGVlcCAubGFiZWx7cGFkZGluZzowfTpob3N0KFtkaXNhYmxlZF0pe3BvaW50ZXItZXZlbnRzOm5vbmV9XFxuXCJdXG4gICAgfSksXG4gICAgX19wYXJhbSQyMCgwLCBJbmplY3QoTkJfU0VMRUNUX0lOSkVDVElPTl9UT0tFTikpLFxuICAgIF9fbWV0YWRhdGEkOTAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBFbGVtZW50UmVmLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBOYk9wdGlvbkNvbXBvbmVudCk7XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTM1ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDg5ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQxOSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbnZhciBOYlNlbGVjdENvbXBvbmVudF8xO1xubGV0IE5iU2VsZWN0TGFiZWxDb21wb25lbnQgPSBjbGFzcyBOYlNlbGVjdExhYmVsQ29tcG9uZW50IHtcbn07XG5OYlNlbGVjdExhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxMzUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItc2VsZWN0LWxhYmVsJyxcbiAgICAgICAgdGVtcGxhdGU6ICc8bmctY29udGVudD48L25nLWNvbnRlbnQ+J1xuICAgIH0pXG5dLCBOYlNlbGVjdExhYmVsQ29tcG9uZW50KTtcbi8qKlxuICogVGhlIGBOYlNlbGVjdENvbXBvbmVudGAgcHJvdmlkZXMgYSBjYXBhYmlsaXR5IHRvIHNlbGVjdCBvbmUgb2YgdGhlIHBhc3NlZCBpdGVtcy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFNob3djYXNlLCBzZWxlY3Qvc2VsZWN0LXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlNlbGVjdE1vZHVsZWAgdG8geW91ciBmZWF0dXJlIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJTZWxlY3RNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSBpdCBhcyB0aGUgbXVsdGktc2VsZWN0IGNvbnRyb2wgeW91IGhhdmUgdG8gbWFyayBpdCBhcyBgbXVsdGlwbGVgLlxuICogSW4gdGhpcyBjYXNlLCBgbmItc2VsZWN0YCB3aWxsIHdvcmsgb25seSB3aXRoIGFycmF5cyAtIGFjY2VwdCBhcnJheXMgYW5kIHByb3BhZ2F0ZSBhcnJheXMuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShNdWx0aXBsZSwgc2VsZWN0L3NlbGVjdC1tdWx0aXBsZS5jb21wb25lbnQpXG4gKlxuICogSXRlbXMgd2l0aG91dCB2YWx1ZXMgd2lsbCBjbGVhbiB0aGUgc2VsZWN0aW9uLiBCb3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzIHdpbGwgYWxzbyBjbGVhbiB0aGUgc2VsZWN0aW9uLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ2xlYW4gc2VsZWN0aW9uLCBzZWxlY3Qvc2VsZWN0LWNsZWFuLmNvbXBvbmVudClcbiAqXG4gKiBTZWxlY3QgbWF5IGJlIGJvdW5kZWQgdXNpbmcgYHNlbGVjdGVkYCBpbnB1dDpcbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItc2VsZWN0IFsoc2VsZWN0ZWQpXT1cInNlbGVjdGVkXCI+PC9uYi1zZWxlY3RlZD5cbiAqIGBgYFxuICpcbiAqIE9yIHlvdSBjYW4gYmluZCBjb250cm9sIHdpdGggZm9ybSBjb250cm9scyBvciBuZ01vZGVsOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2VsZWN0IGZvcm0gYmluZGluZywgc2VsZWN0L3NlbGVjdC1mb3JtLmNvbXBvbmVudClcbiAqXG4gKiBPcHRpb25zIGluIHRoZSBzZWxlY3QgbWF5IGJlIGdyb3VwZWQgdXNpbmcgYG5iLW9wdGlvbi1ncm91cGAgY29tcG9uZW50LlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoR3JvdXBpbmcsIHNlbGVjdC9zZWxlY3QtZ3JvdXBzLmNvbXBvbmVudClcbiAqXG4gKiBTZWxlY3QgbWF5IGhhdmUgYSBwbGFjZWhvbGRlciB0aGF0IHdpbGwgYmUgc2hvd24gd2hlbiBub3RoaW5nIHNlbGVjdGVkOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoUGxhY2Vob2xkZXIsIHNlbGVjdC9zZWxlY3QtcGxhY2Vob2xkZXIuY29tcG9uZW50KVxuICpcbiAqIFlvdSBjYW4gZGlzYWJsZSBzZWxlY3QsIG9wdGlvbnMgYW5kIHdob2xlIGdyb3Vwcy5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKERpc2FibGVkIHNlbGVjdCwgc2VsZWN0L3NlbGVjdC1kaXNhYmxlZC5jb21wb25lbnQpXG4gKlxuICogQWxzbywgdGhlIGN1c3RvbSBsYWJlbCBtYXkgYmUgcHJvdmlkZWQgaW4gc2VsZWN0LlxuICogVGhpcyBjdXN0b20gbGFiZWwgd2lsbCBiZSB1c2VkIGZvciBpbnN0ZWFkIHBsYWNlaG9sZGVyIHdoZW4gc29tZXRoaW5nIHNlbGVjdGVkLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoQ3VzdG9tIGxhYmVsLCBzZWxlY3Qvc2VsZWN0LWxhYmVsLmNvbXBvbmVudClcbiAqXG4gKiBEZWZhdWx0IGBuYi1zZWxlY3RgIHNpemUgaXMgYG1lZGl1bWAgYW5kIHN0YXR1cyBpcyBgYmFzaWNgLlxuICogU2VsZWN0IGlzIGF2YWlsYWJsZSBpbiBtdWx0aXBsZSBjb2xvcnMgdXNpbmcgYHN0YXR1c2AgcHJvcGVydHk6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTZWxlY3Qgc3RhdHVzZXMsIHNlbGVjdC9zZWxlY3Qtc3RhdHVzLmNvbXBvbmVudClcbiAqXG4gKiBUaGVyZSBhcmUgZml2ZSBzZWxlY3Qgc2l6ZXM6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTZWxlY3Qgc2l6ZXMsIHNlbGVjdC9zZWxlY3Qtc2l6ZXMuY29tcG9uZW50KVxuICpcbiAqIEFuZCB0d28gYWRkaXRpb25hbCBzdHlsZSB0eXBlcyAtIGBmaWxsZWRgOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRmlsbGVkIHNlbGVjdCwgc2VsZWN0L3NlbGVjdC1maWxsZWQuY29tcG9uZW50KVxuICpcbiAqIGFuZCBgaGVyb2A6XG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTZWxlY3QgY29sb3JzLCBzZWxlY3Qvc2VsZWN0LWhlcm8uY29tcG9uZW50KVxuICpcbiAqIFNlbGVjdCBpcyBhdmFpbGFibGUgaW4gZGlmZmVyZW50IHNoYXBlcywgdGhhdCBjb3VsZCBiZSBjb21iaW5lZCB3aXRoIHRoZSBvdGhlciBwcm9wZXJ0aWVzOlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2VsZWN0IHNoYXBlcywgc2VsZWN0L3NlbGVjdC1zaGFwZXMuY29tcG9uZW50KVxuICpcbiAqIEBhZGRpdGlvbmFsLWV4YW1wbGUoSW50ZXJhY3RpdmUsIHNlbGVjdC9zZWxlY3QtaW50ZXJhY3RpdmUuY29tcG9uZW50KVxuICpcbiAqIEBzdHlsZXNcbiAqXG4gKiBzZWxlY3QtY3Vyc29yOlxuICogc2VsZWN0LWRpc2FibGVkLWN1cnNvcjpcbiAqIHNlbGVjdC1taW4td2lkdGg6XG4gKiBzZWxlY3Qtb3B0aW9ucy1saXN0LW1heC1oZWlnaHQ6XG4gKiBzZWxlY3Qtb3B0aW9ucy1saXN0LXNoYWRvdzpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3QtYm9yZGVyLXN0eWxlOlxuICogc2VsZWN0LW9wdGlvbnMtbGlzdC1ib3JkZXItd2lkdGg6XG4gKiBzZWxlY3Qtb3V0bGluZS13aWR0aDpcbiAqIHNlbGVjdC1vdXRsaW5lLWNvbG9yOlxuICogc2VsZWN0LXRleHQtZm9udC1mYW1pbHk6XG4gKiBzZWxlY3QtcGxhY2Vob2xkZXItdGV4dC1mb250LWZhbWlseTpcbiAqIHNlbGVjdC1vcHRpb24tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb24tdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb24tc2VsZWN0ZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb24tc2VsZWN0ZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb24tZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb24tZm9jdXMtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb24taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb24taG92ZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb24tZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb24tZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC10aW55LXRleHQtZm9udC1zaXplOlxuICogc2VsZWN0LXRpbnktdGV4dC1mb250LXdlaWdodDpcbiAqIHNlbGVjdC10aW55LXRleHQtbGluZS1oZWlnaHQ6XG4gKiBzZWxlY3QtdGlueS1wbGFjZWhvbGRlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIHNlbGVjdC10aW55LXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBzZWxlY3QtdGlueS1tYXgtd2lkdGg6XG4gKiBzZWxlY3Qtc21hbGwtdGV4dC1mb250LXNpemU6XG4gKiBzZWxlY3Qtc21hbGwtdGV4dC1mb250LXdlaWdodDpcbiAqIHNlbGVjdC1zbWFsbC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogc2VsZWN0LXNtYWxsLXBsYWNlaG9sZGVyLXRleHQtZm9udC1zaXplOlxuICogc2VsZWN0LXNtYWxsLXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBzZWxlY3Qtc21hbGwtbWF4LXdpZHRoOlxuICogc2VsZWN0LW1lZGl1bS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHNlbGVjdC1tZWRpdW0tdGV4dC1mb250LXdlaWdodDpcbiAqIHNlbGVjdC1tZWRpdW0tdGV4dC1saW5lLWhlaWdodDpcbiAqIHNlbGVjdC1tZWRpdW0tcGxhY2Vob2xkZXItdGV4dC1mb250LXNpemU6XG4gKiBzZWxlY3QtbWVkaXVtLXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBzZWxlY3QtbWVkaXVtLW1heC13aWR0aDpcbiAqIHNlbGVjdC1sYXJnZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHNlbGVjdC1sYXJnZS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogc2VsZWN0LWxhcmdlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiBzZWxlY3QtbGFyZ2UtcGxhY2Vob2xkZXItdGV4dC1mb250LXNpemU6XG4gKiBzZWxlY3QtbGFyZ2UtcGxhY2Vob2xkZXItdGV4dC1mb250LXdlaWdodDpcbiAqIHNlbGVjdC1sYXJnZS1tYXgtd2lkdGg6XG4gKiBzZWxlY3QtZ2lhbnQtdGV4dC1mb250LXNpemU6XG4gKiBzZWxlY3QtZ2lhbnQtdGV4dC1mb250LXdlaWdodDpcbiAqIHNlbGVjdC1naWFudC10ZXh0LWxpbmUtaGVpZ2h0OlxuICogc2VsZWN0LWdpYW50LXBsYWNlaG9sZGVyLXRleHQtZm9udC1zaXplOlxuICogc2VsZWN0LWdpYW50LXBsYWNlaG9sZGVyLXRleHQtZm9udC13ZWlnaHQ6XG4gKiBzZWxlY3QtZ2lhbnQtbWF4LXdpZHRoOlxuICogc2VsZWN0LXJlY3RhbmdsZS1ib3JkZXItcmFkaXVzOlxuICogc2VsZWN0LXNlbWktcm91bmQtYm9yZGVyLXJhZGl1czpcbiAqIHNlbGVjdC1yb3VuZC1ib3JkZXItcmFkaXVzOlxuICogc2VsZWN0LW91dGxpbmUtYm9yZGVyLXN0eWxlOlxuICogc2VsZWN0LW91dGxpbmUtYm9yZGVyLXdpZHRoOlxuICogc2VsZWN0LW91dGxpbmUtdGlueS1wYWRkaW5nOlxuICogc2VsZWN0LW91dGxpbmUtc21hbGwtcGFkZGluZzpcbiAqIHNlbGVjdC1vdXRsaW5lLW1lZGl1bS1wYWRkaW5nOlxuICogc2VsZWN0LW91dGxpbmUtbGFyZ2UtcGFkZGluZzpcbiAqIHNlbGVjdC1vdXRsaW5lLWdpYW50LXBhZGRpbmc6XG4gKiBzZWxlY3Qtb3V0bGluZS1iYXNpYy1pY29uLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtYmFzaWMtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWJhc2ljLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1iYXNpYy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtYmFzaWMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtYmFzaWMtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWJhc2ljLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWJhc2ljLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1iYXNpYy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1iYXNpYy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtYmFzaWMtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtYmFzaWMtZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWJhc2ljLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LWljb24tY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXByaW1hcnktZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXByaW1hcnktZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtcHJpbWFyeS1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtcHJpbWFyeS1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXByaW1hcnktZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXByaW1hcnktZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtc3VjY2Vzcy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtc3VjY2Vzcy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1zdWNjZXNzLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1zdWNjZXNzLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3MtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtc3VjY2Vzcy1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtc3VjY2Vzcy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1pY29uLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby10ZXh0LWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1pbmZvLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1pbmZvLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWluZm8taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWluZm8taG92ZXItYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtaW5mby1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1pbmZvLWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1pbmZvLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLWljb24tY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXdhcm5pbmctZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXdhcm5pbmctZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtd2FybmluZy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtd2FybmluZy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXdhcm5pbmctZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXdhcm5pbmctZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1pY29uLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1kYW5nZXItcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtZGFuZ2VyLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLWljb24tY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWNvbnRyb2wtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWNvbnRyb2wtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtY29udHJvbC1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWNvbnRyb2wtZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWNvbnRyb2wtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb24tb3V0bGluZS10aW55LXBhZGRpbmc6XG4gKiBzZWxlY3Qtb3B0aW9uLW91dGxpbmUtc21hbGwtcGFkZGluZzpcbiAqIHNlbGVjdC1vcHRpb24tb3V0bGluZS1tZWRpdW0tcGFkZGluZzpcbiAqIHNlbGVjdC1vcHRpb24tb3V0bGluZS1sYXJnZS1wYWRkaW5nOlxuICogc2VsZWN0LW9wdGlvbi1vdXRsaW5lLWdpYW50LXBhZGRpbmc6XG4gKiBzZWxlY3Qtb3V0bGluZS1hZGphY2VudC1ib3JkZXItc3R5bGU6XG4gKiBzZWxlY3Qtb3V0bGluZS1hZGphY2VudC1ib3JkZXItd2lkdGg6XG4gKiBzZWxlY3Qtb3V0bGluZS1iYXNpYy1vcGVuLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWJhc2ljLWFkamFjZW50LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXByaW1hcnktb3Blbi1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1wcmltYXJ5LWFkamFjZW50LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXN1Y2Nlc3Mtb3Blbi1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1zdWNjZXNzLWFkamFjZW50LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWluZm8tb3Blbi1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1pbmZvLWFkamFjZW50LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLXdhcm5pbmctb3Blbi1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS13YXJuaW5nLWFkamFjZW50LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1vcGVuLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vdXRsaW5lLWRhbmdlci1hZGphY2VudC1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3V0bGluZS1jb250cm9sLW9wZW4tYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW91dGxpbmUtY29udHJvbC1hZGphY2VudC1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZ3JvdXAtb3B0aW9uLW91dGxpbmUtdGlueS1zdGFydC1wYWRkaW5nOlxuICogc2VsZWN0LWdyb3VwLW9wdGlvbi1vdXRsaW5lLXNtYWxsLXN0YXJ0LXBhZGRpbmc6XG4gKiBzZWxlY3QtZ3JvdXAtb3B0aW9uLW91dGxpbmUtbWVkaXVtLXN0YXJ0LXBhZGRpbmc6XG4gKiBzZWxlY3QtZ3JvdXAtb3B0aW9uLW91dGxpbmUtbGFyZ2Utc3RhcnQtcGFkZGluZzpcbiAqIHNlbGVjdC1ncm91cC1vcHRpb24tb3V0bGluZS1naWFudC1zdGFydC1wYWRkaW5nOlxuICogc2VsZWN0LW9wdGlvbnMtbGlzdC1vdXRsaW5lLWJhc2ljLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3Qtb3V0bGluZS1wcmltYXJ5LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3Qtb3V0bGluZS1zdWNjZXNzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3Qtb3V0bGluZS1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3Qtb3V0bGluZS13YXJuaW5nLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3Qtb3V0bGluZS1kYW5nZXItYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW9wdGlvbnMtbGlzdC1vdXRsaW5lLWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1ib3JkZXItc3R5bGU6XG4gKiBzZWxlY3QtZmlsbGVkLWJvcmRlci13aWR0aDpcbiAqIHNlbGVjdC1maWxsZWQtdGlueS1wYWRkaW5nOlxuICogc2VsZWN0LWZpbGxlZC1zbWFsbC1wYWRkaW5nOlxuICogc2VsZWN0LWZpbGxlZC1tZWRpdW0tcGFkZGluZzpcbiAqIHNlbGVjdC1maWxsZWQtbGFyZ2UtcGFkZGluZzpcbiAqIHNlbGVjdC1maWxsZWQtZ2lhbnQtcGFkZGluZzpcbiAqIHNlbGVjdC1maWxsZWQtYmFzaWMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtYmFzaWMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1iYXNpYy1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1iYXNpYy10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1iYXNpYy1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1iYXNpYy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1iYXNpYy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWJhc2ljLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWJhc2ljLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtYmFzaWMtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtYmFzaWMtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1iYXNpYy1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1iYXNpYy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXByaW1hcnktYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LWljb24tY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtcHJpbWFyeS1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXByaW1hcnktZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXByaW1hcnktaG92ZXItYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXByaW1hcnktZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1wcmltYXJ5LWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXByaW1hcnktZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1zdWNjZXNzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXN1Y2Nlc3MtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1zdWNjZXNzLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1zdWNjZXNzLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1zdWNjZXNzLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtc3VjY2Vzcy1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1zdWNjZXNzLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtaW5mby1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8taWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtaW5mby10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1pbmZvLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8tZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtaW5mby1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtaW5mby1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8tZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtaW5mby1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWluZm8tZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtaW5mby1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXdhcm5pbmctYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLWljb24tY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtd2FybmluZy1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXdhcm5pbmctZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXdhcm5pbmctaG92ZXItYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXdhcm5pbmctZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC13YXJuaW5nLWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLXdhcm5pbmctZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWRhbmdlci1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWRhbmdlci1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtZGFuZ2VyLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWRhbmdlci1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1kYW5nZXItZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1kYW5nZXItaG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtZGFuZ2VyLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtZGFuZ2VyLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWRhbmdlci1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWRhbmdlci1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1kYW5nZXItZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1jb250cm9sLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1jb250cm9sLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtZmlsbGVkLWNvbnRyb2wtcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1jb250cm9sLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1jb250cm9sLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1jb250cm9sLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1maWxsZWQtY29udHJvbC1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LWZpbGxlZC1jb250cm9sLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiBzZWxlY3Qtb3B0aW9uLWZpbGxlZC10aW55LXBhZGRpbmc6XG4gKiBzZWxlY3QtZ3JvdXAtb3B0aW9uLWZpbGxlZC10aW55LXBhZGRpbmctc3RhcnQ6XG4gKiBzZWxlY3Qtb3B0aW9uLWZpbGxlZC1zbWFsbC1wYWRkaW5nOlxuICogc2VsZWN0LWdyb3VwLW9wdGlvbi1maWxsZWQtc21hbGwtcGFkZGluZy1zdGFydDpcbiAqIHNlbGVjdC1vcHRpb24tZmlsbGVkLW1lZGl1bS1wYWRkaW5nOlxuICogc2VsZWN0LWdyb3VwLW9wdGlvbi1maWxsZWQtbWVkaXVtLXBhZGRpbmctc3RhcnQ6XG4gKiBzZWxlY3Qtb3B0aW9uLWZpbGxlZC1sYXJnZS1wYWRkaW5nOlxuICogc2VsZWN0LWdyb3VwLW9wdGlvbi1maWxsZWQtbGFyZ2UtcGFkZGluZy1zdGFydDpcbiAqIHNlbGVjdC1vcHRpb24tZmlsbGVkLWdpYW50LXBhZGRpbmc6XG4gKiBzZWxlY3QtZ3JvdXAtb3B0aW9uLWZpbGxlZC1naWFudC1wYWRkaW5nLXN0YXJ0OlxuICogc2VsZWN0LW9wdGlvbnMtbGlzdC1maWxsZWQtYmFzaWMtYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW9wdGlvbnMtbGlzdC1maWxsZWQtcHJpbWFyeS1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3B0aW9ucy1saXN0LWZpbGxlZC1zdWNjZXNzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3QtZmlsbGVkLWluZm8tYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW9wdGlvbnMtbGlzdC1maWxsZWQtd2FybmluZy1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3Qtb3B0aW9ucy1saXN0LWZpbGxlZC1kYW5nZXItYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW9wdGlvbnMtbGlzdC1maWxsZWQtY29udHJvbC1ib3JkZXItY29sb3I6XG4gKiBzZWxlY3QtaGVyby10aW55LXBhZGRpbmc6XG4gKiBzZWxlY3QtaGVyby1zbWFsbC1wYWRkaW5nOlxuICogc2VsZWN0LWhlcm8tbWVkaXVtLXBhZGRpbmc6XG4gKiBzZWxlY3QtaGVyby1sYXJnZS1wYWRkaW5nOlxuICogc2VsZWN0LWhlcm8tZ2lhbnQtcGFkZGluZzpcbiAqIHNlbGVjdC1oZXJvLWJhc2ljLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWJhc2ljLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1iYXNpYy1pY29uLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tYmFzaWMtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWJhc2ljLXBsYWNlaG9sZGVyLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1iYXNpYy1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1iYXNpYy1mb2N1cy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tYmFzaWMtaG92ZXItbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tYmFzaWMtaG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWJhc2ljLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1iYXNpYy1kaXNhYmxlZC1pY29uLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tYmFzaWMtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXByaW1hcnktbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tcHJpbWFyeS1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tcHJpbWFyeS1pY29uLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tcHJpbWFyeS10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8tcHJpbWFyeS1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8tcHJpbWFyeS1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1wcmltYXJ5LWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1wcmltYXJ5LWhvdmVyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXByaW1hcnktaG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXByaW1hcnktZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXByaW1hcnktZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXByaW1hcnktZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXN1Y2Nlc3MtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tc3VjY2Vzcy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tc3VjY2Vzcy1pY29uLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8tc3VjY2Vzcy1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8tc3VjY2Vzcy1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1zdWNjZXNzLWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1zdWNjZXNzLWhvdmVyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXN1Y2Nlc3MtaG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXN1Y2Nlc3MtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXN1Y2Nlc3MtZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXN1Y2Nlc3MtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWluZm8tbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8taW5mby1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8taW5mby1pY29uLWNvbG9yOlxuICogc2VsZWN0LWhlcm8taW5mby10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8taW5mby1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8taW5mby1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1pbmZvLWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1pbmZvLWhvdmVyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWluZm8taG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWluZm8tZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWluZm8tZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWluZm8tZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXdhcm5pbmctbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8td2FybmluZy1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8td2FybmluZy1pY29uLWNvbG9yOlxuICogc2VsZWN0LWhlcm8td2FybmluZy10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8td2FybmluZy1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8td2FybmluZy1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby13YXJuaW5nLWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby13YXJuaW5nLWhvdmVyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXdhcm5pbmctaG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXdhcm5pbmctZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXdhcm5pbmctZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLXdhcm5pbmctZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWRhbmdlci1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1kYW5nZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWRhbmdlci1pY29uLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tZGFuZ2VyLXRleHQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1kYW5nZXItcGxhY2Vob2xkZXItdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWRhbmdlci1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1kYW5nZXItZm9jdXMtcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWRhbmdlci1ob3Zlci1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1kYW5nZXItaG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWRhbmdlci1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tZGFuZ2VyLWRpc2FibGVkLWljb24tY29sb3I6XG4gKiBzZWxlY3QtaGVyby1kYW5nZXItZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWNvbnRyb2wtbGVmdC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tY29udHJvbC1yaWdodC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tY29udHJvbC1pY29uLWNvbG9yOlxuICogc2VsZWN0LWhlcm8tY29udHJvbC10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8tY29udHJvbC1wbGFjZWhvbGRlci10ZXh0LWNvbG9yOlxuICogc2VsZWN0LWhlcm8tY29udHJvbC1mb2N1cy1sZWZ0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1jb250cm9sLWZvY3VzLXJpZ2h0LWJhY2tncm91bmQtY29sb3I6XG4gKiBzZWxlY3QtaGVyby1jb250cm9sLWhvdmVyLWxlZnQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWNvbnRyb2wtaG92ZXItcmlnaHQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWNvbnRyb2wtZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWNvbnRyb2wtZGlzYWJsZWQtaWNvbi1jb2xvcjpcbiAqIHNlbGVjdC1oZXJvLWNvbnRyb2wtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb24taGVyby10aW55LXBhZGRpbmc6XG4gKiBzZWxlY3QtZ3JvdXAtb3B0aW9uLWhlcm8tdGlueS1wYWRkaW5nLXN0YXJ0OlxuICogc2VsZWN0LW9wdGlvbi1oZXJvLXNtYWxsLXBhZGRpbmc6XG4gKiBzZWxlY3QtZ3JvdXAtb3B0aW9uLWhlcm8tc21hbGwtcGFkZGluZy1zdGFydDpcbiAqIHNlbGVjdC1vcHRpb24taGVyby1tZWRpdW0tcGFkZGluZzpcbiAqIHNlbGVjdC1ncm91cC1vcHRpb24taGVyby1tZWRpdW0tcGFkZGluZy1zdGFydDpcbiAqIHNlbGVjdC1vcHRpb24taGVyby1sYXJnZS1wYWRkaW5nOlxuICogc2VsZWN0LWdyb3VwLW9wdGlvbi1oZXJvLWxhcmdlLXBhZGRpbmctc3RhcnQ6XG4gKiBzZWxlY3Qtb3B0aW9uLWhlcm8tZ2lhbnQtcGFkZGluZzpcbiAqIHNlbGVjdC1ncm91cC1vcHRpb24taGVyby1naWFudC1wYWRkaW5nLXN0YXJ0OlxuICogc2VsZWN0LW9wdGlvbnMtbGlzdC1oZXJvLWJhc2ljLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3QtaGVyby1wcmltYXJ5LWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3QtaGVyby1zdWNjZXNzLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3QtaGVyby1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3QtaGVyby13YXJuaW5nLWJvcmRlci1jb2xvcjpcbiAqIHNlbGVjdC1vcHRpb25zLWxpc3QtaGVyby1kYW5nZXItYm9yZGVyLWNvbG9yOlxuICogc2VsZWN0LW9wdGlvbnMtbGlzdC1oZXJvLWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogKi9cbmxldCBOYlNlbGVjdENvbXBvbmVudCA9IE5iU2VsZWN0Q29tcG9uZW50XzEgPSBjbGFzcyBOYlNlbGVjdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG92ZXJsYXksIGhvc3RSZWYsIHBvc2l0aW9uQnVpbGRlciwgdHJpZ2dlclN0cmF0ZWd5QnVpbGRlciwgY2QsIGZvY3VzS2V5TWFuYWdlckZhY3RvcnlTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy5ob3N0UmVmID0gaG9zdFJlZjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkJ1aWxkZXIgPSBwb3NpdGlvbkJ1aWxkZXI7XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5QnVpbGRlciA9IHRyaWdnZXJTdHJhdGVneUJ1aWxkZXI7XG4gICAgICAgIHRoaXMuY2QgPSBjZDtcbiAgICAgICAgdGhpcy5mb2N1c0tleU1hbmFnZXJGYWN0b3J5U2VydmljZSA9IGZvY3VzS2V5TWFuYWdlckZhY3RvcnlTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0IHNpemUsIGF2YWlsYWJsZSBzaXplczpcbiAgICAgICAgICogYHRpbnlgLCBgc21hbGxgLCBgbWVkaXVtYCAoZGVmYXVsdCksIGBsYXJnZWAsIGBnaWFudGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZSA9ICdtZWRpdW0nO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2VsZWN0IHN0YXR1cyAoYWRkcyBzcGVjaWZpYyBzdHlsZXMpOlxuICAgICAgICAgKiBgYmFzaWNgLCBgcHJpbWFyeWAsIGBpbmZvYCwgYHN1Y2Nlc3NgLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgY29udHJvbGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdHVzID0gJ2Jhc2ljJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbGVjdCBzaGFwZXM6IGByZWN0YW5nbGVgIChkZWZhdWx0KSwgYHJvdW5kYCwgYHNlbWktcm91bmRgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYXBlID0gJ3JlY3RhbmdsZSc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWxlY3QgYXBwZWFyYW5jZXM6IGBvdXRsaW5lYCAoZGVmYXVsdCksIGBmaWxsZWRgLCBgaGVyb2BcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXBwZWFyYW5jZSA9ICdvdXRsaW5lJztcbiAgICAgICAgdGhpcy5fZnVsbFdpZHRoID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIHNlbGVjdCBwbGFjZWhvbGRlciBpZiBub3RoaW5nIHNlbGVjdGVkLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyID0gJyc7XG4gICAgICAgIHRoaXMuX211bHRpcGxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaWxsIGJlIGVtaXR0ZWQgd2hlbiBzZWxlY3RlZCB2YWx1ZSBjaGFuZ2VzLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBzZWxlY3RlZCBvcHRpb25zLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IG92ZXJsYXkgcG9zaXRpb24gYmVjYXVzZSBvZiB3ZSBoYXZlIHRvIHRvZ2dsZSBvdmVybGF5UG9zaXRpb25cbiAgICAgICAgICogaW4gW25nQ2xhc3NdIGRpcmVjdGlvbiBhbmQgdGhpcyBkaXJlY3RpdmUgY2FuIHVzZSBvbmx5IHN0cmluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3ZlcmxheVBvc2l0aW9uID0gJyc7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb24gcGFzc2VkIHRocm91Z2ggY29udHJvbCB2YWx1ZSBhY2Nlc3NvciB0byBwcm9wYWdhdGUgY2hhbmdlcy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICgpID0+IHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYG91dGxpbmVgIHN0eWxlc1xuICAgICAqL1xuICAgIGdldCBvdXRsaW5lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBlYXJhbmNlID09PSAnb3V0bGluZSc7XG4gICAgfVxuICAgIHNldCBvdXRsaW5lKHZhbHVlKSB7XG4gICAgICAgIGlmIChjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVhcmFuY2UgPSAnb3V0bGluZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBgZmlsbGVkYCBzdHlsZXNcbiAgICAgKi9cbiAgICBnZXQgZmlsbGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBlYXJhbmNlID09PSAnZmlsbGVkJztcbiAgICB9XG4gICAgc2V0IGZpbGxlZCh2YWx1ZSkge1xuICAgICAgICBpZiAoY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hcHBlYXJhbmNlID0gJ2ZpbGxlZCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBgaGVyb2Agc3R5bGVzXG4gICAgICovXG4gICAgZ2V0IGhlcm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVhcmFuY2UgPT09ICdoZXJvJztcbiAgICB9XG4gICAgc2V0IGhlcm8odmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZWFyYW5jZSA9ICdoZXJvJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyB0aGUgc2VsZWN0XG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgc2V0IGVsZW1lbnQgd2lsbCBmaWxsIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBnZXQgZnVsbFdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZnVsbFdpZHRoO1xuICAgIH1cbiAgICBzZXQgZnVsbFdpZHRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxXaWR0aCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgc2VsZWN0ZWQgaXRlbSBvciBhcnJheSBvZiBzZWxlY3RlZCBpdGVtcy5cbiAgICAgKiAqL1xuICAgIHNldCBzZWxlY3RlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGxlXG4gICAgICAgICAgICA/IHRoaXMuc2VsZWN0aW9uTW9kZWwubWFwKG8gPT4gby52YWx1ZSlcbiAgICAgICAgICAgIDogdGhpcy5zZWxlY3Rpb25Nb2RlbFswXS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZXMgY2FwYWJpbGl0eSBqdXN0IHdyaXRlIGBtdWx0aXBsZWAgb3ZlciB0aGUgZWxlbWVudC5cbiAgICAgKiAqL1xuICAgIGdldCBtdWx0aXBsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX211bHRpcGxlO1xuICAgIH1cbiAgICBzZXQgbXVsdGlwbGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbXVsdGlwbGUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlzIHNlbGVjdCBvcGVuZWQuXG4gICAgICogKi9cbiAgICBnZXQgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWYgJiYgdGhpcy5yZWYuaGFzQXR0YWNoZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpcyBzZWxlY3QgaGlkZGVuLlxuICAgICAqICovXG4gICAgZ2V0IGlzSGlkZGVuKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXNPcGVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdpZHRoIG9mIHRoZSBzZWxlY3QgYnV0dG9uLlxuICAgICAqICovXG4gICAgZ2V0IGhvc3RXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnV0dG9uLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgfVxuICAgIGdldCBzZWxlY3RCdXR0b25DbGFzc2VzKCkge1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gW107XG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25Nb2RlbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgncGxhY2Vob2xkZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uTW9kZWwubGVuZ3RoICYmICF0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2VtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICBjbGFzc2VzLnB1c2godGhpcy5vdmVybGF5UG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgIH1cbiAgICBnZXQgb3B0aW9uc0xpc3RDbGFzc2VzKCkge1xuICAgICAgICBjb25zdCBjbGFzc2VzID0gW1xuICAgICAgICAgICAgYGFwcGVhcmFuY2UtJHt0aGlzLmFwcGVhcmFuY2V9YCxcbiAgICAgICAgICAgIGBzaXplLSR7dGhpcy5zaXplfWAsXG4gICAgICAgICAgICBgc2hhcGUtJHt0aGlzLnNoYXBlfWAsXG4gICAgICAgICAgICBgc3RhdHVzLSR7dGhpcy5zdGF0dXN9YCxcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVBvc2l0aW9uLFxuICAgICAgICBdO1xuICAgICAgICBpZiAodGhpcy5mdWxsV2lkdGgpIHtcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZnVsbC13aWR0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb250ZW50IHJlbmRlcmVkIGluIHRoZSBsYWJlbC5cbiAgICAgKiAqL1xuICAgIGdldCBzZWxlY3Rpb25WaWV3KCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb25Nb2RlbC5tYXAoKG9wdGlvbikgPT4gb3B0aW9uLmNvbnRlbnQpLmpvaW4oJywgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uTW9kZWxbMF0uY29udGVudDtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMuY2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpLCBzdGFydFdpdGgodGhpcy5vcHRpb25zKSwgZmlsdGVyKCgpID0+IHRoaXMucXVldWUgIT0gbnVsbCAmJiB0aGlzLmNhblNlbGVjdFZhbHVlKCkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBDYWxsICd3cml0ZVZhbHVlJyB3aGVuIGN1cnJlbnQgY2hhbmdlIGRldGVjdGlvbiBydW4gaXMgZmluaXNoZWQuXG4gICAgICAgICAgICAvLyBXaGVuIHdyaXRpbmcgaXMgZmluaXNoZWQsIGNoYW5nZSBkZXRlY3Rpb24gc3RhcnRzIGFnYWluLCBzaW5jZVxuICAgICAgICAgICAgLy8gbWljcm90YXNrcyBxdWV1ZSBpcyBlbXB0eS5cbiAgICAgICAgICAgIC8vIFByZXZlbnRzIEV4cHJlc3Npb25DaGFuZ2VkQWZ0ZXJJdEhhc0JlZW5DaGVja2VkRXJyb3IuXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlVmFsdWUodGhpcy5xdWV1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyU3RyYXRlZ3kgPSB0aGlzLmNyZWF0ZVRyaWdnZXJTdHJhdGVneSgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZU9uVHJpZ2dlcnMoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPbk9wdGlvbkNsaWNrKCk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWYuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXJTdHJhdGVneSkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyU3RyYXRlZ3kuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFRvT3ZlcmxheSgpO1xuICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVPcHRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnJlZi5kZXRhY2goKTtcbiAgICAgICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfVxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuYWxpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5TZWxlY3RWYWx1ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIG9wdGlvbiBvciBjbGVhciBhbGwgc2VsZWN0ZWQgb3B0aW9ucyBpZiB2YWx1ZSBpcyBudWxsLlxuICAgICAqICovXG4gICAgaGFuZGxlT3B0aW9uQ2xpY2sob3B0aW9uKSB7XG4gICAgICAgIHRoaXMucXVldWUgPSBudWxsO1xuICAgICAgICBpZiAob3B0aW9uLnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0T3B0aW9uKG9wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzZWxlY3QgYWxsIHNlbGVjdGVkIG9wdGlvbnMuXG4gICAgICogKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5mb3JFYWNoKChvcHRpb24pID0+IG9wdGlvbi5kZXNlbGVjdCgpKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbCA9IFtdO1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgdGhpcy5idXR0b24ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGlzLmVtaXRTZWxlY3RlZCh0aGlzLm11bHRpcGxlID8gW10gOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBob3cgdG8gc2VsZWN0IG9wdGlvbiBhcyBtdWx0aXBsZSBvciBzaW5nbGUuXG4gICAgICogKi9cbiAgICBzZWxlY3RPcHRpb24ob3B0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZU11bHRpcGxlU2VsZWN0KG9wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVNpbmdsZVNlbGVjdChvcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBzaW5nbGUgb3B0aW9uLlxuICAgICAqICovXG4gICAgaGFuZGxlU2luZ2xlU2VsZWN0KG9wdGlvbikge1xuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuc2VsZWN0aW9uTW9kZWwucG9wKCk7XG4gICAgICAgIGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZCAhPT0gb3B0aW9uKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5kZXNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwgPSBbb3B0aW9uXTtcbiAgICAgICAgb3B0aW9uLnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgdGhpcy5idXR0b24ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGlzLmVtaXRTZWxlY3RlZChvcHRpb24udmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgZm9yIG11bHRpcGxlIG9wdGlvbnMuXG4gICAgICogKi9cbiAgICBoYW5kbGVNdWx0aXBsZVNlbGVjdChvcHRpb24pIHtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbCA9IHRoaXMuc2VsZWN0aW9uTW9kZWwuZmlsdGVyKHMgPT4gcy52YWx1ZSAhPT0gb3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIG9wdGlvbi5kZXNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbC5wdXNoKG9wdGlvbik7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0U2VsZWN0ZWQodGhpcy5zZWxlY3Rpb25Nb2RlbC5tYXAoKG9wdCkgPT4gb3B0LnZhbHVlKSk7XG4gICAgfVxuICAgIGF0dGFjaFRvT3ZlcmxheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVPdmVybGF5KCk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZU9uUG9zaXRpb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlS2V5TWFuYWdlcigpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVPbk92ZXJsYXlLZXlzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWYuYXR0YWNoKHRoaXMucG9ydGFsKTtcbiAgICB9XG4gICAgc2V0QWN0aXZlT3B0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb25Nb2RlbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMua2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKHRoaXMuc2VsZWN0aW9uTW9kZWxbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5rZXlNYW5hZ2VyLnNldEZpcnN0SXRlbUFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZU92ZXJsYXkoKSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5jcmVhdGVTY3JvbGxTdHJhdGVneSgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uU3RyYXRlZ3kgPSB0aGlzLmNyZWF0ZVBvc2l0aW9uU3RyYXRlZ3koKTtcbiAgICAgICAgdGhpcy5yZWYgPSB0aGlzLm92ZXJsYXkuY3JlYXRlKHsgcG9zaXRpb25TdHJhdGVneTogdGhpcy5wb3NpdGlvblN0cmF0ZWd5LCBzY3JvbGxTdHJhdGVneSB9KTtcbiAgICB9XG4gICAgY3JlYXRlS2V5TWFuYWdlcigpIHtcbiAgICAgICAgdGhpcy5rZXlNYW5hZ2VyID0gdGhpcy5mb2N1c0tleU1hbmFnZXJGYWN0b3J5U2VydmljZS5jcmVhdGUodGhpcy5vcHRpb25zKS53aXRoVHlwZUFoZWFkKDIwMCk7XG4gICAgfVxuICAgIGNyZWF0ZVBvc2l0aW9uU3RyYXRlZ3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uQnVpbGRlclxuICAgICAgICAgICAgLmNvbm5lY3RlZFRvKHRoaXMuYnV0dG9uKVxuICAgICAgICAgICAgLnBvc2l0aW9uKE5iUG9zaXRpb24uQk9UVE9NKVxuICAgICAgICAgICAgLm9mZnNldCgwKVxuICAgICAgICAgICAgLmFkanVzdG1lbnQoTmJBZGp1c3RtZW50LlZFUlRJQ0FMKTtcbiAgICB9XG4gICAgY3JlYXRlU2Nyb2xsU3RyYXRlZ3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5ibG9jaygpO1xuICAgIH1cbiAgICBjcmVhdGVUcmlnZ2VyU3RyYXRlZ3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXJTdHJhdGVneUJ1aWxkZXJcbiAgICAgICAgICAgIC50cmlnZ2VyKE5iVHJpZ2dlci5DTElDSylcbiAgICAgICAgICAgIC5ob3N0KHRoaXMuaG9zdFJlZi5uYXRpdmVFbGVtZW50KVxuICAgICAgICAgICAgLmNvbnRhaW5lcigoKSA9PiB0aGlzLmdldENvbnRhaW5lcigpKVxuICAgICAgICAgICAgLmJ1aWxkKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZU9uVHJpZ2dlcnMoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5LnNob3ckLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNob3coKSk7XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5LmhpZGUkXG4gICAgICAgICAgICAucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5pc09wZW4pKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoJGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0NsaWNrZWRXaXRoaW5Db21wb25lbnQoJGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVPblBvc2l0aW9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uU3RyYXRlZ3kucG9zaXRpb25DaGFuZ2VcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHBvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVPbk9wdGlvbkNsaWNrKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHVzZXIgY2hhbmdlcyBwcm92aWRlZCBvcHRpb25zIGxpc3QgaW4gdGhlIHJ1bnRpbWUgd2UgaGF2ZSB0byBoYW5kbGUgdGhpc1xuICAgICAgICAgKiBhbmQgcmVzdWJzY3JpYmUgb24gb3B0aW9ucyBzZWxlY3Rpb24gY2hhbmdlcyBldmVudC5cbiAgICAgICAgICogT3RoZXJ3aXNlLCB0aGUgdXNlciB3aWxsIG5vdCBiZSBhYmxlIHRvIHNlbGVjdCBuZXcgb3B0aW9ucy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5vcHRpb25zLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKHN0YXJ0V2l0aCh0aGlzLm9wdGlvbnMpLCBzd2l0Y2hNYXAoKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtZXJnZSguLi5vcHRpb25zLm1hcChvcHRpb24gPT4gb3B0aW9uLmNsaWNrKSk7XG4gICAgICAgIH0pLCB0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChjbGlja2VkT3B0aW9uKSA9PiB0aGlzLmhhbmRsZU9wdGlvbkNsaWNrKGNsaWNrZWRPcHRpb24pKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlT25PdmVybGF5S2V5cygpIHtcbiAgICAgICAgdGhpcy5yZWYua2V5ZG93bkV2ZW50cygpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSksIGZpbHRlcigoKSA9PiB0aGlzLmlzT3BlbikpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5TWFuYWdlci5vbktleWRvd24oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5rZXlNYW5hZ2VyLnRhYk91dFxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb250YWluZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZiAmJiB0aGlzLnJlZi5oYXNBdHRhY2hlZCgpICYmIHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgbmF0aXZlRWxlbWVudDogdGhpcy5yZWYub3ZlcmxheUVsZW1lbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9wYWdhdGUgc2VsZWN0ZWQgdmFsdWUuXG4gICAgICogKi9cbiAgICBlbWl0U2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZShzZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdChzZWxlY3RlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBzZWxlY3RlZCB2YWx1ZSBpbiBtb2RlbC5cbiAgICAgKiAqL1xuICAgIHNldFNlbGVjdGlvbih2YWx1ZSkge1xuICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgYXNzaWduIHNpbmdsZSB2YWx1ZSBpZiBzZWxlY3QgaXMgbWFya2VkIGFzIG11bHRpcGxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBhc3NpZ24gYXJyYXkgaWYgc2VsZWN0IGlzIG5vdCBtYXJrZWQgYXMgbXVsdGlwbGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c2x5U2VsZWN0ZWRPcHRpb25zID0gdGhpcy5zZWxlY3Rpb25Nb2RlbDtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25Nb2RlbCA9IFtdO1xuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgob3B0aW9uKSA9PiB0aGlzLnNlbGVjdFZhbHVlKG9wdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCBvcHRpb25zIHdoaWNoIHdlcmUgc2VsZWN0ZWQgYmVmb3JlIGFuZCB0cmlnZ2VyIGRlc2VsZWN0XG4gICAgICAgIHByZXZpb3VzbHlTZWxlY3RlZE9wdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoKG9wdGlvbikgPT4gIXRoaXMuc2VsZWN0aW9uTW9kZWwuaW5jbHVkZXMob3B0aW9uKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChvcHRpb24pID0+IG9wdGlvbi5kZXNlbGVjdCgpKTtcbiAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB2YWx1ZS5cbiAgICAgKiAqL1xuICAgIHNlbGVjdFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNvcnJlc3BvbmRpbmcgPSB0aGlzLm9wdGlvbnMuZmluZCgob3B0aW9uKSA9PiBvcHRpb24udmFsdWUgPT09IHZhbHVlKTtcbiAgICAgICAgaWYgKGNvcnJlc3BvbmRpbmcpIHtcbiAgICAgICAgICAgIGNvcnJlc3BvbmRpbmcuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsLnB1c2goY29ycmVzcG9uZGluZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0b3VjaGVkIGlmIGZvY3VzIG1vdmVkIG91dHNpZGUgb2YgYnV0dG9uIGFuZCBvdmVybGF5LFxuICAgICAqIGlnbm9yaW5nIHRoZSBjYXNlIHdoZW4gZm9jdXMgbW92ZWQgdG8gb3B0aW9ucyBvdmVybGF5LlxuICAgICAqL1xuICAgIHRyeVNldFRvdWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzQ2xpY2tlZFdpdGhpbkNvbXBvbmVudCgkZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG9zdFJlZi5uYXRpdmVFbGVtZW50ID09PSAkZXZlbnQudGFyZ2V0IHx8IHRoaXMuaG9zdFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKCRldmVudC50YXJnZXQpO1xuICAgIH1cbiAgICBjYW5TZWxlY3RWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0IHRpbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICd0aW55JztcbiAgICB9XG4gICAgZ2V0IHNtYWxsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnc21hbGwnO1xuICAgIH1cbiAgICBnZXQgbWVkaXVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbWVkaXVtJztcbiAgICB9XG4gICAgZ2V0IGxhcmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaXplID09PSAnbGFyZ2UnO1xuICAgIH1cbiAgICBnZXQgZ2lhbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemUgPT09ICdnaWFudCc7XG4gICAgfVxuICAgIGdldCBwcmltYXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdwcmltYXJ5JztcbiAgICB9XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2luZm8nO1xuICAgIH1cbiAgICBnZXQgc3VjY2VzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnc3VjY2Vzcyc7XG4gICAgfVxuICAgIGdldCB3YXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGRhbmdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnZGFuZ2VyJztcbiAgICB9XG4gICAgZ2V0IGJhc2ljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdiYXNpYyc7XG4gICAgfVxuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdjb250cm9sJztcbiAgICB9XG4gICAgZ2V0IHJlY3RhbmdsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUgPT09ICdyZWN0YW5nbGUnO1xuICAgIH1cbiAgICBnZXQgcm91bmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYXBlID09PSAncm91bmQnO1xuICAgIH1cbiAgICBnZXQgc2VtaVJvdW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFwZSA9PT0gJ3NlbWktcm91bmQnO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDEzNShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwic3RhdHVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEzNShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcInNoYXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEzNShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcImFwcGVhcmFuY2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBJbnB1dCgpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5hcHBlYXJhbmNlLW91dGxpbmUnKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvdXRsaW5lXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzUoW1xuICAgIElucHV0KCksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmFwcGVhcmFuY2UtZmlsbGVkJyksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsbGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzUoW1xuICAgIElucHV0KCksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmFwcGVhcmFuY2UtaGVybycpLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcImhlcm9cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEzNShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBJbnB1dCgpLFxuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5mdWxsLXdpZHRoJyksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZnVsbFdpZHRoXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJwbGFjZWhvbGRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMzUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgTmJTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwibXVsdGlwbGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEzNShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE5iU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzZWxlY3RlZENoYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMzUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihOYk9wdGlvbkNvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgTmJTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcIm9wdGlvbnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBDb250ZW50Q2hpbGQoTmJTZWxlY3RMYWJlbENvbXBvbmVudCwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VzdG9tTGFiZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBWaWV3Q2hpbGQoTmJQb3J0YWxEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgTmJQb3J0YWxEaXJlY3RpdmUpXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwicG9ydGFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEzNShbXG4gICAgVmlld0NoaWxkKCdzZWxlY3RCdXR0b24nLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwiYnV0dG9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDEzNShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLm9wZW4nKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcImlzT3BlblwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS10aW55JyksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aW55XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zaXplLXNtYWxsJyksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzbWFsbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1tZWRpdW0nKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcIm1lZGl1bVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2l6ZS1sYXJnZScpLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwibGFyZ2VcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEzNShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNpemUtZ2lhbnQnKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcImdpYW50XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtcHJpbWFyeScpLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwicHJpbWFyeVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWluZm8nKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcImluZm9cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEzNShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1zdWNjZXNzJyksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzdWNjZXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtd2FybmluZycpLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwid2FybmluZ1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWRhbmdlcicpLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGFuZ2VyXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtYmFzaWMnKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJTZWxlY3RDb21wb25lbnQucHJvdG90eXBlLCBcImJhc2ljXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzUoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtY29udHJvbCcpLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2hhcGUtcmVjdGFuZ2xlJyksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyZWN0YW5nbGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDEzNShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnNoYXBlLXJvdW5kJyksXG4gICAgX19tZXRhZGF0YSQ4OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iU2VsZWN0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJyb3VuZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTM1KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc2hhcGUtc2VtaS1yb3VuZCcpLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDg5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VtaVJvdW5kXCIsIG51bGwpO1xuTmJTZWxlY3RDb21wb25lbnQgPSBOYlNlbGVjdENvbXBvbmVudF8xID0gX19kZWNvcmF0ZSQxMzUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItc2VsZWN0JyxcbiAgICAgICAgdGVtcGxhdGU6IFwiPGJ1dHRvbiBbZGlzYWJsZWRdPVxcXCJkaXNhYmxlZFxcXCJcXG4gICAgICAgIFtuZ0NsYXNzXT1cXFwic2VsZWN0QnV0dG9uQ2xhc3Nlc1xcXCJcXG4gICAgICAgIChibHVyKT1cXFwidHJ5U2V0VG91Y2hlZCgpXFxcIlxcbiAgICAgICAgKGtleWRvd24uYXJyb3dEb3duKT1cXFwic2hvdygpXFxcIlxcbiAgICAgICAgKGtleWRvd24uYXJyb3dVcCk9XFxcInNob3coKVxcXCJcXG4gICAgICAgIGNsYXNzPVxcXCJzZWxlY3QtYnV0dG9uXFxcIlxcbiAgICAgICAgdHlwZT1cXFwiYnV0dG9uXFxcIlxcbiAgICAgICAgI3NlbGVjdEJ1dHRvbj5cXG5cXG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cXFwic2VsZWN0aW9uTW9kZWwubGVuZ3RoOyBlbHNlIHBsYWNlaG9sZGVyVGVtcGxhdGVcXFwiPlxcbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XFxcImN1c3RvbUxhYmVsOyBlbHNlIGRlZmF1bHRTZWxlY3Rpb25UZW1wbGF0ZVxcXCI+XFxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcIm5iLXNlbGVjdC1sYWJlbFxcXCI+PC9uZy1jb250ZW50PlxcbiAgICAgIDwvbmctY29udGFpbmVyPlxcblxcbiAgICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdFNlbGVjdGlvblRlbXBsYXRlPnt7IHNlbGVjdGlvblZpZXcgfX08L25nLXRlbXBsYXRlPlxcbiAgICA8L25nLWNvbnRhaW5lcj5cXG5cXG4gICAgPG5nLXRlbXBsYXRlICNwbGFjZWhvbGRlclRlbXBsYXRlPnt7IHBsYWNlaG9sZGVyIH19PC9uZy10ZW1wbGF0ZT5cXG5cXG4gICAgPG5iLWljb24gaWNvbj1cXFwiY2hldnJvbi1kb3duLW91dGxpbmVcXFwiIHBhY2s9XFxcIm5lYnVsYXItZXNzZW50aWFsc1xcXCIgKGNsaWNrKT1cXFwiZGlzYWJsZWQgJiYgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+XFxuICAgIDwvbmItaWNvbj5cXG48L2J1dHRvbj5cXG5cXG48ZGl2ICpuYlBvcnRhbCBbbmdDbGFzc109XFxcIm9wdGlvbnNMaXN0Q2xhc3Nlc1xcXCIgW3N0eWxlLndpZHRoLnB4XT1cXFwiaG9zdFdpZHRoXFxcIiBjbGFzcz1cXFwib3B0aW9ucy1saXN0LWNvbnRhaW5lclxcXCI+XFxuICA8dWwgY2xhc3M9XFxcIm9wdGlvbnMtbGlzdFxcXCIgW2NsYXNzLmZ1bGwtd2lkdGhdPVxcXCJmdWxsV2lkdGhcXFwiPlxcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XFxcIm5iLW9wdGlvbiwgbmItb3B0aW9uLWdyb3VwXFxcIj48L25nLWNvbnRlbnQ+XFxuICA8L3VsPlxcbjwvZGl2PlxcblwiLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTmJTZWxlY3RDb21wb25lbnRfMSksXG4gICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9TRUxFQ1RfSU5KRUNUSU9OX1RPS0VOLCB1c2VFeGlzdGluZzogTmJTZWxlY3RDb21wb25lbnRfMSB9LFxuICAgICAgICBdLFxuICAgICAgICBzdHlsZXM6IFtcIi8qIVxcbiAqIEBsaWNlbnNlXFxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXFxuICovOmhvc3R7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWF4LXdpZHRoOjEwMCV9W2Rpcj1sdHJdIDpob3N0IC5zZWxlY3QtYnV0dG9ue3RleHQtYWxpZ246bGVmdH1bZGlyPWx0cl0gOmhvc3QgLnNlbGVjdC1idXR0b24gbmItaWNvbntyaWdodDowLjJlbX1bZGlyPXJ0bF0gOmhvc3QgLnNlbGVjdC1idXR0b257dGV4dC1hbGlnbjpyaWdodH1bZGlyPXJ0bF0gOmhvc3QgLnNlbGVjdC1idXR0b24gbmItaWNvbntsZWZ0OjAuMmVtfTpob3N0IC5zZWxlY3QtYnV0dG9uLmJvdHRvbXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MH06aG9zdCAuc2VsZWN0LWJ1dHRvbi50b3B7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjB9Omhvc3QoLmZ1bGwtd2lkdGgpe3dpZHRoOjEwMCV9LnNlbGVjdC1idXR0b257cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MTAwJTtvdmVyZmxvdzpoaWRkZW47dGV4dC1vdmVyZmxvdzplbGxpcHNpczt0ZXh0LXRyYW5zZm9ybTpub25lO3doaXRlLXNwYWNlOm5vd3JhcDt0cmFuc2l0aW9uLWR1cmF0aW9uOjAuMTVzO3RyYW5zaXRpb24tcHJvcGVydHk6YmFja2dyb3VuZC1jb2xvcixib3JkZXItY29sb3IsYm9yZGVyLXJhZGl1cyxib3gtc2hhZG93LGNvbG9yO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW59bmItaWNvbntmb250LXNpemU6MS41ZW07cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt0cmFuc2l0aW9uLWR1cmF0aW9uOjAuMTVzO3RyYW5zaXRpb24tcHJvcGVydHk6dHJhbnNmb3JtO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmVhc2UtaW59W2Rpcj1sdHJdIG5iLWljb257cmlnaHQ6LjVyZW19W2Rpcj1ydGxdIG5iLWljb257bGVmdDouNXJlbX06aG9zdCgub3BlbikgbmItaWNvbnt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKSByb3RhdGUoMTgwZGVnKX1cXG5cIl1cbiAgICB9KSxcbiAgICBfX3BhcmFtJDE5KDAsIEluamVjdChOQl9ET0NVTUVOVCkpLFxuICAgIF9fbWV0YWRhdGEkODkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBOYk92ZXJsYXlTZXJ2aWNlLFxuICAgICAgICBFbGVtZW50UmVmLFxuICAgICAgICBOYlBvc2l0aW9uQnVpbGRlclNlcnZpY2UsXG4gICAgICAgIE5iVHJpZ2dlclN0cmF0ZWd5QnVpbGRlclNlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBOYkZvY3VzS2V5TWFuYWdlckZhY3RvcnlTZXJ2aWNlXSlcbl0sIE5iU2VsZWN0Q29tcG9uZW50KTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxMzcgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkOTEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYk9wdGlvbkdyb3VwQ29tcG9uZW50ID0gY2xhc3MgTmJPcHRpb25Hcm91cENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zRGlzYWJsZWRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZEF0dHJpYnV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyAnJyA6IG51bGw7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYXN5bmNVcGRhdGVPcHRpb25zRGlzYWJsZWRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucy5jaGFuZ2VzXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuYXN5bmNVcGRhdGVPcHRpb25zRGlzYWJsZWRTdGF0ZSgpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBkaXNhYmxlZCBzdGF0ZSBmb3IgZWFjaCBvcHRpb24gdG8gY3VycmVudCBncm91cCBkaXNhYmxlZCBzdGF0ZS5cbiAgICAgKi9cbiAgICB1cGRhdGVPcHRpb25zRGlzYWJsZWRTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmZvckVhY2goKG9wdGlvbikgPT4gb3B0aW9uLnNldERpc2FibGVkQnlHcm91cFN0YXRlKHRoaXMuZGlzYWJsZWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBvcHRpb25zIGRpc2FibGVkIHN0YXRlIGFmdGVyIHByb21pc2UgcmVzb2x1dGlvbi5cbiAgICAgKiBUaGlzIHdheSBjaGFuZ2UgZGV0ZWN0aW9uIHdpbGwgYmUgdHJpZ2dlcmVkIGFmdGVyIG9wdGlvbnMgc3RhdGUgdXBkYXRlZC5cbiAgICAgKiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB1cGRhdGluZyBvcHRpb25zIGR1cmluZyBjaGFuZ2UgZGV0ZWN0aW9uIHJ1biAoZS5nLiBRdWVyeUxpc3QuY2hhbmdlcywgbGlmZWN5Y2xlIGhvb2tzKS5cbiAgICAgKi9cbiAgICBhc3luY1VwZGF0ZU9wdGlvbnNEaXNhYmxlZFN0YXRlKCkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHRoaXMudXBkYXRlT3B0aW9uc0Rpc2FibGVkU3RhdGUoKSk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTM3KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYk9wdGlvbkdyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxMzcoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ5MShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkOTEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYk9wdGlvbkdyb3VwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTM3KFtcbiAgICBIb3N0QmluZGluZygnYXR0ci5kaXNhYmxlZCcpLFxuICAgIF9fbWV0YWRhdGEkOTEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEkOTEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iT3B0aW9uR3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkQXR0cmlidXRlXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxMzcoW1xuICAgIENvbnRlbnRDaGlsZHJlbihOYk9wdGlvbkNvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhJDkxKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgTmJPcHRpb25Hcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB2b2lkIDApO1xuTmJPcHRpb25Hcm91cENvbXBvbmVudCA9IF9fZGVjb3JhdGUkMTM3KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLW9wdGlvbi1ncm91cCcsXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxzcGFuIGNsYXNzPVwib3B0aW9uLWdyb3VwLXRpdGxlXCI+e3sgdGl0bGUgfX08L3NwYW4+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibmItb3B0aW9uLCBuZy1jb250YWluZXJcIj48L25nLWNvbnRlbnQ+XG4gIGAsXG4gICAgICAgIHN0eWxlczogW1wiOmhvc3R7ZGlzcGxheTpibG9ja30ub3B0aW9uLWdyb3VwLXRpdGxle2Rpc3BsYXk6YmxvY2t9XFxuXCJdXG4gICAgfSlcbl0sIE5iT3B0aW9uR3JvdXBDb21wb25lbnQpO1xuXG52YXIgX19kZWNvcmF0ZSQxMzQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuY29uc3QgTkJfU0VMRUNUX0NPTVBPTkVOVFMgPSBbXG4gICAgTmJTZWxlY3RDb21wb25lbnQsXG4gICAgTmJPcHRpb25Db21wb25lbnQsXG4gICAgTmJPcHRpb25Hcm91cENvbXBvbmVudCxcbiAgICBOYlNlbGVjdExhYmVsQ29tcG9uZW50LFxuXTtcbmxldCBOYlNlbGVjdE1vZHVsZSA9IGNsYXNzIE5iU2VsZWN0TW9kdWxlIHtcbn07XG5OYlNlbGVjdE1vZHVsZSA9IF9fZGVjb3JhdGUkMTM0KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIE5iU2hhcmVkTW9kdWxlLFxuICAgICAgICAgICAgTmJPdmVybGF5TW9kdWxlLFxuICAgICAgICAgICAgTmJCdXR0b25Nb2R1bGUsXG4gICAgICAgICAgICBOYklucHV0TW9kdWxlLFxuICAgICAgICAgICAgTmJDYXJkTW9kdWxlLFxuICAgICAgICAgICAgTmJDaGVja2JveE1vZHVsZSxcbiAgICAgICAgICAgIE5iSWNvbk1vZHVsZSxcbiAgICAgICAgXSxcbiAgICAgICAgZXhwb3J0czogWy4uLk5CX1NFTEVDVF9DT01QT05FTlRTXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbLi4uTkJfU0VMRUNUX0NPTVBPTkVOVFNdLFxuICAgIH0pXG5dLCBOYlNlbGVjdE1vZHVsZSk7XG5cbnZhciBOYldpbmRvd1N0YXRlO1xuKGZ1bmN0aW9uIChOYldpbmRvd1N0YXRlKSB7XG4gICAgTmJXaW5kb3dTdGF0ZVtcIk1JTklNSVpFRFwiXSA9IFwibWluaW1pemVkXCI7XG4gICAgTmJXaW5kb3dTdGF0ZVtcIk1BWElNSVpFRFwiXSA9IFwibWF4aW1pemVkXCI7XG4gICAgTmJXaW5kb3dTdGF0ZVtcIkZVTExfU0NSRUVOXCJdID0gXCJmdWxsLXNjcmVlblwiO1xufSkoTmJXaW5kb3dTdGF0ZSB8fCAoTmJXaW5kb3dTdGF0ZSA9IHt9KSk7XG4vKipcbiAqIFdpbmRvdyBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKi9cbmNsYXNzIE5iV2luZG93Q29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvciguLi5jb25maWdzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaW5kb3cgdGl0bGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpdGxlID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsIHdpbmRvdyBzdGF0ZS4gRnVsbCBzY3JlZW4gYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbFN0YXRlID0gTmJXaW5kb3dTdGF0ZS5GVUxMX1NDUkVFTjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUgdGhhbiBiYWNrZHJvcCB3aWxsIGJlIHJlbmRlcmVkIGJlaGluZCB3aW5kb3cuXG4gICAgICAgICAqIEJ5IGRlZmF1bHQgc2V0IHRvIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhc0JhY2tkcm9wID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHNldCB0byB0cnVlIG1vdXNlIGNsaWNrcyBvbiBiYWNrZHJvcCB3aWxsIGNsb3NlIGEgd2luZG93LlxuICAgICAgICAgKiBEZWZhdWx0IGlzIHRydWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsb3NlT25CYWNrZHJvcENsaWNrID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUgdGhlbiBlc2NhcGUgcHJlc3Mgd2lsbCBjbG9zZSBhIHdpbmRvdy5cbiAgICAgICAgICogRGVmYXVsdCBpcyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZU9uRXNjID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHdpbmRvdy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2luZG93Q2xhc3MgPSAnJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdGgsIHRlbXBsYXRlIGFuZCBjb21wb25lbnQgbWF5IHJlY2VpdmUgZGF0YSB0aHJvdWdoIGBjb25maWcuY29udGV4dGAgcHJvcGVydHkuXG4gICAgICAgICAqIEZvciBjb21wb25lbnRzLCB0aGlzIGRhdGEgd2lsbCBiZSBzZXQgYXMgY29tcG9uZW50IHByb3BlcnRpZXMuXG4gICAgICAgICAqIEZvciB0ZW1wbGF0ZXMsIHlvdSBjYW4gYWNjZXNzIGl0IGluc2lkZSB0ZW1wbGF0ZSBhcyAkaW1wbGljaXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRleHQgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXJlIHRoZSBhdHRhY2hlZCBjb21wb25lbnQgc2hvdWxkIGxpdmUgaW4gQW5ndWxhcidzICpsb2dpY2FsKiBjb21wb25lbnQgdHJlZS5cbiAgICAgICAgICogVGhpcyBhZmZlY3RzIHdoYXQgaXMgYXZhaWxhYmxlIGZvciBpbmplY3Rpb24gYW5kIHRoZSBjaGFuZ2UgZGV0ZWN0aW9uIG9yZGVyIGZvciB0aGVcbiAgICAgICAgICogY29tcG9uZW50IGluc3RhbnRpYXRlZCBpbnNpZGUgb2YgdGhlIHdpbmRvdy4gVGhpcyBkb2VzIG5vdCBhZmZlY3Qgd2hlcmUgdGhlIHdpbmRvd1xuICAgICAgICAgKiBjb250ZW50IHdpbGwgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSBudWxsO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIC4uLmNvbmZpZ3MpO1xuICAgIH1cbn1cbmNvbnN0IE5CX1dJTkRPV19DT05URU5UID0gbmV3IEluamVjdGlvblRva2VuKCdOZWJ1bGFyIFdpbmRvdyBDb250ZW50Jyk7XG5jb25zdCBOQl9XSU5ET1dfQ09ORklHID0gbmV3IEluamVjdGlvblRva2VuKCdOZWJ1bGFyIFdpbmRvdyBDb25maWcnKTtcbmNvbnN0IE5CX1dJTkRPV19DT05URVhUID0gbmV3IEluamVjdGlvblRva2VuKCdOZWJ1bGFyIFdpbmRvdyBDb250ZXh0Jyk7XG5cbi8qKlxuICogVGhlIGBOYldpbmRvd1JlZmAgaGVscHMgdG8gbWFuaXB1bGF0ZSB3aW5kb3cgYWZ0ZXIgaXQgd2FzIGNyZWF0ZWQuXG4gKiBUaGUgd2luZG93IGNhbiBiZSBkaXNtaXNzZWQgYnkgdXNpbmcgYGNsb3NlYCBtZXRob2Qgb2YgdGhlIHdpbmRvd1JlZi5cbiAqIFlvdSBjYW4gYWNjZXNzIHJlbmRlcmVkIGNvbXBvbmVudCBhcyBgY29tcG9uZW50UmVmYCBwcm9wZXJ0eSBvZiB0aGUgd2luZG93UmVmLlxuICovXG5jbGFzcyBOYldpbmRvd1JlZiB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlJCA9IG5ldyBSZXBsYXlTdWJqZWN0KDEpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbG9zZWQkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IGNvbmZpZy5pbml0aWFsU3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgd2luZG93IHN0YXRlLlxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVWYWx1ZTtcbiAgICB9XG4gICAgc2V0IHN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmIChuZXdTdGF0ZSAmJiB0aGlzLnN0YXRlVmFsdWUgIT09IG5ld1N0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZTdGF0ZVZhbHVlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVWYWx1ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZSQubmV4dCh7IG9sZFN0YXRlOiB0aGlzLnByZXZTdGF0ZVZhbHVlLCBuZXdTdGF0ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyB3aGVuIHdpbmRvdyBzdGF0ZSBjaGFuZ2UuXG4gICAgICovXG4gICAgZ2V0IHN0YXRlQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZUNoYW5nZSQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gd2luZG93IHdhcyBjbG9zZWQuXG4gICAgICovXG4gICAgZ2V0IG9uQ2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlZCQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1pbmltaXplIHdpbmRvdy5cbiAgICAgKi9cbiAgICBtaW5pbWl6ZSgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IE5iV2luZG93U3RhdGUuTUlOSU1JWkVEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXhpbWl6ZSB3aW5kb3cuXG4gICAgICovXG4gICAgbWF4aW1pemUoKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBOYldpbmRvd1N0YXRlLk1BWElNSVpFRDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHdpbmRvdyBvbiB0b3AuXG4gICAgICovXG4gICAgZnVsbFNjcmVlbigpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IE5iV2luZG93U3RhdGUuRlVMTF9TQ1JFRU47XG4gICAgfVxuICAgIHRvUHJldmlvdXNTdGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJldlN0YXRlVmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB3aW5kb3cuXG4gICAgICogKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZSQuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5jbG9zZWQkLm5leHQoKTtcbiAgICAgICAgdGhpcy5jbG9zZWQkLmNvbXBsZXRlKCk7XG4gICAgfVxufVxuXG52YXIgX19kZWNvcmF0ZSQxNDAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkOTMgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbmxldCBOYldpbmRvd3NDb250YWluZXJDb21wb25lbnQgPSBjbGFzcyBOYldpbmRvd3NDb250YWluZXJDb21wb25lbnQge1xufTtcbl9fZGVjb3JhdGUkMTQwKFtcbiAgICBWaWV3Q2hpbGQoJ3ZpZXdDb250YWluZXJSZWYnLCB7IHJlYWQ6IFZpZXdDb250YWluZXJSZWYsIHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhJDkzKFwiZGVzaWduOnR5cGVcIiwgVmlld0NvbnRhaW5lclJlZilcbl0sIE5iV2luZG93c0NvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmlld0NvbnRhaW5lclJlZlwiLCB2b2lkIDApO1xuTmJXaW5kb3dzQ29udGFpbmVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxNDAoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItd2luZG93cy1jb250YWluZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgI3ZpZXdDb250YWluZXJSZWY+PC9uZy1jb250YWluZXI+YCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6ZmxleC1lbmQ7b3ZlcmZsb3cteDphdXRvfTpob3N0IDo6bmctZGVlcCBuYi13aW5kb3c6bm90KC5mdWxsLXNjcmVlbil7bWFyZ2luOjAgMnJlbX1cXG5cIl1cbiAgICB9KVxuXSwgTmJXaW5kb3dzQ29udGFpbmVyQ29tcG9uZW50KTtcblxudmFyIF9fZGVjb3JhdGUkMTQxID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDk0ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQyMiA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbmxldCBOYldpbmRvd0NvbXBvbmVudCA9IGNsYXNzIE5iV2luZG93Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZW50LCBjb250ZXh0LCB3aW5kb3dSZWYsIGNvbmZpZywgZm9jdXNUcmFwRmFjdG9yeSwgZWxlbWVudFJlZiwgcmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy53aW5kb3dSZWYgPSB3aW5kb3dSZWY7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmZvY3VzVHJhcEZhY3RvcnkgPSBmb2N1c1RyYXBGYWN0b3J5O1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfVxuICAgIGdldCBpc0Z1bGxTY3JlZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpbmRvd1JlZi5zdGF0ZSA9PT0gTmJXaW5kb3dTdGF0ZS5GVUxMX1NDUkVFTjtcbiAgICB9XG4gICAgZ2V0IG1heGltaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2luZG93UmVmLnN0YXRlID09PSBOYldpbmRvd1N0YXRlLk1BWElNSVpFRDtcbiAgICB9XG4gICAgZ2V0IG1pbmltaXplZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2luZG93UmVmLnN0YXRlID09PSBOYldpbmRvd1N0YXRlLk1JTklNSVpFRDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuZm9jdXNUcmFwID0gdGhpcy5mb2N1c1RyYXBGYWN0b3J5LmNyZWF0ZSh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuZm9jdXNUcmFwLmJsdXJQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5mb2N1c1RyYXAuZm9jdXNJbml0aWFsRWxlbWVudCgpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcud2luZG93Q2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMuY29uZmlnLndpbmRvd0NsYXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5vdmVybGF5Q29udGFpbmVyIHx8IHRoaXMub3ZlcmxheUNvbnRhaW5lci5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29udGVudCBpbnN0YW5jZW9mIFRlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFRlbXBsYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaENvbXBvbmVudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5mb2N1c1RyYXApIHtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNUcmFwLnJlc3RvcmVGb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgbWluaW1pemUoKSB7XG4gICAgICAgIGlmICh0aGlzLndpbmRvd1JlZi5zdGF0ZSA9PT0gTmJXaW5kb3dTdGF0ZS5NSU5JTUlaRUQpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93UmVmLnRvUHJldmlvdXNTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53aW5kb3dSZWYubWluaW1pemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXhpbWl6ZSgpIHtcbiAgICAgICAgdGhpcy53aW5kb3dSZWYubWF4aW1pemUoKTtcbiAgICB9XG4gICAgZnVsbFNjcmVlbigpIHtcbiAgICAgICAgdGhpcy53aW5kb3dSZWYuZnVsbFNjcmVlbigpO1xuICAgIH1cbiAgICBtYXhpbWl6ZU9yRnVsbFNjcmVlbigpIHtcbiAgICAgICAgaWYgKHRoaXMud2luZG93UmVmLnN0YXRlID09PSBOYldpbmRvd1N0YXRlLk1JTklNSVpFRCkge1xuICAgICAgICAgICAgdGhpcy5tYXhpbWl6ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mdWxsU2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMud2luZG93UmVmLmNsb3NlKCk7XG4gICAgfVxuICAgIGF0dGFjaFRlbXBsYXRlKCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlDb250YWluZXJcbiAgICAgICAgICAgIC5hdHRhY2hUZW1wbGF0ZVBvcnRhbChuZXcgTmJUZW1wbGF0ZVBvcnRhbCh0aGlzLmNvbnRlbnQsIG51bGwsIHRoaXMuY29udGV4dCkpO1xuICAgIH1cbiAgICBhdHRhY2hDb21wb25lbnQoKSB7XG4gICAgICAgIGNvbnN0IHBvcnRhbCA9IG5ldyBOYkNvbXBvbmVudFBvcnRhbCh0aGlzLmNvbnRlbnQsIG51bGwsIG51bGwsIHRoaXMuY2ZyKTtcbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5vdmVybGF5Q29udGFpbmVyLmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIHJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTQxKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTQoXCJkZXNpZ246dHlwZVwiLCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIpXG5dLCBOYldpbmRvd0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2ZyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDE0MShbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmZ1bGwtc2NyZWVuJyksXG4gICAgX19tZXRhZGF0YSQ5NChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ5NChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJXaW5kb3dDb21wb25lbnQucHJvdG90eXBlLCBcImlzRnVsbFNjcmVlblwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTQxKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubWF4aW1pemVkJyksXG4gICAgX19tZXRhZGF0YSQ5NChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ5NChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJXaW5kb3dDb21wb25lbnQucHJvdG90eXBlLCBcIm1heGltaXplZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTQxKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubWluaW1pemVkJyksXG4gICAgX19tZXRhZGF0YSQ5NChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ5NChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJXaW5kb3dDb21wb25lbnQucHJvdG90eXBlLCBcIm1pbmltaXplZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTQxKFtcbiAgICBWaWV3Q2hpbGQoTmJPdmVybGF5Q29udGFpbmVyQ29tcG9uZW50LCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YSQ5NChcImRlc2lnbjp0eXBlXCIsIE5iT3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudClcbl0sIE5iV2luZG93Q29tcG9uZW50LnByb3RvdHlwZSwgXCJvdmVybGF5Q29udGFpbmVyXCIsIHZvaWQgMCk7XG5OYldpbmRvd0NvbXBvbmVudCA9IF9fZGVjb3JhdGUkMTQxKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLXdpbmRvdycsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5iLWNhcmQ+XG4gICAgICA8bmItY2FyZC1oZWFkZXI+XG4gICAgICAgIDxkaXYgY2RrRm9jdXNJbml0aWFsIGNsYXNzPVwidGl0bGVcIiB0YWJpbmRleD1cIi0xXCI+e3sgY29uZmlnLnRpdGxlIH19PC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbnNcIj5cbiAgICAgICAgICA8YnV0dG9uIG5iQnV0dG9uIGdob3N0IChjbGljayk9XCJtaW5pbWl6ZSgpXCI+XG4gICAgICAgICAgICA8bmItaWNvbiBpY29uPVwibWludXMtb3V0bGluZVwiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIj48L25iLWljb24+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvbiBuYkJ1dHRvbiBnaG9zdCAqbmdJZj1cImlzRnVsbFNjcmVlblwiIChjbGljayk9XCJtYXhpbWl6ZSgpXCI+XG4gICAgICAgICAgICA8bmItaWNvbiBpY29uPVwiY29sbGFwc2Utb3V0bGluZVwiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIj48L25iLWljb24+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPGJ1dHRvbiBuYkJ1dHRvbiBnaG9zdCAqbmdJZj1cIm1pbmltaXplZCB8fCBtYXhpbWl6ZWRcIiAoY2xpY2spPVwibWF4aW1pemVPckZ1bGxTY3JlZW4oKVwiPlxuICAgICAgICAgICAgPG5iLWljb24gaWNvbj1cImV4cGFuZC1vdXRsaW5lXCIgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiPjwvbmItaWNvbj5cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8YnV0dG9uIG5iQnV0dG9uIGdob3N0IChjbGljayk9XCJjbG9zZSgpXCI+XG4gICAgICAgICAgICA8bmItaWNvbiBpY29uPVwiY2xvc2Utb3V0bGluZVwiIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIj48L25iLWljb24+XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9uYi1jYXJkLWhlYWRlcj5cbiAgICAgIDxuYi1jYXJkLWJvZHkgKm5nSWY9XCJtYXhpbWl6ZWQgfHwgaXNGdWxsU2NyZWVuXCI+XG4gICAgICAgIDxuYi1vdmVybGF5LWNvbnRhaW5lcj48L25iLW92ZXJsYXktY29udGFpbmVyPlxuICAgICAgPC9uYi1jYXJkLWJvZHk+XG4gICAgPC9uYi1jYXJkPlxuICBgLFxuICAgICAgICBzdHlsZXM6IFtcIjpob3N0e2ZsZXg6MSAwIGF1dG87bWluLXdpZHRoOjIwcmVtfTpob3N0IG5iLWNhcmR7bWFyZ2luOjB9Omhvc3QgbmItY2FyZC1oZWFkZXJ7ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpzcGFjZS1iZXR3ZWVuO2FsaWduLWl0ZW1zOmNlbnRlcjtvdmVyZmxvdzpoaWRkZW59Omhvc3QgLnRpdGxle2ZsZXg6MSAwIGF1dG87bWFyZ2luLXJpZ2h0OjNyZW07b3ZlcmZsb3c6aGlkZGVuO3RleHQtb3ZlcmZsb3c6ZWxsaXBzaXM7d2hpdGUtc3BhY2U6bm93cmFwfTpob3N0IC5idXR0b25ze3dpZHRoOjkuNXJlbTtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OnNwYWNlLWV2ZW5seX06aG9zdCAuYnV0dG9ucyBbbmJCdXR0b25de2ZsZXg6MCAwIDNyZW19Omhvc3QoLmZ1bGwtc2NyZWVuKXtwb3NpdGlvbjpmaXhlZDt0b3A6NTAlO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSwgLTUwJSl9Omhvc3QoLm1heGltaXplZCkgbmItY2FyZHtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MH06aG9zdCgubWluaW1pemVkKSBuYi1jYXJke2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czowO2hlaWdodDphdXRvfTpob3N0KC5taW5pbWl6ZWQpIG5iLWNhcmQgbmItY2FyZC1oZWFkZXJ7Ym9yZGVyLWJvdHRvbTpub25lfVxcblwiXVxuICAgIH0pLFxuICAgIF9fcGFyYW0kMjIoMCwgSW5qZWN0KE5CX1dJTkRPV19DT05URU5UKSksXG4gICAgX19wYXJhbSQyMigxLCBJbmplY3QoTkJfV0lORE9XX0NPTlRFWFQpKSxcbiAgICBfX21ldGFkYXRhJDk0KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdCwgT2JqZWN0LFxuICAgICAgICBOYldpbmRvd1JlZixcbiAgICAgICAgTmJXaW5kb3dDb25maWcsXG4gICAgICAgIE5iRm9jdXNUcmFwRmFjdG9yeVNlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIFJlbmRlcmVyMl0pXG5dLCBOYldpbmRvd0NvbXBvbmVudCk7XG5cbnZhciBfX2RlY29yYXRlJDEzOSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ5MiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMjEgPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG4vKipcbiAqIFRoZSBgTmJXaW5kb3dTZXJ2aWNlYCBjYW4gYmUgdXNlZCB0byBvcGVuIHdpbmRvd3MuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgd2luZG93L3dpbmRvdy1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogIyMjIEluc3RhbGxhdGlvblxuICpcbiAqIEltcG9ydCBgTmJXaW5kb3dNb2R1bGVgIHRvIHlvdXIgYXBwIG1vZHVsZS5cbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJXaW5kb3dNb2R1bGUuZm9yUm9vdChjb25maWcpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqXG4gKiBJZiB5b3UgYXJlIHVzaW5nIGl0IGluIGEgbGF6eSBsb2FkZWQgbW9kdWxlIHRoYW4geW91IGhhdmUgdG8gaW5zdGFsbCBgTmJXaW5kb3dNb2R1bGUuZm9yQ2hpbGRgOlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYldpbmRvd01vZHVsZS5mb3JDaGlsZChjb25maWcpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBMYXp5TG9hZGVkTW9kdWxlIHsgfVxuICogYGBgXG4gKlxuICogIyMjIFVzYWdlXG4gKlxuICogQSBuZXcgd2luZG93IGNhbiBiZSBvcGVuZWQgYnkgY2FsbGluZyB0aGUgYG9wZW5gIG1ldGhvZCB3aXRoIGEgY29tcG9uZW50IG9yIHRlbXBsYXRlIHRvIGJlIGxvYWRlZFxuICogYW5kIGFuIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24uXG4gKiBgb3BlbmAgbWV0aG9kIHdpbGwgcmV0dXJuIGBOYldpbmRvd1JlZmAgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIGZ1cnRoZXIgbWFuaXB1bGF0aW9ucy5cbiAqXG4gKiBgYGB0c1xuICogY29uc3Qgd2luZG93UmVmID0gdGhpcy53aW5kb3dTZXJ2aWNlLm9wZW4oTXlDb21wb25lbnQsIHsgLi4uIH0pO1xuICogYGBgXG4gKlxuICogYE5iV2luZG93UmVmYCBnaXZlcyB5b3UgYWJpbGl0eSBtYW5pcHVsYXRlIG9wZW5lZCB3aW5kb3cuXG4gKiBBbHNvLCB5b3UgY2FuIGluamVjdCBgTmJXaW5kb3dSZWZgIGluc2lkZSBwcm92aWRlZCBjb21wb25lbnQgd2hpY2ggcmVuZGVyZWQgaW4gd2luZG93LlxuICpcbiAqIGBgYHRzXG4gKiB0aGlzLndpbmRvd1NlcnZpY2Uub3BlbihNeVdpbmRvd0NvbXBvbmVudCwgeyAuLi4gfSk7XG4gKlxuICogLy8gbXkuY29tcG9uZW50LnRzXG4gKiBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgd2luZG93UmVmOiBOYldpbmRvd1JlZikge1xuICogfVxuICpcbiAqIG1pbmltaXplKCkge1xuICogICB0aGlzLndpbmRvd1JlZi5taW5pbWl6ZSgpO1xuICogfVxuICpcbiAqIGNsb3NlKCkge1xuICogICB0aGlzLndpbmRvd1JlZi5jbG9zZSgpO1xuICogfVxuICogYGBgXG4gKlxuICogSW5zdGVhZCBvZiBjb21wb25lbnQgeW91IGNhbiBjcmVhdGUgd2luZG93IGZyb20gVGVtcGxhdGVSZWYuIEFzIHVzdWFsIHlvdSBjYW4gYWNjZXNzIGNvbnRleHQgcHJvdmlkZWQgdmlhIGNvbmZpZ1xuICogdmlhIGBsZXQtYCB2YXJpYWJsZXMuIEFsc28geW91IGNhbiBnZXQgcmVmZXJlbmNlIHRvIHRoZSBgTmJXaW5kb3dSZWZgIGluIGNvbnRleHQncyBgd2luZG93UmVmYCBwcm9wZXJ0eS5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFdpbmRvdyBjb250ZW50IGZyb20gVGVtcGxhdGVSZWYsIHdpbmRvdy90ZW1wbGF0ZS13aW5kb3cuY29tcG9uZW50KVxuICpcbiAqICMjIyBDb25maWd1cmF0aW9uXG4gKlxuICogQXMgbWVudGlvbmVkIGFib3ZlLCBgb3BlbmAgbWV0aG9kIG9mIHRoZSBgTmJXaW5kb3dTZXJ2aWNlYCBtYXkgcmVjZWl2ZSBvcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKiBBbHNvLCB5b3UgY2FuIG1vZGlmeSBkZWZhdWx0IHdpbmRvd3MgY29uZmlndXJhdGlvbiB0aHJvdWdoIGBOYldpbmRvd01vZHVsZS5mb3JSb290KHsgLi4uIH0pYC5cbiAqIFlvdSBjYW4gcmVhZCBhYm91dCBhbGwgYXZhaWxhYmxlIG9wdGlvbnMgb24gW0FQSSB0YWJdKGRvY3MvY29tcG9uZW50cy93aW5kb3cvYXBpI25id2luZG93Y29uZmlnKS5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKENvbmZpZ3VyYXRpb24sIHdpbmRvdy93aW5kb3dzLWJhY2tkcm9wLmNvbXBvbmVudClcbiAqL1xubGV0IE5iV2luZG93U2VydmljZSA9IGNsYXNzIE5iV2luZG93U2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBvdmVybGF5U2VydmljZSwgb3ZlcmxheVBvc2l0aW9uQnVpbGRlciwgYmxvY2tTY3JvbGxTdHJhdGVneSwgZGVmYXVsdFdpbmRvd3NDb25maWcsIGNmciwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIgPSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI7XG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UgPSBvdmVybGF5U2VydmljZTtcbiAgICAgICAgdGhpcy5vdmVybGF5UG9zaXRpb25CdWlsZGVyID0gb3ZlcmxheVBvc2l0aW9uQnVpbGRlcjtcbiAgICAgICAgdGhpcy5ibG9ja1Njcm9sbFN0cmF0ZWd5ID0gYmxvY2tTY3JvbGxTdHJhdGVneTtcbiAgICAgICAgdGhpcy5kZWZhdWx0V2luZG93c0NvbmZpZyA9IGRlZmF1bHRXaW5kb3dzQ29uZmlnO1xuICAgICAgICB0aGlzLmNmciA9IGNmcjtcbiAgICAgICAgdGhpcy5vcGVuV2luZG93cyA9IFtdO1xuICAgICAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIG5ldyB3aW5kb3cuXG4gICAgICogQHBhcmFtIHdpbmRvd0NvbnRlbnRcbiAgICAgKiBAcGFyYW0gd2luZG93Q29uZmlnXG4gICAgICogKi9cbiAgICBvcGVuKHdpbmRvd0NvbnRlbnQsIHdpbmRvd0NvbmZpZyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZENyZWF0ZVdpbmRvd3NDb250YWluZXIoKSkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVXaW5kb3dzQ29udGFpbmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnID0gbmV3IE5iV2luZG93Q29uZmlnKHRoaXMuZGVmYXVsdFdpbmRvd3NDb25maWcsIHdpbmRvd0NvbmZpZyk7XG4gICAgICAgIGNvbnN0IHdpbmRvd1JlZiA9IG5ldyBOYldpbmRvd1JlZihjb25maWcpO1xuICAgICAgICB3aW5kb3dSZWYuY29tcG9uZW50UmVmID0gdGhpcy5hcHBlbmRXaW5kb3cod2luZG93Q29udGVudCwgY29uZmlnLCB3aW5kb3dSZWYpO1xuICAgICAgICB0aGlzLm9wZW5XaW5kb3dzLnB1c2god2luZG93UmVmKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb0V2ZW50cyh3aW5kb3dSZWYpO1xuICAgICAgICByZXR1cm4gd2luZG93UmVmO1xuICAgIH1cbiAgICBzaG91bGRDcmVhdGVXaW5kb3dzQ29udGFpbmVyKCkge1xuICAgICAgICBpZiAodGhpcy53aW5kb3dzQ29udGFpbmVyVmlld1JlZikge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyRWwgPSB0aGlzLndpbmRvd3NDb250YWluZXJWaWV3UmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5kb2N1bWVudC5ib2R5LmNvbnRhaW5zKGNvbnRhaW5lckVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY3JlYXRlV2luZG93c0NvbnRhaW5lcigpIHtcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm92ZXJsYXlSZWYgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLmNyZWF0ZSh7XG4gICAgICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5vdmVybGF5U2VydmljZS5zY3JvbGxTdHJhdGVnaWVzLm5vb3AoKSxcbiAgICAgICAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMub3ZlcmxheVBvc2l0aW9uQnVpbGRlci5nbG9iYWwoKS5ib3R0b20oKS5yaWdodCgpLFxuICAgICAgICAgICAgaGFzQmFja2Ryb3A6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB3aW5kb3dzQ29udGFpbmVyUG9ydGFsID0gbmV3IE5iQ29tcG9uZW50UG9ydGFsKE5iV2luZG93c0NvbnRhaW5lckNvbXBvbmVudCwgbnVsbCwgbnVsbCwgdGhpcy5jZnIpO1xuICAgICAgICBjb25zdCBvdmVybGF5UmVmID0gdGhpcy5vdmVybGF5UmVmLmF0dGFjaCh3aW5kb3dzQ29udGFpbmVyUG9ydGFsKTtcbiAgICAgICAgdGhpcy53aW5kb3dzQ29udGFpbmVyVmlld1JlZiA9IG92ZXJsYXlSZWYuaW5zdGFuY2Uudmlld0NvbnRhaW5lclJlZjtcbiAgICB9XG4gICAgYXBwZW5kV2luZG93KGNvbnRlbnQsIGNvbmZpZywgd2luZG93UmVmKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjb250ZW50IGluc3RhbmNlb2YgVGVtcGxhdGVSZWZcbiAgICAgICAgICAgID8geyAkaW1wbGljaXQ6IGNvbmZpZy5jb250ZXh0LCB3aW5kb3dSZWYgfVxuICAgICAgICAgICAgOiBjb25maWcuY29udGV4dDtcbiAgICAgICAgY29uc3QgcHJvdmlkZXJzID0gW1xuICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9XSU5ET1dfQ09OVEVOVCwgdXNlVmFsdWU6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTkJfV0lORE9XX0NPTlRFWFQsIHVzZVZhbHVlOiBjb250ZXh0IH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IE5iV2luZG93Q29uZmlnLCB1c2VWYWx1ZTogY29uZmlnIH0sXG4gICAgICAgICAgICB7IHByb3ZpZGU6IE5iV2luZG93UmVmLCB1c2VWYWx1ZTogd2luZG93UmVmIH0sXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHBhcmVudEluamVjdG9yID0gY29uZmlnLnZpZXdDb250YWluZXJSZWZcbiAgICAgICAgICAgID8gY29uZmlnLnZpZXdDb250YWluZXJSZWYuaW5qZWN0b3JcbiAgICAgICAgICAgIDogdGhpcy53aW5kb3dzQ29udGFpbmVyVmlld1JlZi5pbmplY3RvcjtcbiAgICAgICAgY29uc3QgaW5qZWN0b3IgPSBJbmplY3Rvci5jcmVhdGUoeyBwYXJlbnQ6IHBhcmVudEluamVjdG9yLCBwcm92aWRlcnMgfSk7XG4gICAgICAgIGNvbnN0IHdpbmRvd0ZhY3RvcnkgPSB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShOYldpbmRvd0NvbXBvbmVudCk7XG4gICAgICAgIGNvbnN0IHJlZiA9IHRoaXMud2luZG93c0NvbnRhaW5lclZpZXdSZWYuY3JlYXRlQ29tcG9uZW50KHdpbmRvd0ZhY3RvcnksIG51bGwsIGluamVjdG9yKTtcbiAgICAgICAgcmVmLmluc3RhbmNlLmNmciA9IHRoaXMuY2ZyO1xuICAgICAgICByZWYuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUb0V2ZW50cyh3aW5kb3dSZWYpIHtcbiAgICAgICAgaWYgKHdpbmRvd1JlZi5jb25maWcuY2xvc2VPbkJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVJlZi5iYWNrZHJvcENsaWNrKCkuc3Vic2NyaWJlKCgpID0+IHdpbmRvd1JlZi5jbG9zZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93UmVmLmNvbmZpZy5jbG9zZU9uRXNjKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYua2V5ZG93bkV2ZW50cygpXG4gICAgICAgICAgICAgICAgLnBpcGUoZmlsdGVyKChldmVudCkgPT4gZXZlbnQua2V5Q29kZSA9PT0gMjcpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gd2luZG93UmVmLmNsb3NlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvd1JlZi5zdGF0ZUNoYW5nZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jaGVja0FuZFVwZGF0ZU92ZXJsYXkoKSk7XG4gICAgICAgIHdpbmRvd1JlZi5vbkNsb3NlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9wZW5XaW5kb3dzLnNwbGljZSh0aGlzLm9wZW5XaW5kb3dzLmluZGV4T2Yod2luZG93UmVmKSwgMSk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQW5kVXBkYXRlT3ZlcmxheSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hlY2tBbmRVcGRhdGVPdmVybGF5KCkge1xuICAgICAgICBjb25zdCBmdWxsU2NyZWVuV2luZG93cyA9IHRoaXMub3BlbldpbmRvd3MuZmlsdGVyKHcgPT4gdy5zdGF0ZSA9PT0gTmJXaW5kb3dTdGF0ZS5GVUxMX1NDUkVFTik7XG4gICAgICAgIGlmIChmdWxsU2NyZWVuV2luZG93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrU2Nyb2xsU3RyYXRlZ3kuZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJsb2NrU2Nyb2xsU3RyYXRlZ3kuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdWxsU2NyZWVuV2luZG93cy5zb21lKHcgPT4gdy5jb25maWcuaGFzQmFja2Ryb3ApKSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYuYmFja2Ryb3BFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYuYmFja2Ryb3BFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGlkZGVuJywgJycpO1xuICAgICAgICB9XG4gICAgfVxufTtcbk5iV2luZG93U2VydmljZSA9IF9fZGVjb3JhdGUkMTM5KFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19wYXJhbSQyMSg0LCBJbmplY3QoTkJfV0lORE9XX0NPTkZJRykpLFxuICAgIF9fcGFyYW0kMjEoNiwgSW5qZWN0KE5CX0RPQ1VNRU5UKSksXG4gICAgX19tZXRhZGF0YSQ5MihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIE5iT3ZlcmxheVNlcnZpY2UsXG4gICAgICAgIE5iT3ZlcmxheVBvc2l0aW9uQnVpbGRlcixcbiAgICAgICAgTmJCbG9ja1Njcm9sbFN0cmF0ZWd5QWRhcHRlcixcbiAgICAgICAgTmJXaW5kb3dDb25maWcsXG4gICAgICAgIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgT2JqZWN0XSlcbl0sIE5iV2luZG93U2VydmljZSk7XG5cbnZhciBfX2RlY29yYXRlJDEzOCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgTmJXaW5kb3dNb2R1bGVfMTtcbmxldCBOYldpbmRvd01vZHVsZSA9IE5iV2luZG93TW9kdWxlXzEgPSBjbGFzcyBOYldpbmRvd01vZHVsZSB7XG4gICAgc3RhdGljIGZvclJvb3QoZGVmYXVsdENvbmZpZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iV2luZG93TW9kdWxlXzEsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICBOYldpbmRvd1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9XSU5ET1dfQ09ORklHLCB1c2VWYWx1ZTogZGVmYXVsdENvbmZpZyB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZvckNoaWxkKGRlZmF1bHRDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBOYldpbmRvd01vZHVsZV8xLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgTmJXaW5kb3dTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogTkJfV0lORE9XX0NPTkZJRywgdXNlVmFsdWU6IGRlZmF1bHRDb25maWcgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbk5iV2luZG93TW9kdWxlID0gTmJXaW5kb3dNb2R1bGVfMSA9IF9fZGVjb3JhdGUkMTM4KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE5iT3ZlcmxheU1vZHVsZSwgTmJDYXJkTW9kdWxlLCBOYkljb25Nb2R1bGUsIE5iQnV0dG9uTW9kdWxlXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBOYldpbmRvd3NDb250YWluZXJDb21wb25lbnQsXG4gICAgICAgICAgICBOYldpbmRvd0NvbXBvbmVudCxcbiAgICAgICAgXSxcbiAgICAgICAgZW50cnlDb21wb25lbnRzOiBbTmJXaW5kb3dzQ29udGFpbmVyQ29tcG9uZW50LCBOYldpbmRvd0NvbXBvbmVudF0sXG4gICAgfSlcbl0sIE5iV2luZG93TW9kdWxlKTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxNDMgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkOTUgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDIzID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xudmFyIE5iRGF0ZXBpY2tlckRpcmVjdGl2ZV8xO1xuLyoqXG4gKiBUaGUgYE5iRGF0ZXBpY2tlckFkYXB0ZXJgIGluc3RhbmNlcyBwcm92aWRlIHdheSBob3cgdG8gcGFyc2UsIGZvcm1hdCBhbmQgdmFsaWRhdGVcbiAqIGRpZmZlcmVudCBkYXRlIHR5cGVzLlxuICogKi9cbmNsYXNzIE5iRGF0ZXBpY2tlckFkYXB0ZXIge1xufVxuLyoqXG4gKiBEYXRlcGlja2VyIGlzIGFuIGNvbnRyb2wgdGhhdCBjYW4gcGljayBhbnkgdmFsdWVzIGFueXdheS5cbiAqIEl0IGhhcyB0byBiZSBib3VuZCB0byB0aGUgZGF0ZXBpY2tlciBkaXJlY3RpdmUgdGhyb3VnaCBuYkRhdGVwaWNrZXIgaW5wdXQuXG4gKiAqL1xuY2xhc3MgTmJEYXRlcGlja2VyIHtcbn1cbmNvbnN0IE5CX0RBVEVfQURBUFRFUiA9IG5ldyBJbmplY3Rpb25Ub2tlbignRGF0ZXBpY2tlciBBZGFwdGVyJyk7XG5jb25zdCBOQl9EQVRFX1NFUlZJQ0VfT1BUSU9OUyA9IG5ldyBJbmplY3Rpb25Ub2tlbignRGF0ZSBzZXJ2aWNlIG9wdGlvbnMnKTtcbi8qKlxuICogVGhlIGBOYkRhdGVwaWNrZXJEaXJlY3RpdmVgIGlzIGZvcm0gY29udHJvbCB0aGF0IGdpdmVzIHlvdSBhYmlsaXR5IHRvIHNlbGVjdCBkYXRlcyBhbmQgcmFuZ2VzLiBUaGUgZGF0ZXBpY2tlclxuICogaXMgc2hvd24gd2hlbiBpbnB1dCByZWNlaXZlcyBhIGBmb2N1c2AgZXZlbnQuXG4gKlxuICogYGBgaHRtbFxuICogPGlucHV0IFtuYkRhdGVwaWNrZXJdPVwiZGF0ZXBpY2tlclwiPlxuICogPG5iLWRhdGVwaWNrZXIgI2RhdGVwaWNrZXI+PC9uYi1kYXRlcGlja2VyPlxuICogYGBgXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShTaG93Y2FzZSwgZGF0ZXBpY2tlci9kYXRlcGlja2VyLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYkRhdGVwaWNrZXJNb2R1bGUuZm9yUm9vdCgpYCB0byB5b3VyIHJvb3QgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkRhdGVwaWNrZXJNb2R1bGUuZm9yUm9vdCgpLFxuICogICBdLFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUgeyB9XG4gKiBgYGBcbiAqIEFuZCBgTmJEYXRlcGlja2VyTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYkRhdGVwaWNrZXJNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqICMjIyBVc2FnZVxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSByYW5nZSBzZWxlY3Rpb24sIHlvdSBoYXZlIHRvIHVzZSBgTmJSYW5nZXBpY2tlckNvbXBvbmVudGAgaW5zdGVhZDpcbiAqXG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgW25iRGF0ZXBpY2tlcl09XCJyYW5nZXBpY2tlclwiPlxuICogPG5iLXJhbmdlcGlja2VyICNyYW5nZXBpY2tlcj48L25iLXJhbmdlcGlja2VyPlxuICogYGBgXG4gKlxuICogQm90aCByYW5nZSBhbmQgZGF0ZSBwaWNrZXJzIHN1cHBvcnQgYWxsIHBhcmFtZXRlcnMgYXMgY2FsZW5kYXIsIHNvLCBjaGVjayBgTmJDYWxlbmRhckNvbXBvbmVudGAgZm9yIGFkZGl0aW9uYWxcbiAqIGluZm8uXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShSYW5nZSBzaG93Y2FzZSwgZGF0ZXBpY2tlci9yYW5nZXBpY2tlci1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogRGF0ZXBpY2tlciBpcyB0aGUgZm9ybSBjb250cm9sIHNvIGl0IGNhbiBiZSBib3VuZCB3aXRoIGFuZ3VsYXIgZm9ybXMgdGhyb3VnaCBuZ01vZGVsIGFuZCBmb3JtIGNvbnRyb2xzLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRm9ybXMsIGRhdGVwaWNrZXIvZGF0ZXBpY2tlci1mb3Jtcy5jb21wb25lbnQpXG4gKlxuICogYE5iRGF0ZXBpY2tlckRpcmVjdGl2ZWAgbWF5IGJlIHZhbGlkYXRlZCB1c2luZyBgbWluYCBhbmQgYG1heGAgZGF0ZXMgcGFzc2VkIHRvIHRoZSBkYXRlcGlja2VyLlxuICogQW5kIGBmaWx0ZXJgIHByZWRpY2F0ZSB0aGF0IHJlY2VpdmVzIGRhdGUgb2JqZWN0IGFuZCBoYXMgdG8gcmV0dXJuIGEgYm9vbGVhbiB2YWx1ZS5cbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFZhbGlkYXRpb24sIGRhdGVwaWNrZXIvZGF0ZXBpY2tlci12YWxpZGF0aW9uLmNvbXBvbmVudClcbiAqXG4gKiBUaGUgYE5iRGF0ZXBpY2tlckNvbXBvbmVudGAgc3VwcG9ydHMgZGF0ZSBmb3JtYXR0aW5nOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBbbmJEYXRlcGlja2VyXT1cImRhdGVwaWNrZXJcIj5cbiAqIDxuYi1kYXRlcGlja2VyICNkYXRlcGlja2VyIGZvcm1hdD1cIk1NXFxkZFxceXl5eVwiPjwvbmItZGF0ZXBpY2tlcj5cbiAqIGBgYFxuICpcbiAqICMjIEZvcm1hdHRpbmcgSXNzdWVcbiAqXG4gKiBCeSBkZWZhdWx0LCBkYXRlcGlja2VyIHVzZXMgYW5ndWxhcnMgYExPQ0FMRV9JRGAgdG9rZW4gZm9yIGxvY2FsaXphdGlvbiBhbmQgYERhdGVQaXBlYCBmb3IgZGF0ZXMgZm9ybWF0dGluZy5cbiAqIEFuZCBuYXRpdmUgYERhdGUucGFyc2UoLi4uKWAgZm9yIGRhdGVzIHBhcnNpbmcuIEJ1dCBuYXRpdmUgYERhdGUucGFyc2VgIGZ1bmN0aW9uIGRvZXNuJ3Qgc3VwcG9ydCBmb3JtYXRzLlxuICogVG8gcHJvdmlkZSBjdXN0b20gZm9ybWF0dGluZyB5b3UgaGF2ZSB0byB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmcgcGFja2FnZXM6XG4gKlxuICogLSBgQG5lYnVsYXIvbW9tZW50YCAtIHByb3ZpZGVzIG1vbWVudCBkYXRlIGFkYXB0ZXIgdGhhdCB1c2VzIG1vbWVudCBmb3IgZGF0ZSBvYmplY3RzLiBUaGlzIG1lYW5zIGRhdGVwaWNrZXIgdGhhblxuICogd2lsbCBvcGVyYXRlIG9ubHkgbW9tZW50IGRhdGUgb2JqZWN0cy4gSWYgeW91IHdhbnQgdG8gdXNlIGl0IHlvdSBoYXZlIHRvIGluc3RhbGwgaXQ6IGBucG0gaSBAbmVidWxhci9tb21lbnRgLCBhbmRcbiAqIGltcG9ydCBgTmJNb21lbnREYXRlTW9kdWxlYCBmcm9tIHRoaXMgcGFja2FnZS5cbiAqXG4gKiAtIGBAbmVidWxhci9kYXRlLWZuc2AgLSBhZGFwdGVyIGZvciBwb3B1bGFyIGRhdGUtZm5zIGxpYnJhcnkuIFRoaXMgd2F5IGlzIHByZWZlcnJlZCBpZiB5b3UgbmVlZCBvbmx5IGRhdGUgZm9ybWF0dGluZy5cbiAqIEJlY2F1c2UgZGF0ZS1mbnMgaXMgdHJlZXNoYWthYmxlLCB0aW55IGFuZCBvcGVyYXRlcyBuYXRpdmUgZGF0ZSBvYmplY3RzLiBJZiB5b3Ugd2FudCB0byB1c2UgaXQgeW91IGhhdmUgdG9cbiAqIGluc3RhbGwgaXQ6IGBucG0gaSBAbmVidWxhci9kYXRlLWZuc2AsIGFuZCBpbXBvcnQgYE5iRGF0ZUZuc0RhdGVNb2R1bGVgIGZyb20gdGhpcyBwYWNrYWdlLlxuICpcbiAqICMjIyBOYkRhdGVGbnNEYXRlTW9kdWxlXG4gKlxuICogRm9ybWF0IGlzIHJlcXVpcmVkIHdoZW4gdXNpbmcgYE5iRGF0ZUZuc0RhdGVNb2R1bGVgLiBZb3UgY2FuIHNldCBpdCB2aWEgYGZvcm1hdGAgaW5wdXQgb24gZGF0ZXBpY2tlciBjb21wb25lbnQ6XG4gKiBgYGBodG1sXG4gKiA8bmItZGF0ZXBpY2tlciBmb3JtYXQ9XCJkZC5NTS55eXl5XCI+PC9uYi1kYXRlcGlja2VyPlxuICogYGBgXG4gKiBBbHNvIGZvcm1hdCBjYW4gYmUgc2V0IGdsb2JhbGx5IHdpdGggYE5iRGF0ZUZuc0RhdGVNb2R1bGUuZm9yUm9vdCh7IGZvcm1hdDogJ2RkLk1NLnl5eXknIH0pYCBhbmRcbiAqIGBOYkRhdGVGbnNEYXRlTW9kdWxlLmZvckNoaWxkKHsgZm9ybWF0OiAnZGQuTU0ueXl5eScgfSlgIG1ldGhvZHMuXG4gKlxuICogUGxlYXNlIG5vdGUgdG8gdXNlIHNvbWUgb2YgdGhlIGZvcm1hdHRpbmcgdG9rZW5zIHlvdSBhbHNvIG5lZWQgdG8gcGFzcyBgeyBhd2FyZU9mVW5pY29kZVRva2VuczogdHJ1ZSB9YCB0byBkYXRlLWZuc1xuICogcGFyc2UgYW5kIGZvcm1hdCBmdW5jdGlvbnMuIFlvdSBjYW4gY29uZmlndXJlIG9wdGlvbnMgcGFzc2VkIHRoaXMgZnVuY3Rpb25zIGJ5IHNldHRpbmcgYGZvcm1hdE9wdGlvbnNgIGFuZFxuICogYHBhcnNlT3B0aW9uc2Agb2Ygb3B0aW9ucyBvYmplY3QgcGFzc2VkIHRvIGBOYkRhdGVGbnNEYXRlTW9kdWxlLmZvclJvb3RgIGFuZCBgTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JDaGlsZGAgbWV0aG9kcy5cbiAqIGBgYHRzXG4gKiBOYkRhdGVGbnNEYXRlTW9kdWxlLmZvclJvb3Qoe1xuICogICBwYXJzZU9wdGlvbnM6IHsgYXdhcmVPZlVuaWNvZGVUb2tlbnM6IHRydWUgfSxcbiAqICAgZm9ybWF0T3B0aW9uczogeyBhd2FyZU9mVW5pY29kZVRva2VuczogdHJ1ZSB9LFxuICogfSlcbiAqIGBgYFxuICogRnVydGhlciBpbmZvIG9uIGBkYXRlLWZuc2AgZm9ybWF0dGluZyB0b2tlbnMgY291bGQgYmUgZm91bmQgYXRcbiAqIFtkYXRlLWZucyBkb2NzXShodHRwczovL2RhdGUtZm5zLm9yZy92Mi4wLjAtYWxwaGEuMjcvZG9jcy9Vbmljb2RlLVRva2VucykuXG4gKlxuICogWW91IGNhbiBhbHNvIHVzZSBgcGFyc2VPcHRpb25zYCBhbmQgYGZvcm1hdE9wdGlvbnNgIHRvIHByb3ZpZGUgbG9jYWxlLlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGVvIH0gZnJvbSAnZGF0ZS1mbnMvbG9jYWxlJztcbiAqXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgTmJEYXRlRm5zRGF0ZU1vZHVsZS5mb3JSb290KHtcbiAqICAgICAgIHBhcnNlT3B0aW9uczogeyBsb2NhbGU6IGVvIH0sXG4gKiAgICAgICBmb3JtYXRPcHRpb25zOiB7IGxvY2FsZTogZW8gfSxcbiAqICAgICB9KSxcbiAqICAgXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogZGF0ZXBpY2tlci10ZXh0LWNvbG9yOlxuICogZGF0ZXBpY2tlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogZGF0ZXBpY2tlci1ib3JkZXItY29sb3I6XG4gKiBkYXRlcGlja2VyLWJvcmRlci1zdHlsZTpcbiAqIGRhdGVwaWNrZXItYm9yZGVyLXdpZHRoOlxuICogZGF0ZXBpY2tlci1ib3JkZXItcmFkaXVzOlxuICogZGF0ZXBpY2tlci1zaGFkb3c6XG4gKiBkYXRlcGlja2VyLWFycm93LXNpemU6XG4gKiAqL1xubGV0IE5iRGF0ZXBpY2tlckRpcmVjdGl2ZSA9IE5iRGF0ZXBpY2tlckRpcmVjdGl2ZV8xID0gY2xhc3MgTmJEYXRlcGlja2VyRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgZGF0ZXBpY2tlckFkYXB0ZXJzLCBob3N0UmVmLCBkYXRlU2VydmljZSwgY2hhbmdlRGV0ZWN0b3IpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXJBZGFwdGVycyA9IGRhdGVwaWNrZXJBZGFwdGVycztcbiAgICAgICAgdGhpcy5ob3N0UmVmID0gaG9zdFJlZjtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yID0gY2hhbmdlRGV0ZWN0b3I7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzRGF0ZXBpY2tlclJlYWR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gKCkgPT4geyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybSBjb250cm9sIHZhbGlkYXRvcnMgd2lsbCBiZSBjYWxsZWQgaW4gdmFsaWRhdG9ycyBjb250ZXh0LCBzbywgd2UgbmVlZCB0byBiaW5kIHRoZW0uXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFtcbiAgICAgICAgICAgIHRoaXMucGFyc2VWYWxpZGF0b3IsXG4gICAgICAgICAgICB0aGlzLm1pblZhbGlkYXRvcixcbiAgICAgICAgICAgIHRoaXMubWF4VmFsaWRhdG9yLFxuICAgICAgICAgICAgdGhpcy5maWx0ZXJWYWxpZGF0b3IsXG4gICAgICAgIF0ubWFwKGZuID0+IGZuLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPbklucHV0Q2hhbmdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGRhdGVwaWNrZXIgY29tcG9uZW50LlxuICAgICAqICovXG4gICAgc2V0IHNldFBpY2tlcihwaWNrZXIpIHtcbiAgICAgICAgdGhpcy5waWNrZXIgPSBwaWNrZXI7XG4gICAgICAgIHRoaXMuc2V0dXBQaWNrZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBodG1sIGlucHV0IGVsZW1lbnQuXG4gICAgICogKi9cbiAgICBnZXQgaW5wdXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvc3RSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBob3N0IGlucHV0IHZhbHVlLlxuICAgICAqICovXG4gICAgZ2V0IGlucHV0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0LnZhbHVlO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgdmFsdWUgaW4gcGlja2VyIGFuZCBodG1sIGlucHV0IGVsZW1lbnQuXG4gICAgICogKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZXBpY2tlclJlYWR5KSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlUGlja2VyKHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVJbnB1dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuKSB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gZm47XG4gICAgfVxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmlucHV0LmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9ybSBjb250cm9sIHZhbGlkYXRpb24gYmFzZWQgb24gcGlja2VyIHZhbGlkYXRvciBjb25maWcuXG4gICAgICogKi9cbiAgICB2YWxpZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdG9yKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyBwaWNrZXIsIGZvY3VzZXMgdGhlIGlucHV0XG4gICAgICovXG4gICAgaGlkZVBpY2tlcigpIHtcbiAgICAgICAgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB0aGlzLnBpY2tlci5oaWRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGF0IHdlIGNhbiBwYXJzZSB2YWx1ZSBjb3JyZWN0bHkuXG4gICAgICogKi9cbiAgICBwYXJzZVZhbGlkYXRvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGUgc2VydmljZXMgdHJlYXQgZW1wdHkgc3RyaW5nIGFzIGludmFsaWQgZGF0ZS5cbiAgICAgICAgICogVGhhdCdzIHdoeSB3ZSdyZSBnZXR0aW5nIGludmFsaWQgZm9ybUNvbnRyb2wgaW4gY2FzZSBvZiBlbXB0eSBpbnB1dCB3aGljaCBpcyBub3QgcmVxdWlyZWQuXG4gICAgICAgICAqICovXG4gICAgICAgIGlmICh0aGlzLmlucHV0VmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1ZhbGlkID0gdGhpcy5kYXRlcGlja2VyQWRhcHRlci5pc1ZhbGlkKHRoaXMuaW5wdXRWYWx1ZSwgdGhpcy5waWNrZXIuZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQgPyBudWxsIDogeyBuYkRhdGVwaWNrZXJQYXJzZTogeyB2YWx1ZTogdGhpcy5pbnB1dFZhbHVlIH0gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHBhc3NlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gbWluLlxuICAgICAqICovXG4gICAgbWluVmFsaWRhdG9yKCkge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLnBpY2tlci5nZXRWYWxpZGF0b3JDb25maWcoKTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuZGF0ZXBpY2tlckFkYXB0ZXIucGFyc2UodGhpcy5pbnB1dFZhbHVlLCB0aGlzLnBpY2tlci5mb3JtYXQpO1xuICAgICAgICByZXR1cm4gKCFjb25maWcubWluIHx8ICFkYXRlIHx8IHRoaXMuZGF0ZVNlcnZpY2UuY29tcGFyZURhdGVzKGNvbmZpZy5taW4sIGRhdGUpIDw9IDApID9cbiAgICAgICAgICAgIG51bGwgOiB7IG5iRGF0ZXBpY2tlck1pbjogeyBtaW46IGNvbmZpZy5taW4sIGFjdHVhbDogZGF0ZSB9IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBwYXNzZWQgdmFsdWUgaXMgc21hbGxlciB0aGFuIG1heC5cbiAgICAgKiAqL1xuICAgIG1heFZhbGlkYXRvcigpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5waWNrZXIuZ2V0VmFsaWRhdG9yQ29uZmlnKCk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLmRhdGVwaWNrZXJBZGFwdGVyLnBhcnNlKHRoaXMuaW5wdXRWYWx1ZSwgdGhpcy5waWNrZXIuZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuICghY29uZmlnLm1heCB8fCAhZGF0ZSB8fCB0aGlzLmRhdGVTZXJ2aWNlLmNvbXBhcmVEYXRlcyhjb25maWcubWF4LCBkYXRlKSA+PSAwKSA/XG4gICAgICAgICAgICBudWxsIDogeyBuYkRhdGVwaWNrZXJNYXg6IHsgbWF4OiBjb25maWcubWF4LCBhY3R1YWw6IGRhdGUgfSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgcGFzc2VkIHZhbHVlIHNhdGlzZnkgdGhlIGZpbHRlci5cbiAgICAgKiAqL1xuICAgIGZpbHRlclZhbGlkYXRvcigpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5waWNrZXIuZ2V0VmFsaWRhdG9yQ29uZmlnKCk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLmRhdGVwaWNrZXJBZGFwdGVyLnBhcnNlKHRoaXMuaW5wdXRWYWx1ZSwgdGhpcy5waWNrZXIuZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuICghY29uZmlnLmZpbHRlciB8fCAhZGF0ZSB8fCBjb25maWcuZmlsdGVyKGRhdGUpKSA/XG4gICAgICAgICAgICBudWxsIDogeyBuYkRhdGVwaWNrZXJGaWx0ZXI6IHRydWUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hvb3NlcyBkYXRlcGlja2VyIGFkYXB0ZXIgYmFzZWQgb24gcGFzc2VkIHBpY2tlciBjb21wb25lbnQuXG4gICAgICogKi9cbiAgICBjaG9vc2VEYXRlcGlja2VyQWRhcHRlcigpIHtcbiAgICAgICAgdGhpcy5kYXRlcGlja2VyQWRhcHRlciA9IHRoaXMuZGF0ZXBpY2tlckFkYXB0ZXJzLmZpbmQoKHsgcGlja2VyIH0pID0+IHRoaXMucGlja2VyIGluc3RhbmNlb2YgcGlja2VyKTtcbiAgICAgICAgaWYgKHRoaXMubm9EYXRlcGlja2VyQWRhcHRlclByb3ZpZGVkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0ZXBpY2tlckFkYXB0ZXIgcHJvdmlkZWQgZm9yIHBpY2tlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHBpY2tlciB0byB0aGUgaG9zdCBpbnB1dCBlbGVtZW50IGFuZCBzdWJzY3JpYmVzIG9uIHZhbHVlIGNoYW5nZXMuXG4gICAgICogKi9cbiAgICBzZXR1cFBpY2tlcigpIHtcbiAgICAgICAgdGhpcy5jaG9vc2VEYXRlcGlja2VyQWRhcHRlcigpO1xuICAgICAgICB0aGlzLnBpY2tlci5hdHRhY2godGhpcy5ob3N0UmVmKTtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5waWNrZXIudmFsdWUgPSB0aGlzLmRhdGVwaWNrZXJBZGFwdGVyLnBhcnNlKHRoaXMuaW5wdXRWYWx1ZSwgdGhpcy5waWNrZXIuZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJbiBjYXNlIGRhdGVwaWNrZXIgY29tcG9uZW50IHBsYWNlZCBhZnRlciB0aGUgaW5wdXQgd2l0aCBkYXRlcGlja2VyIGRpcmVjdGl2ZSxcbiAgICAgICAgLy8gd2UgY2FuJ3QgcmVhZCBgdGhpcy5waWNrZXIuZm9ybWF0YCBvbiBmaXJzdCBjaGFuZ2UgZGV0ZWN0aW9uIHJ1bixcbiAgICAgICAgLy8gc2luY2UgaXQncyBub3QgYm91bmQgeWV0LCBzbyB3ZSBoYXZlIHRvIHdhaXQgZm9yIGRhdGVwaWNrZXIgY29tcG9uZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuaXNEYXRlcGlja2VyUmVhZHkpIHtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLmluaXRcbiAgICAgICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSksIHRha2UoMSksIHRhcCgoKSA9PiB0aGlzLmlzRGF0ZXBpY2tlclJlYWR5ID0gdHJ1ZSksIGZpbHRlcigoKSA9PiAhIXRoaXMucXVldWUpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZSh0aGlzLnF1ZXVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMucXVldWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIHRoaXMucXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBpY2tlci52YWx1ZUNoYW5nZVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVQaWNrZXIodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUlucHV0KHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGlja2VyLnNob3VsZEhpZGUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBpY2tlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVyZ2UodGhpcy5waWNrZXIuYmx1ciwgZnJvbUV2ZW50KHRoaXMuaW5wdXQsICdibHVyJykucGlwZShmaWx0ZXIoKCkgPT4gIXRoaXMucGlja2VyLmlzU2hvd24gJiYgdGhpcy5kb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSB0aGlzLmlucHV0KSkpLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9uVG91Y2hlZCgpKTtcbiAgICB9XG4gICAgd3JpdGVQaWNrZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5waWNrZXIudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgd3JpdGVJbnB1dCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBzdHJpbmdSZXByZXNlbnRhdGlvbiA9IHRoaXMuZGF0ZXBpY2tlckFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aGlzLnBpY2tlci5mb3JtYXQpO1xuICAgICAgICB0aGlzLmhvc3RSZWYubmF0aXZlRWxlbWVudC52YWx1ZSA9IHN0cmluZ1JlcHJlc2VudGF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgaWYgbm8gZGF0ZXBpY2tlciBhZGFwdGVyIHByb3ZpZGVkLlxuICAgICAqICovXG4gICAgbm9EYXRlcGlja2VyQWRhcHRlclByb3ZpZGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuZGF0ZXBpY2tlckFkYXB0ZXIgfHwgISh0aGlzLmRhdGVwaWNrZXJBZGFwdGVyIGluc3RhbmNlb2YgTmJEYXRlcGlja2VyQWRhcHRlcik7XG4gICAgfVxuICAgIHN1YnNjcmliZU9uSW5wdXRDaGFuZ2UoKSB7XG4gICAgICAgIGZyb21FdmVudCh0aGlzLmlucHV0LCAnaW5wdXQnKVxuICAgICAgICAgICAgLnBpcGUobWFwKCgpID0+IHRoaXMuaW5wdXRWYWx1ZSksIHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB0aGlzLmhhbmRsZUlucHV0Q2hhbmdlKHZhbHVlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBpbnB1dCB2YWx1ZSBhbmQgd3JpdGUgaWYgaXQgaXNuJ3QgbnVsbC5cbiAgICAgKiAqL1xuICAgIGhhbmRsZUlucHV0Q2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnBhcnNlSW5wdXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UoZGF0ZSk7XG4gICAgICAgIHRoaXMud3JpdGVQaWNrZXIoZGF0ZSk7XG4gICAgfVxuICAgIHBhcnNlSW5wdXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5kYXRlcGlja2VyQWRhcHRlci5pc1ZhbGlkKHZhbHVlLCB0aGlzLnBpY2tlci5mb3JtYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlcGlja2VyQWRhcHRlci5wYXJzZSh2YWx1ZSwgdGhpcy5waWNrZXIuZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxNDMoW1xuICAgIElucHV0KCduYkRhdGVwaWNrZXInKSxcbiAgICBfX21ldGFkYXRhJDk1KFwiZGVzaWduOnR5cGVcIiwgTmJEYXRlcGlja2VyKSxcbiAgICBfX21ldGFkYXRhJDk1KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iRGF0ZXBpY2tlcl0pXG5dLCBOYkRhdGVwaWNrZXJEaXJlY3RpdmUucHJvdG90eXBlLCBcInNldFBpY2tlclwiLCBudWxsKTtcbk5iRGF0ZXBpY2tlckRpcmVjdGl2ZSA9IE5iRGF0ZXBpY2tlckRpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZSQxNDMoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbbmJEYXRlcGlja2VyXScsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE5iRGF0ZXBpY2tlckRpcmVjdGl2ZV8xKSxcbiAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOYkRhdGVwaWNrZXJEaXJlY3RpdmVfMSksXG4gICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0pLFxuICAgIF9fcGFyYW0kMjMoMCwgSW5qZWN0KE5CX0RPQ1VNRU5UKSksXG4gICAgX19wYXJhbSQyMygxLCBJbmplY3QoTkJfREFURV9BREFQVEVSKSksXG4gICAgX19tZXRhZGF0YSQ5NShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIEFycmF5LCBFbGVtZW50UmVmLFxuICAgICAgICBOYkRhdGVTZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBOYkRhdGVwaWNrZXJEaXJlY3RpdmUpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDE0NCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQ5NiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xubGV0IE5iRGF0ZXBpY2tlckNvbnRhaW5lckNvbXBvbmVudCA9IGNsYXNzIE5iRGF0ZXBpY2tlckNvbnRhaW5lckNvbXBvbmVudCBleHRlbmRzIE5iUG9zaXRpb25lZENvbnRhaW5lciB7XG4gICAgYXR0YWNoKHBvcnRhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5Q29udGFpbmVyLmF0dGFjaENvbXBvbmVudFBvcnRhbChwb3J0YWwpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDE0NChbXG4gICAgVmlld0NoaWxkKE5iT3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudCwgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YSQ5NihcImRlc2lnbjp0eXBlXCIsIE5iT3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudClcbl0sIE5iRGF0ZXBpY2tlckNvbnRhaW5lckNvbXBvbmVudC5wcm90b3R5cGUsIFwib3ZlcmxheUNvbnRhaW5lclwiLCB2b2lkIDApO1xuTmJEYXRlcGlja2VyQ29udGFpbmVyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxNDQoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItZGF0ZXBpY2tlci1jb250YWluZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxzcGFuIGNsYXNzPVwiYXJyb3dcIj48L3NwYW4+XG4gICAgPG5iLW92ZXJsYXktY29udGFpbmVyPjwvbmItb3ZlcmxheS1jb250YWluZXI+XG4gIGAsXG4gICAgICAgIHN0eWxlczogW1wiOmhvc3QgLmFycm93e3Bvc2l0aW9uOmFic29sdXRlO3dpZHRoOjA7aGVpZ2h0OjB9Omhvc3QgOjpuZy1kZWVwIG5iLW92ZXJsYXktY29udGFpbmVyIC5wcmltaXRpdmUtb3ZlcmxheXtwYWRkaW5nOjAuNzVyZW0gMXJlbX1cXG5cIl1cbiAgICB9KVxuXSwgTmJEYXRlcGlja2VyQ29udGFpbmVyQ29tcG9uZW50KTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxNDUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkOTcgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDI0ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xuLyoqXG4gKiBUaGUgYE5iQmFzZVBpY2tlcmAgY29tcG9uZW50IGNvbmNlbnRyYXRlcyBvdmVybGF5IG1hbmlwdWxhdGlvbiBsb2dpYy5cbiAqICovXG5jbGFzcyBOYkJhc2VQaWNrZXIgZXh0ZW5kcyBOYkRhdGVwaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKG92ZXJsYXksIHBvc2l0aW9uQnVpbGRlciwgdHJpZ2dlclN0cmF0ZWd5QnVpbGRlciwgY2ZyLCBkYXRlU2VydmljZSwgZGF0ZVNlcnZpY2VPcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3ZlcmxheSA9IG92ZXJsYXk7XG4gICAgICAgIHRoaXMucG9zaXRpb25CdWlsZGVyID0gcG9zaXRpb25CdWlsZGVyO1xuICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneUJ1aWxkZXIgPSB0cmlnZ2VyU3RyYXRlZ3lCdWlsZGVyO1xuICAgICAgICB0aGlzLmNmciA9IGNmcjtcbiAgICAgICAgdGhpcy5kYXRlU2VydmljZSA9IGRhdGVTZXJ2aWNlO1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlT3B0aW9ucyA9IGRhdGVTZXJ2aWNlT3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpemUgb2YgdGhlIGNhbGVuZGFyIGFuZCBlbnRpcmUgY29tcG9uZW50cy5cbiAgICAgICAgICogQ2FuIGJlICdtZWRpdW0nIHdoaWNoIGlzIGRlZmF1bHQgb3IgJ2xhcmdlJy5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5zaXplID0gTmJDYWxlbmRhclNpemUuTUVESVVNO1xuICAgICAgICB0aGlzLmluaXQkID0gbmV3IFJlcGxheVN1YmplY3QoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0cmVhbSBvZiBwaWNrZXIgY2hhbmdlcy4gUmVxdWlyZWQgdG8gYmUgdGhlIHN1YmplY3QgYmVjYXVzZSBwaWNrZXIgaGlkZXMgYW5kIHNob3dzIGFuZCBwaWNrZXJcbiAgICAgICAgICogY2hhbmdlIHN0cmVhbSBiZWNvbWVzIHJlY3JlYXRlZC5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZSQgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ibHVyJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgcGlja2VyIGluc3RhbmNlLlxuICAgICAqICovXG4gICAgZ2V0IHBpY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyUmVmICYmIHRoaXMucGlja2VyUmVmLmluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gb2YgcGlja2VyIHZhbHVlIGNoYW5nZXMuXG4gICAgICogKi9cbiAgICBnZXQgdmFsdWVDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uQ2hhbmdlJC5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgZ2V0IGlzU2hvd24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZiAmJiB0aGlzLnJlZi5oYXNBdHRhY2hlZCgpO1xuICAgIH1cbiAgICBnZXQgaW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCQuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHdoZW4gZGF0ZXBpY2tlciBsb29zZXMgZm9jdXMuXG4gICAgICovXG4gICAgZ2V0IGJsdXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsdXIkLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5jaGVja0Zvcm1hdCgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmZvcm1hdCAmJiAhY2hhbmdlcy5mb3JtYXQuaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrRm9ybWF0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmluaXQkLm5leHQoKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIHRoaXMuaW5pdCQuY29tcGxldGUoKTtcbiAgICAgICAgaWYgKHRoaXMucmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlZi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlclN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJTdHJhdGVneS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0ZXBpY2tlciBrbm93cyBub3RoaW5nIGFib3V0IGhvc3QgaHRtbCBpbnB1dCBlbGVtZW50LlxuICAgICAqIFNvLCBhdHRhY2ggbWV0aG9kIGF0dGFjaGVzIGRhdGVwaWNrZXIgdG8gdGhlIGhvc3QgaW5wdXQgZWxlbWVudC5cbiAgICAgKiAqL1xuICAgIGF0dGFjaChob3N0UmVmKSB7XG4gICAgICAgIHRoaXMuaG9zdFJlZiA9IGhvc3RSZWY7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlT25UcmlnZ2VycygpO1xuICAgIH1cbiAgICBnZXRWYWxpZGF0b3JDb25maWcoKSB7XG4gICAgICAgIHJldHVybiB7IG1pbjogdGhpcy5taW4sIG1heDogdGhpcy5tYXgsIGZpbHRlcjogdGhpcy5maWx0ZXIgfTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuRGF0ZXBpY2tlcigpO1xuICAgIH1cbiAgICBzaG91bGRIaWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWRlT25TZWxlY3QgJiYgISF0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVmLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNhdmUgY3VycmVudCB2YWx1ZSBpZiBwaWNrZXIgd2FzIHJlbmRlcmVkXG4gICAgICAgIGlmICh0aGlzLnBpY2tlcikge1xuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnBpY2tlclJlZi5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnBpY2tlclJlZiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlT3ZlcmxheSgpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvblN0cmF0ZWd5ID0gdGhpcy5jcmVhdGVQb3NpdGlvblN0cmF0ZWd5KCk7XG4gICAgICAgIHRoaXMucmVmID0gdGhpcy5vdmVybGF5LmNyZWF0ZSh7XG4gICAgICAgICAgICBwb3NpdGlvblN0cmF0ZWd5OiB0aGlzLnBvc2l0aW9uU3RyYXRlZ3ksXG4gICAgICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPblBvc2l0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICAgIG9wZW5EYXRlcGlja2VyKCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMucmVmLmF0dGFjaChuZXcgTmJDb21wb25lbnRQb3J0YWwoTmJEYXRlcGlja2VyQ29udGFpbmVyQ29tcG9uZW50LCBudWxsLCBudWxsLCB0aGlzLmNmcikpO1xuICAgICAgICB0aGlzLmluc3RhbnRpYXRlUGlja2VyKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlT25WYWx1ZUNoYW5nZSgpO1xuICAgICAgICB0aGlzLndyaXRlUXVldWUoKTtcbiAgICAgICAgdGhpcy5wYXRjaFdpdGhJbnB1dHMoKTtcbiAgICB9XG4gICAgY3JlYXRlUG9zaXRpb25TdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25CdWlsZGVyXG4gICAgICAgICAgICAuY29ubmVjdGVkVG8odGhpcy5ob3N0UmVmKVxuICAgICAgICAgICAgLnBvc2l0aW9uKE5iUG9zaXRpb24uQk9UVE9NKVxuICAgICAgICAgICAgLmFkanVzdG1lbnQoTmJBZGp1c3RtZW50LkNPVU5URVJDTE9DS1dJU0UpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVPblBvc2l0aW9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uU3RyYXRlZ3kucG9zaXRpb25DaGFuZ2VcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHBvc2l0aW9uKSA9PiBwYXRjaCh0aGlzLmNvbnRhaW5lciwgeyBwb3NpdGlvbiB9KSk7XG4gICAgfVxuICAgIGNyZWF0ZVRyaWdnZXJTdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlclN0cmF0ZWd5QnVpbGRlclxuICAgICAgICAgICAgLnRyaWdnZXIoTmJUcmlnZ2VyLkZPQ1VTKVxuICAgICAgICAgICAgLmhvc3QodGhpcy5ob3N0UmVmLm5hdGl2ZUVsZW1lbnQpXG4gICAgICAgICAgICAuY29udGFpbmVyKCgpID0+IHRoaXMuY29udGFpbmVyKVxuICAgICAgICAgICAgLmJ1aWxkKCk7XG4gICAgfVxuICAgIHN1YnNjcmliZU9uVHJpZ2dlcnMoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlclN0cmF0ZWd5ID0gdGhpcy5jcmVhdGVUcmlnZ2VyU3RyYXRlZ3koKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyU3RyYXRlZ3kuc2hvdyQuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2hvdygpKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyU3RyYXRlZ3kuaGlkZSQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmx1ciQubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnN0YW50aWF0ZVBpY2tlcigpIHtcbiAgICAgICAgdGhpcy5waWNrZXJSZWYgPSB0aGlzLmNvbnRhaW5lci5pbnN0YW5jZS5hdHRhY2gobmV3IE5iQ29tcG9uZW50UG9ydGFsKHRoaXMucGlja2VyQ2xhc3MsIG51bGwsIG51bGwsIHRoaXMuY2ZyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgb24gcGlja2VyIHZhbHVlIGNoYW5nZXMgYW5kIGVtaXQgZGF0YSB0aHJvdWdoIHRoaXMub25DaGFuZ2UkIHN1YmplY3QuXG4gICAgICogKi9cbiAgICBzdWJzY3JpYmVPblZhbHVlQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLnBpY2tlclZhbHVlQ2hhbmdlLnN1YnNjcmliZShkYXRlID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UkLm5leHQoZGF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXRjaFdpdGhJbnB1dHMoKSB7XG4gICAgICAgIHRoaXMucGlja2VyLmJvdW5kaW5nTW9udGggPSB0aGlzLmJvdW5kaW5nTW9udGg7XG4gICAgICAgIHRoaXMucGlja2VyLnN0YXJ0VmlldyA9IHRoaXMuc3RhcnRWaWV3O1xuICAgICAgICB0aGlzLnBpY2tlci5taW4gPSB0aGlzLm1pbjtcbiAgICAgICAgdGhpcy5waWNrZXIubWF4ID0gdGhpcy5tYXg7XG4gICAgICAgIHRoaXMucGlja2VyLmZpbHRlciA9IHRoaXMuZmlsdGVyO1xuICAgICAgICB0aGlzLnBpY2tlci5fY2VsbENvbXBvbmVudCA9IHRoaXMuZGF5Q2VsbENvbXBvbmVudDtcbiAgICAgICAgdGhpcy5waWNrZXIubW9udGhDZWxsQ29tcG9uZW50ID0gdGhpcy5tb250aENlbGxDb21wb25lbnQ7XG4gICAgICAgIHRoaXMucGlja2VyLl95ZWFyQ2VsbENvbXBvbmVudCA9IHRoaXMueWVhckNlbGxDb21wb25lbnQ7XG4gICAgICAgIHRoaXMucGlja2VyLnNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIHRoaXMucGlja2VyLnNob3dIZWFkZXIgPSB0aGlzLnNob3dIZWFkZXI7XG4gICAgICAgIHRoaXMucGlja2VyLnZpc2libGVEYXRlID0gdGhpcy52aXNpYmxlRGF0ZTtcbiAgICAgICAgdGhpcy5waWNrZXIuc2hvd1dlZWtOdW1iZXIgPSB0aGlzLnNob3dXZWVrTnVtYmVyO1xuICAgICAgICB0aGlzLnBpY2tlci53ZWVrTnVtYmVyU3ltYm9sID0gdGhpcy53ZWVrTnVtYmVyU3ltYm9sO1xuICAgIH1cbiAgICBjaGVja0Zvcm1hdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0ZVNlcnZpY2UuZ2V0SWQoKSA9PT0gJ25hdGl2ZScgJiYgdGhpcy5mb3JtYXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBmb3JtYXQgbmF0aXZlIGRhdGUuIFRvIHVzZSBjdXN0b20gZm9ybWF0dGluZyB5b3UgaGF2ZSB0byBpbnN0YWxsIEBuZWJ1bGFyL21vbWVudCBvciAnICtcbiAgICAgICAgICAgICAgICAnQG5lYnVsYXIvZGF0ZS1mbnMgcGFja2FnZSBhbmQgaW1wb3J0IE5iTW9tZW50RGF0ZU1vZHVsZSBvciBOYkRhdGVGbnNEYXRlTW9kdWxlIGFjY29yZGluZ2x5LicgK1xuICAgICAgICAgICAgICAgICdNb3JlIGluZm9ybWF0aW9uIGF0IFwiRm9ybWF0dGluZyBpc3N1ZVwiICcgK1xuICAgICAgICAgICAgICAgICdodHRwczovL2FrdmVvLmdpdGh1Yi5pby9uZWJ1bGFyL2RvY3MvY29tcG9uZW50cy9kYXRlcGlja2VyL292ZXJ2aWV3I25iZGF0ZXBpY2tlcmNvbXBvbmVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRm9ybWF0U2V0ID0gdGhpcy5mb3JtYXQgfHwgKHRoaXMuZGF0ZVNlcnZpY2VPcHRpb25zICYmIHRoaXMuZGF0ZVNlcnZpY2VPcHRpb25zLmZvcm1hdCk7XG4gICAgICAgIGlmICh0aGlzLmRhdGVTZXJ2aWNlLmdldElkKCkgPT09ICdkYXRlLWZucycgJiYgIWlzRm9ybWF0U2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zvcm1hdCBpcyByZXF1aXJlZCB3aGVuIHVzaW5nIE5iRGF0ZUZuc0RhdGVNb2R1bGUnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmxldCBOYkJhc2VQaWNrZXJDb21wb25lbnQgPSBjbGFzcyBOYkJhc2VQaWNrZXJDb21wb25lbnQgZXh0ZW5kcyBOYkJhc2VQaWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBwb3NpdGlvbkJ1aWxkZXIsIHRyaWdnZXJTdHJhdGVneUJ1aWxkZXIsIG92ZXJsYXksIGNmciwgZGF0ZVNlcnZpY2UsIGRhdGVTZXJ2aWNlT3B0aW9ucykge1xuICAgICAgICBzdXBlcihvdmVybGF5LCBwb3NpdGlvbkJ1aWxkZXIsIHRyaWdnZXJTdHJhdGVneUJ1aWxkZXIsIGNmciwgZGF0ZVNlcnZpY2UsIGRhdGVTZXJ2aWNlT3B0aW9ucyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIGlmIHdlIHNob3VsZCByZW5kZXIgcHJldmlvdXMgYW5kIG5leHQgbW9udGhzXG4gICAgICAgICAqIGluIHRoZSBjdXJyZW50IG1vbnRoIHZpZXcuXG4gICAgICAgICAqICovXG4gICAgICAgIHRoaXMuYm91bmRpbmdNb250aCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHN0YXJ0aW5nIHZpZXcgZm9yIGNhbGVuZGFyLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnN0YXJ0VmlldyA9IE5iQ2FsZW5kYXJWaWV3TW9kZS5EQVRFO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2l6ZSBvZiB0aGUgY2FsZW5kYXIgYW5kIGVudGlyZSBjb21wb25lbnRzLlxuICAgICAgICAgKiBDYW4gYmUgJ21lZGl1bScgd2hpY2ggaXMgZGVmYXVsdCBvciAnbGFyZ2UnLlxuICAgICAgICAgKiAqL1xuICAgICAgICB0aGlzLnNpemUgPSBOYkNhbGVuZGFyU2l6ZS5NRURJVU07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIHBpY2tlciB3aGVuIGEgZGF0ZSBvciBhIHJhbmdlIGlzIHNlbGVjdGVkLCBgdHJ1ZWAgYnkgZGVmYXVsdFxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGlkZU9uU2VsZWN0ID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgc2hvdWxkIHdlIHNob3cgY2FsZW5kYXJzIGhlYWRlciBvciBub3QuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG93SGVhZGVyID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgc3ltYm9sIHVzZWQgYXMgYSBoZWFkZXIgZm9yIHdlZWsgbnVtYmVycyBjb2x1bW5cbiAgICAgICAgICogKi9cbiAgICAgICAgdGhpcy53ZWVrTnVtYmVyU3ltYm9sID0gJyMnO1xuICAgICAgICB0aGlzLl9zaG93V2Vla051bWJlciA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHNob3VsZCB3ZSBzaG93IHdlZWsgbnVtYmVycyBjb2x1bW4uXG4gICAgICogRmFsc2UgYnkgZGVmYXVsdC5cbiAgICAgKiAqL1xuICAgIGdldCBzaG93V2Vla051bWJlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3dXZWVrTnVtYmVyO1xuICAgIH1cbiAgICBzZXQgc2hvd1dlZWtOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc2hvd1dlZWtOdW1iZXIgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgcGlja2VyVmFsdWVDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHsgfVxuICAgIHdyaXRlUXVldWUoKSB7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTQ1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkJhc2VQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxNDUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYkJhc2VQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImJvdW5kaW5nTW9udGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTQ1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkJhc2VQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXJ0Vmlld1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxNDUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iQmFzZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDE0NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDk3KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJCYXNlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTQ1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTcoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIE5iQmFzZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDE0NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDk3KFwiZGVzaWduOnR5cGVcIiwgVHlwZSlcbl0sIE5iQmFzZVBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF5Q2VsbENvbXBvbmVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxNDUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjp0eXBlXCIsIFR5cGUpXG5dLCBOYkJhc2VQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIm1vbnRoQ2VsbENvbXBvbmVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxNDUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjp0eXBlXCIsIFR5cGUpXG5dLCBOYkJhc2VQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInllYXJDZWxsQ29tcG9uZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDE0NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDk3KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJCYXNlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDE0NShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDk3KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmJCYXNlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aXNpYmxlRGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxNDUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYkJhc2VQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcImhpZGVPblNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxNDUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYkJhc2VQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNob3dIZWFkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTQ1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYkJhc2VQaWNrZXJDb21wb25lbnQucHJvdG90eXBlLCBcIndlZWtOdW1iZXJTeW1ib2xcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTQ1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTcoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDk3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJCYXNlUGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzaG93V2Vla051bWJlclwiLCBudWxsKTtcbk5iQmFzZVBpY2tlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUkMTQ1KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX3BhcmFtJDI0KDAsIEluamVjdChOQl9ET0NVTUVOVCkpLFxuICAgIF9fcGFyYW0kMjQoNiwgT3B0aW9uYWwoKSksIF9fcGFyYW0kMjQoNiwgSW5qZWN0KE5CX0RBVEVfU0VSVklDRV9PUFRJT05TKSksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3QsIE5iUG9zaXRpb25CdWlsZGVyU2VydmljZSxcbiAgICAgICAgTmJUcmlnZ2VyU3RyYXRlZ3lCdWlsZGVyU2VydmljZSxcbiAgICAgICAgTmJPdmVybGF5U2VydmljZSxcbiAgICAgICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICBOYkRhdGVTZXJ2aWNlLCBPYmplY3RdKVxuXSwgTmJCYXNlUGlja2VyQ29tcG9uZW50KTtcbi8qKlxuICogVGhlIERhdGVQaWNrZXIgY29tcG9uZW50cyBpdHNlbGYuXG4gKiBQcm92aWRlcyBhIHByb3h5IHRvIGBOYkNhbGVuZGFyYCBvcHRpb25zIGFzIHdlbGwgYXMgY3VzdG9tIHBpY2tlciBvcHRpb25zLlxuICovXG5sZXQgTmJEYXRlcGlja2VyQ29tcG9uZW50ID0gY2xhc3MgTmJEYXRlcGlja2VyQ29tcG9uZW50IGV4dGVuZHMgTmJCYXNlUGlja2VyQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgRGF0ZVBpY2tlciBjb21wb25lbnRzIGl0c2VsZi5cbiAgICAgKiBQcm92aWRlcyBhIHByb3h5IHRvIGBOYkNhbGVuZGFyYCBvcHRpb25zIGFzIHdlbGwgYXMgY3VzdG9tIHBpY2tlciBvcHRpb25zLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnBpY2tlckNsYXNzID0gTmJDYWxlbmRhckNvbXBvbmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0ZSB3aGljaCB3aWxsIGJlIHJlbmRlcmVkIGFzIHNlbGVjdGVkLlxuICAgICAqICovXG4gICAgc2V0IGRhdGUoZGF0ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gZGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgZGF0ZSB3aGVuIHNlbGVjdGVkLlxuICAgICAqICovXG4gICAgZ2V0IGRhdGVDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlQ2hhbmdlO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlciA/IHRoaXMucGlja2VyLmRhdGUgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldCB2YWx1ZShkYXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5waWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBkYXRlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVEYXRlID0gZGF0ZTtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLnZpc2libGVEYXRlID0gZGF0ZTtcbiAgICAgICAgICAgIHRoaXMucGlja2VyLmRhdGUgPSBkYXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwaWNrZXJWYWx1ZUNoYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyLmRhdGVDaGFuZ2U7XG4gICAgfVxuICAgIHdyaXRlUXVldWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXVlKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5xdWV1ZTtcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGRhdGU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxNDUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgTmJEYXRlcGlja2VyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxNDUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTcoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpLFxuICAgIF9fbWV0YWRhdGEkOTcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iRGF0ZXBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwiZGF0ZUNoYW5nZVwiLCBudWxsKTtcbk5iRGF0ZXBpY2tlckNvbXBvbmVudCA9IF9fZGVjb3JhdGUkMTQ1KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLWRhdGVwaWNrZXInLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KVxuXSwgTmJEYXRlcGlja2VyQ29tcG9uZW50KTtcbi8qKlxuICogVGhlIFJhbmdlRGF0ZVBpY2tlciBjb21wb25lbnRzIGl0c2VsZi5cbiAqIFByb3ZpZGVzIGEgcHJveHkgdG8gYE5iQ2FsZW5kYXJSYW5nZWAgb3B0aW9ucyBhcyB3ZWxsIGFzIGN1c3RvbSBwaWNrZXIgb3B0aW9ucy5cbiAqL1xubGV0IE5iUmFuZ2VwaWNrZXJDb21wb25lbnQgPSBjbGFzcyBOYlJhbmdlcGlja2VyQ29tcG9uZW50IGV4dGVuZHMgTmJCYXNlUGlja2VyQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGUgUmFuZ2VEYXRlUGlja2VyIGNvbXBvbmVudHMgaXRzZWxmLlxuICAgICAqIFByb3ZpZGVzIGEgcHJveHkgdG8gYE5iQ2FsZW5kYXJSYW5nZWAgb3B0aW9ucyBhcyB3ZWxsIGFzIGN1c3RvbSBwaWNrZXIgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5waWNrZXJDbGFzcyA9IE5iQ2FsZW5kYXJSYW5nZUNvbXBvbmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmFuZ2Ugd2hpY2ggd2lsbCBiZSByZW5kZXJlZCBhcyBzZWxlY3RlZC5cbiAgICAgKiAqL1xuICAgIHNldCByYW5nZShyYW5nZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gcmFuZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHJhbmdlIHdoZW4gc3RhcnQgc2VsZWN0ZWQgYW5kIGVtaXRzIGFnYWluIHdoZW4gZW5kIHNlbGVjdGVkLlxuICAgICAqICovXG4gICAgZ2V0IHJhbmdlQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUNoYW5nZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrZXIgPyB0aGlzLnBpY2tlci5yYW5nZSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0IHZhbHVlKHJhbmdlKSB7XG4gICAgICAgIGlmICghdGhpcy5waWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWUgPSByYW5nZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVEYXRlID0gcmFuZ2UgJiYgcmFuZ2Uuc3RhcnQ7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVEYXRlID0gdmlzaWJsZURhdGU7XG4gICAgICAgICAgICB0aGlzLnBpY2tlci52aXNpYmxlRGF0ZSA9IHZpc2libGVEYXRlO1xuICAgICAgICAgICAgdGhpcy5waWNrZXIucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcGlja2VyVmFsdWVDaGFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tlci5yYW5nZUNoYW5nZTtcbiAgICB9XG4gICAgc2hvdWxkSGlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnNob3VsZEhpZGUoKSAmJiAhISh0aGlzLnZhbHVlICYmIHRoaXMudmFsdWUuc3RhcnQgJiYgdGhpcy52YWx1ZS5lbmQpO1xuICAgIH1cbiAgICB3cml0ZVF1ZXVlKCkge1xuICAgICAgICBpZiAodGhpcy5xdWV1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB0aGlzLnF1ZXVlO1xuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gcmFuZ2U7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxNDUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgTmJSYW5nZXBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE0NShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlciksXG4gICAgX19tZXRhZGF0YSQ5NyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJSYW5nZXBpY2tlckNvbXBvbmVudC5wcm90b3R5cGUsIFwicmFuZ2VDaGFuZ2VcIiwgbnVsbCk7XG5OYlJhbmdlcGlja2VyQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxNDUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItcmFuZ2VwaWNrZXInLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KVxuXSwgTmJSYW5nZXBpY2tlckNvbXBvbmVudCk7XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTQ2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDk4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5sZXQgTmJEYXRlQWRhcHRlclNlcnZpY2UgPSBjbGFzcyBOYkRhdGVBZGFwdGVyU2VydmljZSBleHRlbmRzIE5iRGF0ZXBpY2tlckFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGF0ZVNlcnZpY2UgPSBkYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy5waWNrZXIgPSBOYkRhdGVwaWNrZXJDb21wb25lbnQ7XG4gICAgfVxuICAgIHBhcnNlKGRhdGUsIGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5wYXJzZShkYXRlLCBmb3JtYXQpO1xuICAgIH1cbiAgICBmb3JtYXQoZGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmZvcm1hdChkYXRlLCBmb3JtYXQpO1xuICAgIH1cbiAgICBpc1ZhbGlkKGRhdGUsIGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRlU2VydmljZS5pc1ZhbGlkRGF0ZVN0cmluZyhkYXRlLCBmb3JtYXQpO1xuICAgIH1cbn07XG5OYkRhdGVBZGFwdGVyU2VydmljZSA9IF9fZGVjb3JhdGUkMTQ2KFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YSQ5OChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYkRhdGVTZXJ2aWNlXSlcbl0sIE5iRGF0ZUFkYXB0ZXJTZXJ2aWNlKTtcbmxldCBOYlJhbmdlQWRhcHRlclNlcnZpY2UgPSBjbGFzcyBOYlJhbmdlQWRhcHRlclNlcnZpY2UgZXh0ZW5kcyBOYkRhdGVwaWNrZXJBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRlU2VydmljZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRhdGVTZXJ2aWNlID0gZGF0ZVNlcnZpY2U7XG4gICAgICAgIHRoaXMucGlja2VyID0gTmJSYW5nZXBpY2tlckNvbXBvbmVudDtcbiAgICB9XG4gICAgcGFyc2UocmFuZ2UsIGZvcm1hdCkge1xuICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSByYW5nZS5zcGxpdCgnLScpLm1hcChzdWJEYXRlID0+IHN1YkRhdGUudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmRhdGVTZXJ2aWNlLnBhcnNlKHN0YXJ0LCBmb3JtYXQpLFxuICAgICAgICAgICAgZW5kOiB0aGlzLmRhdGVTZXJ2aWNlLnBhcnNlKGVuZCwgZm9ybWF0KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZm9ybWF0KHJhbmdlLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5kYXRlU2VydmljZS5mb3JtYXQocmFuZ2Uuc3RhcnQsIGZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGlzU3RhcnRWYWxpZCA9IHRoaXMuZGF0ZVNlcnZpY2UuaXNWYWxpZERhdGVTdHJpbmcoc3RhcnQsIGZvcm1hdCk7XG4gICAgICAgIGlmICghaXNTdGFydFZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5kYXRlU2VydmljZS5mb3JtYXQocmFuZ2UuZW5kLCBmb3JtYXQpO1xuICAgICAgICBjb25zdCBpc0VuZFZhbGlkID0gdGhpcy5kYXRlU2VydmljZS5pc1ZhbGlkRGF0ZVN0cmluZyhlbmQsIGZvcm1hdCk7XG4gICAgICAgIGlmIChpc0VuZFZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7c3RhcnR9IC0gJHtlbmR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1ZhbGlkKHJhbmdlLCBmb3JtYXQpIHtcbiAgICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gcmFuZ2Uuc3BsaXQoJy0nKS5tYXAoc3ViRGF0ZSA9PiBzdWJEYXRlLnRyaW0oKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGVTZXJ2aWNlLmlzVmFsaWREYXRlU3RyaW5nKHN0YXJ0LCBmb3JtYXQpICYmIHRoaXMuZGF0ZVNlcnZpY2UuaXNWYWxpZERhdGVTdHJpbmcoZW5kLCBmb3JtYXQpO1xuICAgIH1cbn07XG5OYlJhbmdlQWRhcHRlclNlcnZpY2UgPSBfX2RlY29yYXRlJDE0NihbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEkOTgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJEYXRlU2VydmljZV0pXG5dLCBOYlJhbmdlQWRhcHRlclNlcnZpY2UpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDE0MiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgTmJEYXRlcGlja2VyTW9kdWxlXzE7XG5sZXQgTmJEYXRlcGlja2VyTW9kdWxlID0gTmJEYXRlcGlja2VyTW9kdWxlXzEgPSBjbGFzcyBOYkRhdGVwaWNrZXJNb2R1bGUge1xuICAgIHN0YXRpYyBmb3JSb290KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmdNb2R1bGU6IE5iRGF0ZXBpY2tlck1vZHVsZV8xLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgRGF0ZVBpcGUsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOQl9EQVRFX0FEQVBURVIsXG4gICAgICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1c2VDbGFzczogTmJEYXRlQWRhcHRlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGU6IE5CX0RBVEVfQURBUFRFUixcbiAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVzZUNsYXNzOiBOYlJhbmdlQWRhcHRlclNlcnZpY2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbk5iRGF0ZXBpY2tlck1vZHVsZSA9IE5iRGF0ZXBpY2tlck1vZHVsZV8xID0gX19kZWNvcmF0ZSQxNDIoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgaW1wb3J0czogW05iT3ZlcmxheU1vZHVsZSwgTmJDYWxlbmRhck1vZHVsZSwgTmJDYWxlbmRhclJhbmdlTW9kdWxlXSxcbiAgICAgICAgZXhwb3J0czogW05iRGF0ZXBpY2tlckRpcmVjdGl2ZSwgTmJEYXRlcGlja2VyQ29tcG9uZW50LCBOYlJhbmdlcGlja2VyQ29tcG9uZW50XSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICBOYkRhdGVwaWNrZXJEaXJlY3RpdmUsXG4gICAgICAgICAgICBOYkRhdGVwaWNrZXJDb250YWluZXJDb21wb25lbnQsXG4gICAgICAgICAgICBOYkRhdGVwaWNrZXJDb21wb25lbnQsXG4gICAgICAgICAgICBOYlJhbmdlcGlja2VyQ29tcG9uZW50LFxuICAgICAgICAgICAgTmJCYXNlUGlja2VyQ29tcG9uZW50LFxuICAgICAgICBdLFxuICAgICAgICBlbnRyeUNvbXBvbmVudHM6IFtOYkNhbGVuZGFyQ29tcG9uZW50LCBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQsIE5iRGF0ZXBpY2tlckNvbnRhaW5lckNvbXBvbmVudF0sXG4gICAgfSlcbl0sIE5iRGF0ZXBpY2tlck1vZHVsZSk7XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTQ4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDk5ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG4vKipcbiAqIFRoZSBgTmJSYWRpb0NvbXBvbmVudGAgcHJvdmlkZXMgdGhlIHNhbWUgZnVuY3Rpb25hbGl0eSBhcyBuYXRpdmUgYDxpbnB1dCB0eXBlPVwicmFkaW9cIj5gXG4gKiB3aXRoIE5lYnVsYXIgc3R5bGVzIGFuZCBhbmltYXRpb25zLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIHJhZGlvL3JhZGlvLXNob3djYXNlLmNvbXBvbmVudClcbiAqXG4gKiAjIyMgSW5zdGFsbGF0aW9uXG4gKlxuICogSW1wb3J0IGBOYlJhZGlvTW9kdWxlYCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICpcbiAqIGBgYHRzXG4gKiBATmdNb2R1bGUoe1xuICogICBpbXBvcnRzOiBbXG4gKiAgICAgLy8gLi4uXG4gKiAgICAgTmJSYWRpb01vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICpcbiAqICMjIyBVc2FnZVxuICpcbiAqIFJhZGlvIGJ1dHRvbnMgc2hvdWxkIGJlIHdyYXBwZWQgaW4gYG5iLXJhZGlvLWdyb3VwYCB0byBwcm92aWRlIGZvcm0gYmluZGluZ3MuXG4gKlxuICogYGBgaHRtbFxuICogPG5iLXJhZGlvLWdyb3VwIFsobmdNb2RlbCldPVwic2VsZWN0ZWRPcHRpb25cIj5cbiAqICAgPG5iLXJhZGlvIHZhbHVlPVwiMVwiPk9wdGlvbiAxPC9uYi1yYWRpbz5cbiAqICAgPG5iLXJhZGlvIHZhbHVlPVwiMlwiPk9wdGlvbiAyPC9uYi1yYWRpbz5cbiAqICAgPG5iLXJhZGlvIHZhbHVlPVwiM1wiPk9wdGlvbiAzPC9uYi1yYWRpbz5cbiAqIDwvbmItcmFkaW8tZ3JvdXA+XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGRpc2FibGUgc29tZSByYWRpb3MgaW4gdGhlIGdyb3VwIHVzaW5nIGEgYGRpc2FibGVkYCBhdHRyaWJ1dGUuXG4gKlxuICogQHN0YWNrZWQtZXhhbXBsZShEaXNhYmxlZCwgcmFkaW8vcmFkaW8tZGlzYWJsZWQuY29tcG9uZW50KVxuICpcbiAqXG4gKiBAc3R5bGVzXG4gKlxuICogcmFkaW8td2lkdGg6XG4gKiByYWRpby1oZWlnaHQ6XG4gKiByYWRpby1ib3JkZXItc3R5bGU6XG4gKiByYWRpby1ib3JkZXItd2lkdGg6XG4gKiByYWRpby10ZXh0LWZvbnQtZmFtaWx5OlxuICogcmFkaW8tdGV4dC1mb250LXNpemU6XG4gKiByYWRpby10ZXh0LWZvbnQtd2VpZ2h0OlxuICogcmFkaW8tdGV4dC1saW5lLWhlaWdodDpcbiAqIHJhZGlvLW91dGxpbmUtY29sb3I6XG4gKiByYWRpby1vdXRsaW5lLXdpZHRoOlxuICogcmFkaW8tYmFzaWMtdGV4dC1jb2xvcjpcbiAqIHJhZGlvLWJhc2ljLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1iYXNpYy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1iYXNpYy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWJhc2ljLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWJhc2ljLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWJhc2ljLWZvY3VzLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWJhc2ljLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1iYXNpYy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiByYWRpby1iYXNpYy1ob3Zlci1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1iYXNpYy1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1iYXNpYy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tYmFzaWMtYWN0aXZlLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWJhc2ljLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1iYXNpYy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1iYXNpYy1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogcmFkaW8tYmFzaWMtZGlzYWJsZWQtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tYmFzaWMtZGlzYWJsZWQtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1iYXNpYy1kaXNhYmxlZC1jaGVja2VkLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktdGV4dC1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1wcmltYXJ5LWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1wcmltYXJ5LWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktZm9jdXMtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiByYWRpby1wcmltYXJ5LWhvdmVyLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1hY3RpdmUtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tcHJpbWFyeS1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1wcmltYXJ5LWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiByYWRpby1wcmltYXJ5LWRpc2FibGVkLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXByaW1hcnktZGlzYWJsZWQtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1wcmltYXJ5LWRpc2FibGVkLWNoZWNrZWQtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy10ZXh0LWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1ib3JkZXItY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXN1Y2Nlc3MtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLXN1Y2Nlc3MtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1mb2N1cy1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXN1Y2Nlc3MtaG92ZXItaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWFjdGl2ZS1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1zdWNjZXNzLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXN1Y2Nlc3MtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHJhZGlvLXN1Y2Nlc3MtZGlzYWJsZWQtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tc3VjY2Vzcy1kaXNhYmxlZC1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXN1Y2Nlc3MtZGlzYWJsZWQtY2hlY2tlZC1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1pbmZvLXRleHQtY29sb3I6XG4gKiByYWRpby1pbmZvLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWluZm8tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLWluZm8tY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8taW5mby1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWluZm8taW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8taW5mby1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiByYWRpby1pbmZvLWZvY3VzLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWluZm8taG92ZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLWluZm8taG92ZXItYm9yZGVyLWNvbG9yOlxuICogcmFkaW8taW5mby1ob3Zlci1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1pbmZvLWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLWluZm8tYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWluZm8tYWN0aXZlLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWluZm8tZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLWluZm8tZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8taW5mby1kaXNhYmxlZC10ZXh0LWNvbG9yOlxuICogcmFkaW8taW5mby1kaXNhYmxlZC1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1pbmZvLWRpc2FibGVkLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8taW5mby1kaXNhYmxlZC1jaGVja2VkLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctdGV4dC1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctYm9yZGVyLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby13YXJuaW5nLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby13YXJuaW5nLWZvY3VzLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctZm9jdXMtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiByYWRpby13YXJuaW5nLWhvdmVyLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1hY3RpdmUtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8td2FybmluZy1kaXNhYmxlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby13YXJuaW5nLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiByYWRpby13YXJuaW5nLWRpc2FibGVkLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLXdhcm5pbmctZGlzYWJsZWQtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby13YXJuaW5nLWRpc2FibGVkLWNoZWNrZWQtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLXRleHQtY29sb3I6XG4gKiByYWRpby1kYW5nZXItYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1kYW5nZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiByYWRpby1kYW5nZXItZm9jdXMtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1kYW5nZXItaG92ZXItYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWhvdmVyLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1kYW5nZXItYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWRhbmdlci1hY3RpdmUtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1kYW5nZXItZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWRpc2FibGVkLXRleHQtY29sb3I6XG4gKiByYWRpby1kYW5nZXItZGlzYWJsZWQtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWRpc2FibGVkLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tZGFuZ2VyLWRpc2FibGVkLWNoZWNrZWQtaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC10ZXh0LWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1jb250cm9sLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiByYWRpby1jb250cm9sLWlubmVyLWNpcmNsZS1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtZm9jdXMtYm9yZGVyLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1mb2N1cy1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1jb250cm9sLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1jb250cm9sLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtaG92ZXItaW5uZXItY2lyY2xlLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1jb250cm9sLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiByYWRpby1jb250cm9sLWFjdGl2ZS1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiByYWRpby1jb250cm9sLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiByYWRpby1jb250cm9sLWRpc2FibGVkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtZGlzYWJsZWQtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogcmFkaW8tY29udHJvbC1kaXNhYmxlZC1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHJhZGlvLWNvbnRyb2wtZGlzYWJsZWQtY2hlY2tlZC1pbm5lci1jaXJjbGUtY29sb3I6XG4gKiAqL1xubGV0IE5iUmFkaW9Db21wb25lbnQgPSBjbGFzcyBOYlJhZGlvQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjZCkge1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuX2NoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RhdHVzID0gJ2Jhc2ljJztcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5ibHVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICAgIHNldCBuYW1lKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9uYW1lICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICAgIH1cbiAgICBzZXQgY2hlY2tlZCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBib29sVmFsdWUgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5fY2hlY2tlZCAhPT0gYm9vbFZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja2VkID0gYm9vbFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgICAgY29uc3QgYm9vbFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KGRpc2FibGVkKTtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGVkICE9PSBib29sVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc2FibGVkID0gYm9vbFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jZC5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdHVzO1xuICAgIH1cbiAgICBzZXQgc3RhdHVzKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGVtcHR5U3RhdHVzV2FybmluZygnTmJSYWRpbycpO1xuICAgICAgICAgICAgdmFsdWUgPSAnYmFzaWMnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdGF0dXMgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0dXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzUHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAncHJpbWFyeSc7XG4gICAgfVxuICAgIGdldCBpc1N1Y2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnO1xuICAgIH1cbiAgICBnZXQgaXNXYXJuaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICd3YXJuaW5nJztcbiAgICB9XG4gICAgZ2V0IGlzRGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgaXNJbmZvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdpbmZvJztcbiAgICB9XG4gICAgZ2V0IGlzQmFzaWMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ2Jhc2ljJztcbiAgICB9XG4gICAgZ2V0IGlzQ29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnY29udHJvbCc7XG4gICAgfVxuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTQ4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTkoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEkOTkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIE5iUmFkaW9Db21wb25lbnQucHJvdG90eXBlLCBcIm5hbWVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE0OChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ5OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iUmFkaW9Db21wb25lbnQucHJvdG90eXBlLCBcImNoZWNrZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE0OChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBOYlJhZGlvQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTQ4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkOTkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0Jvb2xlYW5dKVxuXSwgTmJSYWRpb0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZGlzYWJsZWRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE0OChbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBOYlJhZGlvQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdGF0dXNcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE0OChbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQ5OShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE5iUmFkaW9Db21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDE0OChbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQ5OShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE5iUmFkaW9Db21wb25lbnQucHJvdG90eXBlLCBcImJsdXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTQ4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLXByaW1hcnknKSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ5OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJSYWRpb0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNQcmltYXJ5XCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxNDgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtc3VjY2VzcycpLFxuICAgIF9fbWV0YWRhdGEkOTkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlJhZGlvQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc1N1Y2Nlc3NcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE0OChbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy13YXJuaW5nJyksXG4gICAgX19tZXRhZGF0YSQ5OShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pLFxuICAgIF9fbWV0YWRhdGEkOTkoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iUmFkaW9Db21wb25lbnQucHJvdG90eXBlLCBcImlzV2FybmluZ1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTQ4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWRhbmdlcicpLFxuICAgIF9fbWV0YWRhdGEkOTkoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlJhZGlvQ29tcG9uZW50LnByb3RvdHlwZSwgXCJpc0RhbmdlclwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTQ4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWluZm8nKSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ5OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJSYWRpb0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNJbmZvXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxNDgoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtYmFzaWMnKSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ5OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJSYWRpb0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNCYXNpY1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTQ4KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWNvbnRyb2wnKSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQ5OShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJSYWRpb0NvbXBvbmVudC5wcm90b3R5cGUsIFwiaXNDb250cm9sXCIsIG51bGwpO1xuTmJSYWRpb0NvbXBvbmVudCA9IF9fZGVjb3JhdGUkMTQ4KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLXJhZGlvJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bGFiZWw+XG4gICAgICA8aW5wdXRcbiAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgY2xhc3M9XCJuYXRpdmUtaW5wdXQgdmlzdWFsbHktaGlkZGVuXCJcbiAgICAgICAgW25hbWVdPVwibmFtZVwiXG4gICAgICAgIFt2YWx1ZV09XCJ2YWx1ZVwiXG4gICAgICAgIFtjaGVja2VkXT1cImNoZWNrZWRcIlxuICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAoY2hhbmdlKT1cIm9uQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAoY2xpY2spPVwib25DbGljaygkZXZlbnQpXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cIm91dGVyLWNpcmNsZVwiPjwvc3Bhbj5cbiAgICAgIDxzcGFuIGNsYXNzPVwiaW5uZXItY2lyY2xlXCI+PC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJ0ZXh0XCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgIDwvc3Bhbj5cbiAgICA8L2xhYmVsPlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlfTpob3N0IGxhYmVse2Rpc3BsYXk6aW5saW5lLWZsZXg7bWFyZ2luOjA7bWluLWhlaWdodDppbmhlcml0O3BhZGRpbmc6MC4zNzVyZW0gMDthbGlnbi1pdGVtczpjZW50ZXJ9W2Rpcj1sdHJdIDpob3N0IGxhYmVse3BhZGRpbmctcmlnaHQ6MS41cmVtfVtkaXI9cnRsXSA6aG9zdCBsYWJlbHtwYWRkaW5nLWxlZnQ6MS41cmVtfTpob3N0IC5vdXRlci1jaXJjbGUsOmhvc3QgLmlubmVyLWNpcmNsZXtib3JkZXItcmFkaXVzOjUwJTtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfVtkaXI9bHRyXSA6aG9zdCAub3V0ZXItY2lyY2xlLFtkaXI9bHRyXSA6aG9zdCAuaW5uZXItY2lyY2xle2xlZnQ6MH1bZGlyPXJ0bF0gOmhvc3QgLm91dGVyLWNpcmNsZSxbZGlyPXJ0bF0gOmhvc3QgLmlubmVyLWNpcmNsZXtyaWdodDowfTpob3N0IC5pbm5lci1jaXJjbGV7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSkgc2NhbGUoMC42NSl9W2Rpcj1sdHJdIDpob3N0IC50ZXh0e3BhZGRpbmctbGVmdDouNXJlbX1bZGlyPXJ0bF0gOmhvc3QgLnRleHR7cGFkZGluZy1yaWdodDouNXJlbX1cXG5cIl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDk5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NoYW5nZURldGVjdG9yUmVmXSlcbl0sIE5iUmFkaW9Db21wb25lbnQpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDE0OSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxMDAgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDI1ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xudmFyIE5iUmFkaW9Hcm91cENvbXBvbmVudF8xO1xuLyoqXG4gKiBUaGUgYE5iUmFkaW9Hcm91cENvbXBvbmVudGAgaXMgdGhlIHdyYXBwZXIgZm9yIGBuYi1yYWRpb2AgYnV0dG9uLlxuICogSXQgcHJvdmlkZXMgZm9ybSBiaW5kaW5nczpcbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItcmFkaW8tZ3JvdXAgWyhuZ01vZGVsKV09XCJzZWxlY3RlZE9wdGlvblwiPlxuICogICA8bmItcmFkaW8gdmFsdWU9XCIxXCI+T3B0aW9uIDE8L25iLXJhZGlvPlxuICogICA8bmItcmFkaW8gdmFsdWU9XCIyXCI+T3B0aW9uIDI8L25iLXJhZGlvPlxuICogICA8bmItcmFkaW8gdmFsdWU9XCIzXCI+T3B0aW9uIDM8L25iLXJhZGlvPlxuICogPC9uYi1yYWRpby1ncm91cD5cbiAqIGBgYFxuICpcbiAqIEFsc28sIHlvdSBjYW4gdXNlIGB2YWx1ZWAgYW5kIGB2YWx1ZUNoYW5nZWAgZm9yIGJpbmRpbmcgd2l0aG91dCBmb3Jtcy5cbiAqXG4gKiBgYGBodG1sXG4gKiA8bmItcmFkaW8tZ3JvdXAgWyh2YWx1ZSldPVwic2VsZWN0ZWRPcHRpb25cIj5cbiAqICAgPG5iLXJhZGlvIHZhbHVlPVwiMVwiPk9wdGlvbiAxPC9uYi1yYWRpbz5cbiAqICAgPG5iLXJhZGlvIHZhbHVlPVwiMlwiPk9wdGlvbiAyPC9uYi1yYWRpbz5cbiAqICAgPG5iLXJhZGlvIHZhbHVlPVwiM1wiPk9wdGlvbiAzPC9uYi1yYWRpbz5cbiAqIDwvbmItcmFkaW8tZ3JvdXA+XG4gKiBgYGBcbiAqXG4gKiBSYWRpbyBpdGVtcyBuYW1lIGhhcyB0byBiZSBwcm92aWRlZCB0aHJvdWdoIGBuYW1lYCBpbnB1dCBwcm9wZXJ0eSBvZiB0aGUgcmFkaW8gZ3JvdXAuXG4gKlxuICogYGBgaHRtbFxuICogPG5iLXJhZGlvLWdyb3VwIG5hbWU9XCJteS1yYWRpby1ncm91cFwiPlxuICogICAuLi5cbiAqIDwvbmItcmFkaW8tZ3JvdXA+XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIGNoYW5nZSByYWRpbyBncm91cCBzdGF0dXMgYnkgc2V0dGluZyBgc3RhdHVzYCBpbnB1dC5cbiAqIEBzdGFja2VkLWV4YW1wbGUoU3RhdHVzZXMsIHJhZGlvL3JhZGlvLXN0YXR1c2VzLmNvbXBvbmVudClcbiAqXG4gKiBBbHNvLCB5b3UgY2FuIGRpc2FibGUgdGhlIHdob2xlIGdyb3VwIHVzaW5nIGBkaXNhYmxlZGAgYXR0cmlidXRlLlxuICogQHN0YWNrZWQtZXhhbXBsZShEaXNhYmxlZCBncm91cCwgcmFkaW8vcmFkaW8tZGlzYWJsZWQtZ3JvdXAuY29tcG9uZW50KVxuICpcbiAqICovXG5sZXQgTmJSYWRpb0dyb3VwQ29tcG9uZW50ID0gTmJSYWRpb0dyb3VwQ29tcG9uZW50XzEgPSBjbGFzcyBOYlJhZGlvR3JvdXBDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RFbGVtZW50LCBwbGF0Zm9ybUlkLCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLmhvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMucGxhdGZvcm1JZCA9IHBsYXRmb3JtSWQ7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAodmFsdWUpID0+IHsgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9ICdiYXNpYyc7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZXMoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICBzZXQgbmFtZShuYW1lKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnVwZGF0ZU5hbWVzKCk7XG4gICAgfVxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cbiAgICBzZXQgZGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb252ZXJ0VG9Cb29sUHJvcGVydHkoZGlzYWJsZWQpO1xuICAgICAgICB0aGlzLnVwZGF0ZURpc2FibGVkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJhZGlvIGJ1dHRvbnMgc3RhdHVzLlxuICAgICAqIFBvc3NpYmxlIHZhbHVlcyBhcmUgYHByaW1hcnlgIChkZWZhdWx0KSwgYHN1Y2Nlc3NgLCBgd2FybmluZ2AsIGBkYW5nZXJgLCBgaW5mb2AuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXR1cztcbiAgICB9XG4gICAgc2V0IHN0YXR1cyh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICBlbXB0eVN0YXR1c1dhcm5pbmcoJ05iUmFkaW8nKTtcbiAgICAgICAgICAgIHZhbHVlID0gJ2Jhc2ljJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3RhdHVzICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdHVzID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvcHRpb24gJ25hbWUnIGlzbid0IHNldCBvbiBuYi1yYWRpbyBjb21wb25lbnQsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc2V0IGl0J3MgbmFtZSByaWdodCBhd2F5LCBzbyBpdCB3b24ndCBvdmVybGFwIHdpdGggb3B0aW9uc1xuICAgICAgICAvLyB3aXRob3V0IG5hbWVzIGZyb20gb3RoZXIgcmFkaW8gZ3JvdXBzLiBPdGhlcndpc2UgdGhleSBhbGwgd291bGQgaGF2ZVxuICAgICAgICAvLyBzYW1lIG5hbWUgYW5kIHdpbGwgYmUgY29uc2lkZXJlZCBhcyBvcHRpb25zIGZyb20gb25lIGdyb3VwIHNvIG9ubHkgdGhlXG4gICAgICAgIC8vIGxhc3Qgb3B0aW9uIHdpbGwgc3RheSBzZWxlY3RlZC5cbiAgICAgICAgdGhpcy51cGRhdGVOYW1lcygpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHRoaXMudXBkYXRlQW5kU3Vic2NyaWJlVG9SYWRpb3MoKSk7XG4gICAgICAgIHRoaXMucmFkaW9zLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gJ2NoYW5nZXMnIGVtaXQgZHVyaW5nIGNoYW5nZSBkZXRlY3Rpb24gcnVuIGFuZCB3ZSBjYW4ndCB1cGRhdGVcbiAgICAgICAgICAgIC8vIG9wdGlvbiBwcm9wZXJ0aWVzIHJpZ2h0IG9mIHNpbmNlIHRoZXkgYWxyZWFkeSB3YXMgaW5pdGlhbGl6ZWQuXG4gICAgICAgICAgICAvLyBJbnN0ZWFkIHdlIHNjaGVkdWxlIG1pY3JvdGFzayB0byB1cGRhdGUgcmFkaW9zIGFmdGVyIGNoYW5nZSBkZXRlY3Rpb25cbiAgICAgICAgICAgIC8vIHJ1biBpcyBmaW5pc2hlZC5cbiAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gdGhpcy51cGRhdGVBbmRTdWJzY3JpYmVUb1JhZGlvcygpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgfVxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH1cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQW5kU3Vic2NyaWJlVG9SYWRpb3MoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTmFtZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVEaXNhYmxlZCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXR1cygpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZU9uUmFkaW9zVmFsdWVDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVPblJhZGlvc0JsdXIoKTtcbiAgICB9XG4gICAgdXBkYXRlTmFtZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnJhZGlvcykge1xuICAgICAgICAgICAgdGhpcy5yYWRpb3MuZm9yRWFjaCgocmFkaW8pID0+IHJhZGlvLm5hbWUgPSB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVZhbHVlcygpIHtcbiAgICAgICAgaWYgKHRoaXMucmFkaW9zICYmIHR5cGVvZiB0aGlzLnZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5yYWRpb3MuZm9yRWFjaCgocmFkaW8pID0+IHJhZGlvLmNoZWNrZWQgPSByYWRpby52YWx1ZSA9PT0gdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRGlzYWJsZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJhZGlvcyAmJiB0eXBlb2YgdGhpcy5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMucmFkaW9zLmZvckVhY2goKHJhZGlvKSA9PiByYWRpby5kaXNhYmxlZCA9IHRoaXMuZGlzYWJsZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZU9uUmFkaW9zVmFsdWVDaGFuZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5yYWRpb3MgfHwgIXRoaXMucmFkaW9zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlKC4uLnRoaXMucmFkaW9zLm1hcCgocmFkaW8pID0+IHJhZGlvLnZhbHVlQ2hhbmdlKSlcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSwgdGFrZVVudGlsKHRoaXMucmFkaW9zLmNoYW5nZXMpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZVZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHByb3BhZ2F0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgIHRoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVPblJhZGlvc0JsdXIoKSB7XG4gICAgICAgIGNvbnN0IGhhc05vUmFkaW9zID0gIXRoaXMucmFkaW9zIHx8ICF0aGlzLnJhZGlvcy5sZW5ndGg7XG4gICAgICAgIGlmICghaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSB8fCBoYXNOb1JhZGlvcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3RFbGVtZW50ID0gdGhpcy5ob3N0RWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBmcm9tRXZlbnQoaG9zdEVsZW1lbnQsICdmb2N1c2luJylcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSwgZmlsdGVyKGV2ZW50ID0+IGhvc3RFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpLCBzd2l0Y2hNYXAoKCkgPT4gbWVyZ2UoZnJvbUV2ZW50KHRoaXMuZG9jdW1lbnQsICdmb2N1c2luJyksIGZyb21FdmVudCh0aGlzLmRvY3VtZW50LCAnY2xpY2snKSkpLCBmaWx0ZXIoZXZlbnQgPT4gIWhvc3RFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpLCB0YWtlVW50aWwodGhpcy5yYWRpb3MuY2hhbmdlcykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMub25Ub3VjaGVkKCkpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnJhZGlvcykge1xuICAgICAgICAgICAgdGhpcy5yYWRpb3MuZm9yRWFjaCgocmFkaW8pID0+IHJhZGlvLnN0YXR1cyA9IHRoaXMuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5fX2RlY29yYXRlJDE0OShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDEwMChcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxMDAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIE5iUmFkaW9Hcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwidmFsdWVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE0OShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDEwMChcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YSQxMDAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbU3RyaW5nXSlcbl0sIE5iUmFkaW9Hcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwibmFtZVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTQ5KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTAwKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQxMDAoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlJhZGlvR3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcImRpc2FibGVkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxNDkoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxMDAoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEkMTAwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1N0cmluZ10pXG5dLCBOYlJhZGlvR3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXR1c1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTQ5KFtcbiAgICBDb250ZW50Q2hpbGRyZW4oTmJSYWRpb0NvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhJDEwMChcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIE5iUmFkaW9Hcm91cENvbXBvbmVudC5wcm90b3R5cGUsIFwicmFkaW9zXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDE0OShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YSQxMDAoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBOYlJhZGlvR3JvdXBDb21wb25lbnQucHJvdG90eXBlLCBcInZhbHVlQ2hhbmdlXCIsIHZvaWQgMCk7XG5OYlJhZGlvR3JvdXBDb21wb25lbnQgPSBOYlJhZGlvR3JvdXBDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUkMTQ5KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLXJhZGlvLWdyb3VwJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJuYi1yYWRpb1wiPjwvbmctY29udGVudD5gLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOYlJhZGlvR3JvdXBDb21wb25lbnRfMSksXG4gICAgICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgIH0pLFxuICAgIF9fcGFyYW0kMjUoMSwgSW5qZWN0KFBMQVRGT1JNX0lEKSksXG4gICAgX19wYXJhbSQyNSgyLCBJbmplY3QoTkJfRE9DVU1FTlQpKSxcbiAgICBfX21ldGFkYXRhJDEwMChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtFbGVtZW50UmVmLCBPYmplY3QsIE9iamVjdF0pXG5dLCBOYlJhZGlvR3JvdXBDb21wb25lbnQpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDE0NyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5sZXQgTmJSYWRpb01vZHVsZSA9IGNsYXNzIE5iUmFkaW9Nb2R1bGUge1xufTtcbk5iUmFkaW9Nb2R1bGUgPSBfX2RlY29yYXRlJDE0NyhbXG4gICAgTmdNb2R1bGUoe1xuICAgICAgICBpbXBvcnRzOiBbXSxcbiAgICAgICAgZXhwb3J0czogW05iUmFkaW9Db21wb25lbnQsIE5iUmFkaW9Hcm91cENvbXBvbmVudF0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogW05iUmFkaW9Db21wb25lbnQsIE5iUmFkaW9Hcm91cENvbXBvbmVudF0sXG4gICAgfSlcbl0sIE5iUmFkaW9Nb2R1bGUpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IE5CX0RFRkFVTFRfUk9XX0xFVkVMID0gMDtcbi8qKlxuICogSW1wbGljaXQgY29udGV4dCBvZiBjZWxscyBhbmQgcm93c1xuICovXG5jbGFzcyBOYlRyZWVHcmlkUHJlc2VudGF0aW9uTm9kZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogRGF0YSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHJvd1xuICAgICAqL1xuICAgIGRhdGEsIGNoaWxkcmVuLCBcbiAgICAvKipcbiAgICAgKiBSb3cgZXhwYW5kIHN0YXRlXG4gICAgICovXG4gICAgZXhwYW5kZWQsIGxldmVsKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA9IGV4cGFuZGVkO1xuICAgICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgcm93IGhhcyBjaGlsZCByb3dzXG4gICAgICovXG4gICAgaGFzQ2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuY2hpbGRyZW4gJiYgISF0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICB9XG59XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTUzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmxldCBOYlRyZWVHcmlkRGF0YVNlcnZpY2UgPSBjbGFzcyBOYlRyZWVHcmlkRGF0YVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRHZXR0ZXJzID0ge1xuICAgICAgICAgICAgZGF0YUdldHRlcjogbm9kZSA9PiBub2RlLmRhdGEsXG4gICAgICAgICAgICBjaGlsZHJlbkdldHRlcjogZCA9PiBkLmNoaWxkcmVuIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV4cGFuZGVkR2V0dGVyOiBkID0+ICEhZC5leHBhbmRlZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9QcmVzZW50YXRpb25Ob2Rlcyhub2RlcywgY3VzdG9tR2V0dGVycywgbGV2ZWwgPSBOQl9ERUZBVUxUX1JPV19MRVZFTCkge1xuICAgICAgICBjb25zdCBnZXR0ZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0R2V0dGVycywgY3VzdG9tR2V0dGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcE5vZGVzKG5vZGVzLCBnZXR0ZXJzLCBsZXZlbCk7XG4gICAgfVxuICAgIG1hcE5vZGVzKG5vZGVzLCBnZXR0ZXJzLCBsZXZlbCkge1xuICAgICAgICBjb25zdCB7IGRhdGFHZXR0ZXIsIGNoaWxkcmVuR2V0dGVyLCBleHBhbmRlZEdldHRlciB9ID0gZ2V0dGVycztcbiAgICAgICAgcmV0dXJuIG5vZGVzLm1hcChub2RlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuTm9kZXMgPSBjaGlsZHJlbkdldHRlcihub2RlKTtcbiAgICAgICAgICAgIGxldCBjaGlsZHJlbjtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbk5vZGVzKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLnRvUHJlc2VudGF0aW9uTm9kZXMoY2hpbGRyZW5Ob2RlcywgZ2V0dGVycywgbGV2ZWwgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgTmJUcmVlR3JpZFByZXNlbnRhdGlvbk5vZGUoZGF0YUdldHRlcihub2RlKSwgY2hpbGRyZW4sIGV4cGFuZGVkR2V0dGVyKG5vZGUpLCBsZXZlbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmbGF0dGVuRXhwYW5kZWQobm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVzLnJlZHVjZSgocmVzLCBub2RlKSA9PiB7XG4gICAgICAgICAgICByZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIGlmIChub2RlLmV4cGFuZGVkICYmIG5vZGUuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgICAgIHJlcy5wdXNoKC4uLnRoaXMuZmxhdHRlbkV4cGFuZGVkKG5vZGUuY2hpbGRyZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgY29weShub2Rlcykge1xuICAgICAgICByZXR1cm4gbm9kZXMubWFwKChub2RlKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2hpbGRyZW47XG4gICAgICAgICAgICBpZiAobm9kZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNvcHkobm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5iVHJlZUdyaWRQcmVzZW50YXRpb25Ob2RlKG5vZGUuZGF0YSwgY2hpbGRyZW4sIG5vZGUuZXhwYW5kZWQsIG5vZGUubGV2ZWwpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuTmJUcmVlR3JpZERhdGFTZXJ2aWNlID0gX19kZWNvcmF0ZSQxNTMoW1xuICAgIEluamVjdGFibGUoKVxuXSwgTmJUcmVlR3JpZERhdGFTZXJ2aWNlKTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxNTQgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuLyoqXG4gKiBTZXJ2aWNlIHVzZWQgdG8gZmlsdGVyIHRyZWUgZ3JpZCBkYXRhLiBTZWFyY2hlZCBzZWFyY2hTdHJpbmcgaW4gYWxsIG9iamVjdCB2YWx1ZXMuXG4gKiBJZiB5b3UgbmVlZCBjdXN0b20gZmlsdGVyLCB5b3UgY2FuIGV4dGVuZCB0aGlzIHNlcnZpY2UgYW5kIG92ZXJyaWRlIGZpbHRlclByZWRpY2F0ZSBvciB3aG9sZSBmaWx0ZXIgbWV0aG9kLlxuICovXG5sZXQgTmJUcmVlR3JpZEZpbHRlclNlcnZpY2UgPSBjbGFzcyBOYlRyZWVHcmlkRmlsdGVyU2VydmljZSB7XG4gICAgZmlsdGVyKHF1ZXJ5LCBkYXRhKSB7XG4gICAgICAgIGlmICghcXVlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLnJlZHVjZSgoZmlsdGVyZWQsIG5vZGUpID0+IHtcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZENoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZENoaWxkcmVuID0gdGhpcy5maWx0ZXIocXVlcnksIG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4gPSBmaWx0ZXJlZENoaWxkcmVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGZpbHRlcmVkQ2hpbGRyZW4gJiYgZmlsdGVyZWRDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBub2RlLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5maWx0ZXJQcmVkaWNhdGUobm9kZS5kYXRhLCBxdWVyeSkpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGZpbHRlclByZWRpY2F0ZShkYXRhLCBzZWFyY2hRdWVyeSkge1xuICAgICAgICBjb25zdCBwcmVwYXJlZFF1ZXJ5ID0gc2VhcmNoUXVlcnkudHJpbSgpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIE9iamVjdC52YWx1ZXMoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkVmFsID0gYCR7dmFsfWAudHJpbSgpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWRWYWwuaW5jbHVkZXMocHJlcGFyZWRRdWVyeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbk5iVHJlZUdyaWRGaWx0ZXJTZXJ2aWNlID0gX19kZWNvcmF0ZSQxNTQoW1xuICAgIEluamVjdGFibGUoKVxuXSwgTmJUcmVlR3JpZEZpbHRlclNlcnZpY2UpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDE1NiA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxMDMgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDI3ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xudmFyIE5iU29ydERpcmVjdGlvbjtcbihmdW5jdGlvbiAoTmJTb3J0RGlyZWN0aW9uKSB7XG4gICAgTmJTb3J0RGlyZWN0aW9uW1wiQVNDRU5ESU5HXCJdID0gXCJhc2NcIjtcbiAgICBOYlNvcnREaXJlY3Rpb25bXCJERVNDRU5ESU5HXCJdID0gXCJkZXNjXCI7XG4gICAgTmJTb3J0RGlyZWN0aW9uW1wiTk9ORVwiXSA9IFwiXCI7XG59KShOYlNvcnREaXJlY3Rpb24gfHwgKE5iU29ydERpcmVjdGlvbiA9IHt9KSk7XG5jb25zdCBzb3J0RGlyZWN0aW9ucyA9IFtcbiAgICBOYlNvcnREaXJlY3Rpb24uQVNDRU5ESU5HLFxuICAgIE5iU29ydERpcmVjdGlvbi5ERVNDRU5ESU5HLFxuICAgIE5iU29ydERpcmVjdGlvbi5OT05FLFxuXTtcbi8qKlxuICogRGlyZWN0aXZlIHRyaWdnZXJzIHNvcnQgbWV0aG9kIG9mIHBhc3NlZCBvYmplY3Qgd2hlbiBzb3J0IGhlYWRlciBjaGFuZ2VzIGRpcmVjdGlvblxuICovXG5sZXQgTmJTb3J0RGlyZWN0aXZlID0gY2xhc3MgTmJTb3J0RGlyZWN0aXZlIHtcbiAgICAvKipcbiAgICAgKiBEaXJlY3RpdmUgdHJpZ2dlcnMgc29ydCBtZXRob2Qgb2YgcGFzc2VkIG9iamVjdCB3aGVuIHNvcnQgaGVhZGVyIGNoYW5nZXMgZGlyZWN0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc29ydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgZW1pdFNvcnQoc29ydFJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ydGFibGUgJiYgdGhpcy5zb3J0YWJsZS5zb3J0KSB7XG4gICAgICAgICAgICB0aGlzLnNvcnRhYmxlLnNvcnQoc29ydFJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ydC5lbWl0KHNvcnRSZXF1ZXN0KTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxNTYoW1xuICAgIElucHV0KCduYlNvcnQnKSxcbiAgICBfX21ldGFkYXRhJDEwMyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iU29ydERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic29ydGFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTU2KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDEwMyhcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIE5iU29ydERpcmVjdGl2ZS5wcm90b3R5cGUsIFwic29ydFwiLCB2b2lkIDApO1xuTmJTb3J0RGlyZWN0aXZlID0gX19kZWNvcmF0ZSQxNTYoW1xuICAgIERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25iU29ydF0nIH0pXG5dLCBOYlNvcnREaXJlY3RpdmUpO1xuLyoqXG4gKiBEaXJlY3RpdmUgZm9yIGhlYWRlcnMgc29ydCBpY29ucy4gTWFyayB5b3UgaWNvbiBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoaXMgc3RydWN0dXJhbCBkaXJlY3RpdmUgYW5kXG4gKiBpdCdsbCBzZXQgdGVtcGxhdGUncyBpbXBsaWNpdCBjb250ZXh0IHdpdGggY3VycmVudCBkaXJlY3Rpb24uIENvbnRleHQgYWxzbyBoYXMgYGlzQXNjZW5kaW5nYCxcbiAqIGBpc0Rlc2NlbmRpbmdgIGFuZCBgaXNOb25lYCBwcm9wZXJ0aWVzLlxuICovXG5sZXQgTmJTb3J0SGVhZGVySWNvbkRpcmVjdGl2ZSA9IGNsYXNzIE5iU29ydEhlYWRlckljb25EaXJlY3RpdmUge1xufTtcbk5iU29ydEhlYWRlckljb25EaXJlY3RpdmUgPSBfX2RlY29yYXRlJDE1NihbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmJTb3J0SGVhZGVySWNvbl0nIH0pXG5dLCBOYlNvcnRIZWFkZXJJY29uRGlyZWN0aXZlKTtcbmxldCBOYlNvcnRJY29uQ29tcG9uZW50ID0gY2xhc3MgTmJTb3J0SWNvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gTmJTb3J0RGlyZWN0aW9uLk5PTkU7XG4gICAgfVxuICAgIGlzQXNjZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXJlY3Rpb24gPT09IE5iU29ydERpcmVjdGlvbi5BU0NFTkRJTkc7XG4gICAgfVxuICAgIGlzRGVzY2VuZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSBOYlNvcnREaXJlY3Rpb24uREVTQ0VORElORztcbiAgICB9XG4gICAgaXNEaXJlY3Rpb25TZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNjZW5kaW5nKCkgfHwgdGhpcy5pc0Rlc2NlbmRpbmcoKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxNTYoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxMDMoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlNvcnRJY29uQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgdm9pZCAwKTtcbk5iU29ydEljb25Db21wb25lbnQgPSBfX2RlY29yYXRlJDE1NihbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICduYi1zb3J0LWljb24nLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJpc0RpcmVjdGlvblNldCgpXCI+XG4gICAgICA8bmItaWNvbiAqbmdJZj1cImlzQXNjZW5kaW5nKClcIiBpY29uPVwiY2hldnJvbi1kb3duLW91dGxpbmVcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9uYi1pY29uPlxuICAgICAgPG5iLWljb24gKm5nSWY9XCJpc0Rlc2NlbmRpbmcoKVwiIGljb249XCJjaGV2cm9uLXVwLW91dGxpbmVcIiBwYWNrPVwibmVidWxhci1lc3NlbnRpYWxzXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9uYi1pY29uPlxuICAgIDwvbmctY29udGFpbmVyPlxuICBgXG4gICAgfSlcbl0sIE5iU29ydEljb25Db21wb25lbnQpO1xuLyoqXG4gKiBNYXJrcyBoZWFkZXIgYXMgc29ydCBoZWFkZXIgc28gaXQgZW1pdHRpbmcgc29ydCBldmVudCB3aGVuIGNsaWNrZWQuXG4gKi9cbmxldCBOYlNvcnRIZWFkZXJDb21wb25lbnQgPSBjbGFzcyBOYlNvcnRIZWFkZXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHNvcnQsIGNvbHVtbkRlZikge1xuICAgICAgICB0aGlzLnNvcnQgPSBzb3J0O1xuICAgICAgICB0aGlzLmNvbHVtbkRlZiA9IGNvbHVtbkRlZjtcbiAgICAgICAgdGhpcy5kaXNhYmxlZFZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGUgc29ydCBoZWFkZXJcbiAgICAgKi9cbiAgICBzZXQgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZFZhbHVlID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNhYmxlZFZhbHVlO1xuICAgIH1cbiAgICBzb3J0SWZFbmFibGVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc29ydERhdGEoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0FzY2VuZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uID09PSBOYlNvcnREaXJlY3Rpb24uQVNDRU5ESU5HO1xuICAgIH1cbiAgICBpc0Rlc2NlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gTmJTb3J0RGlyZWN0aW9uLkRFU0NFTkRJTkc7XG4gICAgfVxuICAgIHNvcnREYXRhKCkge1xuICAgICAgICBjb25zdCBzb3J0UmVxdWVzdCA9IHRoaXMuY3JlYXRlU29ydFJlcXVlc3QoKTtcbiAgICAgICAgdGhpcy5zb3J0LmVtaXRTb3J0KHNvcnRSZXF1ZXN0KTtcbiAgICB9XG4gICAgZ2V0SWNvbkNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkaW1wbGljaXQ6IHRoaXMuZGlyZWN0aW9uLFxuICAgICAgICAgICAgaXNBc2NlbmRpbmc6IHRoaXMuaXNBc2NlbmRpbmcoKSxcbiAgICAgICAgICAgIGlzRGVzY2VuZGluZzogdGhpcy5pc0Rlc2NlbmRpbmcoKSxcbiAgICAgICAgICAgIGlzTm9uZTogIXRoaXMuaXNBc2NlbmRpbmcoKSAmJiAhdGhpcy5pc0Rlc2NlbmRpbmcoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0RGlzYWJsZWRBdHRyaWJ1dGVWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyAnJyA6IG51bGw7XG4gICAgfVxuICAgIGNyZWF0ZVNvcnRSZXF1ZXN0KCkge1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IHRoaXMuZ2V0TmV4dERpcmVjdGlvbigpO1xuICAgICAgICByZXR1cm4geyBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLCBjb2x1bW46IHRoaXMuY29sdW1uRGVmLm5hbWUgfTtcbiAgICB9XG4gICAgZ2V0TmV4dERpcmVjdGlvbigpIHtcbiAgICAgICAgY29uc3Qgc29ydERpcmVjdGlvbkN5Y2xlID0gc29ydERpcmVjdGlvbnM7XG4gICAgICAgIGxldCBuZXh0RGlyZWN0aW9uSW5kZXggPSBzb3J0RGlyZWN0aW9uQ3ljbGUuaW5kZXhPZih0aGlzLmRpcmVjdGlvbikgKyAxO1xuICAgICAgICBpZiAobmV4dERpcmVjdGlvbkluZGV4ID49IHNvcnREaXJlY3Rpb25DeWNsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5leHREaXJlY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvcnREaXJlY3Rpb25DeWNsZVtuZXh0RGlyZWN0aW9uSW5kZXhdO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDE1NihbXG4gICAgQ29udGVudENoaWxkKE5iU29ydEhlYWRlckljb25EaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YSQxMDMoXCJkZXNpZ246dHlwZVwiLCBUZW1wbGF0ZVJlZilcbl0sIE5iU29ydEhlYWRlckNvbXBvbmVudC5wcm90b3R5cGUsIFwic29ydEljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTU2KFtcbiAgICBJbnB1dCgnbmJTb3J0SGVhZGVyJyksXG4gICAgX19tZXRhZGF0YSQxMDMoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYlNvcnRIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxNTYoW1xuICAgIElucHV0KCksXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLmRpc2FibGVkJyksXG4gICAgX19tZXRhZGF0YSQxMDMoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDEwMyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgTmJTb3J0SGVhZGVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTU2KFtcbiAgICBIb3N0TGlzdGVuZXIoJ2NsaWNrJyksXG4gICAgX19tZXRhZGF0YSQxMDMoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YSQxMDMoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSksXG4gICAgX19tZXRhZGF0YSQxMDMoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBOYlNvcnRIZWFkZXJDb21wb25lbnQucHJvdG90eXBlLCBcInNvcnRJZkVuYWJsZWRcIiwgbnVsbCk7XG5OYlNvcnRIZWFkZXJDb21wb25lbnQgPSBfX2RlY29yYXRlJDE1NihbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICdbbmJTb3J0SGVhZGVyXScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGJ1dHRvblxuICAgICAgY2xhc3M9XCJuYi10cmVlLWdyaWQtaGVhZGVyLWNoYW5nZS1zb3J0LWJ1dHRvblwiXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIFthdHRyLmRpc2FibGVkXT1cImdldERpc2FibGVkQXR0cmlidXRlVmFsdWUoKVwiXG4gICAgICAoY2xpY2spPVwic29ydERhdGEoKVwiPlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvYnV0dG9uPlxuICAgIDxuYi1zb3J0LWljb24gKm5nSWY9XCIhc29ydEljb247IGVsc2UgY3VzdG9tSWNvblwiIFtkaXJlY3Rpb25dPVwiZGlyZWN0aW9uXCI+PC9uYi1zb3J0LWljb24+XG4gICAgPG5nLXRlbXBsYXRlICNjdXN0b21JY29uIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInNvcnRJY29uXCIgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cImdldEljb25Db250ZXh0KClcIj48L25nLXRlbXBsYXRlPlxuICBgLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxuICAgIH0pLFxuICAgIF9fcGFyYW0kMjcoMSwgSW5qZWN0KE5CX1NPUlRfSEVBREVSX0NPTFVNTl9ERUYpKSxcbiAgICBfX21ldGFkYXRhJDEwMyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYlNvcnREaXJlY3RpdmUsIE9iamVjdF0pXG5dLCBOYlNvcnRIZWFkZXJDb21wb25lbnQpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDE1NSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG4vKipcbiAqIFNlcnZpY2UgdXNlZCB0byBzb3J0IHRyZWUgZ3JpZCBkYXRhLiBVc2VzIEFycmF5LnByb3RvdHlwZS5zb3J0IG1ldGhvZC5cbiAqIElmIHlvdSBuZWVkIGN1c3RvbSBzb3J0aW5nLCB5b3UgY2FuIGV4dGVuZCB0aGlzIHNlcnZpY2UgYW5kIG92ZXJyaWRlIGNvbXBhcmF0b3Igb3Igd2hvbGUgc29ydCBtZXRob2QuXG4gKi9cbmxldCBOYlRyZWVHcmlkU29ydFNlcnZpY2UgPSBjbGFzcyBOYlRyZWVHcmlkU29ydFNlcnZpY2Uge1xuICAgIHNvcnQocmVxdWVzdCwgZGF0YSkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IGRhdGEuc29ydCgobmEsIG5iKSA9PiB0aGlzLmNvbXBhcmF0b3IocmVxdWVzdCwgbmEsIG5iKSk7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4gPSB0aGlzLnNvcnQocmVxdWVzdCwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvcnRlZDtcbiAgICB9XG4gICAgY29tcGFyYXRvcihyZXF1ZXN0LCBuYSwgbmIpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcmVxdWVzdC5jb2x1bW47XG4gICAgICAgIGNvbnN0IGRpciA9IHJlcXVlc3QuZGlyZWN0aW9uO1xuICAgICAgICBjb25zdCBhID0gbmEuZGF0YVtrZXldO1xuICAgICAgICBjb25zdCBiID0gbmIuZGF0YVtrZXldO1xuICAgICAgICBsZXQgcmVzID0gMDtcbiAgICAgICAgaWYgKGEgPiBiKSB7XG4gICAgICAgICAgICByZXMgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgcmVzID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpciA9PT0gTmJTb3J0RGlyZWN0aW9uLkFTQ0VORElORyA/IHJlcyA6IHJlcyAqIC0xO1xuICAgIH1cbn07XG5OYlRyZWVHcmlkU29ydFNlcnZpY2UgPSBfX2RlY29yYXRlJDE1NShbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBOYlRyZWVHcmlkU29ydFNlcnZpY2UpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDE1NyA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5sZXQgTmJUcmVlR3JpZFNlcnZpY2UgPSBjbGFzcyBOYlRyZWVHcmlkU2VydmljZSB7XG4gICAgZXhwYW5kKGRhdGEsIHJvdywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmZpbmQoZGF0YSwgcm93KTtcbiAgICAgICAgbm9kZS5leHBhbmRlZCA9IHRydWU7XG4gICAgICAgIGlmIChvcHRpb25zLmRlZXAgJiYgbm9kZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goKG4pID0+IHRoaXMuZXhwYW5kKGRhdGEsIG4uZGF0YSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbGxhcHNlKGRhdGEsIHJvdywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmZpbmQoZGF0YSwgcm93KTtcbiAgICAgICAgbm9kZS5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAob3B0aW9ucy5kZWVwICYmIG5vZGUuaGFzQ2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKChuKSA9PiB0aGlzLmNvbGxhcHNlKGRhdGEsIG4uZGF0YSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvZ2dsZShkYXRhLCByb3csIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5maW5kKGRhdGEsIHJvdyk7XG4gICAgICAgIGlmIChub2RlLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlKGRhdGEsIHJvdywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZChkYXRhLCByb3csIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmQoZGF0YSwgcm93KSB7XG4gICAgICAgIGNvbnN0IHRvQ2hlY2sgPSBbLi4uZGF0YV07XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0b0NoZWNrKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSByb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmhhc0NoaWxkcmVuKCkpIHtcbiAgICAgICAgICAgICAgICB0b0NoZWNrLnB1c2goLi4ubm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuTmJUcmVlR3JpZFNlcnZpY2UgPSBfX2RlY29yYXRlJDE1NyhbXG4gICAgSW5qZWN0YWJsZSgpXG5dLCBOYlRyZWVHcmlkU2VydmljZSk7XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTUyID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEwMiA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xuY2xhc3MgTmJUcmVlR3JpZERhdGFTb3VyY2UgZXh0ZW5kcyBOYkRhdGFTb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvcnRTZXJ2aWNlLCBmaWx0ZXJTZXJ2aWNlLCB0cmVlR3JpZFNlcnZpY2UsIHRyZWVHcmlkRGF0YVNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zb3J0U2VydmljZSA9IHNvcnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmZpbHRlclNlcnZpY2UgPSBmaWx0ZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLnRyZWVHcmlkU2VydmljZSA9IHRyZWVHcmlkU2VydmljZTtcbiAgICAgICAgdGhpcy50cmVlR3JpZERhdGFTZXJ2aWNlID0gdHJlZUdyaWREYXRhU2VydmljZTtcbiAgICAgICAgLyoqIFN0cmVhbSBlbWl0dGluZyByZW5kZXIgZGF0YSB0byB0aGUgdGFibGUgKGRlcGVuZHMgb24gb3JkZXJlZCBkYXRhIGNoYW5nZXMpLiAqL1xuICAgICAgICB0aGlzLnJlbmRlckRhdGEgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtdKTtcbiAgICAgICAgdGhpcy5maWx0ZXJSZXF1ZXN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdCgnJyk7XG4gICAgICAgIHRoaXMuc29ydFJlcXVlc3QgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KG51bGwpO1xuICAgIH1cbiAgICBzZXREYXRhKGRhdGEsIGN1c3RvbUdldHRlcnMpIHtcbiAgICAgICAgbGV0IHByZXNlbnRhdGlvbkRhdGEgPSBbXTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHByZXNlbnRhdGlvbkRhdGEgPSB0aGlzLnRyZWVHcmlkRGF0YVNlcnZpY2UudG9QcmVzZW50YXRpb25Ob2RlcyhkYXRhLCBjdXN0b21HZXR0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHByZXNlbnRhdGlvbkRhdGEpO1xuICAgICAgICB0aGlzLnVwZGF0ZUNoYW5nZVN1YnNjcmlwdGlvbigpO1xuICAgIH1cbiAgICBjb25uZWN0KGNvbGxlY3Rpb25WaWV3ZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyRGF0YTtcbiAgICB9XG4gICAgZGlzY29ubmVjdChjb2xsZWN0aW9uVmlld2VyKSB7XG4gICAgfVxuICAgIGV4cGFuZChyb3cpIHtcbiAgICAgICAgdGhpcy50cmVlR3JpZFNlcnZpY2UuZXhwYW5kKHRoaXMuZGF0YS52YWx1ZSwgcm93KTtcbiAgICAgICAgdGhpcy5kYXRhLm5leHQodGhpcy5kYXRhLnZhbHVlKTtcbiAgICB9XG4gICAgY29sbGFwc2Uocm93KSB7XG4gICAgICAgIHRoaXMudHJlZUdyaWRTZXJ2aWNlLmNvbGxhcHNlKHRoaXMuZGF0YS52YWx1ZSwgcm93KTtcbiAgICAgICAgdGhpcy5kYXRhLm5leHQodGhpcy5kYXRhLnZhbHVlKTtcbiAgICB9XG4gICAgdG9nZ2xlKHJvdywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnRyZWVHcmlkU2VydmljZS50b2dnbGUodGhpcy5kYXRhLnZhbHVlLCByb3csIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRhdGEubmV4dCh0aGlzLmRhdGEudmFsdWUpO1xuICAgIH1cbiAgICB0b2dnbGVCeUluZGV4KGRhdGFJbmRleCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5yZW5kZXJEYXRhLnZhbHVlICYmIHRoaXMucmVuZGVyRGF0YS52YWx1ZVtkYXRhSW5kZXhdO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUobm9kZS5kYXRhLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMZXZlbChyb3dJbmRleCkge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLnJlbmRlckRhdGEudmFsdWVbcm93SW5kZXhdO1xuICAgICAgICByZXR1cm4gcm93ID8gcm93LmxldmVsIDogTkJfREVGQVVMVF9ST1dfTEVWRUw7XG4gICAgfVxuICAgIHNvcnQoc29ydFJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5zb3J0UmVxdWVzdC5uZXh0KHNvcnRSZXF1ZXN0KTtcbiAgICB9XG4gICAgZmlsdGVyKHNlYXJjaFF1ZXJ5KSB7XG4gICAgICAgIHRoaXMuZmlsdGVyUmVxdWVzdC5uZXh0KHNlYXJjaFF1ZXJ5KTtcbiAgICB9XG4gICAgdXBkYXRlQ2hhbmdlU3Vic2NyaXB0aW9uKCkge1xuICAgICAgICBjb25zdCBkYXRhU3RyZWFtID0gdGhpcy5kYXRhO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZERhdGEgPSBjb21iaW5lTGF0ZXN0KGRhdGFTdHJlYW0sIHRoaXMuZmlsdGVyUmVxdWVzdClcbiAgICAgICAgICAgIC5waXBlKG1hcCgoW2RhdGFdKSA9PiB0aGlzLnRyZWVHcmlkRGF0YVNlcnZpY2UuY29weShkYXRhKSksIG1hcChkYXRhID0+IHRoaXMuZmlsdGVyRGF0YShkYXRhKSkpO1xuICAgICAgICBjb25zdCBzb3J0ZWREYXRhID0gY29tYmluZUxhdGVzdChmaWx0ZXJlZERhdGEsIHRoaXMuc29ydFJlcXVlc3QpXG4gICAgICAgICAgICAucGlwZShtYXAoKFtkYXRhXSkgPT4gdGhpcy5zb3J0RGF0YShkYXRhKSkpO1xuICAgICAgICBzb3J0ZWREYXRhXG4gICAgICAgICAgICAucGlwZShtYXAoKGRhdGEpID0+IHRoaXMudHJlZUdyaWREYXRhU2VydmljZS5mbGF0dGVuRXhwYW5kZWQoZGF0YSkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZGF0YSkgPT4gdGhpcy5yZW5kZXJEYXRhLm5leHQoZGF0YSkpO1xuICAgIH1cbiAgICBmaWx0ZXJEYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyU2VydmljZS5maWx0ZXIodGhpcy5maWx0ZXJSZXF1ZXN0LnZhbHVlLCBkYXRhKTtcbiAgICB9XG4gICAgc29ydERhdGEoZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb3J0U2VydmljZS5zb3J0KHRoaXMuc29ydFJlcXVlc3QudmFsdWUsIGRhdGEpO1xuICAgIH1cbn1cbmxldCBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIgPSBjbGFzcyBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGZpbHRlclNlcnZpY2UsIHNvcnRTZXJ2aWNlLCB0cmVlR3JpZFNlcnZpY2UsIHRyZWVHcmlkRGF0YVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJTZXJ2aWNlID0gZmlsdGVyU2VydmljZTtcbiAgICAgICAgdGhpcy5zb3J0U2VydmljZSA9IHNvcnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLnRyZWVHcmlkU2VydmljZSA9IHRyZWVHcmlkU2VydmljZTtcbiAgICAgICAgdGhpcy50cmVlR3JpZERhdGFTZXJ2aWNlID0gdHJlZUdyaWREYXRhU2VydmljZTtcbiAgICB9XG4gICAgY3JlYXRlKGRhdGEsIGN1c3RvbUdldHRlcnMpIHtcbiAgICAgICAgY29uc3QgZGF0YVNvdXJjZSA9IG5ldyBOYlRyZWVHcmlkRGF0YVNvdXJjZSh0aGlzLnNvcnRTZXJ2aWNlLCB0aGlzLmZpbHRlclNlcnZpY2UsIHRoaXMudHJlZUdyaWRTZXJ2aWNlLCB0aGlzLnRyZWVHcmlkRGF0YVNlcnZpY2UpO1xuICAgICAgICBkYXRhU291cmNlLnNldERhdGEoZGF0YSwgY3VzdG9tR2V0dGVycyk7XG4gICAgICAgIHJldHVybiBkYXRhU291cmNlO1xuICAgIH1cbn07XG5OYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIgPSBfX2RlY29yYXRlJDE1MihbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEkMTAyKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iVHJlZUdyaWRGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICBOYlRyZWVHcmlkU29ydFNlcnZpY2UsXG4gICAgICAgIE5iVHJlZUdyaWRTZXJ2aWNlLFxuICAgICAgICBOYlRyZWVHcmlkRGF0YVNlcnZpY2VdKVxuXSwgTmJUcmVlR3JpZERhdGFTb3VyY2VCdWlsZGVyKTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG5jb25zdCBOQl9UUkVFX0dSSUQgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ05CX1RSRUVfR1JJRCcpO1xuXG5jb25zdCBOYkNka1Jvd0RlZiA9IENka1Jvd0RlZjtcbmNvbnN0IE5iQ2RrUm93ID0gQ2RrUm93O1xuY29uc3QgTmJDZGtDZWxsRGVmID0gQ2RrQ2VsbERlZjtcbmNvbnN0IE5iQ2RrSGVhZGVyUm93RGVmID0gQ2RrSGVhZGVyUm93RGVmO1xuY29uc3QgTmJDZGtIZWFkZXJSb3cgPSBDZGtIZWFkZXJSb3c7XG5jb25zdCBOYkNka0hlYWRlckNlbGxEZWYgPSBDZGtIZWFkZXJDZWxsRGVmO1xuY29uc3QgTmJDZGtGb290ZXJSb3dEZWYgPSBDZGtGb290ZXJSb3dEZWY7XG5jb25zdCBOYkNka0Zvb3RlclJvdyA9IENka0Zvb3RlclJvdztcbmNvbnN0IE5iQ2RrRm9vdGVyQ2VsbERlZiA9IENka0Zvb3RlckNlbGxEZWY7XG5jb25zdCBOYkNka0NvbHVtbkRlZiA9IENka0NvbHVtbkRlZjtcbmNvbnN0IE5iQ2RrQ2VsbCA9IENka0NlbGw7XG5jb25zdCBOYkNka0hlYWRlckNlbGwgPSBDZGtIZWFkZXJDZWxsO1xuY29uc3QgTmJDZGtGb290ZXJDZWxsID0gQ2RrRm9vdGVyQ2VsbDtcblxudmFyIF9fZGVjb3JhdGUkMTU4ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEwNCA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIF9fcGFyYW0kMjggPSAodGhpcyAmJiB0aGlzLl9fcGFyYW0pIHx8IGZ1bmN0aW9uIChwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn07XG52YXIgTmJUcmVlR3JpZFJvd0NvbXBvbmVudF8xO1xudmFyIE5iVHJlZUdyaWRIZWFkZXJSb3dDb21wb25lbnRfMTtcbnZhciBOYlRyZWVHcmlkRm9vdGVyUm93Q29tcG9uZW50XzE7XG5jb25zdCBOQl9ST1dfRE9VQkxFX0NMSUNLX0RFTEFZID0gMjAwO1xuLyoqXG4gKiBDZWxscyBjb250YWluZXIuIEFkZHMgdGhlIHJpZ2h0IGNsYXNzIGFuZCByb2xlLlxuICovXG5sZXQgTmJUcmVlR3JpZFJvd0NvbXBvbmVudCA9IE5iVHJlZUdyaWRSb3dDb21wb25lbnRfMSA9IGNsYXNzIE5iVHJlZUdyaWRSb3dDb21wb25lbnQgZXh0ZW5kcyBOYlJvd0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IodHJlZSwgZWxlbWVudFJlZikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLmRvdWJsZUNsaWNrJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lIHRvIHdhaXQgZm9yIHNlY29uZCBjbGljayB0byBleHBhbmQgcm93IGRlZXBseS5cbiAgICAgICAgICogMjAwbXMgYnkgZGVmYXVsdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZG91YmxlQ2xpY2tEZWxheSA9IE5CX1JPV19ET1VCTEVfQ0xJQ0tfREVMQVk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUb2dnbGUgcm93IG9uIGNsaWNrLiBFbmFibGVkIGJ5IGRlZmF1bHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsaWNrVG9Ub2dnbGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgIH1cbiAgICB0b2dnbGVJZkVuYWJsZWROb2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xpY2tUb1RvZ2dsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRpbWVyKE5CX1JPV19ET1VCTEVfQ0xJQ0tfREVMQVkpXG4gICAgICAgICAgICAucGlwZSh0YWtlKDEpLCB0YWtlVW50aWwodGhpcy5kb3VibGVDbGljayQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnRyZWUudG9nZ2xlUm93KHRoaXMpKTtcbiAgICB9XG4gICAgdG9nZ2xlSWZFbmFibGVkTm9kZURlZXAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jbGlja1RvVG9nZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb3VibGVDbGljayQubmV4dCgpO1xuICAgICAgICB0aGlzLnRyZWUudG9nZ2xlUm93KHRoaXMsIHsgZGVlcDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZG91YmxlQ2xpY2skLmNvbXBsZXRlKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTU4KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTA0KFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTmJUcmVlR3JpZFJvd0NvbXBvbmVudC5wcm90b3R5cGUsIFwiZG91YmxlQ2xpY2tEZWxheVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxNTgoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxMDQoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgTmJUcmVlR3JpZFJvd0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY2xpY2tUb1RvZ2dsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxNTgoW1xuICAgIEhvc3RMaXN0ZW5lcignY2xpY2snKSxcbiAgICBfX21ldGFkYXRhJDEwNChcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhJDEwNChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKSxcbiAgICBfX21ldGFkYXRhJDEwNChcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE5iVHJlZUdyaWRSb3dDb21wb25lbnQucHJvdG90eXBlLCBcInRvZ2dsZUlmRW5hYmxlZE5vZGVcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE1OChbXG4gICAgSG9zdExpc3RlbmVyKCdkYmxjbGljaycpLFxuICAgIF9fbWV0YWRhdGEkMTA0KFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEkMTA0KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pLFxuICAgIF9fbWV0YWRhdGEkMTA0KFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTmJUcmVlR3JpZFJvd0NvbXBvbmVudC5wcm90b3R5cGUsIFwidG9nZ2xlSWZFbmFibGVkTm9kZURlZXBcIiwgbnVsbCk7XG5OYlRyZWVHcmlkUm93Q29tcG9uZW50ID0gTmJUcmVlR3JpZFJvd0NvbXBvbmVudF8xID0gX19kZWNvcmF0ZSQxNTgoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAndHJbbmJUcmVlR3JpZFJvd10nLFxuICAgICAgICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgbmJDZWxsT3V0bGV0PjwvbmctY29udGFpbmVyPmAsXG4gICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICdjbGFzcyc6ICduYi10cmVlLWdyaWQtcm93JyxcbiAgICAgICAgICAgICdyb2xlJzogJ3JvdycsXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmJDZGtSb3csIHVzZUV4aXN0aW5nOiBOYlRyZWVHcmlkUm93Q29tcG9uZW50XzEgfV0sXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG4gICAgfSksXG4gICAgX19wYXJhbSQyOCgwLCBJbmplY3QoTkJfVFJFRV9HUklEKSksXG4gICAgX19tZXRhZGF0YSQxMDQoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0LCBFbGVtZW50UmVmXSlcbl0sIE5iVHJlZUdyaWRSb3dDb21wb25lbnQpO1xubGV0IE5iVHJlZUdyaWRIZWFkZXJSb3dDb21wb25lbnQgPSBOYlRyZWVHcmlkSGVhZGVyUm93Q29tcG9uZW50XzEgPSBjbGFzcyBOYlRyZWVHcmlkSGVhZGVyUm93Q29tcG9uZW50IGV4dGVuZHMgTmJIZWFkZXJSb3dDb21wb25lbnQge1xufTtcbk5iVHJlZUdyaWRIZWFkZXJSb3dDb21wb25lbnQgPSBOYlRyZWVHcmlkSGVhZGVyUm93Q29tcG9uZW50XzEgPSBfX2RlY29yYXRlJDE1OChbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICd0cltuYlRyZWVHcmlkSGVhZGVyUm93XScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRhaW5lciBuYkNlbGxPdXRsZXQ+PC9uZy1jb250YWluZXI+YCxcbiAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgJ2NsYXNzJzogJ25iLXRyZWUtZ3JpZC1oZWFkZXItcm93JyxcbiAgICAgICAgICAgICdyb2xlJzogJ3JvdycsXG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5iQ2RrSGVhZGVyUm93LCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZEhlYWRlclJvd0NvbXBvbmVudF8xIH1dXG4gICAgfSlcbl0sIE5iVHJlZUdyaWRIZWFkZXJSb3dDb21wb25lbnQpO1xubGV0IE5iVHJlZUdyaWRGb290ZXJSb3dDb21wb25lbnQgPSBOYlRyZWVHcmlkRm9vdGVyUm93Q29tcG9uZW50XzEgPSBjbGFzcyBOYlRyZWVHcmlkRm9vdGVyUm93Q29tcG9uZW50IGV4dGVuZHMgTmJGb290ZXJSb3dDb21wb25lbnQge1xufTtcbk5iVHJlZUdyaWRGb290ZXJSb3dDb21wb25lbnQgPSBOYlRyZWVHcmlkRm9vdGVyUm93Q29tcG9uZW50XzEgPSBfX2RlY29yYXRlJDE1OChbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICd0cltuYlRyZWVHcmlkRm9vdGVyUm93XScsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPG5nLWNvbnRhaW5lciBuYkNlbGxPdXRsZXQ+PC9uZy1jb250YWluZXI+YCxcbiAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgJ2NsYXNzJzogJ25iLXRyZWUtZ3JpZC1mb290ZXItcm93JyxcbiAgICAgICAgICAgICdyb2xlJzogJ3JvdycsXG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5iQ2RrRm9vdGVyUm93LCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZEZvb3RlclJvd0NvbXBvbmVudF8xIH1dXG4gICAgfSlcbl0sIE5iVHJlZUdyaWRGb290ZXJSb3dDb21wb25lbnQpO1xuXG52YXIgX19kZWNvcmF0ZSQxNTkgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTA1ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG5sZXQgTmJDb2x1bW5zU2VydmljZSA9IGNsYXNzIE5iQ29sdW1uc1NlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGRpZmZlcnMpIHtcbiAgICAgICAgdGhpcy5kaWZmZXJzID0gZGlmZmVycztcbiAgICAgICAgdGhpcy5jb2x1bW5IaWRlJCA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMuY29sdW1uU2hvdyQgPSBuZXcgU3ViamVjdCgpO1xuICAgIH1cbiAgICBzZXRDb2x1bW5zKGNvbHVtbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoYW5nZXNEaWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlc0RpZmZlciA9IHRoaXMuZGlmZmVycy5maW5kKGNvbHVtbnMgfHwgW10pLmNyZWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoYW5nZXNEaWZmZXIuZGlmZihjb2x1bW5zKSkge1xuICAgICAgICAgICAgdGhpcy5hbGxDb2x1bW5zID0gQXJyYXkuZnJvbShjb2x1bW5zKTtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMgPSBBcnJheS5mcm9tKGNvbHVtbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFZpc2libGVDb2x1bW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQ29sdW1ucztcbiAgICB9XG4gICAgaGlkZUNvbHVtbihjb2x1bW4pIHtcbiAgICAgICAgY29uc3QgdG9SZW1vdmUgPSB0aGlzLnZpc2libGVDb2x1bW5zLmluZGV4T2YoY29sdW1uKTtcbiAgICAgICAgaWYgKHRvUmVtb3ZlID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMuc3BsaWNlKHRvUmVtb3ZlLCAxKTtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uSGlkZSQubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3dDb2x1bW4oY29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLnZpc2libGVDb2x1bW5zLmluY2x1ZGVzKGNvbHVtbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2libGVDb2x1bW5zLnNwbGljZSh0aGlzLmZpbmRJbnNlcnRJbmRleChjb2x1bW4pLCAwLCBjb2x1bW4pO1xuICAgICAgICB0aGlzLmNvbHVtblNob3ckLm5leHQoKTtcbiAgICB9XG4gICAgb25Db2x1bW5zQ2hhbmdlKCkge1xuICAgICAgICByZXR1cm4gbWVyZ2UodGhpcy5jb2x1bW5TaG93JCwgdGhpcy5jb2x1bW5IaWRlJCk7XG4gICAgfVxuICAgIGZpbmRJbnNlcnRJbmRleChjb2x1bW4pIHtcbiAgICAgICAgY29uc3QgaW5pdGlhbEluZGV4ID0gdGhpcy5hbGxDb2x1bW5zLmluZGV4T2YoY29sdW1uKTtcbiAgICAgICAgaWYgKGluaXRpYWxJbmRleCA9PT0gMCB8fCAhdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsSW5kZXggPT09IHRoaXMuYWxsQ29sdW1ucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdFNpYmxpbmdJbmRleCA9IGluaXRpYWxJbmRleCAtIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSBsZWZ0U2libGluZ0luZGV4OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgbGVmdFNpYmxpbmcgPSB0aGlzLmFsbENvbHVtbnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudmlzaWJsZUNvbHVtbnMuaW5kZXhPZihsZWZ0U2libGluZyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByaWdodFNpYmxpbmdJbmRleCA9IGluaXRpYWxJbmRleCArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSByaWdodFNpYmxpbmdJbmRleDsgaSA8IHRoaXMuYWxsQ29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcmlnaHRTaWJsaW5nID0gdGhpcy5hbGxDb2x1bW5zW2ldO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnZpc2libGVDb2x1bW5zLmluZGV4T2YocmlnaHRTaWJsaW5nKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCByZXN0b3JlIGNvbHVtbiBwb3NpdGlvbi5gKTtcbiAgICB9XG59O1xuTmJDb2x1bW5zU2VydmljZSA9IF9fZGVjb3JhdGUkMTU5KFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YSQxMDUoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbSXRlcmFibGVEaWZmZXJzXSlcbl0sIE5iQ29sdW1uc1NlcnZpY2UpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDE1MSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxMDEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbnZhciBfX3BhcmFtJDI2ID0gKHRoaXMgJiYgdGhpcy5fX3BhcmFtKSB8fCBmdW5jdGlvbiAocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XG59O1xudmFyIE5iVHJlZUdyaWRDb21wb25lbnRfMTtcbi8qKlxuICogVHJlZSBncmlkIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGRpc3BsYXkgbmVzdGVkIHJvd3Mgb2YgZGF0YS5cbiAqIFN1cHBvcnRzIGZpbHRlcmluZyBhbmQgc29ydGluZy5cbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIHRyZWUtZ3JpZC90cmVlLWdyaWQtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iVHJlZUdyaWRNb2R1bGVgIHRvIHlvdXIgZmVhdHVyZSBtb2R1bGUuXG4gKiBgYGB0c1xuICogQE5nTW9kdWxlKHtcbiAqICAgaW1wb3J0czogW1xuICogICAgIC8vIC4uLlxuICogICAgIE5iVHJlZUdyaWRNb2R1bGUsXG4gKiAgIF0sXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIFBhZ2VNb2R1bGUgeyB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgVXNhZ2VcbiAqXG4gKiBBcyB0aGUgbW9zdCBiYXNpYyB1c2FnZSB5b3UgbmVlZCB0byBkZWZpbmUgW25iVHJlZUdyaWRSb3dEZWZdKGRvY3MvY29tcG9uZW50cy90cmVlZ3JpZC9hcGkjbmJ0cmVlZ3JpZHJvd2RlZmRpcmVjdGl2ZSlcbiAqIHdoZXJlIHlvdSBzaG91bGQgcGFzcyBjb2x1bW5zIHRvIGRpc3BsYXkgaW4gcm93cyBhbmRcbiAqIFtuYlRyZWVHcmlkQ29sdW1uRGVmXShkb2NzL2NvbXBvbmVudHMvdHJlZWdyaWQvYXBpI25idHJlZWdyaWRjb2x1bW5kZWZkaXJlY3RpdmUpIC0gY29tcG9uZW50IGNvbnRhaW5pbmcgY2VsbFxuICogZGVmaW5pdGlvbnMgZm9yIGVhY2ggY29sdW1uIHBhc3NlZCB0byByb3cgZGVmaW5pdGlvbi5cbiAqIEBzdGFja2VkLWV4YW1wbGUoQmFzaWMsIHRyZWUtZ3JpZC90cmVlLWdyaWQtYmFzaWMuY29tcG9uZW50KVxuICpcbiAqIGBOYlRyZWVHcmlkQ29tcG9uZW50YCdzIHNvdXJjZSBpbnB1dCBhbmQgYE5iVHJlZUdyaWREYXRhU291cmNlQnVpbGRlci5jcmVhdGVgIGV4cGVjdGluZyBkYXRhIHRvIGJlIGFuIGFycmF5IG9mXG4gKiBvYmplY3RzIHdpdGggYGRhdGFgLCBgY2hpbGRyZW5gIGFuZCBgZXhwYW5kZWRgIHByb3BlcnRpZXMuIElmIHlvdXIgZGF0YSBkb2Vzbid0IG1hdGNoIHRoaXMgaW50ZXJmYWNlLCB5b3UgY2FuIHBhc3NcbiAqIGdldHRlciBmdW5jdGlvbnMgZm9yIGVhY2ggcHJvcGVydHkgYXMgYXJndW1lbnRzIHRvIGBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIuY3JlYXRlYCBtZXRob2QuXG4gKiBAc3RhY2tlZC1leGFtcGxlKEN1c3RvbSBub2RlIHN0cnVjdHVyZSwgdHJlZS1ncmlkL3RyZWUtZ3JpZC1jdXN0b20tbm9kZS1zdHJ1Y3R1cmUuY29tcG9uZW50KVxuICpcbiAqIFRvIHVzZSBzb3J0aW5nIHlvdSBjYW4gYWRkIGBuYlNvcnRgIGRpcmVjdGl2ZSB0byB0YWJsZSBhbmQgc3Vic2NyaWJlIHRvIGBzb3J0YCBtZXRob2QuIFdoZW4gdXNlciBjbGljayBvbiBoZWFkZXIsXG4gKiBzb3J0IGV2ZW50IHdpbGwgYmUgZW1pdHRlZC4gRXZlbnQgb2JqZWN0IGNvbnRhaW4gY2xpY2tlZCBjb2x1bW4gbmFtZSBhbmQgZGVzaXJlZCBzb3J0IGRpcmVjdGlvbi5cbiAqIEBzdGFja2VkLWV4YW1wbGUoU29ydGFibGUsIHRyZWUtZ3JpZC90cmVlLWdyaWQtc29ydGFibGUuY29tcG9uZW50KVxuICpcbiAqIFlvdSBjYW4gdXNlIGBEYXRhIFNvdXJjZSBCdWlsZGVyYCB0byBjcmVhdGUgYE5iVHJlZUdyaWREYXRhU291cmNlYCB3aGljaCB3b3VsZCBoYXZlIHRvZ2dsZSwgc29ydCBhbmRcbiAqIGZpbHRlciBtZXRob2RzLiBUaGVuIHlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZHMgdG8gY2hhbmdlIHNvcnQgb3IgdG9nZ2xlIHJvd3MgcHJvZ3JhbW1hdGljYWxseS4gQWxzbyBgbmJTb3J0YCBhbmRcbiAqIGBuYkZpbHRlcklucHV0YCBkaXJlY3RpdmVzIGJvdGggc3VwcG9ydCBgTmJUcmVlR3JpZERhdGFTb3VyY2VgLCBzbyB5b3UgY2FuIHBhc3MgaXQgZGlyZWN0bHkgYXMgYW4gaW5wdXQgYW5kXG4gKiBkaXJlY3RpdmVzIHdpbGwgdHJpZ2dlciBzb3J0LCB0b2dnbGUgdGhlbXNlbHZlcy5cbiAqIEBzdGFja2VkLWV4YW1wbGUoRGF0YSBTb3VyY2UgQnVpbGRlciwgdHJlZS1ncmlkL3RyZWUtZ3JpZC1zaG93Y2FzZS5jb21wb25lbnQpXG4gKlxuICogWW91IGNhbiBjcmVhdGUgcmVzcG9uc2l2ZSBncmlkIGJ5IHNldHRpbmcgYGhpZGVPbmAgYW5kIGBzaG93T25gIGlucHV0cyBvZlxuICogW25iVHJlZUdyaWRDb2x1bW5EZWZdKGRvY3MvY29tcG9uZW50cy90cmVlLWdyaWQvYXBpI25idHJlZWdyaWRjb2x1bW5kZWZkaXJlY3RpdmUpIGRpcmVjdGl2ZS5cbiAqIFdoZW4gdmlld3BvcnQgcmVhY2hlcyBzcGVjaWZpZWQgd2lkdGggZ3JpZCBoaWRlcyBvciBzaG93cyBjb2x1bW5zLlxuICogQHN0YWNrZWQtZXhhbXBsZShSZXNwb25zaXZlIGNvbHVtbnMsIHRyZWUtZ3JpZC90cmVlLWdyaWQtcmVzcG9uc2l2ZS5jb21wb25lbnQpXG4gKlxuICogVG8gY3VzdG9taXplIHNvcnQgb3Igcm93IHRvZ2dsZSBpY29ucyB5b3UgY2FuIHVzZSBgbmJTb3J0SGVhZGVySWNvbmAgYW5kIGBuYlRyZWVHcmlkUm93VG9nZ2xlYCBkaXJlY3RpdmVzXG4gKiByZXNwZWN0aXZlbHkuIGBuYlNvcnRIZWFkZXJJY29uYCBpcyBhIHN0cnVjdHVyYWwgZGlyZWN0aXZlIGFuZCBpdCdzIGltcGxpY2l0IGNvbnRleHQgc2V0IHRvIGN1cnJlbnQgZGlyZWN0aW9uLlxuICogQWxzbyBjb250ZXh0IGhhcyB0aHJlZSBwcm9wZXJ0aWVzOiBgaXNBc2NlbmRpbmdgLCBgaXNEZXNjZW5kaW5nYCBhbmQgYGlzTm9uZWAuXG4gKiBAc3RhY2tlZC1leGFtcGxlKEN1c3RvbSBpY29ucywgdHJlZS1ncmlkL3RyZWUtZ3JpZC1jdXN0b20taWNvbnMuY29tcG9uZW50KVxuICpcbiAqIEJ5IGRlZmF1bHQsIHJvdyB0byB0b2dnbGUgaGFwcGVucyB3aGVuIHVzZXIgY2xpY2tzIGFueXdoZXJlIGluIHRoZSByb3cuIEFsc28gZG91YmxlIGNsaWNrIGV4cGFuZHMgcm93IGRlZXBseS5cbiAqIFRvIGRpc2FibGUgdGhpcyB5b3UgY2FuIHNldCBgW2NsaWNrVG9Ub2dnbGVdPVwiZmFsc2VcImAgaW5wdXQgb2YgYG5iVHJlZUdyaWRSb3dgLlxuICogQHN0YWNrZWQtZXhhbXBsZShEaXNhYmxlIGNsaWNrIHRvZ2dsZSwgdHJlZS1ncmlkL3RyZWUtZ3JpZC1kaXNhYmxlLWNsaWNrLXRvZ2dsZS5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHRyZWUtZ3JpZC1jZWxsLWJvcmRlci13aWR0aDpcbiAqIHRyZWUtZ3JpZC1jZWxsLWJvcmRlci1zdHlsZTpcbiAqIHRyZWUtZ3JpZC1jZWxsLWJvcmRlci1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1yb3ctbWluLWhlaWdodDpcbiAqIHRyZWUtZ3JpZC1jZWxsLXBhZGRpbmc6XG4gKiB0cmVlLWdyaWQtaGVhZGVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0cmVlLWdyaWQtaGVhZGVyLXRleHQtY29sb3I6XG4gKiB0cmVlLWdyaWQtaGVhZGVyLXRleHQtZm9udC1mYW1pbHk6XG4gKiB0cmVlLWdyaWQtaGVhZGVyLXRleHQtZm9udC1zaXplOlxuICogdHJlZS1ncmlkLWhlYWRlci10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdHJlZS1ncmlkLWhlYWRlci10ZXh0LWxpbmUtaGVpZ2h0OlxuICogdHJlZS1ncmlkLWZvb3Rlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdHJlZS1ncmlkLWZvb3Rlci10ZXh0LWNvbG9yOlxuICogdHJlZS1ncmlkLWZvb3Rlci10ZXh0LWZvbnQtZmFtaWx5OlxuICogdHJlZS1ncmlkLWZvb3Rlci10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRyZWUtZ3JpZC1mb290ZXItdGV4dC1mb250LXdlaWdodDpcbiAqIHRyZWUtZ3JpZC1mb290ZXItdGV4dC1saW5lLWhlaWdodDpcbiAqIHRyZWUtZ3JpZC1yb3ctYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1yb3ctZXZlbi1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdHJlZS1ncmlkLXJvdy1ob3Zlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdHJlZS1ncmlkLXJvdy10ZXh0LWNvbG9yOlxuICogdHJlZS1ncmlkLXJvdy10ZXh0LWZvbnQtZmFtaWx5OlxuICogdHJlZS1ncmlkLXJvdy10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRyZWUtZ3JpZC1yb3ctdGV4dC1mb250LXdlaWdodDpcbiAqIHRyZWUtZ3JpZC1yb3ctdGV4dC1saW5lLWhlaWdodDpcbiAqIHRyZWUtZ3JpZC1zb3J0LWhlYWRlci1idXR0b24tYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRyZWUtZ3JpZC1zb3J0LWhlYWRlci1idXR0b24tYm9yZGVyOlxuICogdHJlZS1ncmlkLXNvcnQtaGVhZGVyLWJ1dHRvbi1wYWRkaW5nOlxuICovXG5sZXQgTmJUcmVlR3JpZENvbXBvbmVudCA9IE5iVHJlZUdyaWRDb21wb25lbnRfMSA9IGNsYXNzIE5iVHJlZUdyaWRDb21wb25lbnQgZXh0ZW5kcyBOYlRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhU291cmNlQnVpbGRlciwgZGlmZmVycywgY2hhbmdlRGV0ZWN0b3JSZWYsIGVsZW1lbnRSZWYsIHJvbGUsIGRpciwgZG9jdW1lbnQsIHBsYXRmb3JtLCB3aW5kb3cpIHtcbiAgICAgICAgc3VwZXIoZGlmZmVycywgY2hhbmdlRGV0ZWN0b3JSZWYsIGVsZW1lbnRSZWYsIHJvbGUsIGRpciwgZG9jdW1lbnQsIHBsYXRmb3JtKTtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlQnVpbGRlciA9IGRhdGFTb3VyY2VCdWlsZGVyO1xuICAgICAgICB0aGlzLndpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMubGV2ZWxQYWRkaW5nID0gJyc7XG4gICAgICAgIHRoaXMuZXF1YWxDb2x1bW5zV2lkdGhWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyZWVDbGFzcyA9IHRydWU7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHRhYmxlJ3MgZGF0YVxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHR5cGUgezxUPltdIHwgTmJUcmVlR3JpZERhdGFTb3VyY2V9XG4gICAgICovXG4gICAgc2V0IHNvdXJjZShkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTmJUcmVlR3JpZERhdGFTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3NvdXJjZSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2VCdWlsZGVyLmNyZWF0ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSB0aGlzLl9zb3VyY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2UgYWxsIGNvbHVtbnMgZXF1YWwgd2lkdGguIEZhbHNlIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgc2V0IGVxdWFsQ29sdW1uc1dpZHRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZXF1YWxDb2x1bW5zV2lkdGhWYWx1ZSA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBlcXVhbENvbHVtbnNXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxDb2x1bW5zV2lkdGhWYWx1ZTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmNoZWNrRGVmc0NvdW50KCk7XG4gICAgICAgIGNvbnN0IHJvd3NDaGFuZ2UkID0gbWVyZ2UodGhpcy5fY29udGVudFJvd0RlZnMuY2hhbmdlcywgdGhpcy5fY29udGVudEhlYWRlclJvd0RlZnMuY2hhbmdlcywgdGhpcy5fY29udGVudEZvb3RlclJvd0RlZnMuY2hhbmdlcyk7XG4gICAgICAgIHJvd3NDaGFuZ2UkLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNoZWNrRGVmc0NvdW50KCkpO1xuICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlzaWJsZUNvbHVtbnMoKTtcbiAgICAgICAgICAgIGNvbnN0IHdpbmRvd1Jlc2l6ZSQgPSBmcm9tRXZlbnQodGhpcy53aW5kb3csICdyZXNpemUnKS5waXBlKGRlYm91bmNlVGltZSg1MCkpO1xuICAgICAgICAgICAgbWVyZ2Uocm93c0NoYW5nZSQsIHRoaXMuX2NvbnRlbnRDb2x1bW5EZWZzLmNoYW5nZXMsIHdpbmRvd1Jlc2l6ZSQpXG4gICAgICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy51cGRhdGVWaXNpYmxlQ29sdW1ucygpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIubmdPbkRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0b2dnbGVSb3cocm93LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZS50b2dnbGVCeUluZGV4KHRoaXMuZ2V0RGF0YUluZGV4KHJvdyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0b2dnbGVDZWxsUm93KGNlbGwpIHtcbiAgICAgICAgdGhpcy50b2dnbGVSb3codGhpcy5maW5kQ2VsbFJvdyhjZWxsKSk7XG4gICAgfVxuICAgIGdldENvbHVtbldpZHRoKCkge1xuICAgICAgICBpZiAodGhpcy5lcXVhbENvbHVtbnNXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGAkezEwMCAvIHRoaXMuZ2V0Q29sdW1uc0NvdW50KCl9JWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBnZXRDZWxsTGV2ZWwoY2VsbCwgY29sdW1uTmFtZSkge1xuICAgICAgICBjb25zdCBpc0ZpcnN0Q29sdW1uID0gdGhpcy5pc0ZpcnN0Q29sdW1uKGNvbHVtbk5hbWUpO1xuICAgICAgICBjb25zdCByb3cgPSBpc0ZpcnN0Q29sdW1uICYmIHRoaXMuZmluZENlbGxSb3coY2VsbCk7XG4gICAgICAgIGNvbnN0IGxldmVsID0gcm93ICYmIHRoaXMuZ2V0Um93TGV2ZWwocm93KTtcbiAgICAgICAgaWYgKGxldmVsIHx8IGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE5CX0RFRkFVTFRfUk9XX0xFVkVMO1xuICAgIH1cbiAgICBnZXREYXRhSW5kZXgocm93KSB7XG4gICAgICAgIGNvbnN0IHJvd0VsID0gcm93LmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gcm93RWwucGFyZW50RWxlbWVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGNoaWxkKSA9PiBjaGlsZC5oYXNBdHRyaWJ1dGUoJ25idHJlZWdyaWRyb3cnKSlcbiAgICAgICAgICAgICAgICAuaW5kZXhPZihyb3dFbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBnZXRSb3dMZXZlbChyb3cpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZS5nZXRMZXZlbCh0aGlzLmdldERhdGFJbmRleChyb3cpKTtcbiAgICB9XG4gICAgZ2V0Q29sdW1ucygpIHtcbiAgICAgICAgY29uc3QgeyBjb2x1bW5zIH0gPSB0aGlzLl9jb250ZW50SGVhZGVyUm93RGVmcy5sZW5ndGhcbiAgICAgICAgICAgID8gdGhpcy5fY29udGVudEhlYWRlclJvd0RlZnMuZmlyc3RcbiAgICAgICAgICAgIDogdGhpcy5fY29udGVudFJvd0RlZnMuZmlyc3Q7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGNvbHVtbnMgfHwgW10pO1xuICAgIH1cbiAgICBnZXRDb2x1bW5zQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbnMoKS5sZW5ndGg7XG4gICAgfVxuICAgIGlzRmlyc3RDb2x1bW4oY29sdW1uTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW5zKClbMF0gPT09IGNvbHVtbk5hbWU7XG4gICAgfVxuICAgIGZpbmRDZWxsUm93KGNlbGwpIHtcbiAgICAgICAgY29uc3QgY2VsbFJvd0VsZW1lbnQgPSBjZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dzLnRvQXJyYXkoKVxuICAgICAgICAgICAgLmZpbmQoKHJvdykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJvdy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgPT09IGNlbGxSb3dFbGVtZW50O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2hlY2tEZWZzQ291bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50Um93RGVmcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIG11bHRpcGxlIHJvdyBkZWZpbml0aW9uc2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50SGVhZGVyUm93RGVmcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIG11bHRpcGxlIGhlYWRlciByb3cgZGVmaW5pdGlvbnNgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29udGVudEZvb3RlclJvd0RlZnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCBtdWx0aXBsZSBmb290ZXIgcm93IGRlZmluaXRpb25zYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlVmlzaWJsZUNvbHVtbnMoKSB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgY29uc3QgY29sdW1uRGVmcyA9IHRoaXMuX2NvbnRlbnRDb2x1bW5EZWZzO1xuICAgICAgICBjb25zdCBjb2x1bW5zVG9IaWRlID0gY29sdW1uRGVmc1xuICAgICAgICAgICAgLmZpbHRlcigoY29sKSA9PiBjb2wuc2hvdWxkSGlkZSh3aWR0aCkpXG4gICAgICAgICAgICAubWFwKGNvbCA9PiBjb2wubmFtZSk7XG4gICAgICAgIGNvbnN0IGNvbHVtbnNUb1Nob3cgPSBjb2x1bW5EZWZzXG4gICAgICAgICAgICAuZmlsdGVyKChjb2wpID0+IGNvbC5zaG91bGRTaG93KHdpZHRoKSlcbiAgICAgICAgICAgIC5tYXAoY29sID0+IGNvbC5uYW1lKTtcbiAgICAgICAgaWYgKCFjb2x1bW5zVG9IaWRlLmxlbmd0aCAmJiAhY29sdW1uc1RvU2hvdy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByb3dEZWZzID0gW1xuICAgICAgICAgICAgdGhpcy5fY29udGVudEhlYWRlclJvd0RlZnMuZmlyc3QsXG4gICAgICAgICAgICB0aGlzLl9jb250ZW50Um93RGVmcy5maXJzdCxcbiAgICAgICAgICAgIHRoaXMuX2NvbnRlbnRGb290ZXJSb3dEZWZzLmZpcnN0LFxuICAgICAgICBdLmZpbHRlcihkID0+ICEhZCk7XG4gICAgICAgIGZvciAoY29uc3Qgcm93RGVmIG9mIHJvd0RlZnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29sdW1uIG9mIGNvbHVtbnNUb0hpZGUpIHtcbiAgICAgICAgICAgICAgICByb3dEZWYuaGlkZUNvbHVtbihjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBjb2x1bW4gb2YgY29sdW1uc1RvU2hvdykge1xuICAgICAgICAgICAgICAgIHJvd0RlZi5zaG93Q29sdW1uKGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxNTEoW1xuICAgIElucHV0KCduYlRyZWVHcmlkJyksXG4gICAgX19tZXRhZGF0YSQxMDEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTAxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBOYlRyZWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzb3VyY2VcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE1MShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDEwMShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIE5iVHJlZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImxldmVsUGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxNTEoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxMDEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDEwMShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iVHJlZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcImVxdWFsQ29sdW1uc1dpZHRoXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxNTEoW1xuICAgIENvbnRlbnRDaGlsZHJlbihOYlRyZWVHcmlkUm93Q29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhJDEwMShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIE5iVHJlZUdyaWRDb21wb25lbnQucHJvdG90eXBlLCBcInJvd3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTUxKFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MubmItdHJlZS1ncmlkJyksXG4gICAgX19tZXRhZGF0YSQxMDEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYlRyZWVHcmlkQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0cmVlQ2xhc3NcIiwgdm9pZCAwKTtcbk5iVHJlZUdyaWRDb21wb25lbnQgPSBOYlRyZWVHcmlkQ29tcG9uZW50XzEgPSBfX2RlY29yYXRlJDE1MShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgc2VsZWN0b3I6ICd0YWJsZVtuYlRyZWVHcmlkXScsXG4gICAgICAgIHRlbXBsYXRlOiBOQl9UQUJMRV9URU1QTEFURSxcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgeyBwcm92aWRlOiBOQl9UUkVFX0dSSUQsIHVzZUV4aXN0aW5nOiBOYlRyZWVHcmlkQ29tcG9uZW50XzEgfSxcbiAgICAgICAgICAgIE5iQ29sdW1uc1NlcnZpY2UsXG4gICAgICAgIF0sXG4gICAgICAgIHN0eWxlczogW1wiOmhvc3R7dGFibGUtbGF5b3V0OmZpeGVkO2JvcmRlci1zcGFjaW5nOjA7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO3dpZHRoOjEwMCU7bWF4LXdpZHRoOjEwMCU7b3ZlcmZsb3c6YXV0b306Om5nLWRlZXAgLm5iLXRyZWUtZ3JpZC1jZWxsLDo6bmctZGVlcCAubmItdHJlZS1ncmlkLWhlYWRlci1jZWxsLDo6bmctZGVlcCAubmItdHJlZS1ncmlkLWZvb3Rlci1jZWxse292ZXJmbG93OmhpZGRlbn1cXG5cIl1cbiAgICB9KSxcbiAgICBfX3BhcmFtJDI2KDQsIEF0dHJpYnV0ZSgncm9sZScpKSxcbiAgICBfX3BhcmFtJDI2KDYsIEluamVjdChOQl9ET0NVTUVOVCkpLFxuICAgIF9fcGFyYW0kMjYoOCwgSW5qZWN0KE5CX1dJTkRPVykpLFxuICAgIF9fbWV0YWRhdGEkMTAxKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iVHJlZUdyaWREYXRhU291cmNlQnVpbGRlcixcbiAgICAgICAgSXRlcmFibGVEaWZmZXJzLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgRWxlbWVudFJlZiwgU3RyaW5nLCBOYkRpcmVjdGlvbmFsaXR5LCBPYmplY3QsIE5iUGxhdGZvcm0kMSwgT2JqZWN0XSlcbl0sIE5iVHJlZUdyaWRDb21wb25lbnQpO1xuXG52YXIgX19kZWNvcmF0ZSQxNjAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTA2ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTmJUcmVlR3JpZFJvd0RlZkRpcmVjdGl2ZV8xO1xudmFyIE5iVHJlZUdyaWRIZWFkZXJSb3dEZWZEaXJlY3RpdmVfMTtcbnZhciBOYlRyZWVHcmlkRm9vdGVyUm93RGVmRGlyZWN0aXZlXzE7XG52YXIgTmJUcmVlR3JpZENlbGxEZWZEaXJlY3RpdmVfMTtcbnZhciBOYlRyZWVHcmlkSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZV8xO1xudmFyIE5iVHJlZUdyaWRGb290ZXJDZWxsRGVmRGlyZWN0aXZlXzE7XG4vKipcbiAqIERhdGEgcm93IGRlZmluaXRpb24gZm9yIHRoZSB0cmVlLWdyaWQuXG4gKiBDYXB0dXJlcyB0aGUgaGVhZGVyIHJvdydzIHRlbXBsYXRlIGFuZCBjb2x1bW5zIHRvIGRpc3BsYXkuXG4gKi9cbmxldCBOYlRyZWVHcmlkUm93RGVmRGlyZWN0aXZlID0gTmJUcmVlR3JpZFJvd0RlZkRpcmVjdGl2ZV8xID0gY2xhc3MgTmJUcmVlR3JpZFJvd0RlZkRpcmVjdGl2ZSBleHRlbmRzIE5iUm93RGVmRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZSwgZGlmZmVycywgY29sdW1uc1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIodGVtcGxhdGUsIGRpZmZlcnMpO1xuICAgICAgICB0aGlzLmNvbHVtbnNTZXJ2aWNlID0gY29sdW1uc1NlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbHVtbnMgdG8gYmUgZGlzcGxheWVkIG9uIHRoaXMgcm93XG4gICAgICovXG4gICAgc2V0IGNvbHVtbnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zU2VydmljZS5zZXRDb2x1bW5zKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNTZXJ2aWNlLmdldFZpc2libGVDb2x1bW5zKCk7XG4gICAgfVxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgaGlkZUNvbHVtbihjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zU2VydmljZS5oaWRlQ29sdW1uKGNvbHVtbik7XG4gICAgfVxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgc2hvd0NvbHVtbihjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zU2VydmljZS5zaG93Q29sdW1uKGNvbHVtbik7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTYwKFtcbiAgICBJbnB1dCgnbmJUcmVlR3JpZFJvd0RlZkNvbHVtbnMnKSxcbiAgICBfX21ldGFkYXRhJDEwNihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxMDYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSlcbl0sIE5iVHJlZUdyaWRSb3dEZWZEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbHVtbnNcIiwgbnVsbCk7XG5OYlRyZWVHcmlkUm93RGVmRGlyZWN0aXZlID0gTmJUcmVlR3JpZFJvd0RlZkRpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZSQxNjAoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW25iVHJlZUdyaWRSb3dEZWZdJyxcbiAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOYkNka1Jvd0RlZiwgdXNlRXhpc3Rpbmc6IE5iVHJlZUdyaWRSb3dEZWZEaXJlY3RpdmVfMSB9XSxcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDEwNihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZixcbiAgICAgICAgSXRlcmFibGVEaWZmZXJzLFxuICAgICAgICBOYkNvbHVtbnNTZXJ2aWNlXSlcbl0sIE5iVHJlZUdyaWRSb3dEZWZEaXJlY3RpdmUpO1xubGV0IE5iVHJlZUdyaWRIZWFkZXJSb3dEZWZEaXJlY3RpdmUgPSBOYlRyZWVHcmlkSGVhZGVyUm93RGVmRGlyZWN0aXZlXzEgPSBjbGFzcyBOYlRyZWVHcmlkSGVhZGVyUm93RGVmRGlyZWN0aXZlIGV4dGVuZHMgTmJIZWFkZXJSb3dEZWZEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCBkaWZmZXJzLCBjb2x1bW5zU2VydmljZSkge1xuICAgICAgICBzdXBlcih0ZW1wbGF0ZSwgZGlmZmVycyk7XG4gICAgICAgIHRoaXMuY29sdW1uc1NlcnZpY2UgPSBjb2x1bW5zU2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sdW1ucyB0byBiZSBkaXNwbGF5ZWQgb24gdGhpcyByb3dcbiAgICAgKi9cbiAgICBzZXQgY29sdW1ucyh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbHVtbnNTZXJ2aWNlLnNldENvbHVtbnModmFsdWUpO1xuICAgIH1cbiAgICBnZXQgY29sdW1ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uc1NlcnZpY2UuZ2V0VmlzaWJsZUNvbHVtbnMoKTtcbiAgICB9XG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICBoaWRlQ29sdW1uKGNvbHVtbikge1xuICAgICAgICB0aGlzLmNvbHVtbnNTZXJ2aWNlLmhpZGVDb2x1bW4oY29sdW1uKTtcbiAgICB9XG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICBzaG93Q29sdW1uKGNvbHVtbikge1xuICAgICAgICB0aGlzLmNvbHVtbnNTZXJ2aWNlLnNob3dDb2x1bW4oY29sdW1uKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxNjAoW1xuICAgIElucHV0KCduYlRyZWVHcmlkSGVhZGVyUm93RGVmJyksXG4gICAgX19tZXRhZGF0YSQxMDYoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTA2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pXG5dLCBOYlRyZWVHcmlkSGVhZGVyUm93RGVmRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb2x1bW5zXCIsIG51bGwpO1xuTmJUcmVlR3JpZEhlYWRlclJvd0RlZkRpcmVjdGl2ZSA9IE5iVHJlZUdyaWRIZWFkZXJSb3dEZWZEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUkMTYwKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1tuYlRyZWVHcmlkSGVhZGVyUm93RGVmXScsXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmJDZGtIZWFkZXJSb3dEZWYsIHVzZUV4aXN0aW5nOiBOYlRyZWVHcmlkSGVhZGVyUm93RGVmRGlyZWN0aXZlXzEgfV0sXG4gICAgfSksXG4gICAgX19tZXRhZGF0YSQxMDYoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWYsXG4gICAgICAgIEl0ZXJhYmxlRGlmZmVycyxcbiAgICAgICAgTmJDb2x1bW5zU2VydmljZV0pXG5dLCBOYlRyZWVHcmlkSGVhZGVyUm93RGVmRGlyZWN0aXZlKTtcbmxldCBOYlRyZWVHcmlkRm9vdGVyUm93RGVmRGlyZWN0aXZlID0gTmJUcmVlR3JpZEZvb3RlclJvd0RlZkRpcmVjdGl2ZV8xID0gY2xhc3MgTmJUcmVlR3JpZEZvb3RlclJvd0RlZkRpcmVjdGl2ZSBleHRlbmRzIE5iRm9vdGVyUm93RGVmRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZSwgZGlmZmVycywgY29sdW1uc1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIodGVtcGxhdGUsIGRpZmZlcnMpO1xuICAgICAgICB0aGlzLmNvbHVtbnNTZXJ2aWNlID0gY29sdW1uc1NlcnZpY2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbHVtbnMgdG8gYmUgZGlzcGxheWVkIG9uIHRoaXMgcm93XG4gICAgICovXG4gICAgc2V0IGNvbHVtbnModmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zU2VydmljZS5zZXRDb2x1bW5zKHZhbHVlKTtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNTZXJ2aWNlLmdldFZpc2libGVDb2x1bW5zKCk7XG4gICAgfVxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgaGlkZUNvbHVtbihjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zU2VydmljZS5oaWRlQ29sdW1uKGNvbHVtbik7XG4gICAgfVxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgc2hvd0NvbHVtbihjb2x1bW4pIHtcbiAgICAgICAgdGhpcy5jb2x1bW5zU2VydmljZS5zaG93Q29sdW1uKGNvbHVtbik7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTYwKFtcbiAgICBJbnB1dCgnbmJUcmVlR3JpZEZvb3RlclJvd0RlZicpLFxuICAgIF9fbWV0YWRhdGEkMTA2KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDEwNihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKVxuXSwgTmJUcmVlR3JpZEZvb3RlclJvd0RlZkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29sdW1uc1wiLCBudWxsKTtcbk5iVHJlZUdyaWRGb290ZXJSb3dEZWZEaXJlY3RpdmUgPSBOYlRyZWVHcmlkRm9vdGVyUm93RGVmRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlJDE2MChbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdbbmJUcmVlR3JpZEZvb3RlclJvd0RlZl0nLFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5iQ2RrRm9vdGVyUm93RGVmLCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZEZvb3RlclJvd0RlZkRpcmVjdGl2ZV8xIH1dLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkMTA2KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1RlbXBsYXRlUmVmLFxuICAgICAgICBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgIE5iQ29sdW1uc1NlcnZpY2VdKVxuXSwgTmJUcmVlR3JpZEZvb3RlclJvd0RlZkRpcmVjdGl2ZSk7XG4vKipcbiAqIENlbGwgZGVmaW5pdGlvbiBmb3IgYSBuYi10YWJsZS5cbiAqIENhcHR1cmVzIHRoZSB0ZW1wbGF0ZSBvZiBhIGNvbHVtbidzIGRhdGEgcm93IGNlbGwgYXMgd2VsbCBhcyBjZWxsLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cbmxldCBOYlRyZWVHcmlkQ2VsbERlZkRpcmVjdGl2ZSA9IE5iVHJlZUdyaWRDZWxsRGVmRGlyZWN0aXZlXzEgPSBjbGFzcyBOYlRyZWVHcmlkQ2VsbERlZkRpcmVjdGl2ZSBleHRlbmRzIE5iQ2VsbERlZkRpcmVjdGl2ZSB7XG59O1xuTmJUcmVlR3JpZENlbGxEZWZEaXJlY3RpdmUgPSBOYlRyZWVHcmlkQ2VsbERlZkRpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZSQxNjAoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW25iVHJlZUdyaWRDZWxsRGVmXScsXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmJDZGtDZWxsRGVmLCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZENlbGxEZWZEaXJlY3RpdmVfMSB9XSxcbiAgICB9KVxuXSwgTmJUcmVlR3JpZENlbGxEZWZEaXJlY3RpdmUpO1xuLyoqXG4gKiBIZWFkZXIgY2VsbCBkZWZpbml0aW9uIGZvciB0aGUgbmItdGFibGUuXG4gKiBDYXB0dXJlcyB0aGUgdGVtcGxhdGUgb2YgYSBjb2x1bW4ncyBoZWFkZXIgY2VsbCBhbmQgYXMgd2VsbCBhcyBjZWxsLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cbmxldCBOYlRyZWVHcmlkSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSA9IE5iVHJlZUdyaWRIZWFkZXJDZWxsRGVmRGlyZWN0aXZlXzEgPSBjbGFzcyBOYlRyZWVHcmlkSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSBleHRlbmRzIE5iSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSB7XG59O1xuTmJUcmVlR3JpZEhlYWRlckNlbGxEZWZEaXJlY3RpdmUgPSBOYlRyZWVHcmlkSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZSQxNjAoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW25iVHJlZUdyaWRIZWFkZXJDZWxsRGVmXScsXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmJDZGtIZWFkZXJDZWxsRGVmLCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZEhlYWRlckNlbGxEZWZEaXJlY3RpdmVfMSB9XSxcbiAgICB9KVxuXSwgTmJUcmVlR3JpZEhlYWRlckNlbGxEZWZEaXJlY3RpdmUpO1xuLyoqXG4gKiBGb290ZXIgY2VsbCBkZWZpbml0aW9uIGZvciB0aGUgbmItdGFibGUuXG4gKiBDYXB0dXJlcyB0aGUgdGVtcGxhdGUgb2YgYSBjb2x1bW4ncyBmb290ZXIgY2VsbCBhbmQgYXMgd2VsbCBhcyBjZWxsLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gKi9cbmxldCBOYlRyZWVHcmlkRm9vdGVyQ2VsbERlZkRpcmVjdGl2ZSA9IE5iVHJlZUdyaWRGb290ZXJDZWxsRGVmRGlyZWN0aXZlXzEgPSBjbGFzcyBOYlRyZWVHcmlkRm9vdGVyQ2VsbERlZkRpcmVjdGl2ZSBleHRlbmRzIE5iRm9vdGVyQ2VsbERlZkRpcmVjdGl2ZSB7XG59O1xuTmJUcmVlR3JpZEZvb3RlckNlbGxEZWZEaXJlY3RpdmUgPSBOYlRyZWVHcmlkRm9vdGVyQ2VsbERlZkRpcmVjdGl2ZV8xID0gX19kZWNvcmF0ZSQxNjAoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW25iVHJlZUdyaWRGb290ZXJDZWxsRGVmXScsXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmJDZGtGb290ZXJDZWxsRGVmLCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZEZvb3RlckNlbGxEZWZEaXJlY3RpdmVfMSB9XSxcbiAgICB9KVxuXSwgTmJUcmVlR3JpZEZvb3RlckNlbGxEZWZEaXJlY3RpdmUpO1xuXG52YXIgX19kZWNvcmF0ZSQxNjIgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTA4ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTmJUcmVlR3JpZENvbHVtbkRlZkRpcmVjdGl2ZV8xO1xuLyoqXG4gKiBDb2x1bW4gZGVmaW5pdGlvbiBmb3IgdGhlIHRyZWUtZ3JpZC5cbiAqIERlZmluZXMgYSBzZXQgb2YgY2VsbHMgYXZhaWxhYmxlIGZvciBhIHRhYmxlIGNvbHVtbi5cbiAqL1xubGV0IE5iVHJlZUdyaWRDb2x1bW5EZWZEaXJlY3RpdmUgPSBOYlRyZWVHcmlkQ29sdW1uRGVmRGlyZWN0aXZlXzEgPSBjbGFzcyBOYlRyZWVHcmlkQ29sdW1uRGVmRGlyZWN0aXZlIGV4dGVuZHMgTmJDb2x1bW5EZWZEaXJlY3RpdmUge1xuICAgIC8qKlxuICAgICAqIENvbHVtbiBkZWZpbml0aW9uIGZvciB0aGUgdHJlZS1ncmlkLlxuICAgICAqIERlZmluZXMgYSBzZXQgb2YgY2VsbHMgYXZhaWxhYmxlIGZvciBhIHRhYmxlIGNvbHVtbi5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oaWRlT25WYWx1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hvd09uVmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWxzIG9mIHZpZXdwb3J0IGF0IHdoaWNoIGNvbHVtbiBzaG91bGQgYmUgaGlkZGVuLlxuICAgICAqIHR5cGUgbnVtYmVyXG4gICAgICovXG4gICAgZ2V0IGhpZGVPbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlkZU9uVmFsdWU7XG4gICAgfVxuICAgIHNldCBoaWRlT24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5oaWRlT25WYWx1ZSA9ICF2YWx1ZSAmJiB2YWx1ZSAhPT0gMFxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFtb3VudCBvZiBwaXhlbHMgb2Ygdmlld3BvcnQgYXQgd2hpY2ggY29sdW1uIHNob3VsZCBiZSBzaG93bi5cbiAgICAgKiB0eXBlIG51bWJlclxuICAgICAqL1xuICAgIGdldCBzaG93T24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3dPblZhbHVlO1xuICAgIH1cbiAgICBzZXQgc2hvd09uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2hvd09uVmFsdWUgPSAhdmFsdWUgJiYgdmFsdWUgIT09IDBcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuaGlkZU9uICE9IG51bGwgJiYgdGhpcy5zaG93T24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoaWRlT24gYW5kIHNob3dPbiBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIGFuZCBjYW4ndCBiZSB1c2VkIHNpbXVsdGFuZW91c2x5LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNob3VsZEhpZGUod2lkdGgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnNob3VsZFNob3cod2lkdGgpO1xuICAgIH1cbiAgICBzaG91bGRTaG93KHdpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLmhpZGVPbiA9PSBudWxsICYmIHRoaXMuc2hvd09uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhpZGVPbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2lkdGggPiB0aGlzLmhpZGVPbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lkdGggPj0gdGhpcy5zaG93T247XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTYyKFtcbiAgICBJbnB1dCgnbmJUcmVlR3JpZENvbHVtbkRlZicpLFxuICAgIF9fbWV0YWRhdGEkMTA4KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJUcmVlR3JpZENvbHVtbkRlZkRpcmVjdGl2ZS5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZSQxNjIoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxMDgoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpLFxuICAgIF9fbWV0YWRhdGEkMTA4KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW051bWJlcl0pXG5dLCBOYlRyZWVHcmlkQ29sdW1uRGVmRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJoaWRlT25cIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE2MihbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhJDEwOChcImRlc2lnbjp0eXBlXCIsIE51bWJlciksXG4gICAgX19tZXRhZGF0YSQxMDgoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTnVtYmVyXSlcbl0sIE5iVHJlZUdyaWRDb2x1bW5EZWZEaXJlY3RpdmUucHJvdG90eXBlLCBcInNob3dPblwiLCBudWxsKTtcbk5iVHJlZUdyaWRDb2x1bW5EZWZEaXJlY3RpdmUgPSBOYlRyZWVHcmlkQ29sdW1uRGVmRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlJDE2MihbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdbbmJUcmVlR3JpZENvbHVtbkRlZl0nLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTmJDZGtDb2x1bW5EZWYsIHVzZUV4aXN0aW5nOiBOYlRyZWVHcmlkQ29sdW1uRGVmRGlyZWN0aXZlXzEgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTkJfU09SVF9IRUFERVJfQ09MVU1OX0RFRiwgdXNlRXhpc3Rpbmc6IE5iVHJlZUdyaWRDb2x1bW5EZWZEaXJlY3RpdmVfMSB9LFxuICAgICAgICBdLFxuICAgIH0pXG5dLCBOYlRyZWVHcmlkQ29sdW1uRGVmRGlyZWN0aXZlKTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxNjEgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTA3ID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgX19wYXJhbSQyOSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbnZhciBOYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZV8xO1xudmFyIE5iVHJlZUdyaWRIZWFkZXJDZWxsRGlyZWN0aXZlXzE7XG52YXIgTmJUcmVlR3JpZEZvb3RlckNlbGxEaXJlY3RpdmVfMTtcbmxldCBOYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZSA9IE5iVHJlZUdyaWRDZWxsRGlyZWN0aXZlXzEgPSBjbGFzcyBOYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZSBleHRlbmRzIE5iQ2VsbERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmLCB0cmVlLCBwbGF0Zm9ybUlkLCB3aW5kb3csIHNhbml0aXplciwgZGlyZWN0aW9uU2VydmljZSwgY29sdW1uU2VydmljZSwgY2QpIHtcbiAgICAgICAgc3VwZXIoY29sdW1uRGVmLCBlbGVtZW50UmVmKTtcbiAgICAgICAgdGhpcy5wbGF0Zm9ybUlkID0gcGxhdGZvcm1JZDtcbiAgICAgICAgdGhpcy53aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMuc2FuaXRpemVyID0gc2FuaXRpemVyO1xuICAgICAgICB0aGlzLmRpcmVjdGlvblNlcnZpY2UgPSBkaXJlY3Rpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbHVtblNlcnZpY2UgPSBjb2x1bW5TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmluaXRpYWxMZWZ0UGFkZGluZyA9ICcnO1xuICAgICAgICB0aGlzLmluaXRpYWxSaWdodFBhZGRpbmcgPSAnJztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5jb2x1bW5EZWYgPSBjb2x1bW5EZWY7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgfVxuICAgIGdldCBjb2x1bW5XaWR0aCgpIHtcbiAgICAgICAgdGhpcy5sYXRlc3RXaWR0aCA9IHRoaXMudHJlZS5nZXRDb2x1bW5XaWR0aCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRlc3RXaWR0aCB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgbGVmdFBhZGRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvblNlcnZpY2UuaXNMdHIoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnRQYWRkaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCByaWdodFBhZGRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcmVjdGlvblNlcnZpY2UuaXNSdGwoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnRQYWRkaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKSkge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGUkJDEgPSB0aGlzLndpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbExlZnRQYWRkaW5nID0gc3R5bGUkJDEucGFkZGluZ0xlZnQ7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxSaWdodFBhZGRpbmcgPSBzdHlsZSQkMS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5TZXJ2aWNlLm9uQ29sdW1uc0NoYW5nZSgpXG4gICAgICAgICAgICAucGlwZSh0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSksIGZpbHRlcigoKSA9PiB0aGlzLmxhdGVzdFdpZHRoICE9PSB0aGlzLnRyZWUuZ2V0Q29sdW1uV2lkdGgoKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgdG9nZ2xlUm93KCkge1xuICAgICAgICB0aGlzLnRyZWUudG9nZ2xlQ2VsbFJvdyh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGluaXRpYWxTdGFydFBhZGRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvblNlcnZpY2UuaXNMdHIoKVxuICAgICAgICAgICAgPyB0aGlzLmluaXRpYWxMZWZ0UGFkZGluZ1xuICAgICAgICAgICAgOiB0aGlzLmluaXRpYWxSaWdodFBhZGRpbmc7XG4gICAgfVxuICAgIGdldFN0YXJ0UGFkZGluZygpIHtcbiAgICAgICAgY29uc3Qgcm93TGV2ZWwgPSB0aGlzLnRyZWUuZ2V0Q2VsbExldmVsKHRoaXMsIHRoaXMuY29sdW1uRGVmLm5hbWUpO1xuICAgICAgICBpZiAocm93TGV2ZWwgPT09IE5CX0RFRkFVTFRfUk9XX0xFVkVMKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXN0aW5nTGV2ZWwgPSByb3dMZXZlbCArIDE7XG4gICAgICAgIGxldCBwYWRkaW5nID0gJyc7XG4gICAgICAgIGlmICh0aGlzLnRyZWUubGV2ZWxQYWRkaW5nKSB7XG4gICAgICAgICAgICBwYWRkaW5nID0gYGNhbGMoJHt0aGlzLnRyZWUubGV2ZWxQYWRkaW5nfSAqICR7bmVzdGluZ0xldmVsfSlgO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaW5pdGlhbFN0YXJ0UGFkZGluZykge1xuICAgICAgICAgICAgcGFkZGluZyA9IGBjYWxjKCR7dGhpcy5pbml0aWFsU3RhcnRQYWRkaW5nfSAqICR7bmVzdGluZ0xldmVsfSlgO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFkZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2FuaXRpemVyLmJ5cGFzc1NlY3VyaXR5VHJ1c3RTdHlsZShwYWRkaW5nKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxNjEoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS53aWR0aCcpLFxuICAgIF9fbWV0YWRhdGEkMTA3KFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhJDEwNyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJUcmVlR3JpZENlbGxEaXJlY3RpdmUucHJvdG90eXBlLCBcImNvbHVtbldpZHRoXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxNjEoW1xuICAgIEhvc3RCaW5kaW5nKCdzdHlsZS5wYWRkaW5nLWxlZnQnKSxcbiAgICBfX21ldGFkYXRhJDEwNyhcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxMDcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVHJlZUdyaWRDZWxsRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJsZWZ0UGFkZGluZ1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTYxKFtcbiAgICBIb3N0QmluZGluZygnc3R5bGUucGFkZGluZy1yaWdodCcpLFxuICAgIF9fbWV0YWRhdGEkMTA3KFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDEwNyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJUcmVlR3JpZENlbGxEaXJlY3RpdmUucHJvdG90eXBlLCBcInJpZ2h0UGFkZGluZ1wiLCBudWxsKTtcbk5iVHJlZUdyaWRDZWxsRGlyZWN0aXZlID0gTmJUcmVlR3JpZENlbGxEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUkMTYxKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ3RkW25iVHJlZUdyaWRDZWxsXScsXG4gICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICdjbGFzcyc6ICduYi10cmVlLWdyaWQtY2VsbCcsXG4gICAgICAgICAgICAncm9sZSc6ICdncmlkY2VsbCcsXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmJDZGtDZWxsLCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZENlbGxEaXJlY3RpdmVfMSB9XSxcbiAgICB9KSxcbiAgICBfX3BhcmFtJDI5KDIsIEluamVjdChOQl9UUkVFX0dSSUQpKSxcbiAgICBfX3BhcmFtJDI5KDMsIEluamVjdChQTEFURk9STV9JRCkpLFxuICAgIF9fcGFyYW0kMjkoNCwgSW5qZWN0KE5CX1dJTkRPVykpLFxuICAgIF9fbWV0YWRhdGEkMTA3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iVHJlZUdyaWRDb2x1bW5EZWZEaXJlY3RpdmUsXG4gICAgICAgIEVsZW1lbnRSZWYsIE9iamVjdCwgT2JqZWN0LCBPYmplY3QsIERvbVNhbml0aXplcixcbiAgICAgICAgTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBOYkNvbHVtbnNTZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBOYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZSk7XG5sZXQgTmJUcmVlR3JpZEhlYWRlckNlbGxEaXJlY3RpdmUgPSBOYlRyZWVHcmlkSGVhZGVyQ2VsbERpcmVjdGl2ZV8xID0gY2xhc3MgTmJUcmVlR3JpZEhlYWRlckNlbGxEaXJlY3RpdmUgZXh0ZW5kcyBOYkhlYWRlckNlbGxEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGNvbHVtbkRlZiwgZWxlbWVudFJlZiwgdHJlZSwgY29sdW1uU2VydmljZSwgY2QpIHtcbiAgICAgICAgc3VwZXIoY29sdW1uRGVmLCBlbGVtZW50UmVmKTtcbiAgICAgICAgdGhpcy5jb2x1bW5TZXJ2aWNlID0gY29sdW1uU2VydmljZTtcbiAgICAgICAgdGhpcy5jZCA9IGNkO1xuICAgICAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICB9XG4gICAgZ2V0IGNvbHVtbldpZHRoKCkge1xuICAgICAgICB0aGlzLmxhdGVzdFdpZHRoID0gdGhpcy50cmVlLmdldENvbHVtbldpZHRoKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVzdFdpZHRoIHx8IG51bGw7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmNvbHVtblNlcnZpY2Uub25Db2x1bW5zQ2hhbmdlKClcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSwgZmlsdGVyKCgpID0+IHRoaXMubGF0ZXN0V2lkdGggIT09IHRoaXMudHJlZS5nZXRDb2x1bW5XaWR0aCgpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jZC5kZXRlY3RDaGFuZ2VzKCkpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDE2MShbXG4gICAgSG9zdEJpbmRpbmcoJ3N0eWxlLndpZHRoJyksXG4gICAgX19tZXRhZGF0YSQxMDcoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpLFxuICAgIF9fbWV0YWRhdGEkMTA3KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRyZWVHcmlkSGVhZGVyQ2VsbERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiY29sdW1uV2lkdGhcIiwgbnVsbCk7XG5OYlRyZWVHcmlkSGVhZGVyQ2VsbERpcmVjdGl2ZSA9IE5iVHJlZUdyaWRIZWFkZXJDZWxsRGlyZWN0aXZlXzEgPSBfX2RlY29yYXRlJDE2MShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICd0aFtuYlRyZWVHcmlkSGVhZGVyQ2VsbF0nLFxuICAgICAgICBob3N0OiB7XG4gICAgICAgICAgICAnY2xhc3MnOiAnbmItdHJlZS1ncmlkLWhlYWRlci1jZWxsJyxcbiAgICAgICAgICAgICdyb2xlJzogJ2NvbHVtbmhlYWRlcicsXG4gICAgICAgIH0sXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmJDZGtIZWFkZXJDZWxsLCB1c2VFeGlzdGluZzogTmJUcmVlR3JpZEhlYWRlckNlbGxEaXJlY3RpdmVfMSB9XSxcbiAgICB9KSxcbiAgICBfX3BhcmFtJDI5KDIsIEluamVjdChOQl9UUkVFX0dSSUQpKSxcbiAgICBfX21ldGFkYXRhJDEwNyhcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYlRyZWVHcmlkQ29sdW1uRGVmRGlyZWN0aXZlLFxuICAgICAgICBFbGVtZW50UmVmLCBPYmplY3QsIE5iQ29sdW1uc1NlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmXSlcbl0sIE5iVHJlZUdyaWRIZWFkZXJDZWxsRGlyZWN0aXZlKTtcbmxldCBOYlRyZWVHcmlkRm9vdGVyQ2VsbERpcmVjdGl2ZSA9IE5iVHJlZUdyaWRGb290ZXJDZWxsRGlyZWN0aXZlXzEgPSBjbGFzcyBOYlRyZWVHcmlkRm9vdGVyQ2VsbERpcmVjdGl2ZSBleHRlbmRzIE5iRm9vdGVyQ2VsbERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoY29sdW1uRGVmLCBlbGVtZW50UmVmLCB0cmVlLCBjb2x1bW5TZXJ2aWNlLCBjZCkge1xuICAgICAgICBzdXBlcihjb2x1bW5EZWYsIGVsZW1lbnRSZWYpO1xuICAgICAgICB0aGlzLmNvbHVtblNlcnZpY2UgPSBjb2x1bW5TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNkID0gY2Q7XG4gICAgICAgIHRoaXMuYWxpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgIH1cbiAgICBnZXQgY29sdW1uV2lkdGgoKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0V2lkdGggPSB0aGlzLnRyZWUuZ2V0Q29sdW1uV2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF0ZXN0V2lkdGggfHwgbnVsbDtcbiAgICB9XG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VydmljZS5vbkNvbHVtbnNDaGFuZ2UoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpLCBmaWx0ZXIoKCkgPT4gdGhpcy5sYXRlc3RXaWR0aCAhPT0gdGhpcy50cmVlLmdldENvbHVtbldpZHRoKCkpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNkLmRldGVjdENoYW5nZXMoKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTYxKFtcbiAgICBIb3N0QmluZGluZygnc3R5bGUud2lkdGgnKSxcbiAgICBfX21ldGFkYXRhJDEwNyhcImRlc2lnbjp0eXBlXCIsIFN0cmluZyksXG4gICAgX19tZXRhZGF0YSQxMDcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVHJlZUdyaWRGb290ZXJDZWxsRGlyZWN0aXZlLnByb3RvdHlwZSwgXCJjb2x1bW5XaWR0aFwiLCBudWxsKTtcbk5iVHJlZUdyaWRGb290ZXJDZWxsRGlyZWN0aXZlID0gTmJUcmVlR3JpZEZvb3RlckNlbGxEaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUkMTYxKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ3RkW25iVHJlZUdyaWRGb290ZXJDZWxsXScsXG4gICAgICAgIGhvc3Q6IHtcbiAgICAgICAgICAgICdjbGFzcyc6ICduYi10cmVlLWdyaWQtZm9vdGVyLWNlbGwnLFxuICAgICAgICAgICAgJ3JvbGUnOiAnZ3JpZGNlbGwnLFxuICAgICAgICB9LFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE5iQ2RrRm9vdGVyQ2VsbCwgdXNlRXhpc3Rpbmc6IE5iVHJlZUdyaWRGb290ZXJDZWxsRGlyZWN0aXZlXzEgfV0sXG4gICAgfSksXG4gICAgX19wYXJhbSQyOSgyLCBJbmplY3QoTkJfVFJFRV9HUklEKSksXG4gICAgX19tZXRhZGF0YSQxMDcoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmJUcmVlR3JpZENvbHVtbkRlZkRpcmVjdGl2ZSxcbiAgICAgICAgRWxlbWVudFJlZiwgT2JqZWN0LCBOYkNvbHVtbnNTZXJ2aWNlLFxuICAgICAgICBDaGFuZ2VEZXRlY3RvclJlZl0pXG5dLCBOYlRyZWVHcmlkRm9vdGVyQ2VsbERpcmVjdGl2ZSk7XG5cbi8qXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTYzID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX21ldGFkYXRhJDEwOSA9ICh0aGlzICYmIHRoaXMuX19tZXRhZGF0YSkgfHwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEoaywgdik7XG59O1xudmFyIE5iRmlsdGVySW5wdXREaXJlY3RpdmVfMTtcbmxldCBOYkZpbHRlckRpcmVjdGl2ZSA9IGNsYXNzIE5iRmlsdGVyRGlyZWN0aXZlIHtcbiAgICBmaWx0ZXIoZmlsdGVyUmVxdWVzdCkge1xuICAgICAgICB0aGlzLmZpbHRlcmFibGUuZmlsdGVyKGZpbHRlclJlcXVlc3QpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDE2MyhbXG4gICAgSW5wdXQoJ25iRmlsdGVyJyksXG4gICAgX19tZXRhZGF0YSQxMDkoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYkZpbHRlckRpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmlsdGVyYWJsZVwiLCB2b2lkIDApO1xuTmJGaWx0ZXJEaXJlY3RpdmUgPSBfX2RlY29yYXRlJDE2MyhbXG4gICAgRGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdbbmJGaWx0ZXJdJyB9KVxuXSwgTmJGaWx0ZXJEaXJlY3RpdmUpO1xuLyoqXG4gKiBIZWxwZXIgZGlyZWN0aXZlIHRvIHRyaWdnZXIgZGF0YSBzb3VyY2UncyBmaWx0ZXIgbWV0aG9kIHdoZW4gdXNlciB0eXBlcyBpbiBpbnB1dFxuICovXG5sZXQgTmJGaWx0ZXJJbnB1dERpcmVjdGl2ZSA9IE5iRmlsdGVySW5wdXREaXJlY3RpdmVfMSA9IGNsYXNzIE5iRmlsdGVySW5wdXREaXJlY3RpdmUgZXh0ZW5kcyBOYkZpbHRlckRpcmVjdGl2ZSB7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGRpcmVjdGl2ZSB0byB0cmlnZ2VyIGRhdGEgc291cmNlJ3MgZmlsdGVyIG1ldGhvZCB3aGVuIHVzZXIgdHlwZXMgaW4gaW5wdXRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5zZWFyY2gkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5hbGl2ZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWJvdW5jZSB0aW1lIGJlZm9yZSB0cmlnZ2VyaW5nIGZpbHRlciBtZXRob2QuIFNldCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICAgICAqIERlZmF1bHQgMjAwLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWJvdW5jZVRpbWUgPSAyMDA7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnNlYXJjaCRcbiAgICAgICAgICAgIC5waXBlKHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKSwgZGVib3VuY2VUaW1lKHRoaXMuZGVib3VuY2VUaW1lKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHF1ZXJ5KSA9PiB7XG4gICAgICAgICAgICBzdXBlci5maWx0ZXIocXVlcnkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZWFyY2gkLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGZpbHRlcihldmVudCkge1xuICAgICAgICB0aGlzLnNlYXJjaCQubmV4dChldmVudC50YXJnZXQudmFsdWUpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlJDE2MyhbXG4gICAgSW5wdXQoJ25iRmlsdGVySW5wdXQnKSxcbiAgICBfX21ldGFkYXRhJDEwOShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iRmlsdGVySW5wdXREaXJlY3RpdmUucHJvdG90eXBlLCBcImZpbHRlcmFibGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTYzKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTA5KFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTmJGaWx0ZXJJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZGVib3VuY2VUaW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDE2MyhbXG4gICAgSG9zdExpc3RlbmVyKCdpbnB1dCcsIFsnJGV2ZW50J10pLFxuICAgIF9fbWV0YWRhdGEkMTA5KFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pLFxuICAgIF9fbWV0YWRhdGEkMTA5KFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW09iamVjdF0pLFxuICAgIF9fbWV0YWRhdGEkMTA5KFwiZGVzaWduOnJldHVybnR5cGVcIiwgdm9pZCAwKVxuXSwgTmJGaWx0ZXJJbnB1dERpcmVjdGl2ZS5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIG51bGwpO1xuTmJGaWx0ZXJJbnB1dERpcmVjdGl2ZSA9IE5iRmlsdGVySW5wdXREaXJlY3RpdmVfMSA9IF9fZGVjb3JhdGUkMTYzKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1tuYkZpbHRlcklucHV0XScsXG4gICAgICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTmJGaWx0ZXJEaXJlY3RpdmUsIHVzZUV4aXN0aW5nOiBOYkZpbHRlcklucHV0RGlyZWN0aXZlXzEgfV0sXG4gICAgfSlcbl0sIE5iRmlsdGVySW5wdXREaXJlY3RpdmUpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDE2NCA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxMTAgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogV2hlbiB1c2luZyBjdXN0b20gcm93IHRvZ2dsZSwgYXBwbHkgdGhpcyBkaXJlY3RpdmUgb24geW91ciB0b2dnbGUgdG8gdG9nZ2xlIHJvdyBvbiBlbGVtZW50IGNsaWNrLlxuICovXG5sZXQgTmJUcmVlR3JpZFJvd1RvZ2dsZURpcmVjdGl2ZSA9IGNsYXNzIE5iVHJlZUdyaWRSb3dUb2dnbGVEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKGNlbGwpIHtcbiAgICAgICAgdGhpcy5jZWxsID0gY2VsbDtcbiAgICB9XG4gICAgdG9nZ2xlUm93KCRldmVudCkge1xuICAgICAgICB0aGlzLmNlbGwudG9nZ2xlUm93KCk7XG4gICAgICAgICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxNjQoW1xuICAgIEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKSxcbiAgICBfX21ldGFkYXRhJDExMChcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKSxcbiAgICBfX21ldGFkYXRhJDExMChcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtPYmplY3RdKSxcbiAgICBfX21ldGFkYXRhJDExMChcImRlc2lnbjpyZXR1cm50eXBlXCIsIHZvaWQgMClcbl0sIE5iVHJlZUdyaWRSb3dUb2dnbGVEaXJlY3RpdmUucHJvdG90eXBlLCBcInRvZ2dsZVJvd1wiLCBudWxsKTtcbk5iVHJlZUdyaWRSb3dUb2dnbGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlJDE2NChbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdbbmJUcmVlR3JpZFJvd1RvZ2dsZV0nLFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEkMTEwKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW05iVHJlZUdyaWRDZWxsRGlyZWN0aXZlXSlcbl0sIE5iVHJlZUdyaWRSb3dUb2dnbGVEaXJlY3RpdmUpO1xuXG4vKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbnZhciBfX2RlY29yYXRlJDE2NSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19tZXRhZGF0YSQxMTEgPSAodGhpcyAmJiB0aGlzLl9fbWV0YWRhdGEpIHx8IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKGssIHYpO1xufTtcbi8qKlxuICogTmJUcmVlR3JpZFJvd1RvZ2dsZUNvbXBvbmVudFxuICovXG5sZXQgTmJUcmVlR3JpZFJvd1RvZ2dsZUNvbXBvbmVudCA9IGNsYXNzIE5iVHJlZUdyaWRSb3dUb2dnbGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNlbGwpIHtcbiAgICAgICAgdGhpcy5jZWxsID0gY2VsbDtcbiAgICB9XG4gICAgc2V0IGV4cGFuZGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZXhwYW5kZWRWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZXhwYW5kZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuZGVkVmFsdWU7XG4gICAgfVxuICAgIHRvZ2dsZVJvdygkZXZlbnQpIHtcbiAgICAgICAgdGhpcy5jZWxsLnRvZ2dsZVJvdygpO1xuICAgICAgICAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUkMTY1KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTExKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbiksXG4gICAgX19tZXRhZGF0YSQxMTEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQm9vbGVhbl0pXG5dLCBOYlRyZWVHcmlkUm93VG9nZ2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJleHBhbmRlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTY1KFtcbiAgICBIb3N0TGlzdGVuZXIoJ2NsaWNrJywgWyckZXZlbnQnXSksXG4gICAgX19tZXRhZGF0YSQxMTEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbiksXG4gICAgX19tZXRhZGF0YSQxMTEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbT2JqZWN0XSksXG4gICAgX19tZXRhZGF0YSQxMTEoXCJkZXNpZ246cmV0dXJudHlwZVwiLCB2b2lkIDApXG5dLCBOYlRyZWVHcmlkUm93VG9nZ2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0b2dnbGVSb3dcIiwgbnVsbCk7XG5OYlRyZWVHcmlkUm93VG9nZ2xlQ29tcG9uZW50ID0gX19kZWNvcmF0ZSQxNjUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAnbmItdHJlZS1ncmlkLXJvdy10b2dnbGUnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxidXR0b24gY2xhc3M9XCJyb3ctdG9nZ2xlLWJ1dHRvblwiIFthdHRyLmFyaWEtbGFiZWxdPVwiZXhwYW5kZWQgPyAnY29sbGFwc2UnIDogJ2V4cGFuZCdcIj5cbiAgICAgIDxuYi1pY29uIFtpY29uXT1cImV4cGFuZGVkID8gJ2NoZXZyb24tZG93bi1vdXRsaW5lJyA6ICdjaGV2cm9uLXJpZ2h0LW91dGxpbmUnXCJcbiAgICAgICAgICAgICAgIHBhY2s9XCJuZWJ1bGFyLWVzc2VudGlhbHNcIlxuICAgICAgICAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICA8L25iLWljb24+XG4gICAgPC9idXR0b24+XG4gIGAsXG4gICAgICAgIHN0eWxlczogW2BcbiAgICBidXR0b24ge1xuICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICBib3JkZXI6IG5vbmU7XG4gICAgICBwYWRkaW5nOiAwO1xuICAgIH1cbiAgYF1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDExMShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtOYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZV0pXG5dLCBOYlRyZWVHcmlkUm93VG9nZ2xlQ29tcG9uZW50KTtcblxuLypcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxNTAgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuY29uc3QgQ09NUE9ORU5UUyQyID0gW1xuICAgIC8vIFRyZWUgR3JpZFxuICAgIE5iVHJlZUdyaWRDb21wb25lbnQsXG4gICAgTmJUcmVlR3JpZFJvd0RlZkRpcmVjdGl2ZSxcbiAgICBOYlRyZWVHcmlkUm93Q29tcG9uZW50LFxuICAgIE5iVHJlZUdyaWRDZWxsRGVmRGlyZWN0aXZlLFxuICAgIE5iVHJlZUdyaWRDZWxsRGlyZWN0aXZlLFxuICAgIE5iVHJlZUdyaWRIZWFkZXJSb3dEZWZEaXJlY3RpdmUsXG4gICAgTmJUcmVlR3JpZEhlYWRlclJvd0NvbXBvbmVudCxcbiAgICBOYlRyZWVHcmlkSGVhZGVyQ2VsbERlZkRpcmVjdGl2ZSxcbiAgICBOYlRyZWVHcmlkSGVhZGVyQ2VsbERpcmVjdGl2ZSxcbiAgICBOYlRyZWVHcmlkRm9vdGVyUm93RGVmRGlyZWN0aXZlLFxuICAgIE5iVHJlZUdyaWRGb290ZXJSb3dDb21wb25lbnQsXG4gICAgTmJUcmVlR3JpZEZvb3RlckNlbGxEZWZEaXJlY3RpdmUsXG4gICAgTmJUcmVlR3JpZEZvb3RlckNlbGxEaXJlY3RpdmUsXG4gICAgTmJUcmVlR3JpZENvbHVtbkRlZkRpcmVjdGl2ZSxcbiAgICAvLyBTb3J0IGRpcmVjdGl2ZXNcbiAgICBOYlNvcnREaXJlY3RpdmUsXG4gICAgTmJTb3J0SGVhZGVyQ29tcG9uZW50LFxuICAgIE5iU29ydEljb25Db21wb25lbnQsXG4gICAgLy8gRmlsdGVyIGRpcmVjdGl2ZXNcbiAgICBOYkZpbHRlckRpcmVjdGl2ZSxcbiAgICBOYkZpbHRlcklucHV0RGlyZWN0aXZlLFxuICAgIE5iVHJlZUdyaWRSb3dUb2dnbGVEaXJlY3RpdmUsXG4gICAgTmJUcmVlR3JpZFJvd1RvZ2dsZUNvbXBvbmVudCxcbiAgICBOYlNvcnRIZWFkZXJJY29uRGlyZWN0aXZlLFxuXTtcbmxldCBOYlRyZWVHcmlkTW9kdWxlID0gY2xhc3MgTmJUcmVlR3JpZE1vZHVsZSB7XG59O1xuTmJUcmVlR3JpZE1vZHVsZSA9IF9fZGVjb3JhdGUkMTUwKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE5iVGFibGVNb2R1bGUsIE5iSWNvbk1vZHVsZV0sXG4gICAgICAgIGRlY2xhcmF0aW9uczogWy4uLkNPTVBPTkVOVFMkMl0sXG4gICAgICAgIGV4cG9ydHM6IFtOYlRhYmxlTW9kdWxlLCAuLi5DT01QT05FTlRTJDJdLFxuICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgIE5iVHJlZUdyaWRTb3J0U2VydmljZSxcbiAgICAgICAgICAgIE5iVHJlZUdyaWRGaWx0ZXJTZXJ2aWNlLFxuICAgICAgICAgICAgTmJUcmVlR3JpZFNlcnZpY2UsXG4gICAgICAgICAgICBOYlRyZWVHcmlkRGF0YVNlcnZpY2UsXG4gICAgICAgICAgICBOYlRyZWVHcmlkRGF0YVNvdXJjZUJ1aWxkZXIsXG4gICAgICAgIF0sXG4gICAgfSlcbl0sIE5iVHJlZUdyaWRNb2R1bGUpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgQWt2ZW8uIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICovXG52YXIgX19kZWNvcmF0ZSQxNjcgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fbWV0YWRhdGEkMTEyID0gKHRoaXMgJiYgdGhpcy5fX21ldGFkYXRhKSB8fCBmdW5jdGlvbiAoaywgdikge1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShrLCB2KTtcbn07XG52YXIgTmJUb2dnbGVDb21wb25lbnRfMTtcbi8qKlxuICogVG9nZ2xlIGlzIGEgY29udHJvbCByZXByZXNlbnRpbmcgYG9uYCBhbmQgYG9mZmAgc3RhdGVzLlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoU2hvd2Nhc2UsIHRvZ2dsZS90b2dnbGUtc2hvd2Nhc2UuY29tcG9uZW50KVxuICpcbiAqICMjIyBJbnN0YWxsYXRpb25cbiAqXG4gKiBJbXBvcnQgYE5iVG9nZ2xlQ29tcG9uZW50YCB0byB5b3VyIGZlYXR1cmUgbW9kdWxlLlxuICogYGBgdHNcbiAqIEBOZ01vZHVsZSh7XG4gKiAgIGltcG9ydHM6IFtcbiAqICAgICAvLyAuLi5cbiAqICAgICBOYlRvZ2dsZU1vZHVsZSxcbiAqICAgXSxcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgUGFnZU1vZHVsZSB7IH1cbiAqIGBgYFxuICogIyMjIFVzYWdlXG4gKlxuICogVG9nZ2xlIG1heSBoYXZlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHN0YXR1c2VzOiBgYmFzaWNgLCBgcHJpbWFyeWAsIGBzdWNjZXNzYCwgYHdhcm5pbmdgLCBgZGFuZ2VyYCwgYGluZm9gLCBgY29udHJvbGBcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFRvZ2dsZSBzdGF0dXMsIHRvZ2dsZS90b2dnbGUtc3RhdHVzLmNvbXBvbmVudClcbiAqXG4gKiBUb2dnbGUgY2FuIGJlIGRpc2FibGVkIHZpYSBgZGlzYWJsZWRgIGlucHV0LlxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoRGlzYWJsZWQgVG9nZ2xlcywgdG9nZ2xlL3RvZ2dsZS1kaXNhYmxlZC5jb21wb25lbnQpXG4gKlxuICogVG9nZ2xlIG1heSBoYXZlIGEgbGFiZWwgd2l0aCBmb2xsb3dpbmcgcG9zaXRpb25zOiBgbGVmdGAsIGByaWdodGAsIGBzdGFydGAsIGBlbmRgIChkZWZhdWx0KVxuICpcbiAqIEBzdGFja2VkLWV4YW1wbGUoVG9nZ2xlcyBXaXRoIExhYmVscywgdG9nZ2xlL3RvZ2dsZS1sYWJlbC1wb3NpdGlvbi5jb21wb25lbnQudHMpXG4gKlxuICogWW91IGNhbiBzZXQgY29udHJvbCBzdGF0ZSB2aWEgYGNoZWNrZWRgIGJpbmRpbmc6XG4gKlxuICogYGBgaHRtbFxuICogPG5iLXRvZ2dsZSBbKGNoZWNrZWQpXT1cImNoZWNrZWRcIj48L25iLXRvZ2dsZT5cbiAqIGBgYFxuICpcbiAqIE9yIGl0IGNvdWxkIGJlIHNldCB2aWEgcmVhY3RpdmUgZm9ybXMgb3IgbmdNb2RlbCBiaW5kaW5nczpcbiAqXG4gKiBAc3RhY2tlZC1leGFtcGxlKFRvZ2dsZSBmb3JtIGJpbmRpbmcsIHRvZ2dsZS90b2dnbGUtZm9ybS5jb21wb25lbnQpXG4gKlxuICogQHN0eWxlc1xuICpcbiAqIHRvZ2dsZS1oZWlnaHQ6XG4gKiB0b2dnbGUtd2lkdGg6XG4gKiB0b2dnbGUtYm9yZGVyLXdpZHRoOlxuICogdG9nZ2xlLWJvcmRlci1yYWRpdXM6XG4gKiB0b2dnbGUtb3V0bGluZS13aWR0aDpcbiAqIHRvZ2dsZS1vdXRsaW5lLWNvbG9yOlxuICogdG9nZ2xlLXN3aXRjaGVyLXNpemU6XG4gKiB0b2dnbGUtdGV4dC1mb250LWZhbWlseTpcbiAqIHRvZ2dsZS10ZXh0LWZvbnQtc2l6ZTpcbiAqIHRvZ2dsZS10ZXh0LWZvbnQtd2VpZ2h0OlxuICogdG9nZ2xlLXRleHQtbGluZS1oZWlnaHQ6XG4gKiB0b2dnbGUtY3Vyc29yOlxuICogdG9nZ2xlLWRpc2FibGVkLWN1cnNvcjpcbiAqIHRvZ2dsZS1iYXNpYy10ZXh0LWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1jaGVja2VkLXN3aXRjaGVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtY2hlY2tlZC1zd2l0Y2hlci1jaGVja21hcmstY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtZm9jdXMtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtZm9jdXMtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWZvY3VzLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtaG92ZXItYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWhvdmVyLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1iYXNpYy1hY3RpdmUtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtYWN0aXZlLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWJhc2ljLWRpc2FibGVkLXN3aXRjaGVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtZGlzYWJsZWQtY2hlY2tlZC1zd2l0Y2hlci1jaGVja21hcmstY29sb3I6XG4gKiB0b2dnbGUtYmFzaWMtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LXRleHQtY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1jaGVja2VkLXN3aXRjaGVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1jaGVja2VkLXN3aXRjaGVyLWNoZWNrbWFyay1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1mb2N1cy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1mb2N1cy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1hY3RpdmUtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtcHJpbWFyeS1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktZGlzYWJsZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1wcmltYXJ5LWRpc2FibGVkLWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLXByaW1hcnktZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLXRleHQtY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1jaGVja2VkLXN3aXRjaGVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1jaGVja2VkLXN3aXRjaGVyLWNoZWNrbWFyay1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1mb2N1cy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1mb2N1cy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1hY3RpdmUtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtc3VjY2Vzcy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtZGlzYWJsZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1zdWNjZXNzLWRpc2FibGVkLWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLXN1Y2Nlc3MtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLXRleHQtY29sb3I6XG4gKiB0b2dnbGUtaW5mby1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWluZm8tYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWluZm8tY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWluZm8tY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtaW5mby1jaGVja2VkLXN3aXRjaGVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtaW5mby1jaGVja2VkLXN3aXRjaGVyLWNoZWNrbWFyay1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtaW5mby1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtaW5mby1mb2N1cy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtaW5mby1mb2N1cy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtaW5mby1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtaW5mby1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtaW5mby1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWluZm8tYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtaW5mby1hY3RpdmUtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtaW5mby1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWluZm8tZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWluZm8tZGlzYWJsZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1pbmZvLWRpc2FibGVkLWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLWluZm8tZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLXRleHQtY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1jaGVja2VkLXN3aXRjaGVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1jaGVja2VkLXN3aXRjaGVyLWNoZWNrbWFyay1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1mb2N1cy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1mb2N1cy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1hY3RpdmUtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtd2FybmluZy1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctZGlzYWJsZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS13YXJuaW5nLWRpc2FibGVkLWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLXdhcm5pbmctZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWNoZWNrZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1jaGVja2VkLXN3aXRjaGVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1mb2N1cy1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWZvY3VzLWNoZWNrZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItZm9jdXMtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWhvdmVyLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItaG92ZXItY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItYWN0aXZlLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWFjdGl2ZS1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtZGFuZ2VyLWFjdGl2ZS1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1kaXNhYmxlZC1zd2l0Y2hlci1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWRhbmdlci1kaXNhYmxlZC1jaGVja2VkLXN3aXRjaGVyLWNoZWNrbWFyay1jb2xvcjpcbiAqIHRvZ2dsZS1kYW5nZXItZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLXRleHQtY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtY2hlY2tlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1jaGVja2VkLXN3aXRjaGVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1jaGVja2VkLXN3aXRjaGVyLWNoZWNrbWFyay1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWZvY3VzLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1mb2N1cy1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1mb2N1cy1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1mb2N1cy1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWhvdmVyLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1ob3Zlci1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1ob3Zlci1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1ob3Zlci1jaGVja2VkLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtYWN0aXZlLWJvcmRlci1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWFjdGl2ZS1jaGVja2VkLWJhY2tncm91bmQtY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1hY3RpdmUtY2hlY2tlZC1ib3JkZXItY29sb3I6XG4gKiB0b2dnbGUtY29udHJvbC1kaXNhYmxlZC1iYWNrZ3JvdW5kLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtZGlzYWJsZWQtYm9yZGVyLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtZGlzYWJsZWQtc3dpdGNoZXItYmFja2dyb3VuZC1jb2xvcjpcbiAqIHRvZ2dsZS1jb250cm9sLWRpc2FibGVkLWNoZWNrZWQtc3dpdGNoZXItY2hlY2ttYXJrLWNvbG9yOlxuICogdG9nZ2xlLWNvbnRyb2wtZGlzYWJsZWQtdGV4dC1jb2xvcjpcbiAqL1xubGV0IE5iVG9nZ2xlQ29tcG9uZW50ID0gTmJUb2dnbGVDb21wb25lbnRfMSA9IGNsYXNzIE5iVG9nZ2xlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFuZ2VEZXRlY3RvciwgbGF5b3V0RGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5sYXlvdXREaXJlY3Rpb24gPSBsYXlvdXREaXJlY3Rpb247XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMub25Ub3VjaGVkID0gKCkgPT4geyB9O1xuICAgICAgICB0aGlzLmRlc3Ryb3kkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0dXMgPSAnYmFzaWMnO1xuICAgICAgICAvKipcbiAgICAgICAgICogVG9nZ2xlIGxhYmVsIHBvc2l0aW9uLlxuICAgICAgICAgKiBQb3NzaWJsZSB2YWx1ZXMgYXJlOiBgbGVmdGAsIGByaWdodGAsIGBzdGFydGAsIGBlbmRgIChkZWZhdWx0KVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYWJlbFBvc2l0aW9uID0gJ2VuZCc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdXRwdXQgd2hlbiBjaGVja2VkIHN0YXRlIGlzIGNoYW5nZWQgYnkgYSB1c2VyXG4gICAgICAgICAqIEB0eXBlIEV2ZW50RW1pdHRlcjxib29sZWFuPlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgY2hlY2tlZFxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBjaGVja2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hlY2tlZDtcbiAgICB9XG4gICAgc2V0IGNoZWNrZWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIGlucHV0IGRpc2FibGVkIHN0YXRlXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvbnZlcnRUb0Jvb2xQcm9wZXJ0eSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSBzdGF0dXMuXG4gICAgICogUG9zc2libGUgdmFsdWVzIGFyZTogYGJhc2ljYCwgYHByaW1hcnlgLCBgc3VjY2Vzc2AsIGB3YXJuaW5nYCwgYGRhbmdlcmAsIGBpbmZvYCwgYGNvbnRyb2xgLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0dXM7XG4gICAgfVxuICAgIHNldCBzdGF0dXModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgZW1wdHlTdGF0dXNXYXJuaW5nKCdOYlRvZ2dsZScpO1xuICAgICAgICAgICAgdmFsdWUgPSAnYmFzaWMnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXR1cyA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcHJpbWFyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAncHJpbWFyeSc7XG4gICAgfVxuICAgIGdldCBzdWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdzdWNjZXNzJztcbiAgICB9XG4gICAgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gJ3dhcm5pbmcnO1xuICAgIH1cbiAgICBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0dXMgPT09ICdkYW5nZXInO1xuICAgIH1cbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnaW5mbyc7XG4gICAgfVxuICAgIGdldCBiYXNpYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnYmFzaWMnO1xuICAgIH1cbiAgICBnZXQgY29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSAnY29udHJvbCc7XG4gICAgfVxuICAgIGdldCBsYWJlbExlZnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsUG9zaXRpb24gPT09ICdsZWZ0JztcbiAgICB9XG4gICAgZ2V0IGxhYmVsUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsUG9zaXRpb24gPT09ICdyaWdodCc7XG4gICAgfVxuICAgIGdldCBsYWJlbFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFBvc2l0aW9uID09PSAnc3RhcnQnO1xuICAgIH1cbiAgICBnZXQgbGFiZWxFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsUG9zaXRpb24gPT09ICdlbmQnO1xuICAgIH1cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5sYXlvdXREaXJlY3Rpb24ub25EaXJlY3Rpb25DaGFuZ2UoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQoKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICBjaGVja1N0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5jaGVja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXREaXJlY3Rpb24uaXNMdHIoKSA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0RGlyZWN0aW9uLmlzTHRyKCkgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9XG4gICAgd3JpdGVWYWx1ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gdmFsO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBzZXREaXNhYmxlZFN0YXRlKHZhbCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gY29udmVydFRvQm9vbFByb3BlcnR5KHZhbCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIHVwZGF0ZVZhbHVlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSBpbnB1dC5jaGVja2VkO1xuICAgICAgICB0aGlzLmNoZWNrZWRDaGFuZ2UuZW1pdCh0aGlzLmNoZWNrZWQpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlKHRoaXMuY2hlY2tlZCk7XG4gICAgfVxuICAgIG9uSW5wdXRDbGljayhldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZSQxNjcoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxMTIoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iVG9nZ2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjaGVja2VkXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxNjcoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YSQxMTIoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtCb29sZWFuXSlcbl0sIE5iVG9nZ2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkaXNhYmxlZFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTY3KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTEyKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtTdHJpbmddKVxuXSwgTmJUb2dnbGVDb21wb25lbnQucHJvdG90eXBlLCBcInN0YXR1c1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTY3KFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEkMTEyKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgTmJUb2dnbGVDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsUG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUkMTY3KFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5iVG9nZ2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjaGVja2VkQ2hhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlJDE2NyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1wcmltYXJ5JyksXG4gICAgX19tZXRhZGF0YSQxMTIoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTEyKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvZ2dsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicHJpbWFyeVwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTY3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLXN1Y2Nlc3MnKSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxMTIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVG9nZ2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzdWNjZXNzXCIsIG51bGwpO1xuX19kZWNvcmF0ZSQxNjcoW1xuICAgIEhvc3RCaW5kaW5nKCdjbGFzcy5zdGF0dXMtd2FybmluZycpLFxuICAgIF9fbWV0YWRhdGEkMTEyKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJUb2dnbGVDb21wb25lbnQucHJvdG90eXBlLCBcIndhcm5pbmdcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE2NyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1kYW5nZXInKSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxMTIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVG9nZ2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYW5nZXJcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE2NyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1pbmZvJyksXG4gICAgX19tZXRhZGF0YSQxMTIoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTEyKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvZ2dsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiaW5mb1wiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTY3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3Muc3RhdHVzLWJhc2ljJyksXG4gICAgX19tZXRhZGF0YSQxMTIoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTEyKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvZ2dsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYmFzaWNcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE2NyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnN0YXR1cy1jb250cm9sJyksXG4gICAgX19tZXRhZGF0YSQxMTIoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpLFxuICAgIF9fbWV0YWRhdGEkMTEyKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW10pXG5dLCBOYlRvZ2dsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29udHJvbFwiLCBudWxsKTtcbl9fZGVjb3JhdGUkMTY3KFtcbiAgICBIb3N0QmluZGluZygnY2xhc3MudG9nZ2xlLWxhYmVsLWxlZnQnKSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxMTIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVG9nZ2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbExlZnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE2NyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnRvZ2dsZS1sYWJlbC1yaWdodCcpLFxuICAgIF9fbWV0YWRhdGEkMTEyKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJUb2dnbGVDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsUmlnaHRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE2NyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnRvZ2dsZS1sYWJlbC1zdGFydCcpLFxuICAgIF9fbWV0YWRhdGEkMTEyKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgTmJUb2dnbGVDb21wb25lbnQucHJvdG90eXBlLCBcImxhYmVsU3RhcnRcIiwgbnVsbCk7XG5fX2RlY29yYXRlJDE2NyhbXG4gICAgSG9zdEJpbmRpbmcoJ2NsYXNzLnRvZ2dsZS1sYWJlbC1lbmQnKSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjp0eXBlXCIsIE9iamVjdCksXG4gICAgX19tZXRhZGF0YSQxMTIoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbXSlcbl0sIE5iVG9nZ2xlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsYWJlbEVuZFwiLCBudWxsKTtcbk5iVG9nZ2xlQ29tcG9uZW50ID0gTmJUb2dnbGVDb21wb25lbnRfMSA9IF9fZGVjb3JhdGUkMTY3KFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ25iLXRvZ2dsZScsXG4gICAgICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgICAgIHRyaWdnZXIoJ3Bvc2l0aW9uJywgW1xuICAgICAgICAgICAgICAgIHN0YXRlKCdyaWdodCcsIHN0eWxlKHsgcmlnaHQ6IDAsIGxlZnQ6ICcqJyB9KSksXG4gICAgICAgICAgICAgICAgc3RhdGUoJ2xlZnQnLCBzdHlsZSh7IGxlZnQ6IDAsIHJpZ2h0OiAnKicgfSkpLFxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFthbmltYXRlKDApXSksXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbigncmlnaHQgPD0+IGxlZnQnLCBbYW5pbWF0ZSgnMC4xNXMnKV0pLFxuICAgICAgICAgICAgXSksXG4gICAgICAgIF0sXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgPGxhYmVsIGNsYXNzPVwidG9nZ2xlLWxhYmVsXCI+XG4gICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgICBjbGFzcz1cIm5hdGl2ZS1pbnB1dCB2aXN1YWxseS1oaWRkZW5cIlxuICAgICAgICAgICAgIHJvbGU9XCJzd2l0Y2hcIlxuICAgICAgICAgICAgIFthdHRyLmFyaWEtY2hlY2tlZF09XCJjaGVja2VkXCJcbiAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgIFtjaGVja2VkXT1cImNoZWNrZWRcIlxuICAgICAgICAgICAgIChjaGFuZ2UpPVwidXBkYXRlVmFsdWUoJGV2ZW50KVwiXG4gICAgICAgICAgICAgKGJsdXIpPVwib25Ub3VjaGVkKClcIlxuICAgICAgICAgICAgIChjbGljayk9XCJvbklucHV0Q2xpY2soJGV2ZW50KVwiPlxuICAgICAgPGRpdiBjbGFzcz1cInRvZ2dsZVwiIFtjbGFzcy5jaGVja2VkXT1cImNoZWNrZWRcIj5cbiAgICAgICAgPHNwYW4gW0Bwb3NpdGlvbl09XCJjaGVja1N0YXRlKClcIiBjbGFzcz1cInRvZ2dsZS1zd2l0Y2hlclwiPlxuICAgICAgICAgIDxuYi1pY29uICpuZ0lmPVwiY2hlY2tlZFwiIGljb249XCJjaGVja21hcmstYm9sZC1vdXRsaW5lXCIgcGFjaz1cIm5lYnVsYXItZXNzZW50aWFsc1wiPjwvbmItaWNvbj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgICA8c3BhbiBjbGFzcz1cInRleHRcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgPC9zcGFuPlxuICAgIDwvbGFiZWw+XG4gIGAsXG4gICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOYlRvZ2dsZUNvbXBvbmVudF8xKSxcbiAgICAgICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgIH1dLFxuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc3R5bGVzOiBbXCI6aG9zdHtkaXNwbGF5OmlubGluZS1mbGV4O291dGxpbmU6bm9uZX06aG9zdCgudG9nZ2xlLWxhYmVsLWxlZnQpIC50ZXh0Om5vdCg6ZW1wdHkpe3BhZGRpbmctcmlnaHQ6MC42ODc1cmVtfVtkaXI9bHRyXSA6aG9zdCgudG9nZ2xlLWxhYmVsLWxlZnQpIC50ZXh0Om5vdCg6ZW1wdHkpe29yZGVyOi0xfVtkaXI9cnRsXSA6aG9zdCgudG9nZ2xlLWxhYmVsLWxlZnQpIC50ZXh0Om5vdCg6ZW1wdHkpe29yZGVyOjF9Omhvc3QoLnRvZ2dsZS1sYWJlbC1yaWdodCkgLnRleHQ6bm90KDplbXB0eSl7cGFkZGluZy1sZWZ0OjAuNjg3NXJlbX1bZGlyPWx0cl0gOmhvc3QoLnRvZ2dsZS1sYWJlbC1yaWdodCkgLnRleHQ6bm90KDplbXB0eSl7b3JkZXI6MX1bZGlyPXJ0bF0gOmhvc3QoLnRvZ2dsZS1sYWJlbC1yaWdodCkgLnRleHQ6bm90KDplbXB0eSl7b3JkZXI6LTF9Omhvc3QoLnRvZ2dsZS1sYWJlbC1zdGFydCkgLnRvZ2dsZS1sYWJlbHtmbGV4LWRpcmVjdGlvbjpyb3ctcmV2ZXJzZX1bZGlyPWx0cl0gOmhvc3QoLnRvZ2dsZS1sYWJlbC1zdGFydCkgLnRvZ2dsZS1sYWJlbCAudGV4dDpub3QoOmVtcHR5KXtwYWRkaW5nLXJpZ2h0Oi42ODc1cmVtfVtkaXI9cnRsXSA6aG9zdCgudG9nZ2xlLWxhYmVsLXN0YXJ0KSAudG9nZ2xlLWxhYmVsIC50ZXh0Om5vdCg6ZW1wdHkpe3BhZGRpbmctbGVmdDouNjg3NXJlbX1bZGlyPWx0cl0gOmhvc3QoLnRvZ2dsZS1sYWJlbC1lbmQpIC50ZXh0Om5vdCg6ZW1wdHkpe3BhZGRpbmctbGVmdDouNjg3NXJlbX1bZGlyPXJ0bF0gOmhvc3QoLnRvZ2dsZS1sYWJlbC1lbmQpIC50ZXh0Om5vdCg6ZW1wdHkpe3BhZGRpbmctcmlnaHQ6LjY4NzVyZW19LnRvZ2dsZS1sYWJlbHtwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmlubGluZS1mbGV4O2FsaWduLWl0ZW1zOmNlbnRlcn0udG9nZ2xle3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6aW5saW5lLWZsZXg7Ym94LXNpemluZzpjb250ZW50LWJveDt0cmFuc2l0aW9uLWR1cmF0aW9uOjAuMTVzO3RyYW5zaXRpb24tcHJvcGVydHk6YmFja2dyb3VuZC1jb2xvcixib3JkZXIsYm94LXNoYWRvdzt0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjplYXNlLWlufS50b2dnbGUtc3dpdGNoZXJ7cG9zaXRpb246YWJzb2x1dGU7Ym9yZGVyLXJhZGl1czo1MCU7bWFyZ2luOjFweH0udG9nZ2xlLXN3aXRjaGVyIG5iLWljb257cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTtsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsIC01MCUpO3dpZHRoOjQwJX1cXG5cIl1cbiAgICB9KSxcbiAgICBfX21ldGFkYXRhJDExMihcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlXSlcbl0sIE5iVG9nZ2xlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEFrdmVvLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIF9fZGVjb3JhdGUkMTY2ID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbmxldCBOYlRvZ2dsZU1vZHVsZSA9IGNsYXNzIE5iVG9nZ2xlTW9kdWxlIHtcbn07XG5OYlRvZ2dsZU1vZHVsZSA9IF9fZGVjb3JhdGUkMTY2KFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgIE5iSWNvbk1vZHVsZSxcbiAgICAgICAgXSxcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbTmJUb2dnbGVDb21wb25lbnRdLFxuICAgICAgICBleHBvcnRzOiBbTmJUb2dnbGVDb21wb25lbnRdLFxuICAgIH0pXG5dLCBOYlRvZ2dsZU1vZHVsZSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBBa3Zlby4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi9cbi8vIFRPRE86IGV4cG9ydCBhbGwgY29tcG9uZW50c1xuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IE5iQ2FsZW5kYXJXZWVrTnVtYmVyQ29tcG9uZW50IGFzIMm1ZSwgTmJGb2N1c0tleU1hbmFnZXJGYWN0b3J5U2VydmljZSBhcyDJtWQsIE5iU2Nyb2xsU3RyYXRlZ3lPcHRpb25zIGFzIMm1YiwgTmJQbGF0Zm9ybSQxIGFzIMm1ZiwgTmJNZW51SW50ZXJuYWxTZXJ2aWNlIGFzIMm1YSwgTmJTaGFyZWRNb2R1bGUgYXMgybVjLCBOYkNhbGVuZGFySGVhZGVyQ29tcG9uZW50LCBOYkNhbGVuZGFyRGF5Q2VsbENvbXBvbmVudCwgTmJDYWxlbmRhclllYXJQaWNrZXJDb21wb25lbnQsIFlFQVJTX0lOX1ZJRVcsIFlFQVJTX0lOX0NPTFVNTiwgTmJDYWxlbmRhck1vbnRoUGlja2VyQ29tcG9uZW50LCBNT05USFNfSU5fVklFVywgTU9OVEhTX0lOX0NPTFVNTiwgTmJDYWxlbmRhckRheVBpY2tlckNvbXBvbmVudCwgTmJDYWxlbmRhck5hdmlnYXRpb25Db21wb25lbnQsIE5iQ2FsZW5kYXJQYWdlYWJsZU5hdmlnYXRpb25Db21wb25lbnQsIE5iQ2FsZW5kYXJEYXlzTmFtZXNDb21wb25lbnQsIE5iQ2FsZW5kYXJNb250aENlbGxDb21wb25lbnQsIE5iQ2FsZW5kYXJZZWFyQ2VsbENvbXBvbmVudCwgTmJDYWxlbmRhclBpY2tlclJvd0NvbXBvbmVudCwgTmJDYWxlbmRhclBpY2tlckNvbXBvbmVudCwgTmJDYWxlbmRhck1vbnRoTW9kZWxTZXJ2aWNlLCBOYk5hdGl2ZURhdGVTZXJ2aWNlLCBOYkRhdGVTZXJ2aWNlLCBOYk1lbnVTZXJ2aWNlLCBOYk1lbnVJdGVtLCBOYkJsb2NrU2Nyb2xsU3RyYXRlZ3lBZGFwdGVyLCBOQl9USEVNRV9PUFRJT05TLCBOQl9NRURJQV9CUkVBS1BPSU5UUywgTkJfQlVJTFRfSU5fSlNfVEhFTUVTLCBOQl9KU19USEVNRVMsIE5CX1dJTkRPVywgTkJfRE9DVU1FTlQsIHdpbmRvd0ZhY3RvcnksIE5iVGhlbWVNb2R1bGUsIE5iVGhlbWVTZXJ2aWNlLCBOYlNwaW5uZXJTZXJ2aWNlLCBERUZBVUxUX01FRElBX0JSRUFLUE9JTlRTLCBOYk1lZGlhQnJlYWtwb2ludHNTZXJ2aWNlLCBOYkNvbG9ySGVscGVyLCBOYkxheW91dERpcmVjdGlvbiwgTkJfTEFZT1VUX0RJUkVDVElPTiwgTmJMYXlvdXREaXJlY3Rpb25TZXJ2aWNlLCBOYkxheW91dFNjcm9sbFNlcnZpY2UsIE5iTGF5b3V0UnVsZXJTZXJ2aWNlLCBCVUlMVF9JTl9USEVNRVMsIE5iSlNUaGVtZXNSZWdpc3RyeSwgQ09SUE9SQVRFX1RIRU1FLCBDT1NNSUNfVEhFTUUsIERFRkFVTFRfVEhFTUUsIERBUktfVEhFTUUsIE5iQ2FyZE1vZHVsZSwgTmJDYXJkSGVhZGVyQ29tcG9uZW50LCBOYkNhcmRCb2R5Q29tcG9uZW50LCBOYkNhcmRGb290ZXJDb21wb25lbnQsIE5iQ2FyZENvbXBvbmVudCwgTmJGbGlwQ2FyZENvbXBvbmVudCwgTmJSZXZlYWxDYXJkQ29tcG9uZW50LCBOYkNhcmRGcm9udENvbXBvbmVudCwgTmJDYXJkQmFja0NvbXBvbmVudCwgTmJDYWxlbmRhck1vZHVsZSwgTmJDYWxlbmRhckNvbXBvbmVudCwgTmJDYWxlbmRhclJhbmdlTW9kdWxlLCBOYkNhbGVuZGFyUmFuZ2VDb21wb25lbnQsIE5iQmFzZUNhbGVuZGFyQ29tcG9uZW50LCBOYkJhc2VDYWxlbmRhck1vZHVsZSwgTmJDYWxlbmRhclJhbmdlRGF5Q2VsbENvbXBvbmVudCwgTmJDYWxlbmRhclJhbmdlWWVhckNlbGxDb21wb25lbnQsIE5iQ2FsZW5kYXJWaWV3TW9kZSwgTmJDYWxlbmRhclNpemUsIE5iQ2FsZW5kYXJLaXRNb2R1bGUsIE5iTGF5b3V0TW9kdWxlLCBOYkxheW91dENvbXBvbmVudCwgTmJMYXlvdXRDb2x1bW5Db21wb25lbnQsIE5iTGF5b3V0SGVhZGVyQ29tcG9uZW50LCBOYkxheW91dEZvb3RlckNvbXBvbmVudCwgTmJSZXN0b3JlU2Nyb2xsVG9wSGVscGVyLCBOYk1lbnVNb2R1bGUsIE5iVG9nZ2xlU3RhdGVzLCBOYk1lbnVJdGVtQ29tcG9uZW50LCBOYk1lbnVDb21wb25lbnQsIE5iUm91dGVUYWJzZXRNb2R1bGUsIE5iUm91dGVUYWJzZXRDb21wb25lbnQsIE5iU2lkZWJhck1vZHVsZSwgTmJTaWRlYmFyU2VydmljZSwgTmJTaWRlYmFySGVhZGVyQ29tcG9uZW50LCBOYlNpZGViYXJGb290ZXJDb21wb25lbnQsIE5iU2lkZWJhckNvbXBvbmVudCwgTmJUYWJzZXRNb2R1bGUsIE5iVGFiQ29tcG9uZW50LCBOYlRhYnNldENvbXBvbmVudCwgTmJVc2VyTW9kdWxlLCBOYlVzZXJDb21wb25lbnQsIE5iQWN0aW9uc01vZHVsZSwgTmJBY3Rpb25Db21wb25lbnQsIE5iQWN0aW9uc0NvbXBvbmVudCwgTmJTZWFyY2hNb2R1bGUsIE5iU2VhcmNoU2VydmljZSwgTmJTZWFyY2hGaWVsZENvbXBvbmVudCwgTmJTZWFyY2hDb21wb25lbnQsIE5iQ2hlY2tib3hDb21wb25lbnQsIE5iQ2hlY2tib3hNb2R1bGUsIE5iQmFkZ2VDb21wb25lbnQsIE5iQmFkZ2VNb2R1bGUsIE5iUG9wb3ZlckRpcmVjdGl2ZSwgTmJQb3BvdmVyTW9kdWxlLCBOYlBvcG92ZXJDb21wb25lbnQsIE5iQ29udGV4dE1lbnVEaXJlY3RpdmUsIE5iQ29udGV4dE1lbnVDb21wb25lbnQsIE5iQ29udGV4dE1lbnVNb2R1bGUsIE5iUHJvZ3Jlc3NCYXJDb21wb25lbnQsIE5iUHJvZ3Jlc3NCYXJNb2R1bGUsIE5iQWxlcnRDb21wb25lbnQsIE5iQWxlcnRNb2R1bGUsIE5iQ2hhdENvbXBvbmVudCwgTmJDaGF0TWVzc2FnZUNvbXBvbmVudCwgTmJDaGF0TWVzc2FnZU1hcENvbXBvbmVudCwgTmJDaGF0TWVzc2FnZUZpbGVDb21wb25lbnQsIE5iQ2hhdE1lc3NhZ2VRdW90ZUNvbXBvbmVudCwgTmJDaGF0TWVzc2FnZVRleHRDb21wb25lbnQsIE5iQ2hhdEZvcm1Db21wb25lbnQsIE5iQ2hhdE1vZHVsZSwgTmJDaGF0T3B0aW9ucywgTmJTcGlubmVyQ29tcG9uZW50LCBOYlNwaW5uZXJEaXJlY3RpdmUsIE5iU3Bpbm5lck1vZHVsZSwgTkJfU1RFUFBFUiwgTmJTdGVwcGVyQ29tcG9uZW50LCBOYlN0ZXBDb21wb25lbnQsIE5iU3RlcHBlck5leHREaXJlY3RpdmUsIE5iU3RlcHBlclByZXZpb3VzRGlyZWN0aXZlLCBOYlN0ZXBwZXJNb2R1bGUsIE5iQWNjb3JkaW9uQ29tcG9uZW50LCBOYkFjY29yZGlvbkl0ZW1Db21wb25lbnQsIE5iQWNjb3JkaW9uSXRlbUJvZHlDb21wb25lbnQsIE5iQWNjb3JkaW9uSXRlbUhlYWRlckNvbXBvbmVudCwgTmJBY2NvcmRpb25Nb2R1bGUsIE5iQnV0dG9uQ29tcG9uZW50LCBOYkJ1dHRvbk1vZHVsZSwgTmJMaXN0Q29tcG9uZW50LCBOYkxpc3RJdGVtQ29tcG9uZW50LCBOYkxpc3RNb2R1bGUsIE5iTGlzdFBhZ2VUcmFja2VyRGlyZWN0aXZlLCBOYlNjcm9sbGFibGVDb250YWluZXJEaW1lbnRpb25zLCBOYkluZmluaXRlTGlzdERpcmVjdGl2ZSwgTmJJbnB1dERpcmVjdGl2ZSwgTmJJbnB1dE1vZHVsZSwgTmJPdmVybGF5TW9kdWxlLCBwYXRjaCwgY3JlYXRlQ29udGFpbmVyLCBOYk92ZXJsYXlTZXJ2aWNlLCBOYkFkanVzdG1lbnQsIE5iUG9zaXRpb24sIE5iQWRqdXN0YWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksIE5iR2xvYmFsUG9zaXRpb25TdHJhdGVneSwgTmJQb3NpdGlvbkJ1aWxkZXJTZXJ2aWNlLCBOYlBvc2l0aW9uZWRDb250YWluZXIsIE5iT3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudCwgTmJUcmlnZ2VyLCBOYlRyaWdnZXJTdHJhdGVneUJhc2UsIE5iQ2xpY2tUcmlnZ2VyU3RyYXRlZ3ksIE5iSG92ZXJUcmlnZ2VyU3RyYXRlZ3ksIE5iSGludFRyaWdnZXJTdHJhdGVneSwgTmJGb2N1c1RyaWdnZXJTdHJhdGVneSwgTmJOb29wVHJpZ2dlclN0cmF0ZWd5LCBOYlRyaWdnZXJTdHJhdGVneUJ1aWxkZXJTZXJ2aWNlLCBOYlBvcnRhbERpcmVjdGl2ZSwgTmJQb3J0YWxPdXRsZXREaXJlY3RpdmUsIE5iQ29tcG9uZW50UG9ydGFsLCBOYk92ZXJsYXksIE5iUGxhdGZvcm0sIE5iT3ZlcmxheVBvc2l0aW9uQnVpbGRlciwgTmJUZW1wbGF0ZVBvcnRhbCwgTmJPdmVybGF5Q29udGFpbmVyLCBOYkZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSwgTmJQb3J0YWxJbmplY3RvciwgTmJDZGtNYXBwaW5nTW9kdWxlLCBOYkdsb2JhbExvZ2ljYWxQb3NpdGlvbiwgTmJHbG9iYWxQaHlzaWNhbFBvc2l0aW9uLCBOYlBvc2l0aW9uSGVscGVyLCBOYkR5bmFtaWNPdmVybGF5LCBOYkR5bmFtaWNPdmVybGF5Q2hhbmdlLCBOYkR5bmFtaWNPdmVybGF5SGFuZGxlciwgTmJBMTF5TW9kdWxlLCBOYkZvY3VzVHJhcCwgTmJGb2N1c1RyYXBGYWN0b3J5U2VydmljZSwgTmJDZGtBZGFwdGVyTW9kdWxlLCBOYk92ZXJsYXlDb250YWluZXJBZGFwdGVyLCBOYlNjcm9sbERpc3BhdGNoZXJBZGFwdGVyLCBOYlZpZXdwb3J0UnVsZXJBZGFwdGVyLCBOYkRpcmVjdGlvbmFsaXR5LCBOYkJpZGlNb2R1bGUsIE5iUGxhdGZvcm1Nb2R1bGUsIE5iQ2VsbERlZkRpcmVjdGl2ZSwgTmJIZWFkZXJDZWxsRGVmRGlyZWN0aXZlLCBOYkZvb3RlckNlbGxEZWZEaXJlY3RpdmUsIE5CX1NPUlRfSEVBREVSX0NPTFVNTl9ERUYsIE5iQ29sdW1uRGVmRGlyZWN0aXZlLCBOYkhlYWRlckNlbGxEaXJlY3RpdmUsIE5iRm9vdGVyQ2VsbERpcmVjdGl2ZSwgTmJDZWxsRGlyZWN0aXZlLCBOYkRhdGFTb3VyY2UsIE5iRGF0YVJvd091dGxldERpcmVjdGl2ZSwgTmJIZWFkZXJSb3dPdXRsZXREaXJlY3RpdmUsIE5iRm9vdGVyUm93T3V0bGV0RGlyZWN0aXZlLCBOYkNlbGxPdXRsZXREaXJlY3RpdmUsIE5iSGVhZGVyUm93RGVmRGlyZWN0aXZlLCBOYkZvb3RlclJvd0RlZkRpcmVjdGl2ZSwgTmJSb3dEZWZEaXJlY3RpdmUsIE5iSGVhZGVyUm93Q29tcG9uZW50LCBOYkZvb3RlclJvd0NvbXBvbmVudCwgTmJSb3dDb21wb25lbnQsIE5CX1RBQkxFX1RFTVBMQVRFLCBOYlRhYmxlLCBOYlRhYmxlTW9kdWxlLCBOQl9ESUFMT0dfQ09ORklHLCBOYkRpYWxvZ0NvbmZpZywgTmJEaWFsb2dSZWYsIE5iRGlhbG9nU2VydmljZSwgTmJEaWFsb2dNb2R1bGUsIE5iVG9hc3RyTW9kdWxlLCBOYlRvYXN0UmVmLCBOYlRvYXN0Q29udGFpbmVyLCBOYlRvYXN0ckNvbnRhaW5lclJlZ2lzdHJ5LCBOYlRvYXN0clNlcnZpY2UsIE5iVG9hc3QsIE5iVG9hc3RDb21wb25lbnQsIE5CX1RPQVNUUl9DT05GSUcsIE5iVG9hc3RyQ29uZmlnLCBOYlRvYXN0ckNvbnRhaW5lckNvbXBvbmVudCwgTmJUb29sdGlwTW9kdWxlLCBOYlRvb2x0aXBEaXJlY3RpdmUsIE5iVG9vbHRpcENvbXBvbmVudCwgTmJTZWxlY3RNb2R1bGUsIE5iU2VsZWN0TGFiZWxDb21wb25lbnQsIE5iU2VsZWN0Q29tcG9uZW50LCBOYk9wdGlvbkNvbXBvbmVudCwgTmJPcHRpb25Hcm91cENvbXBvbmVudCwgTkJfU0VMRUNUX0lOSkVDVElPTl9UT0tFTiwgTmJXaW5kb3dNb2R1bGUsIE5iV2luZG93U2VydmljZSwgTmJXaW5kb3dSZWYsIE5iV2luZG93U3RhdGUsIE5iV2luZG93Q29uZmlnLCBOQl9XSU5ET1dfQ09OVEVOVCwgTkJfV0lORE9XX0NPTkZJRywgTkJfV0lORE9XX0NPTlRFWFQsIE5iV2luZG93Q29tcG9uZW50LCBOYldpbmRvd3NDb250YWluZXJDb21wb25lbnQsIE5iRGF0ZXBpY2tlck1vZHVsZSwgTmJEYXRlcGlja2VyQWRhcHRlciwgTmJEYXRlcGlja2VyLCBOQl9EQVRFX0FEQVBURVIsIE5CX0RBVEVfU0VSVklDRV9PUFRJT05TLCBOYkRhdGVwaWNrZXJEaXJlY3RpdmUsIE5iRGF0ZUFkYXB0ZXJTZXJ2aWNlLCBOYlJhbmdlQWRhcHRlclNlcnZpY2UsIE5iRGF0ZXBpY2tlckNvbnRhaW5lckNvbXBvbmVudCwgTmJCYXNlUGlja2VyLCBOYkJhc2VQaWNrZXJDb21wb25lbnQsIE5iRGF0ZXBpY2tlckNvbXBvbmVudCwgTmJSYW5nZXBpY2tlckNvbXBvbmVudCwgTmJEaWFsb2dDb250YWluZXJDb21wb25lbnQsIE5iUmFkaW9Nb2R1bGUsIE5iUmFkaW9Hcm91cENvbXBvbmVudCwgTmJSYWRpb0NvbXBvbmVudCwgTmJUcmVlR3JpZE1vZHVsZSwgTmJUcmVlR3JpZENvbXBvbmVudCwgTkJfUk9XX0RPVUJMRV9DTElDS19ERUxBWSwgTmJUcmVlR3JpZFJvd0NvbXBvbmVudCwgTmJUcmVlR3JpZEhlYWRlclJvd0NvbXBvbmVudCwgTmJUcmVlR3JpZEZvb3RlclJvd0NvbXBvbmVudCwgTkJfVFJFRV9HUklELCBOYlNvcnREaXJlY3Rpb24sIE5iU29ydERpcmVjdGl2ZSwgTmJTb3J0SGVhZGVySWNvbkRpcmVjdGl2ZSwgTmJTb3J0SWNvbkNvbXBvbmVudCwgTmJTb3J0SGVhZGVyQ29tcG9uZW50LCBOYlRyZWVHcmlkUm93VG9nZ2xlQ29tcG9uZW50LCBOYlRyZWVHcmlkQ29sdW1uRGVmRGlyZWN0aXZlLCBOYlRyZWVHcmlkQ2VsbERpcmVjdGl2ZSwgTmJUcmVlR3JpZEhlYWRlckNlbGxEaXJlY3RpdmUsIE5iVHJlZUdyaWRGb290ZXJDZWxsRGlyZWN0aXZlLCBOYlRyZWVHcmlkUm93RGVmRGlyZWN0aXZlLCBOYlRyZWVHcmlkSGVhZGVyUm93RGVmRGlyZWN0aXZlLCBOYlRyZWVHcmlkRm9vdGVyUm93RGVmRGlyZWN0aXZlLCBOYlRyZWVHcmlkQ2VsbERlZkRpcmVjdGl2ZSwgTmJUcmVlR3JpZEhlYWRlckNlbGxEZWZEaXJlY3RpdmUsIE5iVHJlZUdyaWRGb290ZXJDZWxsRGVmRGlyZWN0aXZlLCBOYkZpbHRlckRpcmVjdGl2ZSwgTmJGaWx0ZXJJbnB1dERpcmVjdGl2ZSwgTmJUcmVlR3JpZFJvd1RvZ2dsZURpcmVjdGl2ZSwgTkJfREVGQVVMVF9ST1dfTEVWRUwsIE5iVHJlZUdyaWRQcmVzZW50YXRpb25Ob2RlLCBOYlRyZWVHcmlkRGF0YVNvdXJjZSwgTmJUcmVlR3JpZERhdGFTb3VyY2VCdWlsZGVyLCBOYlRyZWVHcmlkRGF0YVNlcnZpY2UsIE5iVHJlZUdyaWRGaWx0ZXJTZXJ2aWNlLCBOYlRyZWVHcmlkU2VydmljZSwgTmJUcmVlR3JpZFNvcnRTZXJ2aWNlLCBOYkNvbHVtbnNTZXJ2aWNlLCBOYkljb25Nb2R1bGUsIE5iSWNvbkNvbXBvbmVudCwgTmJGb250SWNvbiwgTmJTdmdJY29uLCBOYkljb25QYWNrVHlwZSwgTmJJY29uRGVmaW5pdGlvbiwgTmJJY29uTGlicmFyaWVzLCBOYlRvZ2dsZU1vZHVsZSwgTmJUb2dnbGVDb21wb25lbnQgfTtcbiJdfQ==